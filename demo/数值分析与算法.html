<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>数值分析与算法 &mdash; MyKnowledge MyKnowledge 文档</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script src="../_static/translations.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="数理方程" href="%E6%95%B0%E7%90%86%E6%96%B9%E7%A8%8B.html" />
    <link rel="prev" title="模拟电路" href="%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF.html" />
    <link href="../_static/style.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> MyKnowledge
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="%E5%BE%AE%E7%A7%AF%E5%88%86.html">微积分</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0.html">线性代数</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0.html">复变函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86.html">电路原理</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF.html">数字电路</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF.html">模拟电路</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">数值分析与算法</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">误差</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id3">误差的概念</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">误差的衡量</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">多元函数的误差估计</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">数值计算的基本原则</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id7">插值</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#lagrange">Lagrange插值</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id8">插值多项式的存在唯一性</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id9">拉格朗日插值多项式</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id10">插值余项（方法误差）</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#newton">均差与Newton插值</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id11">均差/差商</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id12">差分及其性质</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id13">等距节点的牛顿插值公式</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#hermite">Hermite插值</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id14">函数逼近与计算</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id15">常微分方程的数值解法</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#euler">Euler方法</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id16">改进的Euler格式</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#runge-kutta">Runge-Kutta方法</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id17">四阶Runge-Kutta方法</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id18">方程组与高阶方程的情形</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id19">边值问题的数值解法</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id20">方程求根</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id21">Newton法</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id22">弦截法与抛物线法</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id23">解线性方程组的直接方法</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="%E6%95%B0%E7%90%86%E6%96%B9%E7%A8%8B.html">数理方程</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%B5%81%E4%BD%93%E5%8A%9B%E5%AD%A6.html">流体力学</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E8%AE%A1%E7%AE%97%E6%B5%81%E4%BD%93%E5%8A%9B%E5%AD%A6%E6%9C%89%E9%99%90%E4%BD%93%E7%A7%AF%E6%B3%95.html">计算流体力学有限体积法</a></li>
<li class="toctree-l1"><a class="reference internal" href="AutoCAD.html">AutoCAD</a></li>
<li class="toctree-l1"><a class="reference internal" href="C%2B%2B.html">C++</a></li>
<li class="toctree-l1"><a class="reference internal" href="Latex.html">Latex</a></li>
<li class="toctree-l1"><a class="reference internal" href="OpenFOAM.html">OpenFOAM</a></li>
<li class="toctree-l1"><a class="reference internal" href="OpenFOAM%E7%AE%97%E4%BE%8B%E8%BF%90%E8%A1%8C%E6%A1%88%E4%BE%8B.html">OpenFOAM算例运行案例</a></li>
<li class="toctree-l1"><a class="reference internal" href="Python.html">Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="Salome.html">Salome</a></li>
<li class="toctree-l1"><a class="reference internal" href="Solidworks.html">Solidworks</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">MyKnowledge</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>数值分析与算法</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/demo/数值分析与算法.rst.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1>数值分析与算法<a class="headerlink" href="#id1" title="此标题的永久链接"></a></h1>
<section id="id2">
<h2>误差<a class="headerlink" href="#id2" title="此标题的永久链接"></a></h2>
<section id="id3">
<h3>误差的概念<a class="headerlink" href="#id3" title="此标题的永久链接"></a></h3>
<p>误差的来源一般分为四种：</p>
<ul class="simple">
<li><p>观测误差（测量误差）。任何一个测量仪器一定有误差精度，只是这个精度对最后结果的影响有多大，最后需要做分析。</p></li>
<li><p>模型误差。可以理解为是数学建模过程中抽象、简化过程带来的误差。</p></li>
<li><p>方法误差（截断误差）。任何方法都有误差，尤其是迭代不能是无穷而产生的截断误差。</p></li>
<li><p>舍入误差（计算误差，存储误差）。计算机在存储数字时舍入掉一些位数带来的误差。</p></li>
</ul>
<p>上面的四种误差根据影响情况又可以大致分为两类：对于观测误差和舍入误差，它们对最后结果的影响相似，都是初值或中间值的误差通过计算公式累积变化；而模型误差与方法误差都是对最终结果的影响，前者是将对象进行数学化带来的误差，后者是进一步写成计算公式带来的误差。</p>
<p><strong>案例</strong> 用内接n多边形近似圆（ <span class="math notranslate nohighlight">\(r=1\)</span> ）周长。</p>
<ul class="simple">
<li><p>观测误差——无。因为已经明确给出来了半径等于1；</p></li>
<li><p>模型误差——无。因为可以证明收敛到圆周长；</p></li>
<li><p>方法误差——迭代停止后的理想值与 <span class="math notranslate nohighlight">\(2\pi\)</span> 的差；</p></li>
<li><p>舍入误差——每一步都有计算中间结果的存储，需要累积。</p></li>
</ul>
<p><strong>案例</strong> 已知 <span class="math notranslate nohighlight">\(\sin0.32=0.314567\)</span> ， <span class="math notranslate nohighlight">\(\sin0.34=0.333487\)</span> ，用线性插值 <span class="math notranslate nohighlight">\(L_{1}(x)=\frac{x-x_{1}}{x_{0}-x_{1}}y_{0}+\frac{x-x_{0}}{x_{1}-x_{0}}y_{1}\)</span> 的方法，求 <span class="math notranslate nohighlight">\(\sin0.3367\)</span> 的近似值和误差界。给出的 <span class="math notranslate nohighlight">\(\sin0.32=0.314567\)</span> ， <span class="math notranslate nohighlight">\(\sin0.34=0.333487\)</span> 就是观测误差，因为这是给出的初值就存在误差。</p>
<p><strong>案例</strong> 对于 <span class="math notranslate nohighlight">\(e^{-1}=1+(-1)+\frac{(-1)^{2}}{2!}+\frac{(-1)^{3}}{3!}+\cdots+\frac{(-1)^{k}}{k!}+\cdots\)</span> ，选取 <span class="math notranslate nohighlight">\(k=7\)</span> 来近似得到一个无穷位小数 <span class="math notranslate nohighlight">\(e^{-1}=0.3678571\cdots\)</span> 。在这里截断的过程中， <span class="math notranslate nohighlight">\(R_{7}\leqslant \frac{1}{8!}&lt;\frac{1}{4}\times 10^{-4}\)</span> 就是方法误差（截断误差），这一过程产生的误差的上限是可以分析出来的；而如果最终取的结果保留4位小数为 <span class="math notranslate nohighlight">\(e^{-1}=0.3679\)</span> 就产生了舍入误差。</p>
<p><strong>案例</strong> 记初始值为 <span class="math notranslate nohighlight">\(I_{0}\)</span> ，误差为 <span class="math notranslate nohighlight">\(\Delta I_{0}\)</span> ，计算公式为 <span class="math notranslate nohighlight">\(I_{n}=1-nI_{n-1}\)</span> 。随着迭代的进行，可以发现 <span class="math notranslate nohighlight">\(|\Delta I_{1}|=|\Delta I_{0}|,|\Delta I_{2}|=2|\Delta I_{1}|,\cdots,|\Delta I_{n}|=n!|\Delta I_{0}|\)</span> ，误差非常不稳定，该计算公式会将开始的误差不断放大，所以该计算公式是有问题的，称之为不稳定公式。</p>
</section>
<section id="id4">
<h3>误差的衡量<a class="headerlink" href="#id4" title="此标题的永久链接"></a></h3>
<p>记准确值为 <span class="math notranslate nohighlight">\(x\)</span> ，近似值为 <span class="math notranslate nohighlight">\(x^{*}\)</span> ，那么绝对误差为 <span class="math notranslate nohighlight">\(|\Delta x|=|x-x^{*}|\)</span> ，相对误差为 <span class="math notranslate nohighlight">\(\left | \frac{\Delta x}{x}  \right | =\left | \frac{\Delta x}{x^{*}}  \right |\)</span> 。</p>
<p>如果有一个数是 <span class="math notranslate nohighlight">\(x=1.2345678\)</span> ，它的三位有效数字是 <span class="math notranslate nohighlight">\(x^{*}=1.23\)</span> ，此时取三位有效数字的舍入误差为 <span class="math notranslate nohighlight">\(|\Delta x|\leqslant 0.5\times 10^{-2}\)</span> ；它的五位有效数字是 <span class="math notranslate nohighlight">\(x^{*}=1.2346\)</span> ，此时取五位有效数字的舍入误差为 <span class="math notranslate nohighlight">\(|\Delta x|\leqslant 0.5\times 10^{-4}\)</span> 。</p>
</section>
<section id="id5">
<h3>多元函数的误差估计<a class="headerlink" href="#id5" title="此标题的永久链接"></a></h3>
<p>这个估计进所要解决的问题是：有一个数有误差，它代入到公式当中对最后的结果产生什么影响。可以用来分析观测误差和舍入误差对下一步结果的影响。</p>
<p>有 <span class="math notranslate nohighlight">\(n\)</span> 个数参与到计算方法 <span class="math notranslate nohighlight">\(f\)</span> 来计算得到目标结果 <span class="math notranslate nohighlight">\(A\)</span> ，即 <span class="math notranslate nohighlight">\(A=f(x_{1},x_{2},\cdots,x_{n})\)</span> ，而这 <span class="math notranslate nohighlight">\(n\)</span> 个数都存在误差，即 <span class="math notranslate nohighlight">\(A^{*}=f(x_{1}^{*},x_{2}^{*},\cdots,x_{n}^{*})\)</span> ，那么结果误差为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\Delta A=A-A^{*}\approx(\frac{\partial f}{\partial x_{1}})^{*}(x_{1}-x_{1}^{*})+(\frac{\partial f}{\partial x_{2}})^{*}(x_{2}-x_{2}^{*})+\cdots+(\frac{\partial f}{\partial x_{n}} )^{*}(x_{n}-x_{n}^{*})
\end{align}\]</div>
<p>其中的 <span class="math notranslate nohighlight">\((\frac{\partial f}{\partial x_{n}})^{*}\)</span> 指的是在求出的 <span class="math notranslate nohighlight">\(\frac{\partial f}{\partial x_{n}}\)</span> 表达式中代入 <span class="math notranslate nohighlight">\(x_{n}^{*}\)</span> ，其他以此类推。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>如果严格地进行泰勒展开的话，上面的式子应该是一个无穷级数。但是，由于 <span class="math notranslate nohighlight">\(x_{n}-x_{n}^{*}\)</span> 的值是非常小的，后续的二阶项、三阶项等的值会更加小，所以近似地舍去这些项是合理的。</p>
</div>
<p>根据上式，就可以近似得到</p>
<div class="math notranslate nohighlight">
\[\begin{align}
|\Delta A|\leqslant \left | (\frac{\partial f}{\partial x_{1}})^{*}\right | \cdot |\Delta x_{1}|+\left | (\frac{\partial f}{\partial x_{2}})^{*}\right | \cdot |\Delta x_{2}|+\cdots+\left | (\frac{\partial f}{\partial x_{n}})^{*}\right | \cdot |\Delta x_{n}|
\end{align}\]</div>
<p>但是这样的近似式子在工程应用上是没有价值的，因为它不能明确给出真正的误差上限。所以真正使用的是下面的不等式：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
|\Delta A|\leqslant \max\left | \frac{\partial f}{\partial x_{1}}  \right | \cdot |\Delta x_{1}|+\max\left | \frac{\partial f}{\partial x_{2}}  \right | \cdot |\Delta x_{2}|+\cdots+\max\left | \frac{\partial f}{\partial x_{n}}  \right | \cdot |\Delta x_{n}|
\end{align}\]</div>
<p>上式是通过多元函数的拉格朗日中值定理来推导得到的。对于一元函数的情况，有 <span class="math notranslate nohighlight">\(f(x)-f(x^{*})=f'(\xi)(x-x^{*})\)</span> ，取绝对值放大后就得到 <span class="math notranslate nohighlight">\(|f(x)-f(x^{*})|\leqslant \max|f'(x)|\cdot|x-x^{*}|\)</span> 。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在综合了前序误差之后， <span class="math notranslate nohighlight">\(x_{n}\)</span> 的可能值将会是一个包含了 <span class="math notranslate nohighlight">\(x_{n}^{*}\)</span> 范围，根据这个范围就可以计算出 <span class="math notranslate nohighlight">\(\max\left | \frac{\partial f}{\partial x_{n}}  \right |\)</span> 。</p>
</div>
<p><strong>例题</strong> 比较 <span class="math notranslate nohighlight">\(\sqrt{2}-1\)</span> 和 <span class="math notranslate nohighlight">\(1/(\sqrt{2}+1)\)</span> 的误差，其中 <span class="math notranslate nohighlight">\(\sqrt{2}\)</span> 取 <span class="math notranslate nohighlight">\(1.414\)</span> 。</p>
<p><strong>解</strong> 在这个问题中， <span class="math notranslate nohighlight">\(x=\sqrt{2}\)</span> ， <span class="math notranslate nohighlight">\(x^{*}=1.414\)</span> ， <span class="math notranslate nohighlight">\(f_{1}(x)=x-1\)</span> ， <span class="math notranslate nohighlight">\(f_{2}(x)=\frac{1}{x+1}\)</span> 。</p>
<p>对于 <span class="math notranslate nohighlight">\(f_{1}(x)\)</span> ，其误差为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
|f_{1}(x)-f_{1}(x^{*})|\leqslant \max|f'_{1}(x)|\cdot\Delta x=1\cdot \Delta x
\end{align}\]</div>
<p>对于 <span class="math notranslate nohighlight">\(f_{2}(x)\)</span> ，首先计算 <span class="math notranslate nohighlight">\(|f_{2}'(x)|=\frac{1}{(x+1)^{2}}\)</span> ，而根据舍入误差可知，当 <span class="math notranslate nohighlight">\(x=\sqrt{2}\)</span> 取为 <span class="math notranslate nohighlight">\(x^{*}=1.414\)</span> 时，意味着 <span class="math notranslate nohighlight">\(x\in [1.4135,1.4145)\)</span> ，于是可以得到 <span class="math notranslate nohighlight">\(\max|f_{2}'(x)|=\frac{1}{(1.4135+1)^{2}}&lt; \frac{1}{5}\)</span> ，也就得到</p>
<div class="math notranslate nohighlight">
\[\begin{align}
|f_{2}(x)-f_{2}(x^{*})|\leqslant \max|f_{2}'(x)|\cdot\Delta x \leqslant \frac{1}{5}\Delta x
\end{align}\]</div>
<p>可以发现，两个理论上相等的式子，在数值计算结果上的误差存在明显不同。更进一步地，根据有效位数的保留情况可知 <span class="math notranslate nohighlight">\(\Delta x\leqslant 0.5\times 10^{-3}\)</span> ，代入上面的不等式就可以分别求出 <span class="math notranslate nohighlight">\(f_{1}(x)\)</span> 和 <span class="math notranslate nohighlight">\(f_{2}(x)\)</span> 的误差界限。</p>
<p><strong>例题</strong> 分析 <span class="math notranslate nohighlight">\(y_{n+1}=\frac{1}{2}y_{n}+\frac{1}{n}\)</span> 中观测误差和存储误差的累计结果，假设每次迭代都会产生最大 <span class="math notranslate nohighlight">\(0.5\times 10^{-5}\)</span> 的存储误差。</p>
<p><strong>解</strong> 即初始观测误差为 <span class="math notranslate nohighlight">\(\Delta y_{0}\)</span> ，则</p>
<div class="math notranslate nohighlight">
\[\begin{align}
|\Delta y_{n+1}|
\leqslant \frac{1}{2}|\Delta y_{n}|+0.5\times 10^{-5}
\end{align}\]</div>
<p>为了将迭代过程中关于 <span class="math notranslate nohighlight">\(n\)</span> 的误差结果求出来，考虑将上面的式子写成等比数列，得到</p>
<div class="math notranslate nohighlight">
\[\begin{align}
|\Delta y_{n+1}|-10^{-5}\leqslant \frac{1}{2}(|\Delta y_{n}|-10^{-5})
\quad \Rightarrow \quad
|\Delta y_{n+1}|\leqslant(\frac{1}{2})^{n+1}(|\Delta y_{0}|-10^{-5})+10^{-5}
\end{align}\]</div>
</section>
<section id="id6">
<h3>数值计算的基本原则<a class="headerlink" href="#id6" title="此标题的永久链接"></a></h3>
<ol class="arabic simple">
<li><p>选择数值稳定性好的计算公式。例如 <span class="math notranslate nohighlight">\(I_{n}=1-nI_{n-1}\)</span> 就是稳定性极差的计算公式，而 <span class="math notranslate nohighlight">\(I_{n}=\frac{1-nI_{n-1}}{n}\)</span> 的数值稳定性较好。</p></li>
<li><p>防止被除数远大于除数。例如要解 <span class="math notranslate nohighlight">\(0.00001x_{1}+x_{2}=1,\quad 2x_{1}+x_{2}=2\)</span> 时，如果先求取 <span class="math notranslate nohighlight">\(x_{2}\)</span> 再代入第一个式子来求取 <span class="math notranslate nohighlight">\(x_{1}\)</span> ，就会导致 <span class="math notranslate nohighlight">\(x_{2}\approx 1\)</span> 而 <span class="math notranslate nohighlight">\(x_{1}\approx 0\)</span> ，显然是不合理的。</p></li>
<li><p>防止相近的数相减。例如 <span class="math notranslate nohighlight">\(1-\cos1^{\circ}=1-0.9998=0.0002\)</span> ，而 <span class="math notranslate nohighlight">\(2\sin^{2}0.5^{\circ}=1.523\times 10^{-4}\)</span> ，显然后面的式子精度更高。</p></li>
<li><p>防止大数吃掉小数。例如在计算 <span class="math notranslate nohighlight">\(12345 + (0.1+0.2+0.3+\cdots)\)</span> 时，应该先计算括号内的小数。</p></li>
<li><p>简化计算步骤。</p></li>
</ol>
</section>
</section>
<section id="id7">
<h2>插值<a class="headerlink" href="#id7" title="此标题的永久链接"></a></h2>
<dl class="simple">
<dt>定义<span class="classifier">插值函数</span></dt><dd><p>设函数 <span class="math notranslate nohighlight">\(y=f(x)\)</span> 在 <span class="math notranslate nohighlight">\([a,b]\)</span> 上有定义，且在相异点 <span class="math notranslate nohighlight">\(a\leqslant x_{0}&lt;x_{1}&lt;\cdots&lt;x_{n}\leqslant b\)</span> 上的值分别为 <span class="math notranslate nohighlight">\(y_{0},y_{1},\cdots,y_{n}\)</span> 。若存在一个 <span class="math notranslate nohighlight">\(P(x)\)</span> 使得 <span class="math notranslate nohighlight">\(P(x_{i})=f(x_{i})=y_{i}\quad i=0,1,\cdots,n\)</span> ，则称 <span class="math notranslate nohighlight">\(P(x)\)</span> 为 <span class="math notranslate nohighlight">\(f(x)\)</span> 在 <span class="math notranslate nohighlight">\([a,b]\)</span> 上的插值函数。其中 <span class="math notranslate nohighlight">\(x_{0},x_{1},\cdots,x_{n}\)</span> 称为插值节点， <span class="math notranslate nohighlight">\([a,b]\)</span> 称为插值区间。</p>
</dd>
</dl>
<section id="lagrange">
<h3>Lagrange插值<a class="headerlink" href="#lagrange" title="此标题的永久链接"></a></h3>
<section id="id8">
<h4>插值多项式的存在唯一性<a class="headerlink" href="#id8" title="此标题的永久链接"></a></h4>
<dl class="simple">
<dt>定理<span class="classifier">插值多项式的存在唯一性</span></dt><dd><p>在 <span class="math notranslate nohighlight">\([a,b]\)</span> 上满足 <span class="math notranslate nohighlight">\(P(x_{i})=f(x_{i})=y_{i}\quad i=0,1,\cdots,n\)</span> 的插值多项式 <span class="math notranslate nohighlight">\(P_{n}(x)=a_{0}+a_{1}x+\cdots+a_{n}x^{n}\)</span> 是存在且唯一的。</p>
</dd>
</dl>
<p>这个定理说明了，如果给定了 <span class="math notranslate nohighlight">\(n+1\)</span> 个插值节点，那么插值多项式的次数应该选择为小于等于 <span class="math notranslate nohighlight">\(n\)</span> 次。</p>
<p><strong>证明</strong> 如果有 <span class="math notranslate nohighlight">\(n+1\)</span> 个插值节点分别为 <span class="math notranslate nohighlight">\(x_{0},x_{1},\cdots,x_{n}\)</span> ，那么代入到插值多项式可以得到包含 <span class="math notranslate nohighlight">\(n+1\)</span> 个未知量 <span class="math notranslate nohighlight">\(a_{0},a_{1},\cdots,a_{n}\)</span> 的线性方程组</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\left \{ \begin{array}{c}
a_{0}+a_{1}x_{0}+\cdots+a_{n}x_{0}^{n}=y_{0}, \\
a_{0}+a_{1}x_{1}+\cdots+a_{n}x_{1}^{n}=y_{1}, \\
\vdots \\
a_{0}+a_{1}x_{n}+\cdots+a_{n}x_{n}^{n}=y_{n}
\end{array} \right.
\end{align}\end{split}\]</div>
<p>考虑该方程组的系数行列式（事实上是一个Vandermonde行列式）可以得到</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
V_{n}(x_{0},x_{1},\cdots,x_{n})=
\begin{vmatrix}
1 &amp; x_{0} &amp; x_{0}^{2} &amp; \cdots &amp; x_{0}^{n} \\
1 &amp; x_{1} &amp; x_{1}^{2} &amp; \cdots &amp; x_{1}^{n} \\
\vdots &amp; \vdots &amp; \vdots &amp; &amp; \vdots \\
1 &amp; x_{n} &amp; x_{n}^{2} &amp; \cdots &amp; x_{n}^{n}
\end{vmatrix}
=\prod_{i=1}^{n}\prod_{j=0}^{i-1}(x_{i}-x_{j})
\end{align}\end{split}\]</div>
<p>由于 <span class="math notranslate nohighlight">\(i\ne j\)</span> 时 <span class="math notranslate nohighlight">\(x_{i}\ne x_{j}\)</span> ，上式所有因子 <span class="math notranslate nohighlight">\(x_{i}-x_{j}\ne 0\)</span> ，于是 <span class="math notranslate nohighlight">\(V_{n}(x_{0},x_{1},\cdots,x_{n})\ne 0\)</span> ，所以方程组存在唯一的一组解 <span class="math notranslate nohighlight">\(a_{0},a_{1},\cdots,a_{n}\)</span> 。</p>
</section>
<section id="id9">
<h4>拉格朗日插值多项式<a class="headerlink" href="#id9" title="此标题的永久链接"></a></h4>
<p>拉格朗日插值多项式满足这样的形式：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
L_{n}(x)=l_{0}(x)y_{0}+l_{1}(x)y_{1}+\cdots+l_{n}(x)y_{n}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(l_{i}(x)\)</span> 均为小于等于 <span class="math notranslate nohighlight">\(n\)</span> 次的多项式。</p>
<p>拉格朗日插值多项式能够满足 <span class="math notranslate nohighlight">\(L_{n}(x_{i})=y_{i} \quad i=0,1,\cdots,n\)</span> ，要实现这一点，就需要 <strong>n次插值基函数</strong> 满足</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
l_{i}(x_{k})=
\left\{\begin{array}{ll}
1, &amp; k=i, \\
0, &amp; k\ne i
\end{array}\right.
\quad (i,k=0,1,\cdots,n)
\end{align}\end{split}\]</div>
<p>根据多项式根据根能进行因式分解性质，容易得到n次插值基函数的具体形式为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
l_{i}(x)=\frac{(x-x_{0})\cdots(x-x_{i-1})(x-x_{i+1})\cdots(x-x_{n})}{(x_{i}-x_{0})\cdots(x_{i}-x_{i-1})(x_{i}-x_{i+1})\cdots(x_{i}-x_{n})} \quad (i=0,1,\cdots,n)
\end{align}\]</div>
<p>如果记 <span class="math notranslate nohighlight">\(\omega_{n+1}(x)=\prod_{i=0}^{n}(x-x_{i})\)</span> ，则拉格朗日插值多项式可以用下面的形式来表述：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
L_{n}(x)=\sum_{i=0}^{n}l_{i}(x)y_{i}=\sum_{i=0}^{n}\frac{\omega_{n+1}(x)}{(x-x_{i})\omega'_{n+1}(x_{i})}y_{i}
\end{align}\]</div>
<p>如果取 <span class="math notranslate nohighlight">\(n=1\)</span> ，有两个插值节点 <span class="math notranslate nohighlight">\(x_{0},x_{1}\)</span> ，那么拉格朗日插值多项式为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
L_{1}(x)=l_{0}(x)y_{0}+l_{1}(x)y_{1}=\frac{x-x_{1}}{x_{0}-x_{1}}y_{0}+\frac{x-x_{0}}{x_{1}-x_{0}}y_{1}
\end{align}\]</div>
<p>这就是 <strong>线性插值</strong> 。</p>
<p>如果取 <span class="math notranslate nohighlight">\(n=2\)</span> ，有三个插值节点，那么拉个朗日插值多项式为</p>
<p>这就是 <strong>抛物线插值</strong> 。</p>
</section>
<section id="id10">
<h4>插值余项（方法误差）<a class="headerlink" href="#id10" title="此标题的永久链接"></a></h4>
<p>现在考虑插值余项 <span class="math notranslate nohighlight">\(R_{n}(x)=f(x)-L_{n}(x)\)</span> ，可以知道其已经满足 <span class="math notranslate nohighlight">\(R_{n}(x_{i})=0, \quad i=0,1,\cdots,n\)</span> 。为了进一步分析，我们假设 <span class="math notranslate nohighlight">\(f^{(n+1)}(x)\)</span> 存在且连续，则可以将插值余项分解</p>
<div class="math notranslate nohighlight">
\[\begin{align}
R_{n}(x)=K(x)(x-x_{0})(x-x_{1})\cdots(x-x_{n})=K(x)\omega _{n+1}(x)
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(K(x)\)</span> 也是连续的。接下来，我们构造一个函数 <span class="math notranslate nohighlight">\(\varphi(t)=f(t)-L_{n}(t)-K(x)\omega _{n+1}(t)\)</span> ，这里 <span class="math notranslate nohighlight">\(x\)</span> 为常数， <span class="math notranslate nohighlight">\(t\)</span> 为变量。可以发现所构造的函数在 <span class="math notranslate nohighlight">\(t=x,x_{0},x_{1},\cdots,x_{n}\)</span> 共 <span class="math notranslate nohighlight">\(n+2\)</span> 个点处都满足 <span class="math notranslate nohighlight">\(\varphi(t)=0\)</span> ，也即 <span class="math notranslate nohighlight">\(\varphi(t)\)</span> 在 <span class="math notranslate nohighlight">\([a,b]\)</span> 区间上至少有 <span class="math notranslate nohighlight">\(n+2\)</span> 个零点，进而可以根据中值定理递推出 <span class="math notranslate nohighlight">\(\varphi^{(n+1)}(t)\)</span> 在 <span class="math notranslate nohighlight">\([a,b]\)</span> 区间上至少有 <span class="math notranslate nohighlight">\(1\)</span> 个零点，将该零点记为 <span class="math notranslate nohighlight">\(\xi\)</span> ，则</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\varphi^{(n+1)}(\xi)=f^{(n+1)}(\xi)-0-K(x)(n+1)! =0
\quad \Rightarrow \quad
K(x)=\frac{f^{(n+1)}(\xi)}{(n+1)!}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\xi \in (a,b)\)</span> 并且依赖于 <span class="math notranslate nohighlight">\(x\)</span> 。需要注意，余项表达式只有在 <span class="math notranslate nohighlight">\(f(x)\)</span> 的高阶导数存在时才能应用，且 <span class="math notranslate nohighlight">\(\xi\)</span> 在 <span class="math notranslate nohighlight">\((a,b)\)</span> 内的具体位置通常不可能给出。但是，如果可以求出 <span class="math notranslate nohighlight">\(\max_{a\leqslant x\leqslant b}|f^{(n+1)}(x)|=M_{n+1}\)</span> ，那么插值多项式 <span class="math notranslate nohighlight">\(L_{n}(x)\)</span> 逼近 <span class="math notranslate nohighlight">\(f(x)\)</span> 的截断误差限为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
|R_{n}(x)|\leqslant \frac{M_{n+1}}{(n+1)!}|\omega _{n+1}(x)|
\end{align}\]</div>
<p>当 <span class="math notranslate nohighlight">\(n=1\)</span> 时，线性插值的余项为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
R_{1}(x)=\frac{1}{2}f''(\xi)\omega _{2}(x)=\frac{1}{2}f''(\xi)(x-x_{0})(x-x_{1}), \quad \xi\in[x_{0},x_{1}]
\end{align}\]</div>
<p>当 <span class="math notranslate nohighlight">\(n=2\)</span> 时，抛物插值的余项为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
R_{2}(x)=\frac{1}{6}f'''(\xi)(x-x_{0})(x-x_{1})(x-x_{2}), \quad \xi\in[x_{0},x_{2}]
\end{align}\]</div>
</section>
</section>
<section id="newton">
<h3>均差与Newton插值<a class="headerlink" href="#newton" title="此标题的永久链接"></a></h3>
<p>拉格朗日插值有个缺点，就是当后续增加节点后，之前的计算结果不能再使用，使得计算代价很高。为了让在增加一个插值节点时只增加一项，考虑牛顿多项式形式：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
N_{n}(x)=a_{0}+a_{1}(x-x_{0})+a_{2}(x-x_{0})(x-x_{1})+\cdots + a_{n}(x-x_{0})(x-x_{1})\cdots(x-x_{n-1})
\end{align}\]</div>
<p>其满足 <span class="math notranslate nohighlight">\(N_{n}(x_{i})=f(x_{i}), \quad i=0,1,\cdots,n\)</span> 。其系数也满足下面的迭代关系</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
N_{n}(x_{0}) &amp;= f(x_{0}) = a_{0} &amp;&amp;  a_{0}=f(x_{0}) \\
N_{n}(x_{1}) &amp;= f(x_{1}) = a_{0}+a_{1}(x_{1}-x_{0}) &amp;&amp;  a_{1}=\frac{f(x_{1})-f(x_{0})}{x_{1}-x_{0}}=f[x_{0},x_{1}] \\
N_{n}(x_{2}) &amp;= f(x_{2}) = a_{0}+a_{1}(x_{2}-x_{0})+a_{2}(x_{2}-x_{1})(x_{2}-x_{0}) &amp;&amp; a_{2}=\frac{f[x_{0},x_{2}]-f[x_{0},x_{1}]}{x_{2}-x_{1}}=f[x_{0},x_{1},x_{2}] \\
&amp;~~\vdots  &amp;&amp; ~~\vdots
\end{align}\end{split}\]</div>
<section id="id11">
<h4>均差/差商<a class="headerlink" href="#id11" title="此标题的永久链接"></a></h4>
<dl>
<dt>定义<span class="classifier">均差</span></dt><dd><p>记 <span class="math notranslate nohighlight">\(f[x_{0},x_{k}]=\frac{f(x_{k})-f(x_{0})}{x_{k}-x_{0}}\)</span> 为 <span class="math notranslate nohighlight">\(f(x)\)</span> 关于点 <span class="math notranslate nohighlight">\(x_{0},x_{k}\)</span> 的一阶均差。</p>
<p>记 <span class="math notranslate nohighlight">\(f[x_{0},x_{1},x_{k}]=\frac{f[x_{0},x_{k}]-f[x_{0},x_{1}]}{x_{k}-x_{1}}\)</span> 为 <span class="math notranslate nohighlight">\(f(x)\)</span> 的二阶均差。</p>
<p>更一般地，记 <span class="math notranslate nohighlight">\(f[x_{0},x_{1},\cdots,x_{m}]=\frac{f[x_{0},\cdots,x_{m-2},x_{m}]-f[x_{0},\cdots,x_{m-2},x_{m-1}]}{x_{m}-x_{m-1}}\)</span> 为 <span class="math notranslate nohighlight">\(f(x)\)</span> 的 <span class="math notranslate nohighlight">\(m\)</span> 阶均差。</p>
</dd>
</dl>
<p>可以通过列差商表来逐列计算差商，如下所示，其中差商表的对角线就是牛顿插值多项式的系数。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 11%" />
<col style="width: 14%" />
<col style="width: 18%" />
<col style="width: 22%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><span class="math notranslate nohighlight">\(x_{k}\)</span></p></th>
<th class="head"><p><span class="math notranslate nohighlight">\(f(x_{k})\)</span></p></th>
<th class="head"><p>一阶差商</p></th>
<th class="head"><p>二阶差商</p></th>
<th class="head"><p>三阶差商</p></th>
<th class="head"><p>四阶差商</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(x_{0}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(f(x_{0})\)</span></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(x_{1}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(f(x_{1})\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(f[x_{0},x_{1}]\)</span></p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(x_{2}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(f(x_{2})\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(f[x_{0},x_{2}]\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(f[x_{0},x_{1},x_{2}]\)</span></p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(x_{3}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(f(x_{3})\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(f[x_{0},x_{3}]\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(f[x_{0},x_{1},x_{3}]\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(f[x_{0},x_{1},x_{2},x_{3}]\)</span></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(x_{4}\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(f(x_{4})\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(f[x_{0},x_{4}]\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(f[x_{0},x_{1},x_{4}]\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(f[x_{0},x_{1},x_{2},x_{4}]\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(f[x_{0},x_{1},x_{2},x_{3},x_{4}]\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(\vdots\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\vdots\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\vdots\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\vdots\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\vdots\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\vdots\)</span></p></td>
</tr>
</tbody>
</table>
<p>差商具有如下的基本性质：</p>
<ol class="arabic">
<li><p><span class="math notranslate nohighlight">\(k\)</span> 阶差商可以表示为函数值 <span class="math notranslate nohighlight">\(f(x_{0}),f(x_{1}),\cdots,f(x_{k})\)</span> 的线性组合，即</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{align}
        f[x_{0},x_{1},\cdots,x_{k}]=\sum_{j=0}^{k}\frac{f(x_{j})}{(x_{j}-x_{0})\cdots(x_{j}-x_{j-1})(x_{j}-x_{j+1})\cdots(x_{j}-x_{k})}
        \end{align}\\这个性质可以用归纳法证明。该性质也表明了差商与节点的排列次序无关，称为差商的对称性。\end{aligned}\end{align} \]</div>
</li>
<li><p>差商具有如下的递推关系</p>
<div class="math notranslate nohighlight">
\[\begin{align}
    f[x_{0},x_{1},\cdots,x_{k}]=\frac{f[x_{1},x_{2},\cdots,x_{k}]-f[x_{0},x_{1},\cdots,x_{k-1}]}{x_{k}-x_{0}}
    \end{align}\]</div>
</li>
<li><p>若 <span class="math notranslate nohighlight">\(f(x)\)</span> 在 <span class="math notranslate nohighlight">\([a,b]\)</span> 上存在 <span class="math notranslate nohighlight">\(n\)</span> 阶导数，且节点 <span class="math notranslate nohighlight">\(x_{0},x_{1},\cdots,x_{n}\in [a,b]\)</span> ，则可以根据Rolle定理证明 <span class="math notranslate nohighlight">\(n\)</span> 阶差商与导数的关系为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
    f[x_{0},x_{1},\cdots,x_{n}]=\frac{f^{(n)}(\xi)}{n!}, \quad \xi\in[a,b]
    \end{align}\]</div>
</li>
</ol>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>因为牛顿插值与插值节点顺序的选取是有关的，所以如何选择插值节点是一个需要考虑的问题。一般的经验是：</p>
<ul>
<li><p>当 <span class="math notranslate nohighlight">\(x\)</span> 在 <span class="math notranslate nohighlight">\(x_{0}\)</span> 附近时，先选用 <span class="math notranslate nohighlight">\(x_{0}\)</span> 附近的插值节点，即牛顿向前插值公式。如前面所述的相同。</p></li>
<li><p>当 <span class="math notranslate nohighlight">\(x\)</span> 在 <span class="math notranslate nohighlight">\(x_{n}\)</span> 附近时，先选用 <span class="math notranslate nohighlight">\(x_{n}\)</span> 附近的插值节点，即牛顿向后插值公式。例如</p>
<div class="math notranslate nohighlight">
\[\begin{align}
f(x)\approx f(x_{n}) + f[x_{n},x_{n-1}](x-x_{n}) + f[x_{n},x_{n-1},x_{n-2}](x-x_{n})(x-x_{n-1})+\cdots
\end{align}\]</div>
</li>
<li><p>当 <span class="math notranslate nohighlight">\(x\)</span> 在 <span class="math notranslate nohighlight">\([x_{k},x_{k+1}]\)</span> 中间时，先选用 <span class="math notranslate nohighlight">\(x_{k}\)</span> 附近的插值节点。这是需要逐个比较的，如果比较出顺序为 <span class="math notranslate nohighlight">\(x_{k},x_{k+1},x_{k-1},x_{k+2},x_{k-2},\cdots\)</span> ，则</p>
<div class="math notranslate nohighlight">
\[\begin{align}
f(x)\approx f(x_{k}) + f[x_{k},x_{k+1}](x-x_{k}) + f[x_{k},x_{k+1},x_{k-1}](x-x_{k})(x-x_{k+1})+\cdots
\end{align}\]</div>
</li>
</ul>
</div>
<div class="admonition attention">
<p class="admonition-title">注意</p>
<p>当插值节点分布非常不均匀时，多形式系数容易有不稳定性。</p>
</div>
</section>
<section id="id12">
<h4>差分及其性质<a class="headerlink" href="#id12" title="此标题的永久链接"></a></h4>
<dl>
<dt>定义<span class="classifier">差分</span></dt><dd><p>设函数 <span class="math notranslate nohighlight">\(y=f(x)\)</span> 在等距节点 <span class="math notranslate nohighlight">\(x_{k}=x_{0}+kh ~~(k=0,1,\cdots,n)\)</span> 上的值 <span class="math notranslate nohighlight">\(f_{k}=f(x_{k})\)</span> 已知，这里的 <span class="math notranslate nohighlight">\(h\)</span> 为常数，称为 <strong>步长</strong> 。下面的三种偏差</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}\begin{align}
        \Delta f_{k}&amp;=f_{k+1}-f_{k} \\
        \nabla f_{k}&amp;=f_{k}-f_{k-1} \\
        \delta f_{k}&amp;=f(x_{k}+h/2)-f(x_{k}-h/2)=f_{k+\frac{1}{2}}-f_{k-\frac{1}{2}}
        \end{align}\end{split}\\分别称为 :math:`f(x)` 在 :math:`x_{k}` 处以 :math:`h` 为步长的 **向前差分** 、 **向后差分** 以及 **中心差分** ，符号 :math:`\Delta ,\nabla,\delta` 分别称为 **向前差分算子** 、 **向后差分算子** 以及 **中心差分算子** 。\end{aligned}\end{align} \]</div>
</dd>
</dl>
<p>向前差分算子和向后差分算子有下面的性质：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; \Delta f_{k} = \nabla f_{k+1} , \qquad \nabla f_{k}=\Delta f_{k-1} \\
&amp; \Delta ^{2}f_{k}=\Delta (\Delta f_{k})=\Delta (f_{k+1}-f_{k})=\Delta f_{k+1}-\Delta f_{k} = f_{k+2}-2f_{k+1} + f_{k} \\
&amp; \nabla ^{2}f_{k}=\nabla (\nabla f_{k})=\nabla (f_{k}-f_{k-1})=\nabla f_{k}-\nabla f_{k-1}=f_{k}-2f_{k-1}+f_{k-2} \\
&amp; \Delta ^{2}f_{k} = \nabla ^{2}f_{k+2}
\end{align}\end{split}\]</div>
<p>为了更好地推导高阶差分，这里引入两个新的算子：不变算子 <span class="math notranslate nohighlight">\(I\)</span> 和位移算子 <span class="math notranslate nohighlight">\(E\)</span></p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp;If_{k}=f_{k}, \qquad I^{n}f_{k}=f_{k} \\
&amp;E^{n}f_{k}=f_{k+n}, \qquad E^{-n}f_{k}=f_{k-n}
\end{align}\end{split}\]</div>
<p>于是向前差分算子和向后差分算子就可以用不变算子和位移算子来表示：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp;\Delta f_{k}=f_{k+1} - f_{k} = (E-I)f_{k} \quad\Rightarrow\quad \Delta =E-I \\
&amp;\nabla f_{k}=f_{k}-f_{k-1} = (I-E^{-1})f_{k} \quad\Rightarrow\quad \nabla =I-E^{-1}
\end{align}\end{split}\]</div>
<p>于是高阶差分可以如下表示</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp;\Delta ^{n}f_{k}=(E-I)^{n}f_{k} = \sum_{j=0}^{n}(-1)^{j}C_{n}^{j}E^{n-j}I^{j}f_{k}=\sum_{j=0}^{n}(-1)^{j}C_{n}^{j}f_{k+n-j}  \\
&amp;\nabla ^{n}f_{k}=(I-E^{-1})^{n}f_{k}=\sum_{j=0}^{n}(-1)^{j}C_{n}^{j}E^{-j}f_{k}=\sum_{j=0}^{n}(-1)^{j}C_{n}^{j}f_{k-j}
\end{align}\end{split}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(C_{n}^{j}=\frac{n!}{(n-j)!j!}\)</span> 。不难发现， <span class="math notranslate nohighlight">\(\Delta ^{n}f_{k-n}=\nabla ^{n}f_{k}\)</span> 。</p>
<p>差分和均差的关系为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
f[x_{k},x_{k+1},\cdots,x_{k+n}]=\frac{1}{m!h^{m}}\Delta ^{m}f_{k}=\frac{1}{m!h^{m}}\nabla ^{m}f_{k+m}
\end{align}\]</div>
<p>差分和导数的关系为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
f[x_{k},\cdots,x_{k+n}]=\frac{1}{n!h^{n}}\Delta ^{n}f_{k}=\frac{f^{(n)}(\xi)}{n!}
\quad \Rightarrow \quad
\Delta ^{n}f_{k}=h^{n}f^{(n)}(\xi) \quad \xi\in[x_{k},x_{k+n}]
\end{align}\]</div>
</section>
<section id="id13">
<h4>等距节点的牛顿插值公式<a class="headerlink" href="#id13" title="此标题的永久链接"></a></h4>
<p>对于牛顿向前插值公式，如果令 <span class="math notranslate nohighlight">\(x=x_{0}+th\)</span> ， <span class="math notranslate nohighlight">\(x_{k}=x_{0}+kh\)</span> ，则有 <span class="math notranslate nohighlight">\(x-x_{k}=(t-k)h\)</span> ，于是牛顿向前插值公式可以改写为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
f(x)\approx f(x_{0})+\Delta f_{0}\cdot t+\frac{\Delta ^{2}f_{0}}{2}\cdot t(t-1)+\frac{\Delta ^{3}f_{0}}{3!}\cdot t(t-1)(t-2)+\cdots
\end{align}\]</div>
<p>可以得到其余项为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
R_{n}(x)=f(x)-N_{n}(x_{0}+th)=\frac{t(t-1)\cdots(t-n)}{(n+1)!}h^{n+1}f^{(n+1)}(\xi) , \quad \xi\in(x_{0},x_{n})
\end{align}\]</div>
<p>对于牛顿向后插值公式，如果令 <span class="math notranslate nohighlight">\(x=x_{n}+th\)</span> ， <span class="math notranslate nohighlight">\(x_{n-i}=x_{n}-ih\)</span> ，则有 <span class="math notranslate nohighlight">\(x-x_{n-i}=(t+i)h\)</span> ，于是牛顿向后插值公式可以改写为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
f(x)\approx f(x_{n})+\nabla f_{n}\cdot t+\frac{\nabla ^{2}f_{n}}{2!}\cdot t(t+1)+\frac{\nabla ^{3}f_{n}}{3!}\cdot t(t+1)(t+2)+\cdots
\end{align}\]</div>
<p>可以得到其插值余项为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
R_{n}(x)=f(x)-N_{n}(x_{n}+th)=\frac{t(t+1)\cdots(t+n)h^{n+1}f^{(n+1)}(\xi)}{(n+1)!} , \quad \xi\in(x_{0},x_{n})
\end{align}\]</div>
</section>
</section>
<section id="hermite">
<h3>Hermite插值<a class="headerlink" href="#hermite" title="此标题的永久链接"></a></h3>
<p>接下来我们讨论更进一步的插值条件：不但要求在节点上函数值相等，还要求它的导数值相等，即插值条件</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; H(x_{i})=f(x_{i})=y_{i} \\
&amp;H'(x_{i})=f'(x_{i})=y_{i}
\end{align}\end{split}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(i=0,1,\cdots,n\)</span> ，以上的 <span class="math notranslate nohighlight">\(2n+2\)</span> 个方程可以确定 <span class="math notranslate nohighlight">\(2n+2\)</span> 个未知数，可以唯一确定一个次数不超过 <span class="math notranslate nohighlight">\(2n+1\)</span> 的多项式。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>这个唯一性可以通过反证法来证明。假设存在 <span class="math notranslate nohighlight">\(P(x)\)</span> 及 <span class="math notranslate nohighlight">\(Q(x)\)</span> 均满足条件，于是可以构造 <span class="math notranslate nohighlight">\(\varphi(x)=P(x)+Q(x)\)</span> ，其在每个节点 <span class="math notranslate nohighlight">\(x_{k}\)</span> 上均有二重根，即 <span class="math notranslate nohighlight">\(\varphi(x)\)</span> 有 <span class="math notranslate nohighlight">\(2n+2\)</span> 重根，但是 <span class="math notranslate nohighlight">\(\varphi(x)\)</span> 是不高于 <span class="math notranslate nohighlight">\(2n+1\)</span> 次的多项式，因此 <span class="math notranslate nohighlight">\(\varphi(x)\equiv 0\)</span> ，唯一性得证。</p>
</div>
<p>采用求Lagrange插值多项式的基函数方法，先求插值基函数 <span class="math notranslate nohighlight">\(\alpha _{j}(x)\)</span> 以及 <span class="math notranslate nohighlight">\(\beta_{j}(x)\)</span> ，其中 <span class="math notranslate nohighlight">\(j=0,1,\cdots,n\)</span> ，共有 <span class="math notranslate nohighlight">\(2n+2\)</span> 个，每一个基函数都是 <span class="math notranslate nohighlight">\(2n+1\)</span> 次多项式，于是埃尔米特插值多项式可以表示为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
H_{2n+1}(x)=\sum_{i=0}^{n}y_{i}\alpha _{i}(x)+\sum_{i=0}^{n}y'_{i}\beta_{i}(x)
\end{align}\]</div>
<p>插值基函数满足条件</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; \alpha _{i}(x_{j})=\left \{\begin{array}{l}1 &amp; i=j \\ 0 &amp; i\ne j\end{array}\right.  &amp;&amp; \beta_{i}(x_{j})=0  \\
&amp; \alpha _{i}'(x_{j})=0  &amp;&amp; \beta' _{i}(x_{j})=\left \{\begin{array}{l}1 &amp; i=j \\ 0 &amp; i\ne j\end{array}\right.
\end{align}\end{split}\]</div>
<p>在上述条件下，可以使得 <span class="math notranslate nohighlight">\(H_{2n+1}(x_{i})=y_{i},~~H_{2n+1}'(x_{i})=y'_{i}\quad(i=0,1,\cdots,n)\)</span> 。</p>
<p>因为 <span class="math notranslate nohighlight">\(\beta_{i}(x)\)</span> 在 <span class="math notranslate nohighlight">\(x_{j}(i\ne j)\)</span> 处为二阶零点（两重根），在 <span class="math notranslate nohighlight">\(x_{i}\)</span> 处为一阶零点，于是可以分解为 <span class="math notranslate nohighlight">\(\beta_{i}(x)=A(x-x_{i})l_{i}^{2}(x)\)</span> ，根据 <span class="math notranslate nohighlight">\(\beta_{i}'(x_{i})=1\)</span> 可以得到 <span class="math notranslate nohighlight">\(A=1\)</span> 。</p>
<p>因为 <span class="math notranslate nohighlight">\(\alpha_{i}(x)\)</span> 在 <span class="math notranslate nohighlight">\(x_{j}(i\ne j)\)</span> 处为二阶零点，所以可以分解为 <span class="math notranslate nohighlight">\(\alpha_{i}(x)=(ax+b)l_{i}^{2}(x)\)</span> 。根据 <span class="math notranslate nohighlight">\(\alpha_{i}(x_{i})=1\)</span> 可以得到 <span class="math notranslate nohighlight">\(ax_{i}+b=1\)</span> ；根据 <span class="math notranslate nohighlight">\(\alpha_{i}'(x_{i})=0\)</span> 可以得到 <span class="math notranslate nohighlight">\(al_{i}^{2}(x_{i})+2l_{i}(x_{i})l_{i}'(x_{i})(ax_{i}+b)=a+2l_{i}'(x_{i})=0\)</span> ，从而可以得到</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
a = -2l'_{i}(x_{i})=-2\sum_{\substack{j=0 \\ j\ne i}}^{n}\frac{1}{x_{i}-x_{j}}
\end{align}\end{split}\]</div>
<p>进而根据 <span class="math notranslate nohighlight">\(b=1-ax_{i}\)</span> 得到</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
ax+b=ax + 1 - ax_{i}=1+a(x-x_{i})=1-2(x-x_{i})\sum_{\substack{j=0 \\ j\ne i}}^{n}\frac{1}{x_{i}-x_{j}}
\end{align}\end{split}\]</div>
<p>综上可知插值基函数的表达形式为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; \alpha _{i}(x)=\Big ( 1-2(x-x_{i})\sum_{\substack{j=0 \\ j\ne i}}^{n}\frac{1}{x_{i}-x_{j}} \Big )l_{i}^{2}(x)  \\
&amp; \beta_{i}(x)=(x-x_{i})l_{i}^{2}(x_{i})
\end{align}\end{split}\]</div>
<p>仿照拉格朗日插值余项的证明方法，如果 <span class="math notranslate nohighlight">\(f(x)\)</span> 在 <span class="math notranslate nohighlight">\((a,b)\)</span> 内的 <span class="math notranslate nohighlight">\(2n+2\)</span> 阶导数存在，则其插值余项为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
R(x)=f(x)-H_{2n+1}(x)=\frac{f^{(2n+2)}(\xi)}{(2n+2)!}\omega _{n+1}^{2}(x)
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\xi\in(a,b)\)</span> 且与 <span class="math notranslate nohighlight">\(x\)</span> 有关。</p>
</section>
</section>
<section id="id14">
<h2>函数逼近与计算<a class="headerlink" href="#id14" title="此标题的永久链接"></a></h2>
<p>函数逼近与计算要解决的问题是：对于函数类A中给定的函数 <span class="math notranslate nohighlight">\(f(x)\)</span> ，要求在另一类较简单的便于计算的函数类B中，求函数 <span class="math notranslate nohighlight">\(P(x)\in B\subseteq A\)</span> ，使 <span class="math notranslate nohighlight">\(P(x)\)</span> 与 <span class="math notranslate nohighlight">\(f(x)\)</span> 之差在某种度量意义下最小。函数A通常是区间 <span class="math notranslate nohighlight">\([a,b]\)</span> 上的连续函数，记作 <span class="math notranslate nohighlight">\(C[a,b]\)</span> ；函数类B通常是代数多项式、分式有理函数或三角多项式。</p>
<p>度量标准最常用的有两种，一种是一致逼近或均匀逼近：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\left \| f(x)-P(x) \right \| _{\infty} = \max_{a\leqslant x\leqslant b}\left | f(x)-P(x) \right |
\end{align}\]</div>
<p>另一种度量标准是均方逼近或平方逼近：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\left \| f(x)-P(x) \right \| _{2}=\sqrt{\int_{a}^{b}[f(x)-P(x)]^{2}\mathrm{d}x}
\end{align}\]</div>
</section>
<section id="id15">
<h2>常微分方程的数值解法<a class="headerlink" href="#id15" title="此标题的永久链接"></a></h2>
<p>需要解决的一阶方程初值问题：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; y' = f(x,y) \\
&amp; y(x_{0}) = y_{0}
\end{align}\end{split}\]</div>
<p>只要函数 <span class="math notranslate nohighlight">\(f(x,y)\)</span> 适当光滑，比如关于 <span class="math notranslate nohighlight">\(y\)</span> 满足Lipschitz条件 <span class="math notranslate nohighlight">\(|f(x,y)-f(x,\overline{y})|\leqslant L|y-\overline{y}|\)</span> ，理论上就可以保证初值问题的解 <span class="math notranslate nohighlight">\(y=y(x)\)</span> 存在并且唯一。</p>
<section id="euler">
<h3>Euler方法<a class="headerlink" href="#euler" title="此标题的永久链接"></a></h3>
<section id="id16">
<h4>改进的Euler格式<a class="headerlink" href="#id16" title="此标题的永久链接"></a></h4>
<p>先用Euler格式求得一个初步的近似值 <span class="math notranslate nohighlight">\(\overline{y}_{n+1}\)</span> ，称之为预测值，然后再使用梯形公式将它校正一次得到校正值 <span class="math notranslate nohighlight">\(y_{n+1}\)</span> ：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; \overline{y}_{n+1}=y_{n}+hf(x_{n},y_{n}) \\
&amp; y_{n+1}=y_{n}+\frac{h}{2}[f(x_{n},y_{n})+f(x_{n+1},\overline{y}_{n+1})]
\end{align}\end{split}\]</div>
<p>这一计算格式也可以表示为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
y_{n+1}=y_{n}+\frac{h}{2}[f(x_{n},y_{n})+f(x_{n}+h,y_{n}+hf(x_{n},y_{n}))]
\end{align}\]</div>
<p>或者表示为下列的平均化格式：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; y_{p}=y_{n}+hf(x_{n},y_{n}) \\
&amp; y_{c}=y_{n}+hf(x_{n+1},y_{p}) \\
&amp; y_{n+1}=\frac{1}{2}(y_{p}+y_{c})
\end{align}\end{split}\]</div>
</section>
</section>
<section id="runge-kutta">
<h3>Runge-Kutta方法<a class="headerlink" href="#runge-kutta" title="此标题的永久链接"></a></h3>
<section id="id17">
<h4>四阶Runge-Kutta方法<a class="headerlink" href="#id17" title="此标题的永久链接"></a></h4>
<p>四阶龙格库塔格式是非常常用的一个方法，其截断误差为 <span class="math notranslate nohighlight">\(O(h^{5})\)</span> ：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; y_{n+1} = y_{n}+\frac{h}{6}(K_{1}+2K_{2}+2K_{3}+K_{4}) \\
&amp; K_{1} = f(x_{n},y_{n}) \\
&amp; K_{2} = f(x_{n}+\frac{h}{2}, y_{n}+\frac{h}{2}K_{1} ) \\
&amp; K_{3} = f(x_{n}+\frac{h}{2}, y_{n}+\frac{h}{2}K_{2} ) \\
&amp; K_{4} = f(x_{n}+h,y_{n}+hK_{3})
\end{align}\end{split}\]</div>
<div class="admonition attention">
<p class="admonition-title">注意</p>
<p>四阶Runge-Kutta方法也有不足之处，它要求函数 <span class="math notranslate nohighlight">\(f\)</span> 具有较高的光滑性，如果 <span class="math notranslate nohighlight">\(f\)</span> 的光滑性差，那么它的精度可能还不如改进的Euler格式。其另一个缺点是计算量较大，相比之下，Hamming方法可以节省计算量。</p>
</div>
</section>
</section>
<section id="id18">
<h3>方程组与高阶方程的情形<a class="headerlink" href="#id18" title="此标题的永久链接"></a></h3>
<p>只要把原本的 <span class="math notranslate nohighlight">\(y\)</span> 和 <span class="math notranslate nohighlight">\(f\)</span> 理解为向量，那么之前提供的各种计算格式即可应用到一阶方程组的情形，此时方程组的初值问题可以表示为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\left \{\begin{array}{l}
\boldsymbol{y}'=\boldsymbol{f}(x,\boldsymbol{y}) \\
\boldsymbol{y}(x_{0})=\boldsymbol{y}_{0}
\end{array}\right .
\end{align}\end{split}\]</div>
<p>求解这一初值问题的四阶Runge-Kutta格式为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; \boldsymbol{y}_{n+1} = \boldsymbol{y}_{n}+\frac{h}{6}(\boldsymbol{k}_{1}+2\boldsymbol{k}_{2}+2\boldsymbol{k}_{3}+\boldsymbol{k}_{4}) \\
&amp; \boldsymbol{k}_{1} = f(x_{n},\boldsymbol{y}_{n}) \\
&amp; \boldsymbol{k}_{2} = f(x_{n}+\frac{h}{2}, \boldsymbol{y}_{n}+\frac{h}{2}\boldsymbol{k}_{1} ) \\
&amp; \boldsymbol{k}_{3} = f(x_{n}+\frac{h}{2}, \boldsymbol{y}_{n}+\frac{h}{2}\boldsymbol{k}_{2} ) \\
&amp; \boldsymbol{k}_{4} = f(x_{n}+h,\boldsymbol{y}_{n}+h\boldsymbol{k}_{3})
\end{align}\end{split}\]</div>
<p>关于高阶微分方程（组）的初值问题，原则上都可以通过引入新变量来归结为一阶方程组来求解。例如考虑 <span class="math notranslate nohighlight">\(m\)</span> 阶微分方程：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
y^{(m)}=f(x,y,y',\cdots,y^{(m-1)})
\end{align}\]</div>
<p>初始条件为 <span class="math notranslate nohighlight">\(y(x_{0})=y_{0},~y'(x_{0})=y_{0}',~\cdots,~y^{(m-1)}(x_{0})=y_{0}^{(m-1)}\)</span> 。只要引进新变量 <span class="math notranslate nohighlight">\(y_{1}=y,~y_{2}=y',~\cdots,~y_{m}=y^{(m-1)}\)</span> 即可将 <span class="math notranslate nohighlight">\(m\)</span> 阶方程化为如下的一阶方程组：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; y_{1}'=y_{2} \\
&amp; y_{2}'=y_{3} \\
&amp; ~~~\cdots \\
&amp; y_{m-1}'=y_{m} \\
&amp; y_{m}' = f(x,y_{1},y_{2},\cdots,y_{m})
\end{align}\end{split}\]</div>
<p>初始条件也相应地变为 <span class="math notranslate nohighlight">\(y_{1}(x_{0})=y_{0},~y_{2}(x_{0})=y_{0}',~\cdots,~y_{m}(x_{0})=y_{0}^{(m-1)}\)</span> 。</p>
</section>
<section id="id19">
<h3>边值问题的数值解法<a class="headerlink" href="#id19" title="此标题的永久链接"></a></h3>
<p>给出积分曲线首末两端的性态的条件称为边界条件，相应的定解问题称为边值问题。以二阶方程</p>
<div class="math notranslate nohighlight">
\[\begin{align}
y''=f(x,y,y')
\end{align}\]</div>
<p>为例，设在区间 <span class="math notranslate nohighlight">\(a&lt;x&lt;b\)</span> 上求解上述方程，则边界条件可以给为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
y(a)=\alpha , \qquad y(b)=\beta
\end{align}\]</div>
<p>一阶导数的逼近可以使用向前差商、向后差商或中心差商。为了逼近二阶导数 <span class="math notranslate nohighlight">\(y''(x)\)</span> ，一般使用二阶差分（向前差商的向后差商/向后差商的向前差商）：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
y''(x)\approx \frac{\frac{y(x+h)-y(x)}{h}-\frac{y(x)-y(x-h)}{h} }{h} =\frac{y(x+h)-2y(x)+y(x-h)}{h^{2}}
\end{align}\]</div>
<p>用差商代替相应的导数，可以将边值问题离散化得到下列计算公式：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; \frac{y_{n+1}-2y_{n}+y_{n-1}}{h^{2}}=f(x_{n},y_{n},\frac{y_{n+1}-y_{n-1}}{2h} ) \\
&amp; y_{0}=\alpha ,\quad y_{N}=\beta
\end{align}\end{split}\]</div>
<p>如果函数 <span class="math notranslate nohighlight">\(f\)</span> 是非线性的，那么归结出来的差分方程也是非线性的，这时求解比较困难。但是如果所给的方程的形式是如下的线性方程：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
y''+p(x)y'+q(x)y=r(x)
\end{align}\]</div>
<p>那么差分方程相应的形式就变为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{y_{n+1}-2y_{n}+y_{n-1}}{h^{2}}+p_{n}\frac{y_{n+1}-y_{n-1}}{2h}+q_{n}y_{n}=r_{n}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(n=1,\cdots,N-1\)</span> 。利用边界条件消去式中的 <span class="math notranslate nohighlight">\(y_{0}\)</span> 和 <span class="math notranslate nohighlight">\(y_{N}\)</span> 整理到得到下列方程组：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\left \{\begin{array}{ll}
(-2+h^{2}q_{1})y_{1}+(1+\frac{h}{2}p_{1})y_{2}=h^{2}r_{1}-(1-\frac{h}{2}p_{1})\alpha  \\
(1-\frac{h}{2}p_{n})y_{n-1}+(-2+h^{2}q_{n})y_{n}+(1+\frac{h}{2}p_{n})y_{n+1}=h^{2}r_{n} &amp; (2\leqslant n\leqslant N-2) \\
(1-\frac{h}{2}p_{N-1})y_{N-2}+(-2+h^{2}q_{N-1})y_{N-1}=h^{2}r_{N-1}-(1+\frac{h}{2}p_{N-1})\beta
\end{array}\right .
\end{align}\end{split}\]</div>
<p>如此可以看到归结出来的方程组的系数矩阵是三对角型的，即</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\begin{bmatrix}
 -2+h^{2}q_{1} &amp; 1+\frac{h}{2}p_{1}  &amp;  &amp;  &amp; \\
1-\frac{h}{2}p_{2}  &amp; -2+h^{2}q_{2} &amp; 1+\frac{h}{2}p_{2}  &amp;  &amp; \\
  &amp; \ddots  &amp; \ddots &amp; \ddots &amp; \\
  &amp;  &amp; 1-\frac{h}{2}p_{N-2}  &amp; -2+h^{2}q_{N-2} &amp; 1+\frac{h}{2}p_{N-2} \\
  &amp;  &amp; &amp; 1-\frac{h}{2}p_{N-1}  &amp; -2+h^{2}q_{N-1}
\end{bmatrix}
\end{align}\end{split}\]</div>
</section>
</section>
<section id="id20">
<h2>方程求根<a class="headerlink" href="#id20" title="此标题的永久链接"></a></h2>
<section id="id21">
<h3>Newton法<a class="headerlink" href="#id21" title="此标题的永久链接"></a></h3>
<p>牛顿迭代公式选取了 <span class="math notranslate nohighlight">\(\varphi(x) = x - \frac{f(x)}{f'(x)}\)</span> ，于是其迭代公式为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
x_{n+1}=x_{n}-\frac{f(x_{n})}{f'(x_{n})}
\end{align}\]</div>
<p>初始值的选取非常重要，应当离 <span class="math notranslate nohighlight">\(x^{*}\)</span> 很近。</p>
<p>使用Newton法求方程根的计算步骤如下：</p>
<ol class="arabic">
<li><p>选定初始近似值 <span class="math notranslate nohighlight">\(x_{0}\)</span> ，计算 <span class="math notranslate nohighlight">\(f_{0}=f(x_{0}),~f_{0}'=f'(x_{0})\)</span> 。</p></li>
<li><p>按公式 <span class="math notranslate nohighlight">\(x_{1}=x_{0}-f_{0}/f'_{0}\)</span> 迭代一次，得到新的近似值 <span class="math notranslate nohighlight">\(x_{1}\)</span> ，计算 <span class="math notranslate nohighlight">\(f_{1}=f(x_{1}),~f'_{1}=f'(x_{1})\)</span> 。</p></li>
<li><p>如果 <span class="math notranslate nohighlight">\(x_{1}\)</span> 满足 <span class="math notranslate nohighlight">\(|\delta|&lt;\varepsilon_{1}\)</span> 或 <span class="math notranslate nohighlight">\(|f_{1}|&lt;\varepsilon _{2}\)</span> 则终止迭代，以 <span class="math notranslate nohighlight">\(x_{1}\)</span> 作为所求的根，否则进入下一步。这里的 <span class="math notranslate nohighlight">\(\varepsilon _{1},\varepsilon _{2}\)</span> 是允许误差，而</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}\begin{align}
        \delta = \left \{\begin{array}{ll}
        |x_{1}-x_{0}|, &amp; \text{当}|x_{1}|&lt;C\text{时} \\
        \frac{|x_{1}-x_{0}|}{|x_{1}|}, &amp;  \text{当}|x_{1}|\geqslant C\text{时}
        \end{array}\right .
        \end{align}\end{split}\\其中 :math:`C` 是取绝对误差或相对误差的控制系数，一般可以取 :math:`C=1` 。\end{aligned}\end{align} \]</div>
</li>
</ol>
<ol class="arabic simple" start="5">
<li><p>如果迭代次数达到预定指定的次数 <span class="math notranslate nohighlight">\(N\)</span> 或者 <span class="math notranslate nohighlight">\(f_{1}'=0\)</span> ，则方法失败，否则以 <span class="math notranslate nohighlight">\((x_{1},f_{1},f_{1}')\)</span> 代替 <span class="math notranslate nohighlight">\((x_{0},f_{0},f'_{0})\)</span> 回到步骤2继续迭代。</p></li>
</ol>
<p>一般来说，Newton法的收敛性依赖于初值 <span class="math notranslate nohighlight">\(x_{0}\)</span> 的选取，如果 <span class="math notranslate nohighlight">\(x_{0}\)</span> 偏离所求的根 <span class="math notranslate nohighlight">\(x^{*}\)</span> 比较远，则Newton法可能发散。为了防止迭代发散，对迭代过程再附加一项要求，即具有单调性：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
|f(x_{k+1})| &lt; |f(x_{k})|
\end{align}\]</div>
<p>满足这项要求的算法称为下山法。将Newton法与下山法结合起来使用，即可在下山法保证函数值稳定下降的前提下，用Newton法加快收敛速度。为此，将Newton法的计算结果 <span class="math notranslate nohighlight">\(\overline{x}_{k+1} = x_{k} - \frac{f(x_{k})}{f'(x_{k})}\)</span> 与前一步的近似值 <span class="math notranslate nohighlight">\(x_{k}\)</span> 适当加权平均作为新的改进值，即</p>
<div class="math notranslate nohighlight">
\[\begin{align}
x_{k+1} = \lambda \overline{x}_{k+1} + (1-\lambda)x_{k}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\lambda~(0&lt;\lambda \leqslant 1)\)</span> 称为下山因子。下山因子的选择时个逐步探索的过程。假设从 <span class="math notranslate nohighlight">\(\lambda=1\)</span>lambda` 减半进行试算，如果能定出值 <span class="math notranslate nohighlight">\(\lambda\)</span> 使单调性条件成立，则称“下山成功”；如果在上述过程中找不到使该条件成立的下山因子，则称“下山失败”，此时需要另外选择初值 <span class="math notranslate nohighlight">\(x_{0}\)</span> 重算。</p>
<p>另外，当 <span class="math notranslate nohighlight">\(x^{*}\)</span> 是 <span class="math notranslate nohighlight">\(f(x)\)</span> 的多重根时，分母 <span class="math notranslate nohighlight">\(f'(x^{*})=0\)</span> 。对于这种重根问题，有两种改良思路：</p>
<ul class="simple">
<li><p>如果已知重数为 <span class="math notranslate nohighlight">\(m\)</span> ，那么可以改令 <span class="math notranslate nohighlight">\(\varphi(x)=x-m\frac{f(x)}{f'(x)}\)</span> 。</p></li>
<li><p>或者直接令 <span class="math notranslate nohighlight">\(u(x)=\frac{f(x)}{f'(x)}\)</span> ，此时 <span class="math notranslate nohighlight">\(u(x)\)</span> 以 <span class="math notranslate nohighlight">\(x^{*}\)</span> 为单根，对 <span class="math notranslate nohighlight">\(u(x)\)</span> 应用牛顿法即可。</p></li>
</ul>
</section>
<section id="id22">
<h3>弦截法与抛物线法<a class="headerlink" href="#id22" title="此标题的永久链接"></a></h3>
<p>在用Newton法时要求提供导数值 <span class="math notranslate nohighlight">\(f'(x_{k})\)</span> 。为了回避导数值的计算，可以考虑使用之前迭代的信息的插值结果。</p>
<p>弦截法是使用 <span class="math notranslate nohighlight">\(f(x_{n}),f(x_{n-1})\)</span> 构造插值多项式 <span class="math notranslate nohighlight">\(P_{1}(x)=f(x_{n})+f[x_{n},x_{n-1}](x-x_{n})\)</span> ，用 <span class="math notranslate nohighlight">\(P_{1}(x)\)</span> 的根来近似 <span class="math notranslate nohighlight">\(x^{*}\)</span> ，此时</p>
<div class="math notranslate nohighlight">
\[\begin{align}
x_{n+1}=x_{n}-\frac{f(x_{n})}{f[x_{n},x_{n-1}]}
\end{align}\]</div>
<p>这相当于用 <span class="math notranslate nohighlight">\(f[x_{n},x_{n-1}]=\frac{f(x_{n})-f(x_{n-1})}{x_{n}-x_{n-1}}\)</span> 。该迭代过程的几何意义为：根据已知两点形成的弦在 <span class="math notranslate nohighlight">\(x\)</span> 轴的交点作为求得的下一个点的横坐标。</p>
<p>弦截法的计算步骤如下：</p>
<ol class="arabic">
<li><p>选取初值近似值 <span class="math notranslate nohighlight">\(x_{0},x_{1}\)</span> ，计算相应的函数值 <span class="math notranslate nohighlight">\(f_{0}=f(x_{0}),f_{1}=f(x_{1})\)</span> 。</p></li>
<li><p>根据公式 <span class="math notranslate nohighlight">\(x_{2}=x_{1}-f_{1}/(\frac{f_{1}-f_{0}}{x_{1}-x_{0}} )\)</span> 迭代一次得到新的近似值 <span class="math notranslate nohighlight">\(x_{2}\)</span> ，计算 <span class="math notranslate nohighlight">\(f_{2}=f(x_{2})\)</span> 。</p></li>
<li><p>如果 <span class="math notranslate nohighlight">\(x_{2}\)</span> 满足 <span class="math notranslate nohighlight">\(|\delta| \leqslant \varepsilon _{1}\)</span> 或 <span class="math notranslate nohighlight">\(|f_{2}|\leqslant \varepsilon _{2}\)</span> 则认为过程收敛，终止迭代而以 <span class="math notranslate nohighlight">\(x_{2}\)</span> 作为所求的根；否则执行下一步。此处 <span class="math notranslate nohighlight">\(\varepsilon _{1},\varepsilon _{2}\)</span> 是允许误差，而</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}\begin{align}
            \delta = \left \{\begin{array}{ll}
            |x_{2}-x_{1}|, &amp; \text{当}|x_{2}|&lt;C\text{时} \\
            \frac{|x_{2}-x_{1}|}{|x_{2}|}, &amp;  \text{当}|x_{2}|\geqslant C\text{时}
            \end{array}\right .
            \end{align}\end{split}\\其中 :math:`C` 是预先指定的控制数。\end{aligned}\end{align} \]</div>
</li>
<li><p>如果迭代次数达到预先指定的次数 <span class="math notranslate nohighlight">\(N\)</span> ，则认为过程不收敛，计算失败；否则以 <span class="math notranslate nohighlight">\((x_{1},f_{1}),(x_{2},f_{2})\)</span> 分别代替 <span class="math notranslate nohighlight">\((x_{0},f_{0}),(x_{1},f_{1})\)</span> 回到步骤2继续迭代。</p></li>
</ol>
<p>抛物线法是使用 <span class="math notranslate nohighlight">\(x_{n},x_{n-1},x_{n-2}\)</span> 三个点来构造 <span class="math notranslate nohighlight">\(P_{2}(x)\)</span> ，把 <span class="math notranslate nohighlight">\(P_{2}(x)\)</span> 的根作为 <span class="math notranslate nohighlight">\(x_{n+1}\)</span> ，此时</p>
<div class="math notranslate nohighlight">
\[\begin{align}
x_{n+1} = x_{n} - \frac{2f(x_{n})}{\omega \pm \sqrt{\omega ^{2} - 4f(x_{n}f[x_{n},x_{n-1},x_{n-2}])}}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\omega =f[x_{n},x_{n-1}]+f[x_{n},x_{n-1},x_{n-2}](x_{n}-x_{n-1})\)</span> 。根式前的 <span class="math notranslate nohighlight">\(\pm\)</span> 号选择与 <span class="math notranslate nohighlight">\(\omega\)</span> 符号一致。</p>
</section>
</section>
<section id="id23">
<h2>解线性方程组的直接方法<a class="headerlink" href="#id23" title="此标题的永久链接"></a></h2>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF.html" class="btn btn-neutral float-left" title="模拟电路" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="%E6%95%B0%E7%90%86%E6%96%B9%E7%A8%8B.html" class="btn btn-neutral float-right" title="数理方程" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2022-2023, Koishi.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a>开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
