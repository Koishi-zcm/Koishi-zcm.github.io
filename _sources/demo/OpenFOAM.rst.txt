********
OpenFOAM
********

运行算例
========

cavity算例
-----------

在运行算例前要先创立一个 :code:`run` 文件夹来存放算例文件。该文件位于 :code:`HOME/OpenFOAM/<USER>/run` 下，其中 :code:`<USER>` 为用户具体的名称。 :code:`run` 文件夹通过 :code:`$FOAM_RUN` 环境变量来定义，可以在终端输入

.. code-block:: 

    ls $FOAM_RUN

来查看 :code:`run` 文件夹的具体位置。如果终端返回空文件夹，则可以输入

.. code-block:: 

    mkdir -p $FOAM_RUN

来创建 :code:`run` 文件夹。

下面来尝试运行教程算例中的cavity算例。先将该算例拷贝到run目录下，同时进入该算例目录。

.. code-block:: 

    cd $FOAM_RUN
    cp -r $FOAM_TUTORIALS/incompressible/icoFoam/cavity/cavity .
    cd cavity

.. attention:: 上面第二行命令中最后的实心句号 :code:`.` 不可遗漏。

接下来用OpenFOAM提供的 :code:`blockMesh` 命令来生成网格。该命令通过读取位于算例文件夹下的 :code:`system/ployMesh` 文件夹内的 :code:`blockMeshDict` 字典文件的信息来生成网格。该文件首先指定各个block顶点(vertices)的坐标，然后通过顶点编号来定义block，最后定义边界面。

进入到算例目录下之后，直接在终端输入该命令即可生成网格：

.. code-block:: 

    blockMesh

网格生成完毕后，就可以进入算例目录下查看该算例的初始场信息。因为cavity算例是从0秒开始计算的，所以初始的场信息存储在cavity目录下的 :code:`0` 文件夹下。该文件夹下包含 :code:`p` 和 :code:`U` 两个文件夹，分别是压力场和速度场，它们的初值和边界条件必须指定。

首先进入 :code:`p` 文件查看其信息。可以看到场文件中有3个主要信息：

- :code:`dimensions` 指定场的单位，此处为运动压力，即除以密度之后的压力，单位为 :math:`\mathrm{m^{2}}\mathrm{s^{-2}}` 。
- :code:`internalField` 内部场可以指定为 :code:`uniform` (均一场)，或者每个网格的数据都需要指定的 :code:`nonuniform` (非均一场)。
- :code:`boundaryField` 指定边界场信息，包括边界条件以及所有边界面所需的信息。
  
对于这个cavity算例，边界场由 :code:`walls` 组成，并分为两个 :code:`patches` ：(1) :code:`fixedWalls` 用来指定固定边界，即cavity几何的底部和侧面。(2) :code:`movingWall` 用来指定cavity几何的上部。它们作为壁面，压力边界条件均为 :code:`zeroGradient` ，意味着压力的法向梯度为零。 :code:`frontAndBack` 面即为2D算例的前后面，因此必须指定为 :code:`empty` 。

在该算例中，由于压力是运动压力，作为不可压缩流，其绝对值是没有意义的，关心的是相对压力，同时由于压力边界条件全部为 :code:`zeroGradient` ，需要设置压力参考点和参考值，所以初始场都设置为 :code:`uniform` ，考虑相对值时无所谓具体数值，就保持默认设置，即 :code:`uniform 0` 即可。

进入到 :code:`U` 文件查看其信息。 :code:`dimensions` 是速度的单位。内部场初始化为零，而由于速度是具有三个分量的矢量，因此初始化要写成 :code:`uniform (0 0 0)` 。速度场的 :code:`frontAndBack` 同样为 :code:`empty` ，其他的 :code:`patches` 均为 :code:`fixedWalls` ，且指定为无滑移边界条件即 :code:`fixedValue` ，其值为 :code:`value uniform (0 0 0)` 。因为在该算例中，我们假设顶部壁面以每秒1米的速度在x方向移动，这是一个固定速度即 :code:`fixedValue` ，其具体的值为 :code:`uniform (1 0 0)` ，所以 :code:`movingWall` 当中有相应的些设定。


算例的物理特性存储在 :code:`constant` 文件夹内的 :code:`physicalProperties` 文件当中。对于cavity算例，唯一需要给定的参数为运动粘度。我们的算例雷诺数为 :code:`10` ，根据雷诺数的定义 :code:`\operatorname{Re}=\frac{d|\boldsymbol{U}|}{\nu}` ，此处特征长度 :code:`d=0.1~\mathrm{m}` ，速度 :code:`|\boldsymbol{U}|=1~\mathrm{m/s}` ，运动粘度为 :code:`0.01~\mathrm{m^{2}/s}` 。指定运动粘度场的方式为：

.. code-block:: C

    nu              [0 2 -1 0 0 0 0] 0.01;



进入 :code:`system` 文件夹内的 :code:`controlDict` 字典来对时间步、输入输出时间、场数据的读取和写入进行控制。因为我们在 :math:`t=0` 的时候开始进行计算，所以设定 :code:`startFrom` 关键字信息为 :code:`startTime` ，并把 :code:`startTime` 指定为 :code:`0` 。运算结束的时候，我们希望能够达到稳定的状态，即流体在空腔内循环，一个通用准则是：层流下流体应该穿过(循环)计算域 :math:`10` 次。不过，该算例中没有进出口，因此流体没有穿过计算域，所以结束时间应该设置为空腔内循环 :math:`10` 次的时间。这里我们设置设置结束时间为 :math:`0.5~\mathrm{s}` ，于是把 :code:`stopAt` 关键字指定为 :code:`endTime` 并指定为 :code:`endTime` 为 :code:`0.5` 。


当运行 :code:`icoFoam` 的时候，为了达到数值稳定以及时间计算精度，库朗数 :math:`\mathrm{Co}=\frac{\delta t|\boldsymbol{U}|}{\delta x}` 应该小于1，其中 :math:`\delta t` 为时间步， :math:`|\boldsymbol{U}|` 为某个网格单元内的速度矢量的模， :code:`\delta x` 为速度方向的网格长度。由于流体域内速度并不均一，为了保证库朗数在各处都小于 :math:`1` ，可以依据最大速度和最小网格尺寸来确定时间步。在该算例中，网格大小是固定的，因此在顶盖附近，速度接近 :math:`1~\mathrm{m/s}` 的地方库朗数最大，网格大小为

.. math::
	\begin{align}
	\delta x=\frac{d}{n}=\frac{0.1}{20}=0.005~\mathrm{m}   
	\end{align}

为了使库朗数在整个流体域都小于或等于1，时间必须小于或等于

.. math::
	\begin{align}
	\delta t=\frac{\mathrm{Co}\delta x }{|\boldsymbol{U}|}=\frac{1\times 0.005}{1}=0.005~\mathrm{s} 
	\end{align}

所以设定时间步 :code:`deltaT` 为 :code:`0.005` 。随着计算的进行，为了在某个固定的时间间隔写入数据，可以通过 :code:`writeControl` 关键字来控制，如果要在 :math:`0.1~\mathrm{s},~0.2~\mathrm{s},\cdots,~0.5~\mathrm{s}` 写入结果，由于计算时间步为 :math:`0.005~\mathrm{s}` ，因此需要每 :math:`20` 个时间步输出一次结果，所以设定 :code:`writeInterval` 为 :code:`20` 。启动运算后OpenFOAM将会在每一个时间步内创建一个文件夹，例如0.1文件夹。

在 :code:`system` 文件夹下的 :code:`fvScheme` 文件来指定有限体积法的离散格式。在 :code:`system` 下的 :code:`fvSolution` 文件中指定方程组矩阵求解器、残差以及其他算法控制。

在运行算例之前，最好通过ParaView查看一下网格。使用ParaView之前，要保证每个版本OpenFOAM对应的Thirdparty文件编译完成，即进入对应的Thirdparty文件目录，在终端输入：

.. code-block:: 

    ./Allwmake


编译完成后，进入算例文件夹下，输入

.. code-block:: 

    paraFoam &

即可打开ParaView窗口。在该窗口中，可以看到算例模块打开的名称为 :code:`cavity.openfoam` 。在Properties选项卡内中找到Mesh Regions，勾选所有网格，之后点击Apply即可加载所有几何数据。找到Display选项卡，可以更改Representation为Wireframe使几何数据以线网格的形式呈现；在Coloring中修改为Solid Color来更改着色方式。


cavityFine算例
-----------------

现在在cavity算例的基础上，复制重命名一个算例为cavityFine，进入blockMeshDict编辑网格信息，将原本的 :code:`(20 20 1)` 修改为 :code:`(40 40 1)` 来增加每个方向的网格数量以提高密度。重新进入终端运行 :code:`blockMesh` 重新生成网格。

从cavity到cavityFine时，由于几何、边界类型和条件是相同的，因此场本身可以认为是相同的，于是可以用 :code:`mapFields` 命令来把一个给定几何的场信息映射到另一个几何的对应场。读取的场信息通过 :code:`controlDict` 中的 :code:`startFrom` 的 :code:`startTime` 指定，而cavity算例的最终结果存储在0.5文件夹中，因此cavityFine算例中 :code:`controlDict` 文件中的 :code:`startTime` 应该设定为 :code:`0.5` 。设定完后，还需要将0.5文件夹中的 :code:`p` 文件和 :code:`U` 文件当中已存在的点数据全部删除，否则后续会出现点数量不对应的报错。删除后就可以在该算例目录中的终端运行：

.. code-block::

    mapFields ../cavity -consistent

正常运行完成后0.5文件夹内的 :code:`p` 文件和 :code:`U` 文件中的点数据就更新成功了。在网格大小减半后，为了保持 :math:`\mathrm{Co}` 小于 :math:`1` ， :code:`controlDict` 字典中的 :code:`deltaT` 需要设定为 :code:`0.0025` ，同时设置 :code:`endTime` 为 :code:`0.7` 。之前设定写入数据的方式是固定 :code:`timeStep` ，现在我们将 :code:`writeControl` 改为 :code:`runTime` 方式来指定每多少个物理时间间隔来写结果文件，此时 :code:`writeInterval` 为 :code:`0.1` 。

为了将输出信息记录为log文件以便查看，通过下面的方式来运行 :code:`icoFoam` ：

.. code-block:: 

    icoFoam > log &

可以直接点开log文件或者用命令 :code:`cat log` 查看其中的信息。删除原本的 :code:`cavity.foam` 文件，重新在终端输入下面的命令来启动Paraview查看结果。

.. code-block:: 

    paraFoam -builtin

可以在算例目录下运行下面的命令来得到速度场各分量的文件：（注意其中的双引号）

.. code-block:: 

    postProcess -func "components(U)"

之后就可以在ParaView中Refresh Times来加载新的场，同时注意如果网格选择了边界区域，那么在ParaView中的插值会出现问题，因此要不能勾选边界面如 :code:`movingWall` ， :code:`fixedWalls` 和 :code:`frontAndBack` ，只勾选 :code:`internalMesh` 。

现在，在ParaView当中，对cavity.foam添加Filter，选择 :code:`Data Analysis` 中的 :code:`Plot Over Line` 。设置线的起始端和结束端，这里设置 :code:`Point1` 起始点为 :code:`(0.05,0,0.005)` ，在 :code:`Point2` 中设置终点为 :code:`(0.05,0.1,0.005)` ，同时设置 :code:`Resolution` 为 :code:`100` 。点击Apply后就会生成对应的图表，默认在Display面板中设置 :code:`Attribute Type` 为 :code:`Point Data` ，设置 :code:`X Array name` 为 :code:`arc_length` 。可以在 :code:`Series Parameters` 中选择显示的场，同时左键选择对应的量之后，可以进一步设置线条颜色、标签名、线条宽度、线条类型、标记点类型、坐标轴类型。



cavityGrade算例
----------------

在对任何一个算例求解之前应该预测哪里误差比较大然后在那一部分细化网格。在cavity算例中，速度最大的变动发生在壁面处，因此这一部分网格可以进行非均匀化处理。从blockMeshDict文件中可以看到，在该算例中使用了4个blocks，上下面和左右面都需要网格非均匀化分布处理，每个block在x,y方向都有10个网格，最大网格和最小网格的大小比为2。可以执行 :code:`blockMesh` 命令后用ParaView查看一下非均匀化处理之后的网格情况。

因为顶盖附近的速度最高，网格最小，顶盖附近的库朗数也会变大，所以要计算一下顶盖附近网格的大小来确定适合本算例的时间步。当使用一个非均匀网格时，如果长度为 :math:`l` ，内置 :math:`n` 个网格单元，最末端和起始端网格比为 :math:`R` ，那么最小的网格大小就是 :math:`\delta x` ，其大小为

.. math::
    \begin{align}
    \delta x=l \frac{r - 1}{\alpha r - 1} 
    \end{align}

其中 :math:`r=R^{\frac{1}{n-1}}` 是相邻网格单元的大小比，且有

.. math::
    \begin{align}
    \alpha =\left \{  \begin{array}{cl}
    R & R>1; \\
    1-r^{-n}r^{-1} & R<1;
    \end{array} \right.
    \end{align}

对于cavityGrade算例，每个方向网格数为10，最大网格单元和最小网格单元大小比为2，block的高宽为 :math:`0.05~\mathrm{m}` ，因此最小的网格单元为 :math:`3.45~\mathrm{mm}` ，从而可知时间步应该小于 :math:`3.45~\mathrm{ms}` 才能保证库朗数小于1。为了方便写入每个时间步的计算结果， :code:`deltaT` 设置为 :math:`2.5~\mathrm{ms}` ， :code:`writeInterval` 设置为 :code:`40` ，因此每隔0.1秒写一个结果文件。本算例的 :code:`startTime` 需要设置为cavityFine的结束时间，即 :math:`0.7~\mathrm{s}` ，而由于cavity和cavityFine算例都已经收敛地很好了，因此整个算例只需要计算 :math:`0.1~\mathrm{s}` ，即结束时间 :code:`endTime` 设为 :code:`0.8` 。之后在cavityGrade目录下使用下面的命令即可映射结果：

.. code-block::

    mapFields ../cavityFine -consistent

运行 :code:`icoFoam` 监控运行输出信息，并对结果后处理与之前的结果比对。



cavityHighRe算例
--------------------

目前的算例雷诺数非常低，仅为10，可以快速地达到稳定状态，并且只有一个非常小的涡旋存在于空腔的底角。接下来我们把雷诺数增加到100，这会明显增加收敛时间。首先拷贝cavity算例并命名为cavityHighRe。可以在run目录下用下面的命令来完成拷贝：

.. code-block:: 

    foamCloneCase -latestTime cavity cavityHighRe

进入cavityHighRe算例中的constant文件夹，编辑physicalProperties文件，为了让雷诺数扩大为10倍，可以通过把粘度降低为原来的1/10来实现，即变为 :math:`10\mathrm{e}-3~\mathrm{m^{2}s^{-1}}` 。修改 :code:`startTime` 为 :code:`latestTime` ，结束时间 :code:`endTime` 设为 :math:`2~\mathrm{s}` 。

接下来在算例目录下运行算例查看输出。可以用下面的命令来以后台进程的方式来运行算例，其中的UNIX命令 :code:`nohup` 表示当用户退出登录时程序依然继续运行， :code:`nice` 用于调整进程优先级， :code:`-20` 对应最高优先进程， :code:`19` 对应最低优先进程。

.. code-block:: 

    nohup nice -n 19 icoFoam > log &


.. note:: 

    查看log文件可以发现，icoFoam在非常短的时间内就停止了对速度进行迭代， :code:`No Iterations 0` 表示速度的求解已经停止，并且在压力的初始残差小于 :code:`fvSolution` 设定的残差值 :code:`10e-6` 之后，求解就已经收敛。

接下来可以用ParaView查看结果的速度矢量，可以发现角落里的第二个涡略微变大了。可以继续尝试减少粘度来增加雷诺数并重新运行算例，涡的数量会增加，因此也就需要在涡的附近增加网格来求解更复杂的流型。另外，高雷诺数也增加了收敛所需要的时间，需要监控残差并延长求解时间以确保收敛。


cavityRAS算例
--------------

在如果继续用上一个算例的思想来求解湍流域的话，提高网格数量和增加求解时间将会带来求解稳定性较差、计算资源消耗庞大的问题。接下来我们使用Reynolds-Average Simulation (RAS)湍流模型来求解流体的平均行为以及统计波动，算例雷诺数为 :code:`10e4` 的顶盖驱动流，使用附带壁面函数的标准 :math:`k-\varepsilon` 模型来进行求解。这会出现两个新的变量：湍流动能场 :math:`k` 和湍流动能耗散率场 :math:`\varepsilon` ，需要使用的求解器为 :code:`pisoFoam` 。

首先从 :code:`tutorials/incompressible/pisoFoam/RAS` 文件夹中将 :code:`cavity` 算例复制出来并重命名为 :code:`cavityRAS` 。进入算例目录，直接使用 :code:`blockMesh` 生成网格。

.. note:: 当使用附带壁面函数的标准 :math:`k-\varepsilon` 模型时，没必要引入非均匀网格，因为壁面附近的流型已经被模化而不是直接求解。

OpenFOAM自带的壁面函数边界条件可以分别用于不同边界面，不同壁面可以使用不同的壁面边界条件。我们可以对湍流粘度场 :math:`\nu_{t}` 进行修改以使用不同的壁面函数，其位于 :code:`0/nut` 文件夹内。在该算例中，通过把 :code:`movingWall` 和 :code:`fixedWall` 指定为 :code:`nutWallFunction` 类型来使用标准壁面函数模型。如果想指定其他的壁面边界模型，例如指定为粗糙壁面边界类型，可以通过 :code:`nutRoughWallFunction` 关键词来指定。

我们可以打开 :math:`k` 文件和 :math:`\varepsilon` 文件来查看它们的边界类型。对于壁面边界条件， :math:`\varepsilon` 为 :code:`epsilonWallFunction` 边界条件， :math:`k` 为 :code:`kqRWallFunction` 边界条件。 :code:`kqRWallFunction` 是一个普适性边界条件，它可以用于任何的湍动能类场，例如 :math:`k` 、 :math:`q` 以及雷诺应力 :math:`R` 场。最初的 :math:`k` 和 :math:`\varepsilon` 值通过对速度波动量 :math:`\boldsymbol{U}'` 和湍流尺度量 :math:`l` 进行预估来计算，它们的计算公式为：

.. math::
    \begin{align}
    & k=\frac{1}{2}\overline{\boldsymbol{U}'\cdot \boldsymbol{U}'}, && \varepsilon =\frac{C_{\mu}^{0.75}k^{1.5}}{l} 
    \end{align}

其中 :math:`C_{\mu}` 是 :math:`k-\varepsilon` 模型的标准参数，其值为 :math:`0.09` 。对于笛卡尔坐标系， :math:`k` 的计算公式可以改写为

.. math::
    \begin{align}
    k=\frac{1}{2}\left ( U_{x}'^{2}+U_{y}'^{2}+U_{z}'^{2} \right )
    \end{align}

其中 :math:`U_{x}'` , :math:`U_{y}'` , :math:`U_{z}'` 是速度在 :math:`x,y,z` 方向的脉动速度。

在本算例中，我们假定其为各向同性湍流，满足 :math:`U_{x}'^{2}=U_{y}'^{2}=U_{z}'^{2}` ，其值为顶盖速度的 :math:`5\%` ，湍流尺度为正方体宽度的 :math:`20\%` 即 :math:`0.1~\mathrm{m}` ，从而可以计算出 :math:`k` 和 :math:`\varepsilon` 的初始条件：

.. math::
    \begin{align}
    & U_{x}'=U_{y}'=U_{z}'=\frac{5}{100}~\mathrm{m/s} \\
    & k=\frac{3}{2}(\frac{5}{100})^{2} = 3.75\times 10^{-3}~\mathrm{m^{2}s^{-2}} \\
    & \varepsilon =\frac{C_{\mu}^{0.75}k^{.15}}{l}\approx 7.54\times 10^{-4}~\mathrm{m^{2}s^{-2}}    
    \end{align}

速度和压力的边界条件跟之前的相同，为 :code:`(0 0 0)` 和 :code:`0` 。

目前存在很多的湍流模型，在大多数瞬态求解器中，湍流模型是在运行时进行选择的。求解器最开始运行的时候，它会读取 :code:`constant/momentum Transport` 文件中的 :code:`simulationType` 关键字来获取湍流模型的相关信息。可选的 :code:`simulationType` 包括 :code:`laminar` ， :code:`RAS` 和 :code:`LES` 。在该算例中我们选择 :code:`RAS` ，并选择标准 :math:`k-\varepsilon` 模型 :code:`kEpsilon` ，同时要确保 :code:`turbulence` 设置为 :code:`on` 状态。每个湍流模型的参数都存储在每个湍流模型的代码中并且具有一个默认值，如果 :code:`printCoeffs` 设置为 :code:`on` 的话，那么这些参数的值会被输出到终端。这些模型的参数也可以通过在 :code:`RAS` 子字典文件中自定义来修改。

接下来到 :code:`physicalProperties` 文件中设置层流粘度。经过计算可知当设置动力粘度为 :code:`10e-5` 时雷诺数可以达到 :math:`10^{4}` 。最后进入 :code:`controlDict` 里面进行调整。为了保证库朗数小于1，将 :code:`deltaT` 设置为 :code:`0.005` ，并将结束时间设置为 :math:`10~\mathrm{s}` 。

此时在算例目录下进入终端键入 :code:`pisoFoam` 命令来运行算例。在这个算例中，由于粘度非常低，顶盖附近的边界层会非常薄，而我们顶盖附近的网格又比较稀疏，因此在这些网格中的速度要比顶盖的速度小得多。实际上，大约100个时间步之后，可以看到顶盖附近的网格单元速度的上限大约为 :math:`0.2~\mathrm{m/s}` ，因此最大库朗数不会超过 :math:`0.2` ，从而可以通过调节时间步来增大库朗数的同时保持小于1的条件。这里，我们从第10秒开始，将 :code:`endTime` 设置为 :code:`20` ，同时调节 :code:`deltaT` 为 :code:`0.02` ，重新运行。

.. note:: 监控残差情况可以判断是否达到稳态，或者算例的某个结果场达到了一种循环的状态。后者的情况下，算例可能永远不会收敛，但这并不意味着计算地不精确。


cavityClipped算例
-------------------

有时候可能会需要改变一下几何模型然后重新计算，在这种情况下最好保留所有计算过的文件，并在新算例中调用它们。然而，在新的几何模型中，场数据可能不一样了。不过， :code:`mapFields` 程序可以处理完全一样的几何或者不一样的几何，以及重合边界或者非重合边界。这里我们来运行 :code:`icoFoam/cavity/cavityClipped` 算例。在这个算例中，几何模型在底部的右边有一个边长为0.04米正方形被移除，可以进入 :code:`blockMeshDict` 来查看网格细节。直接使用 :code:`blockMesh` 生成网格， :code:`patches` 参考之前算例的设定。为了在 :code:`mapFields` 的过程中便于区分，在本算例中，将原本的 :code:`movingWall` 改名为 :code:`lid` 。

在非连续几何的映射中，不能保证所有场数据都能映射过来。在某些区域，原始场并不包含相关数据，这些区域还是被映射场的原始数据，因此在映射前，在响应的时间步内就应该存在响应的场数据。在这个算例中，我们从0.5秒开始进行映射，因此在 :code:`controlDict` 中设定 :code:`startTime` 为 :code:`0.5` ，并把0秒的场数据拷贝到0.5文件中。

接下来将cavity中的速度和压力场数据映射到cavityClipped算例中。因为映射是不连续的，因此需要编辑 :code:`system/mapFieldsDict` 文件。该文件内包含两个关键词： :code:`patchMap` 和 :code:`cuttingPatches` 。

如果想把原始场的 :code:`patches` 条件映射到被映射场的 :code:`patches` 的时候，要使用 :code:`patchMap` 。在本算例中，我们的 :code:`lid` 边界条件和cavity算例中的 :code:`movingWall` 边界条件是一致的，因此可以如下设置：

.. code-block:: C

    patchMap        (lid movingWall);

当需要把原始场的内部数据映射到被映射场的边界时，要使用 :code:`cuttingPatches` 。在本算例中，因为 :code:`fixedWalls` 的边界条件为 :code:`noSlip` ，因此我们不需要对 :code:`fixedWalls` 的边界的值进行映射，所以可以指定为空：

.. code-block:: C

    cuttingPatches  ();

.. note:: 如果需要将内部场的值映射到 :code:`fixedWalls` 边界上，则需要在 :code:`fixedWalls` 中指定 :code:`fixedValue` 边界条件，其关键字 :code:`value` 值在映射过程中将会被改写。在这种情况下，需要在 :code:`cuttingPatches` 里面指定 :code:`fixedWalls` 关键词。

接下来就可以执行下面的命令进行映射：

.. code-block:: 

    mapFields ../cavity

之后就可以运行 :code:`icoFoam` 并进入ParaView查看结果。在ParaView中可以直接添加Stream Tracer滤镜来查看流线情况，并且可以添加Aphabetical当中的Extract Block滤镜，选择lid和fixedWalls边界面进行高亮来让图像结果更加漂亮。


plateHole算例
---------------

本算例我们来对一个中心带有圆形空洞的方盘进行线弹性稳态应力分析。整个方盘边长4米，中心空洞的半径为0.5米，该方盘左右面分别承受了一个均匀的 :math:`10~\mathrm{kpa}` 的载荷。由于该几何体是对称的，因此求解域只需要覆盖整个几何体的四分之一即可。这里我们选择右上角作为求解域并绘制对应的网格。

从 :code:`tutorials/stressAnalysis/solidDisplacementFoam` 中将 :code:`plateHole` 算例复制出来，进入 :code:`system/blockMeshDict` 查看网格信息。

作为二维算例，网格需要有两层，其高度也要指定，这里指定为 :code:`0.5` 。从图中可以看出一层有11个顶点，依次编号写出 :code:`vertices` 内容：

.. code-block:: C

    vertices
    (
        (0.5 0 0)                   // 0
        (1 0 0)                     // 1
        (2 0 0)                     // 2
        (2 0.707107 0)              // 3
        (0.707107 0.707107 0)       // 4
        (0.353553 0.353553 0)       // 5
        (2 2 0)                     // 6
        (0.707107 2 0)              // 7
        (0 2 0)                     // 8
        (0 1 0)                     // 9
        (0 0.5 0)                   // 10
        // 二维算例网格的第二层直接在第一层顶点信息的基础上修改高度即可
        (0.5 0 0.5)                 // 11
        (1 0 0.5)                   // 12
        (2 0 0.5)                   // 13
        (2 0.707107 0.5)            // 14
        (0.707107 0.707107 0.5)     // 15
        (0.353553 0.353553 0.5)     // 16
        (2 2 0.5)                   // 17
        (0.707107 2 0.5)            // 18
        (0 2 0.5)                   // 19
        (0 1 0.5)                   // 20
        (0 0.5 0.5)                 // 21
    );

根据图中的block结构，可以看到整个网格划分成了5个大网格块，注意顶点标签顺序决定的block自身坐标系方向，可以在图中看到各个block的 :math:`x_{1},x_{2}` 方向；在设置加密数量的时候要根据各个block之间坐标系方向的配合关系，不能出现同一边缘出现不同的加密设置；并且由于是二维算例，三个方向的加密设置在第三个参数都设置为了 :code:`1` ；同时希望生成均匀网格，所以非均匀化参数全部设置为了 :code:`1` ，如下所示：

.. code-block:: C

    blocks
    (
        hex (5 4 9 10 16 15 20 21) (10 10 1) simpleGrading (1 1 1)
        hex (0 1 4 5 11 12 15 16) (10 10 1) simpleGrading (1 1 1)
        hex (1 2 3 4 12 13 14 15) (20 10 1) simpleGrading (1 1 1)
        hex (4 3 6 7 15 14 17 18) (20 20 1) simpleGrading (1 1 1)
        hex (9 4 7 8 20 15 18 19) (10 20 1) simpleGrading (1 1 1)
    );

然后设置特殊边缘，这里都是圆弧类型边缘，通过 :code:`arc` 关键词指定，需要给定起始点、终止点标签以及该圆弧通过的一个点的坐标。注意不要忘记第二层的网格也需要指定圆弧边缘：

.. code-block:: C

    edges
    (
        arc 0 5 (0.469846 0.17101 0)
        arc 5 10 (0.17101 0.469846 0)
        arc 1 4 (0.939693 0.34202 0)
        arc 4 9 (0.34202 0.939693 0)
        arc 11 16 (0.469846 0.17101 0.5)
        arc 16 21 (0.17101 0.469846 0.5)
        arc 12 15 (0.939693 0.34202 0.5)
        arc 15 20 (0.34202 0.939693 0.5)
    );


接下来设置边界面信息。对于这个算例，可以区分出left,right,up,down,up（这些可以自由命名）以及二维算例统一的上下表面frontAndBack共六个边界面。由于我们是根据对称性只画了右上角的网格，因此left和down边界面实际上是完整网格的对称界面，于是设置为 :code:`symmetryPlane` ；frontAndBack作为二维算例统一的边界面，固定类型为 :code:`empty` ；其余边界面属于普通边界面，指定为 :code:`patch` 即可。通过在 :code:`faces` 里面列出完整的顶点标签列表来指定边界面：

.. code-block:: C

    boundary
    (
        left
        {
            type symmetryPlane;
            faces
            (
                (8 9 20 19)
                (9 10 21 20)
            );
        }
        right
        {
            type patch;
            faces
            (
                (2 3 14 13)
                (3 6 17 14)
            );
        }
        down
        {
            type symmetryPlane;
            faces
            (
                (0 1 12 11)
                (1 2 13 12)
            );
        }
        up
        {
            type patch;
            faces
            (
                (7 8 19 18)
                (6 7 18 17)
            );
        }
        hole
        {
            type patch;
            faces
            (
                (10 5 16 21)
                (5 0 11 16)
            );
        }
        frontAndBack
        {
            type empty;
            faces
            (
                (10 9 4 5)
                (5 4 1 0)
                (1 4 3 2)
                (4 7 6 3)
                (4 9 8 7)
                (21 16 15 20)
                (16 11 12 15)
                (12 13 14 15)
                (15 14 17 18)
                (15 18 19 20)
            );
        }
    );


.. figure:: ../_images/openFOAM/二维中心空洞平板第一层的block结构.png
  :align: center

*Figure 二维中心空洞平板第一层的block结构*



以上就设置好了blockMeshDict，可以通过 :code:`blockMesh` 来生成网格文件夹 :code:`constant/polyMesh` 并通过ParaView查看网格情况。网格生成后就需要指定边界条件的初始场。对于无热应力的单纯应力分析，只有位移量 :math:`D` 需要设定，进入 :code:`0/D` 文件，内部场位移量初始条件设置为：

.. code-block:: C

    internalField   uniform (0 0 0);

然后依次设定各个边界面的初始场信息。对于特殊边界面，例如已经left,down已经指定为了 :code:`symmetryPlane` ，frontAndBack指定为了 :code:`empty` ，那么在设定边界场的时候也要使用对应的类型。而其他没有特殊指定的，就要给定所需类型，在本算例中，应力边界类型是 :code:`tractionDisplacement` ，在该关键词内需要用 :code:`traction` 关键词给定应力边界矢量大小，用 :code:`pressure` 关键词给定边界面压力大小。因为up和hole边界面的牵引力为零，因此边界牵引力和压力设为零，而right边界面的牵引力应该设为 :code:`(1e4 0 0)` ，压力设为零：

.. code-block:: C

    boundaryField
    {
        left
        {
            type            symmetryPlane;
        }
        right
        {
            type            tractionDisplacement;
            traction        uniform (10000 0 0);
            pressure        uniform 0;
            value           uniform (0 0 0);
        }
        down
        {
            type            symmetryPlane;
        }
        up
        {
            type            tractionDisplacement;
            traction        uniform (0 0 0);
            pressure        uniform 0;
            value           uniform (0 0 0);
        }
        hole
        {
            type            tractionDisplacement;
            traction        uniform (0 0 0);
            pressure        uniform 0;
            value           uniform (0 0 0);
        }
        frontAndBack
        {
            type            empty;
        }
    }


接下来进入 :code:`constant/physicalProperties` 设置物理特性。在本算例中，我们需要指定钢材料的物理特性，包括密度为 :math:`7854~\mathrm{kg/m^{3}}` ，杨氏模量为 :math:`2\times10^{11}\mathrm{Pa}` ，泊松比为 :math:`0.3` 。 :code:`solidDisplacementFoam` 求解器也可以计算温度场，因此可以求解和动量方程耦合（通过生成的热应力来耦合）在一起的热物理方程，如果需要的话就需要额外指定热物理特性如热容、热导和热膨胀系数。当然，在本算例中我们不求解热物理方程，因此设定 :code:`planeStress     yes;` 而 :code:`thermalStress   no;` 。下面是各物理特性参数的设置：

.. code-block:: C

    rho
    {
        type        uniform;
        value       7854;
    }

    nu
    {
        type        uniform;
        value       0.3;
    }

    E
    {
        type        uniform;
        value       2e+11;
    }

    Cp
    {
        type        uniform;
        value       434;
    }

    kappa
    {
        type        uniform;
        value       60.5;
    }

    alphav
    {
        type        uniform;
        value       1.1e-05;
    }


接下来进入controlDict进行求解的控制设定。由于这是一个稳态问题，因此时间步无关紧要，方便起见设定时间步长 :code:`deltaT` 为 :code:`1` 。在稳态问题中，时间步也就表示了迭代步。终止时间 :code:`endTime` 设定为 :code:`100` ，即最高迭代次数。写入控制 :code:`writeInterval` 设定为 :code:`20` ：

.. code-block:: C

    application     solidDisplacementFoam;

    startFrom       startTime;

    startTime       0;

    stopAt          endTime;

    endTime         100;

    deltaT          1;

    writeControl    timeStep;

    writeInterval   20;

    purgeWrite      0;

    writeFormat     ascii;

    writePrecision  6;

    writeCompression off;

    timeFormat      general;

    timePrecision   6;

    graphFormat     raw;

    runTimeModifiable true;



接下来进入fvSchemes字典文件进行离散格式设置和求解器控制。本算例分析的是一个稳态问题，因此 :code:`timeScheme` 的时间离散里面选择 :code:`SteadyState` ，这样就屏蔽了时间离散项。应力分析的动量方程包含几个含有位移梯度量的显性项。梯度项计算的精确性和光滑性对结果有着很大影响，一般情况下有限体积离散建立于高斯定律之上，高斯定律对于大部分的模拟也是足够精确的。不过在本算例中，我们使用最小二乘法，该方法对网格质量较差的情况能更好地计算梯度，因此需要修改 :code:`gradSchemes` 关键词下的 :code:`grad(U)` 和 :code:`grad(T)` 改用 :code:`leastSquares` 关键词：

.. code-block:: C

    d2dt2Schemes
    {
        default         steadyState;
    }

    ddtSchemes
    {
        default         Euler;
    }

    gradSchemes
    {
        default         leastSquares;
        grad(D)         leastSquares;
        grad(T)         leastSquares;
    }

    divSchemes
    {
        default         none;
        div(sigmaD)     Gauss linear;
    }

    laplacianSchemes
    {
        default         none;
        laplacian(DD,D) Gauss linear corrected;
        laplacian(kappa,T) Gauss linear corrected;
    }

    interpolationSchemes
    {
        default         linear;
    }

    snGradSchemes
    {
        default         none;
    }



接下来进入fvSolution设置求解线性方程组使用的矩阵求解器。可以看到， :math:`D` 的矩阵求解器为GAMG，是多重网格矩阵求解法；求解器的 :code:`tolerance` 为 :math:`10^{-6}` ；矩阵求解器的相对误差由 :code:`relTol` 控制，用于控制每次迭代的残差减少量。在本算例中，由于方程式中很多项是显性的，并且采用分离迭代求解技术，因此迭代残差设置地太小是不经济的，合理的迭代残差为0.01，在本算例中甚至可以更高设置为0.9。在 :code:`stressAnalysis` 关键词中包含了该求解器所需的控制参数，其中 :code:`nCorrectors` 表示整个方程组求解的外循环数，包括每个时间步的拉伸边界条件。由于这是个稳态问题，我们用时间步代表迭代数，因此可以设置 :code:`nCorrectors` 为1；同时还需要设置求解变量的外循环收敛残差，当达到该值的时候迭代停止，在本算例中我们设置为 :math:`10^{-6}` ：

.. code-block:: C

    solvers
    {
        "(D|T)"
        {
            solver          GAMG;
            tolerance       1e-06;
            relTol          0.9;
            smoother        GaussSeidel;
            nCellsInCoarsestLevel 20;
        }
    }

    stressAnalysis
    {
        compactNormalStress yes;
        nCorrectors     1;
        D               1e-06;
    }


接下来就可以开始运行算例。应该在log文件中查看收敛信息，它包括了迭代数、每步迭代的初始残差和最终残差。根据之前的设定，最终残差应该总是小于最初残差的0.9倍，一旦初始残差小于收敛残差 :math:`10^{-6}` 的时候程序收敛，就可以终止程序：

.. code-block:: 

    solidDisplacementFoam > log &


求解器求解出来的对称张量应力场为sigma，通过 :code:`postProcess` 可以求出该张量的分量，如此每个时间步内就会得到sigmaxx,sigmaxy,sigmaxz,sigmayy,sigmayz,sigmazz分量文件。

.. code-block:: 

    postProcess -func 'components(sigma)'


如果要把计算域中对称面的左边的数据输出出来，可以通过 :code:`postProcess` 使用 :code:`graphUniform` 函数来获得。在此之前，需要 :code:`system/graphUniform` 文件来进行设置。该函数能够提取指定线段中的数据，分别需要设定起始点、终止点和采样点个数，需要提取的场在 :code:`fields` 关键词处指定，而输出坐标点也可以通过 :code:`axis` 关键词来指定，可以指定为x,y,z,xyz四种类型：

.. code-block:: C

    start           (0 0.5 0.25);
    end             (0 2 0.25);
    nPoints         100;

    fields          (sigmaxx);

    axis            y;

    #includeEtc "caseDicts/postProcessing/graphs/graphUniform.cfg"


接下来就可以执行下面的命令来提取数据：

.. code-block:: 

    postProcess -func 'graphUniform'

之后就得到了 :code:`postProcessing/graphUniform` 文件夹，每个时间文件内都包含了指定线段范围处场的数据集，可以导出到其他软件与其他数据配合或进行后处理绘制成图。



damBreak算例
---------------

简化的二维溃坝问题 :code:`tutorial/multiphase/interFoam/laminar/damBreak` 将使用 :code:`interFoam` 来进行求解。该问题为两种液体被一种尖锐的界面（或者自由表面）分隔的瞬态流动。 :code:`interFoam` 中的两相算法基于流体的体积分数法(VOF)，在该方法中，每个网格中的相体积分数（或相分数 :code:`alpha` ）通过求解一个组分输运方程确定。物理属性则基于这个相分数通过加权平均计算。在VOF方法中，组分间的界面不是计算出来的，而是作为相分数场的一个属性表现出来，这个界面需要通过后处理得到。由于相分数可以为0到1之间的任何值，所以相界面并没有被严格定义，因此相界面表示它应存在的那些网格单元。

本算例的物理过程如下：设置为一个静止的水柱，使其位于水箱左侧，在水箱的底部有一个小的障碍，在 :math:`t=0~\mathrm{s}` 时让水柱自由流动发生水柱崩塌。在崩塌过程中，水撞击水箱底部的一个障碍形成复杂的流场结构，其中包括若干被水包裹的气泡。几何场与网格设置如图所示。


.. figure:: ../_images/openFOAM/溃坝的几何场与网格划分.png
  :align: center

*Figure 溃坝的几何场与网格划分*


进入 :code:`system/blockMeshDict` 查看网格信息，可以看到通过 :code:`convertToMeters` 关键词设置了倍数0.146，从而让记录点坐标的时候能有更多整数。在本2D算例中，里面没有在边界中指定 :code:`frontAndBack` 来描述上下面，而是使用了 :code:`defaultPatch` 关键词来给定，这样在生成 :code:`polyMesh/boundary` 后会自动添加 :code:`defaultFaces` ，并且类型为 :code:`empty` 。对于作为水坝壁面的leftWall,rightWall,lowerWall，他们的类型应该设定为 :code:`wall` ；而上边界为了允许流动的出入，可以只简单地指定为 :code:`patch` 类型。设置完成后可以直接运行 :code:`blockMesh` 生成网格文件。


.. note:: 边界面设定为壁面类型 :code:`wall` 时可以在后续应用壁面函数模型或者其他有关壁面的模型。例如在 :code:`interFoam` 求解器中，可以壁面依附模型来附加壁面表面张力的影响。该模型通过将 :code:`alpha` 场的边界条件设置为 :code:`constantAlphaContactAngle` 来实现。如果要使用这个边界条件，必须给出关键词静态接触角 :code:`theta0` 的值。



.. code-block:: C

    convertToMeters 0.146;

    vertices
    (
        (0 0 0)                // 0
        (2 0 0)                // 1
        (2.16438 0 0)          // 2
        (4 0 0)                // 3
        (0 0.32876 0)          // 4
        (2 0.32876 0)          // 5
        (2.16438 0.32876 0)    // 6
        (4 0.32876 0)          // 7
        (0 4 0)                // 8
        (2 4 0)                // 9
        (2.16438 4 0)          // 10
        (4 4 0)                // 11
        // 下面是第二层顶点，设置了高度为0.1
        (0 0 0.1)              // 12
        (2 0 0.1)              // 13
        (2.16438 0 0.1)        // 14
        (4 0 0.1)              // 15
        (0 0.32876 0.1)        // 16
        (2 0.32876 0.1)        // 17
        (2.16438 0.32876 0.1)  // 18
        (4 0.32876 0.1)        // 19
        (0 4 0.1)              // 20
        (2 4 0.1)              // 21
        (2.16438 4 0.1)        // 22
        (4 4 0.1)              // 23
    );

    blocks
    (
        hex (0 1 5 4 12 13 17 16) (23 8 1) simpleGrading (1 1 1)
        hex (2 3 7 6 14 15 19 18) (19 8 1) simpleGrading (1 1 1)
        hex (4 5 9 8 16 17 21 20) (23 42 1) simpleGrading (1 1 1)
        hex (5 6 10 9 17 18 22 21) (4 42 1) simpleGrading (1 1 1)
        hex (6 7 11 10 18 19 23 22) (19 42 1) simpleGrading (1 1 1)
    );

    defaultPatch
    {
        type empty;
    }

    boundary
    (
        leftWall
        {
            type wall;
            faces
            (
                (0 12 16 4)
                (4 16 20 8)
            );
        }
        rightWall
        {
            type wall;
            faces
            (
                (7 19 15 3)
                (11 23 19 7)
            );
        }
        lowerWall
        {
            type wall;
            faces
            (
                (0 1 13 12)
                (1 5 17 13)
                (5 6 18 17)
                (2 14 18 6)
                (2 3 15 14)
            );
        }
        atmosphere
        {
            type patch;
            faces
            (
                (8 20 21 9)
                (9 21 22 10)
                (10 22 23 11)
            );
        }
    );


在本算例中，我们将忽略界面和壁面间的表面张力效应，这可以使用 :code:`constantAlphaContactAngle` 边界条件并设定静态接触角 :math:`\theta=90` 来实现，不过这里我们直接设定 :code:`alpha` 的边界条件为 :code:`zeroGradient` 来实现该效果。

本算例上边界与大气环境自由相通，允许流动的出入，因此 :code:`atmosphere` 界面需要设定边界基础类型为 :code:`patch` 类型，并针对不同的物理量设置不同的边界数值类型：

+--------+-----------------------------+----------------------------------------------------------------------------------+
| 物理量 | 数值类型                    | 含义                                                                             |
+========+=============================+==================================================================================+
| 压力   | totalPressure               | 一种fixedValue条件，利用指定的总压p0和局部速度U来计算得到                        |
+--------+-----------------------------+----------------------------------------------------------------------------------+
| 速度   | pressureInletOutletVelocity | 对所有分量应用zeroGradient条件；当流动为入流是，对边界切向分量应用fixedValue条件 |
+--------+-----------------------------+----------------------------------------------------------------------------------+
| 相分数 | inletOutlet                 | 出流时为zeroGradient条件，入流时则为fixedValue条件                               |
+--------+-----------------------------+----------------------------------------------------------------------------------+

不过在本例中，使用p_rgh场作为初始场而不是p场，所以在所有边界处采用fixedFluxPressure边界条件，且上述的totalPressure类型也要更改为prghTotalPressure。在某些包含重力以及表面张力的求解器中，fixedFluxPressure边界条件能够调节压力梯度以使得边界的通量和速度边界条件相匹配。


下面需要为相分数 :math:`\alpha_{\text{water}}` 指定一个非均匀条件以区分水和空气。两相问题一般区分为1和0两个值，而区域的赋值需要通过setFields实现，因此需要书写system/setFieldsDict字典。在本例中setFieldsDict文件的核心内容为：

.. code-block:: C

    defaultFieldValues
    (
        volScalarFieldValue alpha.water 0
    );

    regions
    (
        boxToCell
        {
            box (0 0 -1) (0.1461 0.292 1);
            fieldValues
            (
                volScalarFieldValue alpha.water 1
            );
        }
    );


其中defaultFieldValues关键词用来设置场的默认值，这个值将会在下面的regions关键词指定的区域以外使用。在regions关键词中，boxToCell通过定义一个最小和最大的矢量来创建一个方块区域，在此区域为水相，即设定值为1。

.. attention:: 

    setFields从文件中读取场并重新定义这些场，然后把它们写入文件，原始的文件将会被覆盖，因此建议在执行setFields前先进行备份。OpenFOAM中通过在原文件名字后面加上 :code:`.orig` 来表示备份文件。



设置完成后就可以在算例目录终端中输入：

.. code-block:: 

    setFields



接下来设置物质特性(物理常量)。对于两相问题，需要在constant文件夹内设置各相物质的physicalProperties以及两相物性phaseProperties，在本例中就需要有physicalProperties.water，physicalProperties.air和phaseProperties三个文件来进行描述。本例中涉及到的物性参数有：

+----------------+------------------------------------+--------+----------------------------+
| 物理量         | 单位                               | 关键词 | 值                         |
+================+====================================+========+============================+
| 水的运动粘度   | :math:`\mathrm{m^{2}\cdot s^{-1}}` | nu     | :math:`1.0\times 10^{-6}`  |
+----------------+------------------------------------+--------+----------------------------+
| 水的密度       | :math:`\mathrm{kg/m^{3}}`          | rho    | :math:`1.0\times 10^{3}`   |
+----------------+------------------------------------+--------+----------------------------+
| 空气的运动粘度 | :math:`\mathrm{m^{2}\cdot s^{-1}}` | nu     | :math:`1.48\times 10^{-5}` |
+----------------+------------------------------------+--------+----------------------------+
| 空气的密度     | :math:`\mathrm{kg/m^{3}}`          | rho    | :math:`1.0`                |
+----------------+------------------------------------+--------+----------------------------+
| 两相表面张力   | :math:`\mathrm{N/m}`               | sigma  | :math:`0.7`                |
+----------------+------------------------------------+--------+----------------------------+

因此三个文件应当如下进行书写：

.. code-block:: C

    FoamFile
    {
        format      ascii;
        class       dictionary;
        location    "constant";
        object      physicalProperties.water;
    }
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    viscosityModel  constant;

    nu              1e-06;

    rho             1000;


.. code-block:: C

    FoamFile
    {
        format      ascii;
        class       dictionary;
        location    "constant";
        object      physicalProperties.air;
    }
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    viscosityModel  constant;

    nu              1.48e-05;

    rho             1;


.. code-block:: C

    FoamFile
    {
        format      ascii;
        class       dictionary;
        location    "constant";
        object      phaseProperties;
    }
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    phases          (water air);

    sigma           0.07;



重力加速度g在真个求解域内统一分布，因此也属于constant文件件内需要设置的内容。与普通的场文件不同，g是uniformDimensionedVectorField类型，因此只需要指定dimensions关键词和value关键词，本例中的书写方式如下：

.. code-block:: C

    FoamFile
    {
        format      ascii;
        class       uniformDimensionedVectorField;
        location    "constant";
        object      g;
    }
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    dimensions      [0 1 -2 0 0 0 0];
    value           (0 -9.81 0);

在constant文件夹内还需要有动量传递文件momentumTransport，在本例中不求解湍流模型，因此simulationType设置为laminar。




与标准流体算法相比，表面追踪算法对库朗数更加敏感。如果采用显性MULES算法，在界面区域库朗数不应该超过上限如0.25；如果在MULESCorr中指定采用半隐型MULES算法，理论上库朗数对相方程求解没有影响，因此库朗数只取决于时间精度。

对于速度容易预测的算例，最好直接指定一个满足库朗数要求的固定时间步长，但这对于复杂的算例来说相当困难。因此，interFoam求解器在controlDict中提供了自动调整时间步长的方法。需要指定adjustTimeStep为yes，设置writeControl为adjustableRunTime，并设置最大库朗数maxCo和最大相场库朗数maxAlphaCo为1.0；时间步长的上限maxDeltaT可以设置为一个不会超过的值，比如1.0。如此就可以在给定的deltaT基础上，根据情况自动缩小时间步长以满足库朗数要求，而给定writeInterval一个具体数值将会强制要求调节时间步长以达到对应时间进行输出。


.. attention:: 在tutorial提供的controlDict中，设置了writeFormat为binary，这对于巨量数据的情况是有益于提升读取速度的；但是如果希望便于查看文件，则修改writeFormat为ascii。



interFoam求解器在求解相场的时候采用了MULES方法，可以保证在任何数值格式、网格类型的情况下的相场有界，因此在使用interFoam求解器时，对流项格式的选择不再局限于如迎风格式的稳定且有界的格式。

对流项格式设置在fvSchemes文件中的divSchemes关键词中。在本例中，动量方程的对流项为 :math:`\nabla \cdot (\rho \boldsymbol{U}\boldsymbol{U})` ，书写为 :code:`div(rhophi, U)` ，这里使用 :code:`Gauss linearUpwind grad(U)` 以实现良好的精度。 :math:`\nabla \cdot (\boldsymbol{U}\alpha_{l})` 书写为 :code:`div(phi, alpha)` ，采用 :code:`vanLeer` 格式，通常情况下有界线性格式需要一个系数，这里设置该系数为1.0来实现最好的稳定性。其他离散项采用常用的格式，因此fvSchemes文件中的核心内容如下：

.. code-block:: C

    ddtSchemes
    {
        default         Euler;
    }

    gradSchemes
    {
        default         Gauss linear;
    }

    divSchemes
    {
        div(rhoPhi,U)  Gauss linearUpwind grad(U);
        div(phi,alpha)  Gauss interfaceCompression vanLeer 1;
        div(((rho*nuEff)*dev2(T(grad(U))))) Gauss linear;
    }

    laplacianSchemes
    {
        default         Gauss linear corrected;
    }

    interpolationSchemes
    {
        default         linear;
    }

    snGradSchemes
    {
        default         corrected;
    }



fvSolution文件控制矩阵求解器，其中的alpha.water子字典中包含了interFoam特定的一些参数。nAlphaCorr代表的是 :math:`\alpha_{l}` 通量修正的次数；nAlphaSubCycles代表的是将每个时间步长均分成对应个数的子步长，循环后加和；MULESCorr即Weller所提出的MULES修正，一般设置为yes；cAlpha是一个控制界面压缩的因子，0相当于无压缩，1相当于守恒压缩，大于1的数表示强化界面压缩，一般取1。本算例的fvSolution文件的核心内容如下：

.. code-block:: C

    solvers
    {
        "alpha.water.*"
        {
            nAlphaCorr      2;
            nAlphaSubCycles 1;
            cAlpha          1;
            
            MULESCorr       yes;
            nLimiterIter    5;
            
            solver          smoothSolver;
            smoother        symGaussSeidel;
            tolerance       1e-8;
            relTol          0;
        }

        "pcorr.*"
        {
            solver          PCG;
            preconditioner  DIC;
            tolerance       1e-5;
            relTol          0;
        }

        p_rgh
        {
            solver          PCG;
            preconditioner  DIC;
            tolerance       1e-07;
            relTol          0.05;
        }

        p_rghFinal
        {
            $p_rgh;
            relTol          0;
        }

        U
        {
            solver          smoothSolver;
            smoother        symGaussSeidel;
            tolerance       1e-06;
            relTol          0;
        }
    }

    PIMPLE
    {
        momentumPredictor   no;
        nOuterCorrectors    1;
        nCorrectors         3;
        nNonOrthogonalCorrectors 0;
    }

    relaxationFactors
    {
        equations
        {
            ".*" 1;
        }
    }


完成后就可以开始运行算例。可以采用tee命令来让程序交互式地运行，同时在终端输出结果并备份输出到文件log：

.. code-block:: 

    interFoam | tee log



damBreakFine算例
-----------------

下面增加damBreak算例的网格数量，并采用多核运算来减少运行时间。首先复制damBreak算例改名为damBreakFine，然后进入system/blockMeshDict修改blocks关键词内容：

.. code-block:: C

    blocks
    (
        hex (0 1 5 4 12 13 17 16) (46 10 1) simpleGrading (1 1 1)
        hex (2 3 7 6 14 15 19 18) (40 10 1) simpleGrading (1 1 1)
        hex (4 5 9 8 16 17 21 20) (46 76 1) simpleGrading (1 2 1)
        hex (5 6 10 9 17 18 22 21) (4 76 1) simpleGrading (1 2 1)
        hex (6 7 11 10 18 19 23 22) (40 76 1) simpleGrading (1 2 1)
    );

运行blockMesh重新生成网格，此时由于网格发生了变化，通过mapFields映射场可能会在界面处产生插值，并且已有的0/alpha.water.gz文件中的网格编号与新生成的网格不相符，因此需要删除该文件并重新运行setFields

OpenFOAM使用区域分解法进行并行计算。在该方法中，几何和相关的场被分割为若干部分并被分配到不同的处理器进行求解。因此，并行运算一个算例的第一步是利用decomposePar分解求解域，所以需要设置decomposeParDict文件。

numberOfSubdomains指定了要将算例分割成为子区域的数量，通常与可用于运算此算例的处理器数一致。本例中，区域分割的方法method选择simple，其对应的simpleCoeffs通过矢量n给定，其分量决定xyz方向分割求解域的个数，必须满足 :math:`n_{x}\times n_{y} \times n_{z}=\text{numberOfSubdomains}` 。最好使每个子区域的网格连接面数量最少。本算例是二维的，因此z方向不能被分割， :math:`n_{z}` 必须设置为1。本例中decomposeParDict文件书写为：

.. code-block:: C

    FoamFile
    {
        format      ascii;
        class       dictionary;
        location    "system";
        object      decomposeParDict;
    }
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    numberOfSubdomains 4;

    method          simple;

    simpleCoeffs
    {
        n               (2 2 1);
    }

    hierarchicalCoeffs
    {
        n               (1 1 1);
        order           xyz;
    }

    manualCoeffs
    {
        dataFile        "";
    }

    distributed     no;

    roots           ( );


完成后就可以在算例目录终端下输入下面的命令对网格进行分解：

.. code-block:: 

    decomposePar

本例中使用openMPI来进行并行运算：

.. code-block:: 

    mpirun -np 4 interFoam -parallel > log &

算例运行结束之后，需要使用reconstructPar命令来将分割后的场和网格重新合并起来。也可以单独对分割后的求解域的一部分进行后处理，例如

.. code-block:: 

    paraFoam -case processor1





cylinder算例
--------------

下面使用potentialFoam来研究圆柱势流(potential flow)，该求解器假设流场不可压缩、无旋无黏、稳态且忽略重力。控制方程有两个：不可压缩流体的质量守恒方程

.. math::
    \begin{align}
    \nabla \cdot \boldsymbol{U}=0
    \end{align}

不可压缩无旋场的稳态压力方程

.. math::
    \begin{align}
    \nabla ^{2}p=0
    \end{align}


.. note:: 

    potentialFoam求解器能够为其他问题提供符合质量守恒方程的初始场，在运行算例之前首先运行势流求解器可以大大加快收敛且增加求解稳定性。





复制算例tutorials/basic/potentialFoam/cylinder。在这个算例中，圆柱是对称的，所以计算域只取上半部分。左边界是入口Inlet，右边界是出口Outlet，下边界和圆柱边界为symmetryPlane，而上边界我们假设计算域在y方向上无穷大，垂直于上边界的速度梯度特别小，因此上边界选择垂直于上边界速度梯度为0的边界条件，即symmetryPlane。运行blockMesh得到网格。

在本算例中，我们不需要设置流体的性质，因为整个流体是不可压缩、无旋、无黏的。在system/controlDict中记录算例运行的参数，而由于我们处理的是稳态问题，所以算例只应该运行一个时间步。

potentialFoam通过迭代来求解压力方程，并且可以对压力方程中的拉普拉斯项进行非正交修正(压力方程中的显式项会在正交修正迭代之后进行更新)。对压力方程的非正交修正迭代次数由fvSolution当中potentialFlow字典的nNonOrthogonalCorrectors关键字来决定。可以明显观察到nNonOrthogonalCorrectors设置为0或3时结果的不同，非正交修正能够使结果与理论解更加相近。

直接运行potentialFoam的时候只会计算U和phi，额外添加控制语句可以输出其他内容：

.. code-block:: 

    potentialFoam -withFunctionObjects -writePhi -writep





pitzDaily算例
------------------

在tutorials/incompressible/simpleFoam/pitzDaily算例中，计算域是一个二维的、由一个窄的入口、一个后向台阶、一个在出口处收缩的喷管组成。simpleFoam求解器的控制方程有两个：不可压缩流体的质量守恒方程

.. math::
    \begin{align}
    \nabla \cdot \boldsymbol{U} = 0
    \end{align}

稳态动量方程

.. math::
    \begin{align}
    \nabla \cdot (\boldsymbol{U}\boldsymbol{U}) + \nabla \cdot \boldsymbol{R} = -\nabla p
    \end{align}

其中 :math:`p` 是动压， :math:`\boldsymbol{R} = \nu_{\text{eff}} \nabla \boldsymbol{U}` 是带有有效动力粘度系数 :math:`\nu_{\text{eff}}` 的粘性力项。 :math:`\nu_{\text{eff}}` 是通过传递模型和湍流模型计算得到的。初始条件 :math:`\boldsymbol{U}=0~\mathrm{m/s}` 、 :math:`p=0~\mathrm{Pa}` ，进口为固定速度入口， :math:`\boldsymbol{U}=(10,0,0)~\mathrm{m/s}` ，出口为固定压力出口 :math:`p=0~\mathrm{Pa}` ，其他边界都是非滑移边界。空气的运动粘度系数为

.. math::
    \begin{align}
    \nu = \frac{\mu}{\rho} = 18.1 \times 10^{-6} / 1.293 = 14.0 ~\mu\mathrm{m^{2}/s}
    \end{align}

湍流模型选用标准 :math:`k-\epsilon` 模型，常数分别为 :math:`C_{\mu} = 0.09` ； :math:`C_{1}=1.44` ； :math:`C_{2}=1.92` ； :math:`\alpha_{k}=1` ； :math:`\alpha_{\varepsilon}=0.76923` 。

.. note:: 

    simpleFoam利用SIMPLE格式来求解稳态不可压缩流体的问题。这个求解器可以使用incompressibleTurbulenceModel库中所有的湍流模式以及incompressibleTransportModel库中的所有牛顿以及非牛顿流体模型。

一般来说，剪切应力(速度梯度)大的区域网格细化尤其重要，这些区域的网格需要比其他剪切应力较其他剪切应力较低的区域更细。在进行求解之前，我们可以提前估计一下在哪些地方容易出现大的剪切应力。在入口处有一个沿着x方向的稳态流动，在流体经过台阶时，这个稳态流动和下方静止的流体之间会产生一个剪切应力，并且在计算域的下半部分产生漩涡，因此剪切应力比较大的区域应该在计算域的中心线附近和靠近壁面的地方。

在本算例中，需要为速度 :math:`\boldsymbol{U}` 、压力 :math:`p` 、湍流动能 :math:`k` 和耗散率 :math:`\varepsilon` 设置边界条件和初始条件。上下边界设置为wall，左边界设置为Inlet，右边界设置为Outlet，这样的边界组合需要在入口处设定 :math:`U` 、 :math:`k` 、 :math:`\varepsilon` 的类型为fixedValue。

:math:`k` 和 :math:`\varepsilon` 的值如下进行计算：假设入口湍流是各向同性，而且入口处的速度波动为 :math:`5\%` 则有

.. math::
    \begin{align}
    U_{x}' = U_{y}' = U_{z}' = \frac{5}{100} \times 10 = 0.5 ~\mathrm{m/s}
    \end{align}

且有

.. math::
    \begin{align}
    k = 1.5 \times (0.5)^{2} = 0.375 ~\mathrm{m^{2}/s^{2}}
    \end{align}

如果假定湍流尺度为入口边界长度的十分之一则有

.. math::
    \begin{align}
    \varepsilon = \frac{C_{\mu}^{0.75}k^{1.5}}{l} = \frac{0.09^{0.75} \times 0.375^{1.5}}{0.1 \times 25.4 \times 10^{-3}} = 14855 ~\mathrm{m^{2}/s^{2}}
    \end{align}

在出口处只需要将 :math:`p` 设置为 :math:`0~\mathrm{Pa}` 。




forwardStep算例
-----------------

本算例将探究前向台阶的超音速绕流，入口速度马赫数为3，在入口附近有一个台阶，在台阶附近会产生激波。复制tutorials/compressible/rhoCentralFoam/forwardStep算例，将使用rhoCentralFoam求解器进行计算。控制方程有四个，分别是质量守恒方程：

.. math::
    \begin{align}
    \frac{\partial \rho}{\partial t} + \nabla \cdot (\rho \boldsymbol{U}) = 0 
    \end{align}

理想气体状态方程：

.. math::
    \begin{align}
    p = \rho RT
    \end{align}


牛顿流体的动量守恒方程：

.. math::
    \begin{align}
    \frac{\partial \rho \boldsymbol{U}}{\partial t} + \nabla \cdot (\rho \boldsymbol{U}\boldsymbol{U}) - \nabla \cdot \mu \nabla \boldsymbol{U} = -\nabla p 
    \end{align}

能量方程(忽略粘性项)和傅里叶定律：

.. math::
    \begin{align}
    & \frac{\partial \rho e}{\partial t} + \nabla \cdot (\rho \boldsymbol{U}e) - \nabla \cdot \frac{k}{c_{\nu}} \nabla e = -p \nabla \cdot \boldsymbol{U}  \\
    & e = C_{\nu} T \\
    & q = -k\nabla T
    \end{align}


算例的初始条件为： :math:`U = 1~\mathrm{m/s}` ， :math:`p = 1~\mathrm{Pa}` ， :math:`T = 1~\mathrm{K}` 。


在physicalProperties文件中，可以看到模型的设置情况：

.. code-block:: C

    thermoType
    {
        type            hePsiThermo;    // 基于密度计算
        mixture         pureMixture;    
        transport       const;          // 拥有固定的动力黏度和热导热系数(普朗特数)
        thermo          hConst;         // 拥有固定的定压比热容
        equationOfState perfectGas;     // 理想气体
        specie          specie;
        energy          sensibleInternalEnergy;   // 以焓作为能量方程的变量
    }

    mixture
    {
        specie
        {
            molWeight       11640.3;    // 物质的摩尔质量g/mol
        }
        thermodynamics
        {
            Cp              2.5;
            Hf              0;
        }
        transport
        {
            mu              0;          // 动力粘度
            Pr              1;          // 普朗特数
        }
    }




网格生成
========


blockMesh
---------

blockMesh能够创建具有分级和弯曲边缘的参数网格，其运行根据式位于 :code:`constant/polyMesh` 文件中的 :code:`blockMeshDict` 字典文件。 :code:`blockMeshDict` 文件的包含的关键词如下所示：

+-------------------------+----------------------------+---------------------------------------------------------------------------+
| 关键词                  | 含义                       | 例子                                                                      |
+=========================+============================+===========================================================================+
| :code:`convertToMeters` | 顶点坐标的放缩比例         | 取0.01时长度单位为毫米                                                    |
+-------------------------+----------------------------+---------------------------------------------------------------------------+
| :code:`vertices`        | 顶点坐标集合               | 原点坐标为 :code:`(0 0 0)`                                                |
+-------------------------+----------------------------+---------------------------------------------------------------------------+
| :code:`edges`           | 用来指定圆弧或样条曲线边缘 | 用两个顶点标签和中间经过点坐标指定圆弧 :code:`arc 1 4 (0.939 0.342 -0.5)` |
+-------------------------+----------------------------+---------------------------------------------------------------------------+
| :code:`block`           | 顶点标签集合和网格大小     | :code:`hex (0 1 2 3 4 5 6 7) (10 10 1) simpleGrading (1 1 1)`             |
+-------------------------+----------------------------+---------------------------------------------------------------------------+
| :code:`patches`         | 面的集合                   | :code:`symmetryPlan base ( (0 1 2 3) )`                                   |
+-------------------------+----------------------------+---------------------------------------------------------------------------+
| :code:`mergePatchPairs` | 合并的面的集合             |                                                                           |
+-------------------------+----------------------------+---------------------------------------------------------------------------+

 

顶点的描述是按照坐标点列表的方式进行的，从上往下依次表示顶点标签的递增，例如下面是一个block的顶点集合表示方式：

.. code-block:: C

    vertices
    (
            (0     0     0  )    // 标签0
            (1     0     0.1)    // 标签1
            (1.1   1     0.1)    // 标签2
            (0     1     0.1)    // 标签3
            (-0.1  -0.1  1  )    // 标签4
            (1.3   0     1.2)    // 标签5
            (1.4   1.1   1.3)    // 标签6
            (0     1     1.1)    // 标签7
    );


边缘的描述需要使用两个顶点标签，不过同样要用关键词指定边缘类型，不同类型还要求更进一步的补充点坐标信息，下面是可用的关键词：

+----------------------+--------------+--------------------+
| 关键词               | 含义         | 补充信息           |
+======================+==============+====================+
| :code:`arc`          | 圆弧         | 一个中间插值点坐标 |
+----------------------+--------------+--------------------+
| :code:`simpleSpline` | 样条曲线     | 一系列插值点坐标   |
+----------------------+--------------+--------------------+
| :code:`polyLine`     | 一组线       | 一系列插值点坐标   |
+----------------------+--------------+--------------------+
| :code:`polySpline`   | 一组样条曲线 | 一系列插值点坐标   |
+----------------------+--------------+--------------------+
| :code:`line`         | 直线         |                    |
+----------------------+--------------+--------------------+

下面是通过标签1顶点和标签5顶点定义的圆弧边缘，该圆弧通过了坐标为 :code:`(1.1  0.0  0.5)` 的点：

.. code-block:: C

    edges
    (
            arc  1  5  (1.1  0.0  0.5)
    );


网格块的定义涉及到点标签集、三个方向的网格数量、非均匀化比例的定义。一个block将会涉及到8个顶点标签，顶点标签的顺序决定了该网格块的坐标方向，也就会影响加密的设置顺序。顶点标签与坐标方向有下面的关系：

- 第一个顶点标签决定了坐标系的原点；
- 从第一个顶点标签位置指向第二个顶点标签位置决定了 :math:`x_{1}` 方向；
- 从第二个顶点标签位置到第三个顶点标签位置决定了 :math:`x_{2}` 方向；
- 前四个顶点标签位置决定了 :math:`x_{3}=0` 的平面位置；
- 从第一个标签位置指向第五个标签位置决定了 :math:`x_{3}` 方向；
- 剩余三个标签类似地依次从第二、三、四个标签位置沿 :math:`x_{3}` 方向移动得到。



snappyHexMesh
---------------

生成背景网格
^^^^^^^^^^^^

该功能可以通过三角面片模型文件(stl,obj,vtk,...)来创建网格，该模型文件应当放置在constant/triSurface文件夹内。同时还需要背景网格来决定计算域和基本网格密度，通常通过blockMesh来生成，而由于一般来说都是要生成长方体规则网格，所以可以按照下面的格式来书写blockMeshDict文件（根据需要修改大小以及边界面类型）：

.. code-block:: C

    /*--------------------------------*- C++ -*----------------------------------*\
      =========                 |
      \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
       \\    /   O peration     | Website:  https://openfoam.org
        \\  /    A nd           | Version:  10
         \\/     M anipulation  |
    \*---------------------------------------------------------------------------*/
    FoamFile
    {
        format      ascii;
        class       dictionary;
        object      blockMeshDict;
    }
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    convertToMeters 1;

        xmin      -3;
        xmax      3;
        ymin      -3;
        ymax      3;
        zmin      0;
        zmax      10;
        
        xcells    40;
        ycells    40;
        zcells    40;

    vertices
    (
        ($xmin $ymin $zmin)
        ($xmax $ymin $zmin)
        ($xmax $ymax $zmin)
        ($xmin $ymax $zmin)
        
        ($xmin $ymin $zmax)
        ($xmax $ymin $zmax)
        ($xmax $ymax $zmax)
        ($xmin $ymax $zmax)
    );

    blocks
    (
        hex (0 1 2 3 4 5 6 7) ($xcells $ycells $zcells) simpleGrading (1 1 1)
    );

    boundary
    (
        inlet
        {
            type patch;
            faces
            (
                (0 4 7 3)
            );
        }
        outlet
        {
            type patch;
            faces
            (
                (1 2 6 5)
            );
        }
        ground
        {
            type patch;
            faces
            (
                (0 3 2 1)
            );
        }
        top
        {
            type patch;
            faces
            (
                (4 5 6 7)
            );
        }
        side1
        {
            type patch;
            faces
            (
                (0 1 5 4)
            );
        }
        side2
        {
            type patch;
            faces
            (
                (3 7 6 2)
            );
        }
    );


    mergePatchPairs
    (
    );


    // ************************************************************************* //


surfaceFeaturesDict
^^^^^^^^^^^^^^^^^^^

然后需要设置位于system文件夹中的surfaceFeaturesDict文件、snappyHexMeshDict文件以及meshQualityDict文件，这三个文件的模板可以从教程案例中复制得到。

首先说明surfaceFeaturesDict文件，它用来提取模型文件的表面特征，需要指定模型文件以及调用的程序，其模板为：

.. code-block:: C

    /*--------------------------------*- C++ -*----------------------------------*\
      =========                 |
      \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
       \\    /   O peration     | Website:  https://openfoam.org
        \\  /    A nd           | Version:  10
         \\/     M anipulation  |
    \*---------------------------------------------------------------------------*/
    FoamFile
    {
        format      ascii;
        class       dictionary;
        object      surfaceFeaturesDict;
    }
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    surfaces ("combined.stl");
    includedAngle 150;

    #includeEtc "caseDicts/surface/surfaceFeaturesDict.cfg"

    // ************************************************************************* //

完成后就可以在算例目录下在终端输入：

.. code-block:: 

    surfaceFeatures

如此就能从几何文件中提取出特征边缘，并在triSurface文件夹内生成cylinder.eMesh文件。



meshQualityDict
^^^^^^^^^^^^^^^

meshQualityDict文件几乎不需要改动，其内容只有调用相应程序：

.. code-block:: C

    /*--------------------------------*- C++ -*----------------------------------*\
      =========                 |
      \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
       \\    /   O peration     | Website:  https://openfoam.org
        \\  /    A nd           | Version:  10
         \\/     M anipulation  |
    \*---------------------------------------------------------------------------*/
    FoamFile
    {
        format      ascii;
        class       dictionary;
        object      meshQualityDict;
    }
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    #includeEtc "caseDicts/mesh/generation/meshQualityDict.cfg"

    //- minFaceWeight (0 -> 0.5)
    //minFaceWeight 0.02;

    // ************************************************************************* //


snappyHexMeshDict
^^^^^^^^^^^^^^^^^

完成上述文件后就可以开始对snappyHexMeshDict文件进行修改。该文件中涉及的关键词如下：

+-------------------------+-----------------------------------------+----------+
| 关键词                  | 含义                                    | 常见赋值 |
+=========================+=========================================+==========+
| castellatedMesh         | 是否创建堞状网格                        | true     |
+-------------------------+-----------------------------------------+----------+
| snap                    | 是否进行表面贴合                        | true     |
+-------------------------+-----------------------------------------+----------+
| addLayers               | 是否添加表面边界层                      | false    |
+-------------------------+-----------------------------------------+----------+
| mergeTolerance          | 合并公差作为初始网格边界框的分数        | 1e-6     |
+-------------------------+-----------------------------------------+----------+
| debug                   | 控制中间网格和网线打印的写入            |          |
+                         +-----------------------------------------+----------+
|                         | 只写最终网格                            | 0        |
+                         +-----------------------------------------+----------+
|                         | 写中间网格                              | 1        |
+                         +-----------------------------------------+----------+
|                         | 用cellLevel写volScalarField进行后期处理 | 2        |
+                         +-----------------------------------------+----------+
|                         | 将当前交叉点写入.obj文件                | 4        |
+-------------------------+-----------------------------------------+----------+
| geometry                | 所使用的表面图形的信息                  |          |
+-------------------------+-----------------------------------------+----------+
| castellatedMeshControls | 生成蜂窝网格的控制信息                  |          |
+-------------------------+-----------------------------------------+----------+
| snapControls            | 表面贴合的控制信息                      |          |
+-------------------------+-----------------------------------------+----------+
| addLayersControls       | 表面边界层添加的控制信息                |          |
+-------------------------+-----------------------------------------+----------+
| meshQualityControls     | 网格质量的控制信息                      |          |
+-------------------------+-----------------------------------------+----------+


geometry
""""""""

在geometry关键词内设置所需的几何文件以及体加密信息。下面是一个简单的案例：

.. code-block:: C

    geometry
    {
        cylinder    // 模型边界面的自定义命名
        {
            type triSurfaceMesh;
            file "cylinder.stl";    // 所用文件
        }

        refinementBox    // 体加密区域的自定义命名
        {
            type searchableBox;    // 体加密类型
            min  (  -5   -5   -1);
            max  (15 15  5);
        }
    };  


如果在stl文件中已经自行定义了各个solid的名字，那么就可以添加 :code:`regions` 关键字来提取这些面域，进而在后续的面加密中各自进行处理。例如：

.. code-block:: C

    geometry
    {
        cylinder    // 模型边界面的自定义命名
        {
            type triSurfaceMesh;
            file "cylinder.stl";    // 所用文件

            regions
            {
                top { name top; }
                bottom { name bottom; }
                wall { name wall; }
            }
        }

        refinementBox    // 体加密区域的自定义命名
        {
            type searchableBox;    // 体加密类型
            min  (  -5   -5   -1);
            max  (15 15  5);
        }
    };  







体加密除了上述方块体加密设置，还有其他可选加密方式：

+--------------------------+----------------+--------------+-----------------+
| 加密类型                 | 类型含义       | 所需参数     | 参数解释        |
+==========================+================+==============+=================+
| searchableBox            | 立方体         | min          | 最小对角点坐标  |
+                          +                +--------------+-----------------+
|                          |                | max          | 最大对角点坐标  |
+--------------------------+----------------+--------------+-----------------+
| searchableCylinder       | 圆柱           | point1       | 中轴线端点1     |
+                          +                +--------------+-----------------+
|                          |                | point2       | 中轴线端点2     |
+                          +                +--------------+-----------------+
|                          |                | radius       | 外圆半径        |
+--------------------------+----------------+--------------+-----------------+
| searchableSphere         | 球             | Centre       | 中心点坐标      |
+                          +                +--------------+-----------------+
|                          |                | radius       | 球半径          |
+--------------------------+----------------+--------------+-----------------+
| searchableCone           | 圆锥体（空心） | point1       | 中轴线端点1     |
+                          +                +--------------+-----------------+
|                          |                | point2       | 中轴线端点2     |
+                          +                +--------------+-----------------+
|                          |                | radius1      | 断面1外圆半径   |
+                          +                +--------------+-----------------+
|                          |                | radius2      | 断面2外圆半径   |
+                          +                +--------------+-----------------+
|                          |                | innerRadius1 | 断面1内圆半径   |
+                          +                +--------------+-----------------+
|                          |                | innerRadius2 | 断面2内圆半径   |
+--------------------------+----------------+--------------+-----------------+
| searchableRotatedBox     | 旋转立方体     | origin       | 最小对角点坐标  |
+                          +                +--------------+-----------------+
|                          |                | span         | XYZ方向尺寸长度 |
+                          +                +--------------+-----------------+
|                          |                | e1           | 几何i方向向量   |
+                          +                +--------------+-----------------+
|                          |                | e2           | 几何j方向向量   |
+                          +                +--------------+-----------------+
|                          |                | e3           | 几何k方向向量   |
+--------------------------+----------------+--------------+-----------------+
| searchableExtrudedCircle | 圆管           | file         | 导入曲线文件    |
+                          +                +--------------+-----------------+
|                          |                | radius       | 圆管半径        |
+--------------------------+----------------+--------------+-----------------+



castellatedMeshControls
"""""""""""""""""""""""

全局网格细化参数在castellatedMeshControls中设置，其目的为细化背景网格，通过细化背景网格以使几何特征与几何表面上拥有一定网格量，以提高几何特征捕捉的准确性。同时通过参数设置，保证网格细化时尺寸变化尽量平缓。在该关键词内需要设置的内容包括：

+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| 关键词                     | 含义                 | 常用赋值           | 备注                                                                                                                                                                                                                                                                        |
+============================+======================+====================+=============================================================================================================================================================================================================================================================================+
| maxGlobalCells             | 全局最大网格量       | 2e+06              | 该功能主要目的是保证网格细化过程中，避免划分网格量太大，导致计算机内存溢出。当划分网格量超过此值时，细化过程将立即终止。此时，局部细化功能可能终止运行。                                                                                                                    |
+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| maxLocalCells              | 单核最大网格量       | 1e+06              | 该参数主要应用于网格并行计算，其指定了细化网格过程中每个处理器处理的最大数量网格数。设置该参数时请保证一定的富余量，经常重新平衡每个处理器计算量将减慢网格生成过程。                                                                                                        |
+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| maxLoadUnbalance           | 最大负载平衡参数     | 0.1                | 该参数主要应用于网格并行计算。当该参数值为0时，即强制负载平衡，即各处理器间处理的网格量严格保持单元总数/计算核数。较低的值可能会导致系统频繁的均衡网格负载量。而参数值设置为1时，则完全禁用网格均衡操作。                                                                   |
+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minRefinementCells         | 最小细化单元数       | 0                  | 该参数指定了需细化特征的最小单元数。若特征上网格单元数量小于该参数，则停止对其细化。                                                                                                                                                                                        |
+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nCellsBetweenLevels        | 缓冲层数             | 3                  | 若用户设置参数值为1，则表示不添加过渡区域。越大的值可使得网格大小过渡越平缓，但将导致网格量增加。                                                                                                                                                                           |
+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| resolveFeatureAngle        | 自动检测角           | 30                 | 当曲率变化角超过该参数值时，特征区域网格使用最大面细化等级，而低于此角度的特征均采用最小面细化级别。默认参数值为30，参数值设置为360时，表示关闭此功能。该参数生效的前置条件：(1)面细化参数中最小和最大细化等级需不同。(2)面贴合过程中特征捕捉需采用隐式方法。               |
+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| locationInMesh             | 网格域控制点         | (-3.25 -2.25 1.25) | 指定需要保留背景网格表面与封闭几何表面之间的网格，还是封闭几何内部的网格。保留区域网格中需包含指定的参数点，该点的位置不能和网格单元的面或边重合。                                                                                                                          |
+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| allowFreeStandingZoneFaces | 允许有独立面         | false              | 该参数定义是否允许几何中有独立的面存在。若设置参数值为false，则表示在refinementSurfaces中指定的faceZones仅位于相应cellZones的边界上，作为不同域之间交界面。若该参数值为true，则允许此faceZones作为独立面域（例如：挡板界面等）。如果用户没有指定faceZones，则该参数不生效。 |
+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| features                   | 需要细化的特性信息   |                    |                                                                                                                                                                                                                                                                             |
+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| refinementRegions          | 用于细化的区域的信息 |                    |                                                                                                                                                                                                                                                                             |
+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| refinementSurfaces         | 用于细化的曲面的信息 |                    |                                                                                                                                                                                                                                                                             |
+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+



一般情况下，castellatedMeshControls可以按照如下方式设置：

.. code-block:: C

    castellatedMeshControls
    {
        features
        (
          { file  "cylinder.eMesh"; level 1; }
        );

        refinementSurfaces
        {
            cylinder    // 对应之前定义的几何表面名称
            {
                level (3 3);
                patchInfo { type wall; }
            }
        }

        refinementRegions
        {
            refinementBox    // 对应之前定义的加密区域名称
            {
                mode    inside;
                level   2;
            }
        }

        locationInMesh (-3.25 -2.25 1.25);
    }



如果在之前 :code:`geometry` 部分指明了不同的regions，那么在 :code:`refinementSurfaces` 就可以针对不同的面域进行不同程度的细化，同时赋予不同的边界类型：

.. code-block:: C

    castellatedMeshControls
    {
        features
        (
          { file  "cylinder.eMesh"; level 1; }
        );

        refinementSurfaces
        {
            cylinder    // 对应之前定义的几何表面名称
            {
                level (0 0);

                regions
                {
                    top
                    {
                        level (1 1);
                        patchInfo { type patch; }
                    }
                    bottom
                    {
                        level (1 1);
                        patchInfo { type patch; }
                    }
                    wall
                    {
                        level (2 2);
                        patchInfo { type wall; }
                    }
                }
            }
        }

        refinementRegions
        {
            refinementBox    // 对应之前定义的加密区域名称
            {
                mode    inside;
                level   2;
            }
        }

        locationInMesh (-3.25 -2.25 1.25);
    }



snapControls
""""""""""""

面贴合参数在snapControls中设置，主要目的是将体网格节点移动到几何表面上，贴合体网格中锯齿状表面。在该关键词内需要设置的内容包括：

+------------------------+----------------------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| 关键词                 | 含义                 | 常用赋值 | 备注                                                                                                                                                                                                                                                                                                                                                                                 |
+========================+======================+==========+======================================================================================================================================================================================================================================================================================================================================================================================+
| tolerance              | 捕捉点最大相对距离   | 5        | 建议2-5之间。该参数指定贴合算法中捕捉与特征面相关网格节点的最大相对距离，实际捕捉距离为tolerance参数值乘以相邻体网格尺寸。参数值必须大于或等于1，如果值太低，则可能无法使偏差较大的网格节点移动到几何表面上。较高的值有助于增加几何的捕捉范围，但如果参数值设置过高，则有可能捕捉到与表面无关的网格节点。                                                                            |
+------------------------+----------------------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nSolveIter             | 网格贴合最大迭代次数 | 100      | 该参数指定了网格贴合算法的最大迭代次数。较高的值会提高网格的质量，网格一致性更好，但网格划分时间会更长。简单模型可以将该参数值设置为100，若贴合后网格质量不太理想，可尝试将该参数值增加到300。                                                                                                                                                                                       |
+------------------------+----------------------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nSmoothPatch           | 面平滑迭代次数       | 0        | 0表示初始网格外形。该参数指定了表面上网格贴合的平滑迭代次数。增加迭代次数可以使曲面上网格平滑、贴合性更好，且能降低曲面上网格的歪斜率，但可能导致曲率突变特征（如直角等）弱化。                                                                                                                                                                                                      |
+------------------------+----------------------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nSmoothInternal        | 体网格平滑迭代次数   | 0        | 建议参数值与nSmoothPatch参数值一致。在执行网格平滑迭代时，边界面网格平滑迭代nSmoothPatch将与内部体网格平滑迭代nSmoothInternal联合使用。平滑迭代顺序为优先执行一次面平滑迭代（nSmoothPatch），再执行一次体网格平滑迭代（nSmoothInterna），以此循环。若用户设置nSmoothInternal参数值大于nSmoothPatch值时，平滑迭代次数统一采用nSmoothPatch参数值。默认值为零，表示禁用体网格平滑迭代。 |
+------------------------+----------------------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nRelaxIter             | 贴合松弛迭代次数     | 8        | 一般为5-8之间。该参数指定贴合过程中松弛迭代次数，用以消除质量较差的单元或网格节点。如果迭代完成后网格仍存在质量较差单元，则用户可以尝试增加此迭代次数，较高的值将确保更好的网格质量，但会花费更多计算时间。                                                                                                                                                                          |
+------------------------+----------------------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nFeatureSnapIter       | 特征边捕捉迭代次数   | 10       | 该参数指定了特征捕捉迭代次数，以将网格点捕捉到表面边缘。如果在nFeatureSnaplter迭代后局部特征区域网格没有达到足够的质量标准，则取消该区域特征边捕捉并恢复到之前状态。未指定该参数，特征捕捉功能将被禁用。                                                                                                                                                                             |
+------------------------+----------------------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nFaceSplitInterval     | 面拆分迭代           | 5        | 当系统执行完特征边捕捉迭代步骤后，若网格边缘与特征边未完全对齐，则有可能在特征边处网格产生凹面。从而导致在添加边界层时，其投影体网格的非正交性增大。如果体网格不满足质量要求，则取消该处边界层生成。nFaceSplitInterval参数默认值为-1（禁用），使用建议参数值设置为特征边捕捉迭代（nFeatureSnaplter）次数的一半。                                                                     |
+------------------------+----------------------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| explicitFeatureSnap    | 显式特征捕捉         | true     | 显示特征捕捉方法需要用户自定义特征边文件（.eMesh），并且指定特征边的细化等级（通过castellatedMeshControls子字典中features参数指定）。                                                                                                                                                                                                                                                |
+------------------------+----------------------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| implicitFeatureSnap    | 隐式特征捕捉         | false    | 隐式方法不需要用户提取几何特征边，其特征识别自动化程度优于显示特征捕捉方法。它使用全局细化参数中resolveFeatureAngle参数识别曲面几何特征（例如：面的相交线、曲率变化较大的曲面特征）。但在尖角特征或者挡板界面处，显示方法捕捉特征效果优于隐式方法。                                                                                                                                  |
+------------------------+----------------------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| multiRegionFeatureSnap | 多域特征捕捉         | false    | 该参数用于捕捉多域网格间的特征面，这对于具有多个区域（例如流体区域和固体区域）的网格进行共轭传热模拟或类似操作很重要。该参数生效的前置条件为采用显示特征捕捉方法explicitFeatureSnap。使用该参数时，它会加强特征面两边网格贴合，即内部区域和外部区域，这可能会导致特征面处网格歪斜率上升。                                                                                            |
+------------------------+----------------------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+


一般情况下，snapControls采用下面的设置就已经能够得到相对可以接受的网格了：

.. code-block:: C

    snapControls
    {
        explicitFeatureSnap    true;
        implicitFeatureSnap    false;
        multiRegionFeatureSnap false;
        
        tolerance           5;
        nSolveIter          100;
        nSmoothPatch        0;
        nSmoothInternal     0;
        nRelaxIter          8;
        nFeatureSnapIter    10;
        nFaceSplitInterval  5;
    }


addLayersControls
"""""""""""""""""""

在划分边界层时，需要在全局参数设置中激活边界层划分功能，即将addLayers值设置为true。边界层配置参数在addLayersControls子字典中设置，其参数类型可分为基本参数与高级控制参数：


+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| 关键词                    | 含义                           | 备注                                                                                                                                                                                                                                                  |
+===========================+================================+=======================================================================================================================================================================================================================================================+
| relativeSizes             | 是否采用相对临近单元尺寸比值   | 设置为true时，边界层厚度参数值为相对于邻近曲面上的体网格单元大小的比值；设置为false时，边界层厚度参数值直接由绝对单位的值(单位.米)定义                                                                                                                |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| expansionRatio            | 边界层膨胀比                   | 两个相邻层的厚度比，该值越大，各层间的高度差越大                                                                                                                                                                                                      |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| finalLayerThickness       | 边界层最后一层厚度             | 确保边界层最后一层网格不大于该值                                                                                                                                                                                                                      |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| firstLayerThickness       | 边界层第一层的厚度             | 指定距离曲面最近的边界层的高度，确保边界层第一层网格不大于该值                                                                                                                                                                                        |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| thickness                 | 边界层总厚度                   | 所有边界层的最大厚度。设置较大的边界层总厚度值会导致体网格收缩位移相应增大，体网格变形量增加将导致网格质量降低。当网格质量小于用户设置网格质量控制参数时，系统将取消此处边界层网格划分。                                                              |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minThickness              | 最小总层厚度                   | 所有边界层的总体最小厚度。若边界层挤出区域厚度小于该值，则该区域将不会生成边界层                                                                                                                                                                      |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nGrow                     | 最大取消边界层单元数           | 指定未设置边界层的相邻面相交处边界层的过渡层数。这有助于将边界层过渡到特征边附近                                                                                                                                                                      |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nSurfaceLayers            | 边界层层数                     | 需在指定面设置边界层基本参数中输入，为强制性参数                                                                                                                                                                                                      |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| maxFaceThicknessRatio     | 表面网格最大纵横比             | 当要在高度扭曲的单元上（特别是在角落）生成边界层时，纵横比高于此值的单元上边界层停止生成，以保证边界层网格质量                                                                                                                                        |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| featureAngle              | 边界层最大面夹角               | 当两个曲面之间的法向夹角小于参数featureAngle值时，允许两个曲面的相交边处体网格向域内收缩，形成边界层划分区域                                                                                                                                          |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| slipFeatureAngle          | 边界层滑移角度                 | 使边界层面边缘处顶点延边界面滑动，以保证边界层在边缘处的划分空间。建议使用70-80之间的最佳值来限制层的滑动，默认值为featureAngle的一半                                                                                                                 |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nBufferCellsNoExtrude     | 边界层终止面的缓冲单元数       | 为边界层终止端创建缓冲收缩区，即逐渐降低边界层数。设置值小于0，则表示在终止端立即停止边界层                                                                                                                                                           |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nSmoothThickness          | 边界层厚度平滑迭代次数         | 边界层网格生成前，需要根据投影厚度值收缩现有体网格，可通过nSmoothThickness值设置投影厚度值的迭代次数                                                                                                                                                  |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nSmoothSurfaceNormals     | 边界层曲面法线平滑迭代次数     | 边界层网格生成前，需要根据曲面法线方向收缩现有体网格，可通过nSmoothSurfaceNormals指定曲面法线平滑迭代次数                                                                                                                                             |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minMedianAxisAngle        | 拾取中间轴点的角度             | 这指定用于拾取中间轴点的角度。建议值为90度                                                                                                                                                                                                            |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| maxThicknessToMedialRatio | 层厚度与中间轴长度的最大比率   | 当比率大于指定值时，层生长减少。建议值为0.3                                                                                                                                                                                                           |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nRelaxIter                | 体网格收缩迭代次数             | 单步投影厚度值的迭代中，系统需根据投影厚度值计算体网格收缩松弛系数。该值越大越有利于提高体网格网格质量。建议值为5                                                                                                                                     |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nSmoothNormals            | 体网格平滑迭代次数             | 体网格收缩时，可通过nSmoothNormals指定体网格间移动方向的迭代次数。该值越高，体网格间平滑性越好，但网格划分时间越长。建议值为3                                                                                                                         |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nLayerIter                | 边界层添加的最大总迭代次数     | 如果达到此迭代次数，边界层网格划分将立即停止，并保留最后一次迭代生成的边界层。建议值为50-60                                                                                                                                                           |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nRelaxedIter              | 宽松质量控制标准的起始迭代次数 | 划分边界层网格时会优先使用meshQualityControls中基础质量控制参数，检测网格是否满足要求。若边界层添加算法迭代次数达到用户设置nRelaxedIter参数值后，网格依然不能达到质量控制要求，则在此后的迭代中软件将采用用户设置的宽松质量控制标准值。参数建议值为20 |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+



meshQualityControls
"""""""""""""""""""

meshQualityControls关键词中设置网格质量控制参数。在snappyHexMesh执行全局参数控制、面贴合、局部细化以及边界层生成时，程序都会依据网格质量控制参数不断调整网格迭代，同时，当网格位移或拓扑更改操作导致单元或面网格质量降低时，可根据控制参数撤消移动或拓扑更改操作以将网格还原为之前满足网格质量标准的状态。在该关键词内需要设定的内容如下：

+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| 关键词              | 含义                             | 常见赋值 | 备注                                                                                                                                                                                                                                                                        |
+=====================+==================================+==========+=============================================================================================================================================================================================================================================================================+
| maxNonOrtho         | 最大非正交角                     | 65       | 该参数指定允许的最大非正交角，其通过计算相邻两单元中心点向量与公共面法向量的夹角，此值为0时表示相邻两个网格完全正交。默认参考值为65，当设置为180时，表示关闭此项控制。该参数是衡量网格质量的主要指标之一。                                                                  |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| maxBoundarySkewness | 最大边界面网格偏斜度             | 20       | 此参数指定边界面网格允许的最大偏斜度。其定义一个面或体与理想几何(即等边或等角)的接近程度。默认参考值为20，当设置小于0的值时，表示关闭此项控制。                                                                                                                             |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| maxInternalSkewness | 最大内部面网格偏斜度             | 4        | 参数计算方式与最大边界面网格偏斜度一致，不过其主要测试内部网格质量。默认参考值为4，当设置小于0的值时，表示关闭此项控制。该参数是衡量网格质量的主要指标之一。                                                                                                                |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| maxConcave          | 最大凹度                         | 80       | 该参数用于检查构成面的内凹角度，以允许低于该角度的凹面。0表示直面，小于0表示凸面。默认参考值为80，当设置为180时，表示关闭此项控制。                                                                                                                                         |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minFlatness         | 最小平整值                       | 0.5      | 最小投影面积和实际面积的比值，该参数值为1时，表示检测面为平面。默认参数为0.5，设置为-1时，表示禁用此项控制。                                                                                                                                                                |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minVol              | 最小单元体积                     | 1e-13    | 该参数为允许最小金字塔单元体积，其为网格绝对体积参数（单位m3），默认参数为1e-13。设置为较大的负值时（例如-1e30），表示禁用此项控制。该参数是衡量网格质量的主要指标之一。                                                                                                    |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minArea             | 最小网格面面积                   | -1       | 该参数为允许最小网格面的面积，默认为-1，该参数设置为负值时，表示禁用此项控制。                                                                                                                                                                                              |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minTwist            | 最小面扭曲                       | 0.05     | 使用面中心将面分解为三角形单元，并通过相邻两个单元中心点向量与分解后三角形面法向量的点积计算面扭曲值。默认参考值为0.05，当设置参数小于-1时，表示关闭此项控制。                                                                                                              |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minDeterminant      | 最小归一化单元行列式值           | 0.001    | 通过计算每一个六面体的雅可比行列式值，然后标准化行列式的矩阵来表征单元的变形。参数值取值范围为0到1，参数值设置为1 表示只允许有理想六面体网格；如果某单元行列式的值为0，则这个立方体有一个或多个退化的边。参数值设置小于或等于0表示允许有负体积单元，默认参数值为0.001。     |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minFaceWeight       | 相邻网格间面权重最小值           | 0.05     | 其定义了面相对于相邻单元间中心的相对位置（正交时为0.5），计算方法是先计算出单元中心到公共面中心长度L1，再计算出相邻单元中心到公共面中心长度L2，面权重值等于L1与L2的最小值除以L1与L2之和。较小的面权重值表示相邻网格尺寸相差较大。参数值取值范围为0到0.5，默认参考值为0.05。 |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minVolRatio         | 相邻网格间的最小体积膨胀率       | 0.01     | 该参数指定允许相邻网格间的最小体积膨胀率, 参数值取值范围为0到1， 默认参考值为0.01。较大的比值会导致插值结果误差较大。                                                                                                                                                       |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minTriangleTwist    | 最小三角单元扭曲值               | -1       | 该参数表示允许最小三角单元扭曲值，通过使用面中心将面分解为三角形单元，然后依据相邻的三角形单元法向量的点积计算出三角形面扭曲值。默认参数值为-1，表示禁用此功能。若参数值大于0，则启用此功能项。其主要目的为确保生成网格与Fluent网格的兼容性。                               |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minTetQuality       | ?                                | 1e-30    | 通过网格单元中心和面中心将单元分解为四面体，然后根据圆周半径（Rc）和四面体体积（Vtet）计算四面体单元质量。对于一些跟踪算例时（如流线计算），该参数需要设置为一个较小正值，以确保内部单元质量检查正常运行。默认参数值为1e-30。                                               |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nSmoothScale        | 每次网格缩放恢复迭代时的平滑次数 | 4        | snappyHexMesh网格划分过程中可将局部网格缩放到之前网格质量满足标准的状态。可通过nSmoothScale参数指定每次网格缩放恢复迭代时的平滑次数，参数默认值为4。                                                                                                                        |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| errorReduction      | 误差点处的缩放位移量             | 0.75     | errorReduction参数同nSmoothScale参数一样应用于网格缩放恢复迭代，用户可通过该参数减小误差点处的缩放位移量，参数默认值为0.75。                                                                                                                                                |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| relaxed             | 相对宽松的上述标准列表           | ?        | 在划分边界层网格时会优先使用meshQualityControls中基础质量控制参数，检测网格是否满足要求。若边界层添加算法迭代次数达到用户设置nRelaxedIter参数值后，网格依然不能达到质量控制要求，则在此后的迭代中软件将采用设置的宽松质量控制标准值，以提高边界层网格的覆盖率。             |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+


snappyHexMeshDict模板
^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    /*--------------------------------*- C++ -*----------------------------------*\
      =========                 |
      \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
       \\    /   O peration     | Website:  https://openfoam.org
        \\  /    A nd           | Version:  10
         \\/     M anipulation  |
    \*---------------------------------------------------------------------------*/
    FoamFile
    {
        format      ascii;
        class       dictionary;
        object      snappyHexMeshDict;
    }
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    #includeEtc "caseDicts/mesh/generation/snappyHexMeshDict.cfg"

    castellatedMesh true;
    snap            true;
    addLayers       true;  // create boundary layers

    geometry
    {
        combined
        {
            type triSurfaceMesh;
            file "combined.stl";
            
            regions
            {
                sideFace { name sideFace; }
                topFace { name topFace; }
                leftFace { name leftFace; }
                rightFace { name rightFace; }
            }
        }
        
        /*
        refinementBox    
        {
            type searchableBox;    
            min  (-4 -4 -1);
            max  ( 4  4  4);
        }
        */
    };

    castellatedMeshControls
    {
        features
        (
          { file  "combined.eMesh"; level 0; }
        );

        refinementSurfaces
        {
            combined
            {
            level (0 0);
            
                regions
                {
                sideFace
                {
                    level (0 0);
                    patchInfo { type patch; }
                }
                topFace
                {
                    level (0 0);
                    patchInfo { type patch; }
                }
                leftFace
                {
                    level (0 0);
                    patchInfo { type patch; }
                }
                rightFace
                {
                    level (0 0);
                    patchInfo { type patch; }
                }
                }
            }
        }
        /*
        refinementRegions
        {
            refinementBox  
            {
                mode    inside;
                level   1;
            }
        }
        */
        


        locationInMesh (0 0 2.25);
        
        resolveFeatureAngle    15;
        nCellsBetweenLevels    2;
    }

    snapControls
    {
        explicitFeatureSnap    true;
        implicitFeatureSnap    false;
        multiRegionFeatureSnap false;
        
        nSmoothPatch        0;
        nSmoothInternal     0;
        tolerance           5;
        nSolveIter          100;
        nRelaxIter          10;
        nFeatureSnapIter    10;
        nFaceSplitInterval  5;
    }

    addLayersControls
    {
        layers
        {
            sideFace
            {
                nSurfaceLayers 3;
            }
        }

        relativeSizes       false;
        expansionRatio      1.2;
        finalLayerThickness 0.15;
        minThickness        0.0;
        nGrow               0;
        
        featureAngle             130;
        nRelaxIter               30;
        nSmoothSurfaceNormals    3;
        nSmoothNormals           8;
        nSmoothThickness         10;
        maxFaceThicknessRatio    0.5;
        maxThicknessToMedialRatio  1;
        minMedianAxisAngle       130;
        nBufferCellsNoExtrude    0;
        nLayerIter               50;
    }

    meshQualityControls
    {
        #include "meshQualityDict"
        
        maxNonOrtho             65;
        maxBoundarySkewness     20;
        maxInternalSkewness     4;
        maxConcave              80;
        minFlatness             0.5;
        minArea                 0.01;
    }

    /*
    writeFlags
    (
        scalarLevels
        layerSets
        layerFields
    );
    */

    mergeTolerance 1e-6;

    // ************************************************************************* //






网格检查
--------

在通过blockMesh或snappyHexMesh生成网格之后，可以在算例目录下运行下面的命令来查看网格质量是否合格：

.. code-block:: 

    checkMesh






残差监控
========


在算例目录下输入下面的命令：

.. code-block:: 

    foamGet residuals

选择第一个文件，就会在system文件夹内创建residuals文件，其基本内容如下所示：

.. code-block:: C

    #includeEtc "caseDicts/postProcessing/numerical/residuals.cfg"

    fields (p U);

其中 :code:`fields` 关键词决定了之后运行的时候需要检测残差变化的变量，可以根据需要自行添加变量名。在写好residuals文件之后，还需要进入controlDict文件中添加下面的内容：

.. code-block:: C

    functions
    {
            #includeFunc    residuals
    }


如此就设定好了残差检测。运行算例之后，就会创建postProcessing/residuals/0/residuals.dat文件，其中记录了之前设置变量的残差变化数据集。

该数据文件的数据是右对齐的，而且通过空格分隔。如果将其转换为csv文件然后用Python来读取，则可以通过下面的方式来进行：（核心是指定分隔符为多位空格"\s+"）

.. code-block:: python

    df = pd.read_csv("line.csv", sep="\s+")






physicalProperties文件
========================

physicalProperties文件给定所有流体属性的参数值，按照“物理量名+量纲+数值”的形式进行定义。量纲由方括号内的七个数定义，七个数代表SI标准和USCS标准的量纲的幂：

+------+----------+--------+-----------+
| 编号 | 名称     | SI单位 | USCS单位  |
+======+==========+========+===========+
| 1    | 质量     | kg     | lbm       |
+------+----------+--------+-----------+
| 2    | 长度     | m      | ft        |
+------+----------+--------+-----------+
| 3    | 时间     | s      | s         |
+------+----------+--------+-----------+
| 4    | 温度     | K      | Rankine°R |
+------+----------+--------+-----------+
| 5    | 物质的量 | kg/mol | lbmol     |
+------+----------+--------+-----------+
| 6    | 电流     | A      | A         |
+------+----------+--------+-----------+
| 7    | 光强     | cd     | cd        |
+------+----------+--------+-----------+



常见的物理特性参数的关键字与其对应的量纲如下：

+----------+--------------+-------------+------------------------------------+--------------------------+
| 物理特性 | 符号         | 关键字      | 量纲                               | dimensionSet             |
+==========+==============+=============+====================================+==========================+
| 运动粘度 | :math:`\nu`  | :code:`nu`  | :math:`\mathrm{m^{2}\cdot s^{-1}}` | :code:`[0 2 -1 0 0 0 0]` |
+----------+--------------+-------------+------------------------------------+--------------------------+
| 密度     | :math:`\rho` | :code:`rho` | :math:`\mathrm{kg\cdot m^{-3}}`    | :code:`[1 -3 0 0 0 0 0]` |
+----------+--------------+-------------+------------------------------------+--------------------------+




应力分析是会用到的物理特性参数：


+------------+----------------+----------------+---------------------------------------------+---------------------------+
| 物理特性   | 符号           | 关键字         | 量纲                                        | dimensionSet              |
+============+================+================+=============================================+===========================+
| 密度       | :math:`\rho`   | :code:`rho`    | :math:`\mathrm{kg\cdot m^{-3}}`             | :code:`[1 -3 0 0 0 0 0]`  |
+------------+----------------+----------------+---------------------------------------------+---------------------------+
| 杨氏模量   | :math:`E`      | :code:`E`      | :math:`\mathrm{Pa}`                         | :code:`[1 -1 -2 0 0 0 0]` |
+------------+----------------+----------------+---------------------------------------------+---------------------------+
| 泊松比     | :math:`\nu`    | :code:`nu`     |                                             | :code:`[0 0 0 0 0 0 0]`   |
+------------+----------------+----------------+---------------------------------------------+---------------------------+
| 比热容     | :math:`C_{p}`  | :code:`Cp`     | :math:`\mathrm{J\cdot kg^{-1}\cdot K^{-1}}` | :code:`[0 2 -2 -1 0 0 0]` |
+------------+----------------+----------------+---------------------------------------------+---------------------------+
| 热导率     | :math:`\kappa` | :code:`kappa`  | :math:`\mathrm{W\cdot m^{-1}\cdot K^{-1}}`  | :code:`[1 1 -3 -1 0 0 0]` |
+------------+----------------+----------------+---------------------------------------------+---------------------------+
| 热膨胀系数 | :math:`\alpha` | :code:`alphav` | :math:`\mathrm{K^{-1}}`                     | :code:`[0 0 0 -1 0 0 0]`  |
+------------+----------------+----------------+---------------------------------------------+---------------------------+





场设置
=========


常用的场文件名称及其意义如下所示：

+---------+---------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| 文件名  | 含义                                                                                  | 量纲                                                                                                 |
+=========+=======================================================================================+======================================================================================================+
| U       | 速度                                                                                  | :math:`\mathrm{m\cdot s^{-1}}`                                                                       |
+---------+---------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| U_0     | 前一个时间步长的速度(需要重新启动更高阶时间步长的格式时建立)                          | :math:`\mathrm{m\cdot s^{-1}}`                                                                       |
+---------+---------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| phi     | 流量                                                                                  | 对于不可压缩流为 :math:`\mathrm{m^{3}\cdot s^{-1}}` ；对于可压缩流为 :math:`\mathrm{kg\cdot s^{-1}}` |
+---------+---------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| p       | 压力。对于不可压缩求解器，这个场实际上是由恒定流体密度归一化的压力，                  | 对于不可压缩流为 :math:`\mathrm{m^{3}\cdot s^{-1}}` ；                                               |
+         +                                                                                       +                                                                                                      +
|         | 如果要得到真实的压力则需要在后期处理中乘以流体的密度。对于可压缩解算器，p是真实压力。 | 对于可压缩流为 :math:`\mathrm{kg\cdot s^{-1}}`                                                       |
+---------+---------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| epsilon | 湍流耗散率                                                                            | :math:`\mathrm{m^{2}\cdot s^{-3}}`                                                                   |
+---------+---------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| k       | 湍流动能                                                                              | :math:`\mathrm{m^{2}\cdot s^{-2}}`                                                                   |
+---------+---------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| rho     | 密度                                                                                  | :math:`\mathrm{kg\cdot m^{-3}}`                                                                      |
+---------+---------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| alpha   | 分散相体积分数                                                                        |                                                                                                      |
+---------+---------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| Theta   | 颗粒温度                                                                              | :math:`\mathrm{m^{2}\cdot s^{-2}}`                                                                   |
+---------+---------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| rDeltaT | 时间步长的倒数。对于改变局部时间步长的求解器，这表示局部时间步长。                    | :math:`\mathrm{s^{-1}}`                                                                              |
+         +                                                                                       +                                                                                                      +
|         | 这对于调试尤其有用。rDeltaT的高值可能表明需要在一个区域内进一步细化网格。             |                                                                                                      |
+---------+---------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+





热物理模型
=============

在physicalProperties文件中的thermoType关键词下指定运行中的热物理模型。


每个调用热物理模型库的求解器均会构建一个具体的热物理模型类：

+-------------------------+-----------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| 热物理模型类            | 简介                                                                                                            | 涉及求解器                                                                                                                                                                              |
+=========================+=================================================================================================================+=========================================================================================================================================================================================+
| psiThermo               | 固定组分、基于可压缩性 :math:`\varphi = (RT)^{-1}` 的热物理模型库， :math:`R` 为理想气体常数， :math:`T` 为温度 | 调用该类的求解器主要为可压缩求解器，例如rhoCentralFoam、uncoupledKinematicParcelFoam以及coldEngineFoam                                                                                  |
+-------------------------+-----------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| rhoThermo               | 固定组分、基于密度 :math:`\rho` 的热物理模型库                                                                  | 调用该类的求解器主要为传热类求解器，例如 buoyantSimpleFoam、buoyantPimpleFoam、rhoPorousSimpleFoam、twoPhaseEulerFoam以及thermoFoam                                                     |
+-------------------------+-----------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| psiReactionThermo       | 基于可压缩性 :math:`\varphi` 的附加反应的热物理模型库                                                           | 调用该类的求解器主要为燃烧求解器，例如sprayFoam、engineFoam、fireFoam、reactingFoam，以及一些拉格朗日求解器，例如coalChemistryFoam                                                      |
+-------------------------+-----------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| psiuReactionThermo      | 基于未燃气体可压缩性 :math:`\varphi u` 的反应混合热物理模型库                                                   | 调用该类的求解器主要为燃烧求解器，这些求解器的物理模型基于层流火焰速度以及回归变量，如XiFoam、XiEngineFoam和PDRFoam                                                                     |
+-------------------------+-----------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| rhoReactionThermo       | 基于密度 :math:`\rho` 的反应混合热物理模型库                                                                    | 调用该类的求解器主要为chtMultiRegionFoam以及一些燃烧求解器，如chemFoam、rhoReactinFoam、rhoReactingBuoyantFoam， 以及一些拉格朗日求解器，如reactingParcelFoam和simpleReactingParcelFoam |
+-------------------------+-----------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| multiPhaseMixtureThermo | 多相流热物理模型库                                                                                              | 调用该类的求解器主要为可压缩多相界面捕获求解器，如compressibleInterFoam、compressibleMultiphaseInterFoam                                                                                |
+-------------------------+-----------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+


type关键词用来指定具体的热物理模型库：

+----------------+-------------------------------------------------------------------------------+
| 热物理模型库   | 使用场景                                                                      |
+================+===============================================================================+
| hePsiThermo    | 调用fluidThermo，fluidReactionThermo以及psiThermo的求解器需指定               |
+----------------+-------------------------------------------------------------------------------+
| heRhoThermo    | 调用fluidThermo，fluidReactionThermo以及multiphaseMixtureThermo的求解器需指定 |
+----------------+-------------------------------------------------------------------------------+
| heheuPsiThermo | 调用psiuReactionThermo的求解器需指定                                          |
+----------------+-------------------------------------------------------------------------------+

mixture关键词指定混合组分。无反应的热物理模型库通常使用pureMixture，也即固定组分。当指定pureMixture的时候，相关的热物理模型系数在mixture子字典中指定。


transport传递模型需要计算动力粘度 :math:`\mu` 、热导率 :math:`\kappa` 、扩散率(用于内能方程或焓方程中) :math:`\alpha` 。可选的transport模型有：

+---------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| transport模型 | 含义                                                                                                                                                                                     |
+===============+==========================================================================================================================================================================================+
| const         | 粘度 :math:`\mu` 为常数，普朗特数由 :math:`P_{r} = C_{p}\mu / \varepsilon` 来计算，需要指定 :math:`mu` 和 :math:`P_{r}`                                                                  |
+---------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| sutherland    | 通过温度 :math:`T` 和两个系数 :math:`A_{s},T_{s}` 的函数来计算粘度 :math:`\mu` ，即 :math:`\mu = \frac{A_{s}\sqrt{T}}{1+T_{s}/T}` ，需要指定 :math:`A_{s}` 和 :math:`T_{s}`              |
+---------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| polynomial    | 从一个可以指定任意阶数的函数通过温度 :math:`T` 来计算粘度 :math:`\mu` 和热导率 :math:`\varepsilon` ，即 :math:`\mu = \sum\limits_{i=0}^{N-1}a_{i}T^{i}`                                  |
+---------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| logPolynomial | 从任意阶数依据 :math:`\ln(T)` 来计算 :math:`\ln(\mu)` 和 :math:`\ln(k)` ，即 :math:`\ln(\mu)=\sum\limits_{i=0}^{N-1}a_{i}(\ln T)^{i}`                                                    |
+---------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| icoTabulated  | 使用粘度和热导率的非均匀列表数据作为温度函数                                                                                                                                             |
+---------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| WLF           | 计算 :math:`\ln(\mu)` 和 :math:`\ln(\kappa)` 作为 :math:`\ln(T)` 的函数由任意阶N的多项式通过指数来计算 :math:`\mu,\kappa` ，即 :math:`\ln(\mu)=\sum\limits_{i=0}^{N-1}a_{i}[\ln(T)]^{i}` |
+---------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+


thermo热力模型参数和比热容 :math:`C_{p}` 有关，别的相关特性可以从比热容计算而来。可选的模型有：

+---------------+-------------------------------------------------------------------------------------------------------------------+
| thermo模型    | 含义                                                                                                              |
+===============+===================================================================================================================+
| hConst        | 指定 :math:`C_{p}` 以及 :math:`H_{f}` 为常量                                                                      |
+---------------+-------------------------------------------------------------------------------------------------------------------+
| eConst        | 指定 :math:`C_{\nu}` 以及 :math:`H_{f}` 为常量                                                                    |
+---------------+-------------------------------------------------------------------------------------------------------------------+
| eIcoTabulated | 通过插值 :math:`(T,C_{p})` 键值对的非均匀数据列表计算 :math:`C_{\nu}`                                             |
+---------------+-------------------------------------------------------------------------------------------------------------------+
| hIcoTabulated | 通过插值 :math:`(T,C_{p})` 键值对的均匀数据列表计算 :math:`C_{\nu}`                                               |
+---------------+-------------------------------------------------------------------------------------------------------------------+
| ePolynomial   | 通过任意N阶多项式计算 :math:`C_{\nu}` 作为温度的函数，即 :math:`C_{\nu}=\sum\limits_{i=0}^{N-1}a_{i}T^{i}`        |
+---------------+-------------------------------------------------------------------------------------------------------------------+
| hPower        | 将 :math:`C_{p}` 作为温度的指数来计算，即 :math:`C_{p}=c_{0}\left ( \frac{T}{T_{\text{ref}}}\right )^{n_{0}}`     |
+---------------+-------------------------------------------------------------------------------------------------------------------+
| ePower        | 将 :math:`C_{\nu}` 作为温度的指数来计算，即 :math:`C_{\nu}=c_{0}\left ( \frac{T}{T_{\text{ref}}}\right )^{n_{0}}` |
+---------------+-------------------------------------------------------------------------------------------------------------------+
| janaf         | 从JANAF热力学表来选择参数，以温度的函数来计算                                                                     |
+---------------+-------------------------------------------------------------------------------------------------------------------+


组分的量只有一种选择specie，后续需要进一步输入下面的信息：

+----------------+---------------------------------------------------------------------------+
| specie组分信息 | 含义                                                                      |
+================+===========================================================================+
| nMoles         | 摩尔数。仅仅在使用反应组分均一混合回归变量燃烧模型的时候起作用，否则其为1 |
+----------------+---------------------------------------------------------------------------+
| molWeight      | 摩尔质量g/mol                                                             |
+----------------+---------------------------------------------------------------------------+


状态方程equationOfState可选的有：

+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| 状态方程                 | 含义                                                                                                                                                            |
+==========================+=================================================================================================================================================================+
| rhoConst                 | 密度为常量                                                                                                                                                      |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| perfectGas               | 理想气体，即 :math:`\rho=\frac{1}{RT}p`                                                                                                                         |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| incompressiblePerfectGas | 不可压缩理想气体，即 :math:`\rho=\frac{1}{RT}p_{\text{ref}}` ，其中 :math:`p_{\text{ref}}` 为参考压力                                                           |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| perfectFluid             | 理想液体，即 :math:`\rho=\frac{1}{RT}p+\rho_{0}` ，其中 :math:`p_{0}` 为 :math:`T=0` 下的密度                                                                   |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| linear                   | 线性状态方程，即 :math:`\rho=\varphi p+\rho_{0}` ，其中 :math:`\varphi` 为可压缩性                                                                              |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| adiabaticPerfectFluid    | 绝热理想气体，即 :math:`\rho=\rho_{0}\left ( \frac{p+B}{p_{0}B}\right ) ^{1/\gamma}` ，其中 :math:`\rho_{0},p_{0}` 为参考密度和参考压力， :math:`B` 为模型常数  |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Boussinesq               | 布辛涅司克近似，即 :math:`\rho=\rho_{0}\big(1-\beta(T-T_{0})\big)` ，其中 :math:`\beta` 表示体膨胀率， :math:`\rho_{0}` 表示参考温度 :math:`T_{0}` 下的参考密度 |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| PengRobinsonGas          | 彭-罗宾森状态方程，即 :math:`\rho=\frac{1}{zRT}p` ，其中 :math:`z=z(p,T)`                                                                                       |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| icoPolynomial            | 不可压缩多项式状态方程 :math:`\rho=\sum\limits_{i=0}^{N-1}a_{i}T^{i}` ，其中 :math:`\varphi` 为可压缩性                                                         |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| icoTabulated             | 提供不可压缩流体 :math:`(T,\rho)` 键值对的数据列表                                                                                                              |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| rhoTabulated             | 可压缩流体的统一表格数据，计算 :math:`\rho` 作为 :math:`T` 和 :math:`T` 的函数                                                                                  |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| rPolynomial              | 液体或固体的倒数多项式状态方程，即 :math:`\frac{1}{\rho}=C_{0}+C_{1}T+C_{2}T^{2}-C_{3}p-C_{4}pT` ，其中的 :math:`C_{i}` 为系数                                  |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+

可以对能量方程求解的变量进行指定，其可为内能 :math:`e` 也可以为焓 :math:`h` ，并可以选择是否包含热源 :math:`\Delta h_{f}` 。其可以通过指定energy关键字来实现：

+------------------------+--------------------------------+
| 能量方程变量           | 含义                           |
+========================+================================+
| sensibleEnthalpy       | 利用焓值求解温度               |
+------------------------+--------------------------------+
| sensibleInternalEnergy | 利用内能求解温度               |
+------------------------+--------------------------------+
| absoluteEnthalpy       | 使用绝对能量表示包含热源的情况 |
+------------------------+--------------------------------+


每个组分都需要输入基本的热物理参数。他们必须以组分名作为关键词，其后是子字典，包含的参数主要有specie、thermoDynamics、transport。例如下面是一个组分名称为fuel，使用sutherland模型和janaf模型的范例：

.. code-block:: C

    fuel
    {
        specie
        {
            nMoles 1;
            molWeight 16.0428;
        }
        thermodynamics
        {
            Tlow 200;
            Thigh 6000;
            Tcommon 1000;
            highCpCoeffs (1.63543 0.0100844 -3.36924e-06 5.34973e-10 -3.15528e-14 -10005.6 9.9937);
            lowCpCoeffs (5.14988 -0.013671 4.91801e-05 -4.84744e-08 1.66694e-11 -10246.6 -4.64132);
        }
        transport
        {
            As 1.67212e-06;
            Ts 170.672;
        }
    }






湍流模型
=============

所有包含湍流的求解器都需要读取momentumTransport文件内设置的湍流模型信息。在该文件内，由 :code:`simulationType` 关键词决定所使用的湍流模型，其可能的赋值有：

- :code:`laminar` ，表示不使用湍流模型；
- :code:`RAS` ，表示使用雷诺平均模型；
- :code:`LES` ，表示使用大涡模拟。
  


RAS模型
---------

如果选用了RAS模型，就需要在momentumTransport文件内进一步创建RAS子字典，该子字典需要包含下列内容：

- :code:`model` ：具体采用的RAS湍流模型的名称；
- :code:`turbulence` ：开启或关闭湍流模型，可能的赋值有 :code:`on` 或 :code:`off` ；
- :code:`printCoeffs` ：输出或不输出湍流模型系数，可能的赋值有 :code:`on` 或 :code:`off` ；
- :code:`<model>Coeffs` ：可选参数，指定后可以覆盖默认的湍流模型参数。
  

以 :code:`kEpsilon` 模型为例，上述RAS子字典应该写为

.. code-block:: C

    RAS
    {
        model           kEpsilon;

        turbulence      on;

        printCoeffs     on;
    }

在运行算例后可以看到默认设置如下：

.. code-block:: C

    RAS
    {
        model           kEpsilon;
        turbulence      on;
        printCoeffs     on;
        Cmu             0.09;
        C1              1.44;
        C2              1.92;
        C3              0;
        sigmak          1;
        sigmaEps        1.3;
    }





fvShemes离散格式设置
=======================

参考 `OpenFOAM中fvSchemes字典文件解析 <https://www.zybuluo.com/daidezhi/note/389113>`_ 

system/fvSchemes文件用来设置离散格式，凡是求解器里面出现的方程，都需要在这里进行离散格式设置。需要指定的信息主要以下子字典：

+----------------------+------------------+
| 子字典关键词         | 含义             |
+======================+==================+
| interpolationSchemes | 插值格式         |
+----------------------+------------------+
| snGradSchemes        | 面法向梯度格式   |
+----------------------+------------------+
| ddtSchemes           | 时间一阶导项格式 |
+----------------------+------------------+
| d2dt2Schemes         | 时间二阶导项格式 |
+----------------------+------------------+
| divSchemes           | 散度项格式       |
+----------------------+------------------+
| gradSchemes          | 梯度项格式       |
+----------------------+------------------+
| laplacianSchemes     | 拉普拉斯项格式   |
+----------------------+------------------+
| fluxRequired         | 需要计算通量的场 |
+----------------------+------------------+


插值格式interpolationSchemes
-------------------------------

插值格式在子字典interpolationSchemes下设置，通常用来指定从相邻两个体单元计算公共面单元处变量值的计算方法：

+----------+----------------------+------------------------------+------------------+
| 插值格式 | 具体方法             | 含义                         | 用途             |
+==========+======================+==============================+==================+
| 中心格式 | linear               | 线性插值(中心差分)格式       | 应用于普通场插值 |
+          +----------------------+------------------------------+                  +
|          | cubicCorrection      | 立方正交格式                 |                  |
+          +----------------------+------------------------------+                  +
|          | midPoint             | 对称加权线性插值格式         |                  |
+----------+----------------------+------------------------------+------------------+
| 迎风格式 | upwind               | 一阶迎风格式                 | 主要应用于对流项 |
+          +----------------------+------------------------------+                  +
|          | linearUpwind         | 线性迎风格式                 |                  |
+          +----------------------+------------------------------+                  +
|          | skewLinear           | 带畸变修正线性迎风格式       |                  |
+          +----------------------+------------------------------+                  +
|          | filteredLinear2      | 高频波过滤线性迎风格式       |                  |
+----------+----------------------+------------------------------+------------------+
| TVD家族  | limitedLinear        | 有界线性格式                 | 主要应用于对流项 |
+          +----------------------+------------------------------+                  +
|          | limitedLimitedLinear | 有界线性格式(带限制器)       |                  |
+          +----------------------+------------------------------+                  +
|          | limitedLinearV       | 有界线性格式(矢量场专用)     |                  |
+          +----------------------+------------------------------+                  +
|          | vanLeer              | van Leer有界格式             |                  |
+          +----------------------+------------------------------+                  +
|          | limitedVanLeer       | van Leer有界格式(带限制器)   |                  |
+          +----------------------+------------------------------+                  +
|          | vanLeerV             | van Leer有界格式(矢量场专用) |                  |
+          +----------------------+------------------------------+                  +
|          | MUSCL                | MUSCL有界格式                |                  |
+          +----------------------+------------------------------+                  +
|          | limitedMUSCL         | MUSCL有界格式(带限制器)      |                  |
+          +----------------------+------------------------------+                  +
|          | limitedCubic         | 立方正交有界格式             |                  |
+          +----------------------+------------------------------+                  +
|          | limitedLimitedCubic  | 立方正交有界格式(带限制器)   |                  |
+          +----------------------+------------------------------+                  +
|          | limitedCubicV        | 立方正交有界格式(矢量场专用) |                  |
+----------+----------------------+------------------------------+------------------+
| NVD家族  | SFCD                 | 自过滤中心格式               | 主要应用于对流项 |
+          +----------------------+------------------------------+                  +
|          | SFCDV                | 自过滤中心格式(矢量场专用)   |                  |
+          +----------------------+------------------------------+                  +
|          | Gamma                | Gamma差分格式                |                  |
+          +----------------------+------------------------------+                  +
|          | limitedGamma         | Gamma差分格式(带限制器)      |                  |
+          +----------------------+------------------------------+                  +
|          | GammaV               | Gamma差分格式(矢量场专用)    |                  |
+----------+----------------------+------------------------------+------------------+



针对对流项的插值格式需要在通量的基础上计算插值，因此这些格式的指定需要提供通量场的名称。在OpenFOAM标准求解器中，体积通量名称一般为phi，类型为surfaceScalarField（面心标量场），因此针对对流项的插值格式指定方式为：

.. code-block:: C

    default upwind phi;


一些基于TVD或者NVD的格式需要系数 :math:`\psi` ，该系数的值介于0和1之间。当 :math:`\psi=1` 时对应标准TVD格式，能够达到最快的收敛速度；当 :math:`\psi=0` 时对应最高精度，例如：

.. code-block:: C

    default limitedLinear phi 1.0;



某些标量场是严格有界的，例如VOF模型中的流体体积分数场 :math:`F` 的值严格介于0和1之间，因此才会出现一些带有限制器的增强版格式。如果想要指定有界场的上下限，需要在格式名称前加上limited前缀。例如将vanLeer格式的上下限设置为 :math:`[-2,3]` ：

.. code-block:: C

    default limitedVanLeer -2.0 3.0;

特别地，对于类似于流体体积分数场上下限严格为 :math:`[0,1]` 的情况，可以添加后缀01，例如：

.. code-block:: C

    default vanLeer01;


针对矢量场的有向性，一些带有限制器的格式具有矢量场的专用版本，使用方法为添加后缀V，如：

.. code-block:: C

    default limitedLinearV;


下面是一些具体的设置案例：

.. code-block:: C

    default            linear;
    reconstruct(rho)   vanLeer;
    reconstruct(U)     vanLeerV;




面法向梯度格式snGradSchemes
-------------------------------

面法向梯度指的是变量场梯度在面 :math:`f` 处的法向分量，一般需要在单独计算面法向梯度 :math:`\nabla_{f}\cdot \mathbf{A}_{f}` 或者指定拉普拉斯项 :math:`\nabla^{2}\cdot` 离散格式时指定面法向梯度格式。支持的标准格式有：

+----------------+--------------------------+
| 面法向梯度格式 | 含义                     |
+================+==========================+
| corrected      | 显示非正交修正格式       |
+----------------+--------------------------+
| uncorrected    | 无非正交修正格式         |
+----------------+--------------------------+
| limited        | 非完全正交修正格式       |
+----------------+--------------------------+
| bounded        | 对正值标量的有界修正格式 |
+----------------+--------------------------+
| fourth         | 四阶格式                 |
+----------------+--------------------------+


特别地，非完全正交修正格式limited需要指定系数 :math:`\psi` ，其值介于0和1之间：

- 取值为0时，无非正交修正；
- 取值为0.333时，限制非正交修正部分不超过正交部分的一半；
- 取值为0.5时，限制非正交修正部分不超过正交部分；
- 取值为1时，不限制非正交修正部分，等同于corrected格式。


下面是一些具体的设置案例：

.. code-block:: C

    default         corrected;








时间一阶导项格式ddtSchemes
----------------------------

时间一阶导项 :math:`\frac{\partial}{\partial t}` 格式支持的标准格式有：



+------------------+----------------------------------+
| 时间一阶导项格式 | 含义                             |
+==================+==================================+
| backward         | 二阶向后差分格式(BDS2)，隐式     |
+------------------+----------------------------------+
| bounded          |                                  |
+------------------+----------------------------------+
| CoEuler          | 一阶，可控制局部库朗数           |
+------------------+----------------------------------+
| CrankNicolson    | 二阶精度，有界，隐式             |
+------------------+----------------------------------+
| Euler            | 一阶精度，有界，隐式             |
+------------------+----------------------------------+
| localEuler       | 局部时间步，一阶精度，有界，隐式 |
+------------------+----------------------------------+
| SLTS             |                                  |
+------------------+----------------------------------+
| steadyState      | 定常，忽略时间导数项             |
+------------------+----------------------------------+







其中CrankNicolson格式需要设置系数 :math:`\psi` ，其值介于0和1之间。当 :math:`\psi=1` 时为纯Crank-Nicolson格式；当 :math:`\psi=0` 时为纯Euler格式。

下面是一些具体使用的案例：

.. code-block:: C

    default         Euler;
    default         localEuler;






时间二阶导项格式d2dt2Schemes
-------------------------------

时间二阶导项 :math:`\frac{\partial^{2}}{\partial t^{2}}` 格式只支持Euler格式。



梯度项格式gradSchemes
------------------------

梯度项 :math:`\nabla` 格式支持的标准格式有：


+-----------------------------+-------------------------------------------------------+
| 梯度项格式                  | 含义                                                  |
+=============================+=======================================================+
| Gauss <interpolationScheme> | 高斯积分，<interpolationScheme>设置插值格式，二阶精度 |
+-----------------------------+-------------------------------------------------------+
| leastSquares                | 最小二乘法，二阶精度                                  |
+-----------------------------+-------------------------------------------------------+
| fourth                      | 最小二乘法，四阶精度                                  |
+-----------------------------+-------------------------------------------------------+
| cellLimited <gradScheme>    | 上述格式的体单元有界版本                              |
+-----------------------------+-------------------------------------------------------+
| faceLimited <gradScheme>    | 上述格式的面单元有界版本                              |
+-----------------------------+-------------------------------------------------------+


下面是一些具体的设置案例：

.. code-block:: C

    default         Gauss linear;





散度项格式divSchemes
-----------------------

参考 `Divergence schemes <https://www.openfoam.com/documentation/guides/latest/doc/guide-schemes-divergence.html>`_ 

此项一般只出现在涉及流体流动的数值模拟中，例如标量形式的 :math:`\nabla\cdot(\rho \mathbf{U}T)` 和矢量形式的 :math:`\nabla\cdot(\rho \mathbf{U}\mathbf{U})` 。以动量方程中的对流项 :math:`\nabla\cdot(\rho \mathbf{U}\mathbf{U})` 为例，基于有限体积积分有

.. math::
    \begin{align}
    \int_{V}\nabla\cdot(\rho\mathbf{U}\mathbf{U})~\mathrm{d}V=\int_{\mathbf{A}_{f}}\rho\mathbf{U}\mathbf{U}\cdot \mathrm{d}\mathbf{A}_{f}=\sum \rho_{f}\mathbf{U}_{f}\mathbf{U}_{f}\cdot \mathbf{A}_{f}=\sum \phi_{f}\mathbf{U}_{f} 
    \end{align}

其中 :math:`\phi_{f}` 表示面 :math:`f` 处的质量通量，即 :math:`\rho_{f}\mathbf{U}_{f}\cdot\mathbf{A}_{f}` ，也因此在OpenFOAM中表示为 :code:`div(phi, U)` 。

散度项格式一般为下面的格式：

.. code-block:: 

    Gauss <interpolationScheme>


为线性化此非线性项，在对对流项进行离散的过程中， :math:`\phi_{f}` 是作为已知量参与计算的，一般使用上一时间步的速度场 :math:`\mathbf{U}^{n}` 计算得到，即

.. math::
    \begin{align}
    \sum\rho_{f}\mathbf{U}_{f}\mathbf{U}_{f}\cdot\mathbf{A}_{f}=\sum\rho_{f}^{n}\mathbf{U}_{f}^{n+1}\mathbf{U}_{f}^{n}\cdot\mathbf{A}_{f}=\sum\phi_{f}^{n}\mathbf{U}_{f}^{n+1}
    \end{align}

其中 :math:`\phi_{f}^{n}` 的数值通过Rhie-Chow动量插值计算得到。因此，这里的插值格式<interpolationScheme>只针对上式中的 :math:`\mathbf{U}_{f}^{n+1}` ，其数学特性如下：



+-------------------------------+----------------------------+
| 所选用的<interpolationScheme> | 数学特性                   |
+===============================+============================+
| linear                        | 二阶，无界                 |
+-------------------------------+----------------------------+
| skewLinear                    | 二阶，带skewness修正，无界 |
+-------------------------------+----------------------------+
| cubicCorrected                | 四阶，无界                 |
+-------------------------------+----------------------------+
| upwind                        | 一阶，有界                 |
+-------------------------------+----------------------------+
| linearUpwind                  | 一/二阶，有界              |
+-------------------------------+----------------------------+
| QUICK                         | 一/二阶，有界              |
+-------------------------------+----------------------------+
| TVD家族                       | 一/二阶，有界              |
+-------------------------------+----------------------------+
| SFCD                          | 二阶，有界                 |
+-------------------------------+----------------------------+
| NVD家族                       | 一/二阶，有界              |
+-------------------------------+----------------------------+



+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| 散度项格式                                      | 数学特性                                                                                                                                                                                                                                                         |
+=================================================+==================================================================================================================================================================================================================================================================+
| Gauss limitedLinear <coeff>                     | 一阶或二阶，无界                                                                                                                                                                                                                                                 |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss linear                                    | 二阶，无界，低耗散(适合于LES)，用于各项同性网格                                                                                                                                                                                                                  |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss linearUpwind grad(U)                      | 二阶，无界，采用迎风插值权重并基于局部单元梯度进行显式修正                                                                                                                                                                                                       |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss midPoint                                  | 一阶或二阶，无界，应用于各向同性网格时等价于linear，使用表面通量计算                                                                                                                                                                                             |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss Minmod                                    | 一阶，无界，最小模量                                                                                                                                                                                                                                             |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss MUSCL                                     | 二阶，无界，守恒定律的单调上游中心格式                                                                                                                                                                                                                           |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss QUICK                                     | 二阶，无界，对流运动学的二次上游插值                                                                                                                                                                                                                             |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss UMIST                                     | 二阶，无界，标量传输的上游单调插值                                                                                                                                                                                                                               |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss upwind                                    | 一阶，有界，根据上游值设置面值，相当于假设单元值是各向同性的且其值代表平均值                                                                                                                                                                                     |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss vanLeer                                   | 二阶，无界                                                                                                                                                                                                                                                       |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss CoBlended <co1> <scheme1> <co2> <scheme2> | 基于表面库朗数混合两种格式：当Co小于<co1>时采用<scheme1>，当Co大于<co2>时采用<scheme2>，当<co1>小于Co小于<co2>时线性混合<scheme1>和<scheme2>                                                                                                                     |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss DEShybrid <many coeff>                    | 基于局部属性混合两种格式                                                                                                                                                                                                                                         |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss filteredLinear2 <k> <l>                   | 二阶，无界，试图限制linear格式的无界性。<k>是缩放校正应用的比率，取0时为线性，取1时为完全限制；<l>是相对于difference across the face的最大允许overshoot/undershoot，取0时为没有overshoot/undershoot，取1时为overshoot/undershoot与difference across the face相等 |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss LUST <grad-scheme>                        | 无界，线性迎风稳定输送，固定使用linearUpwind权重0.25，linear权重0.75                                                                                                                                                                                             |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+





对于某些流动情况，有几种对流方案可供选择：稳态，有界标量传输和有限方案。对于稳态情况，可以应用有界形式：

.. code-block:: C

    bounded Gauss <interpolation scheme>

这增加了一个线性化，隐式源贡献的传输方程的形式。也就是说，它去掉了一个与连续性误差成比例的分量。随着计算的进行，这作为收敛辅助，趋向于有界解。在收敛时，这一项变为零，对最终解没有贡献。




下面是一些具体的设置案例：

.. code-block:: C

    div(tauMC)          Gauss linear;
    div(phi,U)          Gauss limitedLinear 1;
    div(phi,U)          bounded Gauss upwind;
    div(phi,k)          bounded Gauss linearUpwind limited;








拉普拉斯项格式laplacianSchemes
----------------------------------

在流体流动的动量方程中，拉普拉斯项一般为 :math:`\nabla\cdot(\nu\nabla\mathbf{U})` ，在OpenFOAM中表示为 :code:`laplacian(nu, U)` ，基于有限体积积分有：

.. math::
    \begin{align}
    \int_{V}\nabla\cdot(\nu\nabla\mathbf{U})~\mathrm{d}V=\int_{\mathbf{A}_{f}}\nu_{f}\nabla\mathbf{U}_{f}\cdot\mathrm{d}\mathbf{A}_{f}=\sum\nu_{f}\nabla\mathbf{U}_{f}\cdot\mathbf{A}_{f}    
    \end{align}

因此，需要指定 :math:`\nu_{f}` 的插值格式，同时也要指定面法向梯度 :math:`\nabla\mathbf{U}_{f}` 的离散格式。拉普拉斯格式laplacianSchemes只支持下面的格式：

.. code-block:: 

    Gauss <interpolationScheme> <snGradScheme>

其中 :code:`<interpolationScheme>` 用于指定 :math:`\nu_{f}` 的插值格式； :code:`<snGradScheme>` 用于指定面法向梯度 :math:`\nabla\mathbf{U}_{f}\cdot\mathbf{A}_{f}` 的离散格式：

+----------------------+----------------------------------+
| 所选的<snGradScheme> | 数学特性                         |
+======================+==================================+
| corrected            | 无界，二阶，守恒                 |
+----------------------+----------------------------------+
| uncorrected          | 有界，一阶，非守恒               |
+----------------------+----------------------------------+
| limited              | corrected和uncorrected的混合格式 |
+----------------------+----------------------------------+
| bounded              | 有界，一阶                       |
+----------------------+----------------------------------+
| fourth               | 无界，四阶，守恒                 |
+----------------------+----------------------------------+


下面是一些具体的设置案例：

.. code-block:: C

    default         Gauss linear corrected;





需要计算通量的场fluxRequired
------------------------------

fluxRequired子字典列举了数值模拟过程中需要计算通量的场。例如流体流动模拟中，在求解压力p的方程后需要计算通量，这可以通过在fluxRequired子字典中简单地指定：

.. code-block:: C

    fluxRequired 
    { 
        p; 
    }





fvSolution代数方程组求解设置
==============================

该文件由solvers、所采用耦合算法(PISO、SIMPLE、PIMPLE)以及relaxationFactors等子字典组成。

solvers设置
---------------

+----------------+--------------------------------------------------------------------------------------------------------------------+
| solvers关键词  | 含义                                                                                                               |
+================+====================================================================================================================+
| solver         | 代数方程组求解器                                                                                                   |
+----------------+--------------------------------------------------------------------------------------------------------------------+
| preconditioner | 预处理器。本质上为一个改变原先系数矩阵条件数的左乘矩阵。当solver采用了PCG/PBiCG求解器时进行设置。                  |
+----------------+--------------------------------------------------------------------------------------------------------------------+
| smoother       | 光滑器。当solver采用了smoothSolver时进行设置。                                                                     |
+----------------+--------------------------------------------------------------------------------------------------------------------+
| tolerance      | 绝对残差(前后两次迭代结果的差值)。决定了求解器退出的标准。对于稳态问题应该取得很小，而对于瞬态问题则不能取得太小。 |
+----------------+--------------------------------------------------------------------------------------------------------------------+
| relTol         | 相对残差(前后两次迭代残差的比值)。当设置为非零数时将忽略tolerance的设置。                                          |
+----------------+--------------------------------------------------------------------------------------------------------------------+
| maxIter        | 最大迭代次数。                                                                                                     |
+----------------+--------------------------------------------------------------------------------------------------------------------+


关键词solver可以选择的代数方程组求解器包括：

+--------------+------------------------------------+
| solver       | 含义                               |
+==============+====================================+
| PCG          | 预处理共轭梯度(对称)求解器         |
+--------------+------------------------------------+
| PBiCG        | 预处理稳定双共轭梯度(非对称)求解器 |
+--------------+------------------------------------+
| smoothSolver | 光滑求解器                         |
+--------------+------------------------------------+
| GAMG         | 几何-代数多重网格求解器            |
+--------------+------------------------------------+
| diagonal     | 对角求解器(显式离散)               |
+--------------+------------------------------------+

关键词preconditioner可以选择的预处理器包括：

+----------------+-----------------------------------------------------+
| preconditioner | 含义                                                |
+================+=====================================================+
| DIC            | 不完全的对角Cholesky预处理器(对称矩阵)              |
+----------------+-----------------------------------------------------+
| FDIC           | 不完全的快速对角Cholesky预处理器(相当于带缓存的DIC) |
+----------------+-----------------------------------------------------+
| DILU           | 对角不完全LU预处理器(非对称)                        |
+----------------+-----------------------------------------------------+
| diagonal       | 对角预处理器                                        |
+----------------+-----------------------------------------------------+
| GAMG           | 几何-代数多重网格预处理器                           |
+----------------+-----------------------------------------------------+
| none           | 不进行预处理                                        |
+----------------+-----------------------------------------------------+


关键词smoother可以选择的光滑器包括：

+----------------+----------------------------------------------------------------------------+
| smoother       | 含义                                                                       |
+================+============================================================================+
| GaussSeidel    | 高斯塞德尔光顺器。一般情况下最可靠。                                       |
+----------------+----------------------------------------------------------------------------+
| DIC            | 不完全的对角Cholesky光顺器(对称矩阵)。对于有些条件数不好的矩阵收敛性更好。 |
+----------------+----------------------------------------------------------------------------+
| DICGaussSeidel | 不完全的对角Cholesky-高斯塞德尔光顺器(对称矩阵)                            |
+----------------+----------------------------------------------------------------------------+


耦合算法设置
---------------

.. code-block:: C

    //PISO算法设置
    PISO
    {
        nCorrectors     2;                  //PISO修正次数
        nNonOrthogonalCorrectors 0;         //非正交修正次数
        pRefCell        0;                  //压力参考单元
        pRefValue       0;                  //压力参考值
    }


欠松弛处理设置
----------------

欠松弛处理主要有两种不同的使用方式：

- 在迭代之前提高系数矩阵主对角元素数值，并且降低源项来保证系数矩阵对角占优，比如速度场U；
- 限制变量在迭代后改变的大小，比如压力场p。
  
欠松弛因子 :math:`\alpha` 介于0和1之间，越接近0求解越稳定，但同时也会降低求解效率；提高 :math:`\alpha` 的数值会提高求解效率，但同时也会降低稳定性。

欠松弛因子在子字典relaxationFactors下指定，通过子字典名equations和fields来设置不同的欠松弛方式，例如：

.. code-block:: C

    relaxationFactors
    {
        fields
        {
            p 0.3;
        }
        equations
        {
            U 0.7;
        }
    }



controlDict设置
====================

位于system文件夹内的controlDict文件用于设置时间和输入输出控制，包括时间控制、计算结果输出控制、时间步长自适应控制、字典读取控制和运行时加载库或者函数五个部分。

常规设置
----------

时间控制部分startFrom关键词决定了开始计算的时间，可选的取值包括：

+------------+---------------------------------------------------------------+
| startFrom  | 含义                                                          |
+============+===============================================================+
| firstTime  | 所有时间目录中最早的时间步                                    |
+------------+---------------------------------------------------------------+
| latestTime | 所有时间目录中最近的时间步                                    |
+------------+---------------------------------------------------------------+
| startTime  | 从指定开始的时间步开始计算，需要在下面指定startTime关键词的值 |
+------------+---------------------------------------------------------------+


时间控制部分stopAt关键词决定了停止计算的时间，可选的取值包括：

+------------+-----------------------------------------------------------+
| stopAt     | 含义                                                      |
+============+===========================================================+
| endTime    | 在指定的结束时间停止计算，需要在下面指定endTime关键词的值 |
+------------+-----------------------------------------------------------+
| writeNow   | 当前时间步完成时结束计算并且输出计算结果                  |
+------------+-----------------------------------------------------------+
| noWriteNow | 当前时间步完成时结束计算但是不输出计算结果                |
+------------+-----------------------------------------------------------+
| nextWrite  | 下一个时间步完成时结束计算并且输出计算结果                |
+------------+-----------------------------------------------------------+


计算结果输出控制部分writeControl关键词决定计算结果输出间隔方式，可选的取值包括：

+-------------------+------------------------------------------------------------------------+
| writeControl      | 含义                                                                   |
+===================+========================================================================+
| timeStep          | 按照时间步输出，间隔由关键字writeInterval指定，单位为[步]              |
+-------------------+------------------------------------------------------------------------+
| runTime           | 按照计算时间输出，间隔由关键字writeInterval指定，单位为[s]             |
+-------------------+------------------------------------------------------------------------+
| adjustableRunTime | 时间自适应下按照计算时间输出，间隔由关键字writeInterval指定，单位为[s] |
+-------------------+------------------------------------------------------------------------+
| cpuTime           | 按照CPU时间输出，间隔由关键字writeInterval指定，单位为[s]              |
+-------------------+------------------------------------------------------------------------+
| clockTime         | 按照真实时间输出，间隔由关键字writeInterval指定，单位为[s]             |
+-------------------+------------------------------------------------------------------------+


计算结果输出控制部分writeFormat关键词决定了计算结果输出的格式，可选的取值包括：

+-------------+------------------------------------------------------------------------+
| writeFormat | 含义                                                                   |
+=============+========================================================================+
| ascii       | 文本格式，由writePrecision关键词控制有效数字位数                       |
+-------------+------------------------------------------------------------------------+
| binary      | 二进制格式，直接将内存内容写入文件，能够减少文件存储空间，提高读写效率 |
+-------------+------------------------------------------------------------------------+


计算结果输出控制部分writeCompression关键词决定了输出文件是否压缩，可选的取值包括：

+------------------+--------------+
| writeCompression | 含义         |
+==================+==============+
| uncompressed     | 不压缩       |
+------------------+--------------+
| compressed       | gzip压缩格式 |
+------------------+--------------+


计算结果输出控制部分timeFormat关键词决定了时间的格式，可选的取值包括：

+------------+----------------------------------------------------------------------------+
| timeFormat | 含义                                                                       |
+============+============================================================================+
| fixed      | :math:`\pm\text{m.dddddd}` ，其中d由timePrecision来控制                    |
+------------+----------------------------------------------------------------------------+
| scientific | :math:`\pm\text{m.dddddd}\pm\text{xx}` ，其中d由timePrecision来控制        |
+------------+----------------------------------------------------------------------------+
| general    | 使用scientific格式，默认小数点后有4位有效位数，也可通过timePrecision来调节 |
+------------+----------------------------------------------------------------------------+

自适应时间步长需要指定自适应开关adjustTimeStep，最大库朗数maxCo时间步长最大值maxDeltaT的数值，例如：

.. code-block:: C

    //时间步长自适应控制
    adjustTimeStep  yes;                //是否开启时间步长自适应
    maxCo           0.5;                //最大库郎数
    maxDeltaT       1.0;                //最大时间步长


在计算过程当中，一些字典文件可能会被修改，这时需要打开读取开关runTimeModifiable，以让求解器更新一些参数。


运行时加载库或者函数控制
----------------------------

设置运行时需要加载的库或函数如下所示：

.. code-block:: C

    libs        libUser1.so;    //库列表，库文件位于$LD_LIBRARY_PATH
    functions   probes;         //函数列表




初始条件与边界条件
====================

边界条件可以分为下面三种类型，在应用中可以任选其中一个：

- Dirichlet边界：直接指定边界上待求物理变量的值；
- Neumann边界：指定边界上物理量的法向梯度；
- Robin边界：上面两种边界的混合，既指定物理量的值，也指定梯度值。
  

初始化条件可以分为两类：

- uniform：均匀的初始条件；
- nonuniform：非均匀的初始条件。
  
可以从以下途径获取非一致的初始条件：

- 其他仿真计算得到的结构作为初始条件；
- 数学函数计算结果；
- 势流求解器计算的结果；
- 降阶模型计算的结果；
- 实验数据。
  


进出口边界条件
----------------

参考 `OpenFOAM初始条件与边界条件 <https://www.topcfd.cn/12217/>`_ 

在进出口边界条件中，入口边界用于计算区域中预期会有流体流入的区域，但是当边界条件指定为速度分布时，入口可以允许流体流出；压力边界条件不允许入口有流体流出。速度入口主要用于不可压缩流动，压力于流量入口适合于可压缩与不可压缩流动。相同的概念也适合于出口。

零梯度边界条件zerogradient从计算区域中通过外推得到物理量的值，设置为零梯度边界时不需要任何信息，该条件可以用于入口、出口和壁面。

回流边界条件backflow提供了一个通用的流出/流入条件，对于存在回流的问题可以指定流入/流出条件。对于回流出口backflowoutlet，当通量为正(流出计算域)时应用neumann边界条件(零梯度)；当通量为负(流体流入计算域)将应用Dirichlet边界条件(固定值)。同样的概念也适用于回流入口。


.. note:: 有些边界条件的一些组合非常稳定，而有些组合的可靠性较低，如入口处设置为速度和出口处设置为零压力梯度，这种组合由于静压不固定，此模拟最终将崩溃。


对称边界条件仅适用于平面，只有当几何形状和流场都对称时才可以使用对称边界。从数学上将，设置对称边界条件等于该平面上的法向速度为零以及平面上所有变量的法向梯度为零；从物理上讲，它们等效于滑移壁面。



OpenFoam中边界类型分为基本类型和数值类型。基本类型边界在网格文件夹中的boundary文件中定义；数值类型边界在物理量文件夹中的场文件当中定义，通常指的是Dirichlet、Neumann或Robin边界条件。


下面所示的类型是在boundary文件与场文件当中保持一致的，在OpenFOAM中称为约束边界(constraint patch)：

+---------------+---------------+----------+
| 基础类型      | 数值类型      | 含义     |
+===============+===============+==========+
| cyclic        | cyclic        | 周期性的 |
+---------------+---------------+----------+
| cyclicAMI     | cyclicAMI     | ?        |
+---------------+---------------+----------+
| empty         | empty         | 空       |
+---------------+---------------+----------+
| processor     | processor     | 并行     |
+---------------+---------------+----------+
| symmetry      | symmetry      | 对称     |
+---------------+---------------+----------+
| symmetryPlane | symmetryPlane | 对称面   |
+---------------+---------------+----------+
| wedge         | wedge         | ?        |
+---------------+---------------+----------+



:code:`patch` 基本类型是OpenFOAM中可用的任何边界条件，可以匹配所有Dirichlet, Neumann或Robin边界条件。

基础类型 :code:`wall` 通过下面方式定义：

+----------+------------------------+--------------+
| 基础类型 | 数值类型                              |
+==========+========================+==============+
| boundary | 0/U                    | 0/p          |
+----------+------------------------+--------------+
| wall     | type fixedValue;       | zeroGradient |
+          +                        +              +
|          | value uniform (0 0 0); |              |
+----------+------------------------+--------------+




backflow出口边界，可以使用以下边界条件组合：

+----------+-----------------------------+------------------+
| 基础类型 | 数值类型                                       |
+==========+=============================+==================+
| boundary | 0/U                         | 0/p              |
+----------+-----------------------------+------------------+
| patch    | type inletOutlet;           | type fixedValue; |
+          +                             +                  +
|          | inletValue uniform (0 0 0); | value uniform 0; |
+          +                             +                  +
|          | value uniform (0 0 0);      |                  |
+----------+-----------------------------+------------------+


.. note:: 在上面的0/U的数值类型当中， :code:`inletValue` 用于回流处理。如果流体返回计算区域，将使用 :code:`inletValue` 设置的值，其他情况使用 :code:`zeroGradient` 边界条件。



外部空气动力学计算中典型的边界条件如下所示：

+----------+--------------+-------------+-------------+
| 边界描述 | 压力         | 速度        | 湍流场      |
+==========+==============+=============+=============+
| 入口面   | zeroGradient | fixedValue  | fixedValue  |
+----------+--------------+-------------+-------------+
| 出口面   | fixedValue   | inletOutlet | inletOutlet |
+----------+--------------+-------------+-------------+
| 壁面     | zeroGradient | fixedValue  | 壁面函数    |
+----------+--------------+-------------+-------------+
| 对称面   | symmetry     | symmetry    | symmetry    |
+----------+--------------+-------------+-------------+
| 周期面   | cyclic       | cyclic      | cyclic      |
+----------+--------------+-------------+-------------+
| 空面     | empty        | empty       | empty       |
+----------+--------------+-------------+-------------+
| 滑移壁面 | slip         | slip        | slip        |
+----------+--------------+-------------+-------------+


上面提到的壁面函数如下表所示：

+---------+---------------------+-----------------------------------------------+
| 物理场  | 壁面函数(高雷诺数)  | 求解边界层(低雷诺数)                          |
+=========+=====================+===============================================+
| nut     | nut壁面函数         | fixedValue 0 或者一个较小值                   |
+---------+---------------------+-----------------------------------------------+
| k,q,R   | kqRWallFunction     | fixedValue 0 或者一个较小值                   |
+---------+---------------------+-----------------------------------------------+
| epsilon | epsilonWallFunction | zeroGradient 或者 fixedValue 0 或者一个较小值 |
+---------+---------------------+-----------------------------------------------+
| omega   | omegaWallFunction   | fixedValue指定一个较大值                      |
+---------+---------------------+-----------------------------------------------+
| zeta    |                     | fixedValue 0 或者一个较小值                   |
+---------+---------------------+-----------------------------------------------+
| nuTilda |                     | fixedValue 0 或者一个较小值                   |
+---------+---------------------+-----------------------------------------------+


上面提到的nut壁面函数可以是：nutkAtmRoughWallFunction, nutkRoughWallFunction, nutkWallFunction, nutLowReWallFunction, nutURoughWallFunction, nutUSpaldingWallFunction, nutUTabulatedWallFunction, nutUWallFunction, nutWallFunction。





各种边界的数值类型及其一般设置方式
------------------------------------


cyclic
^^^^^^^^^

.. code-block:: C

    // incompressible/pimpleFoam/LES/channel395/0.orig/U
    sides1_half0
    {
        type            cyclic;
    }


epsilonWallFunction
^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    // compressible/pisoFoam/RAS/cavityRAS/0/epsilon
    fixedWalls
    {
        type            epsilonWallFunction;
        value           uniform 0.00754;
    }


fixedValue
^^^^^^^^^^^^^

.. code-block:: C

    // incompressible/icoFoam/cavity/cavity/0/U
    movingWall
    {
        type            fixedValue;
        value           uniform (1 0 0);
    }


inletOutlet
^^^^^^^^^^^^^^

.. code-block:: C

    // incompressible/pimpleFoam/RAS/flowWithOpenBoundary/0/T
    atmosphere
    {
        type            inletOutlet;
        inletValue      uniform 0;
        value           uniform 0;
    }


kqRWallFunction
^^^^^^^^^^^^^^^^^^

.. code-block:: C

    // incompressible/pisoFoam/RAS/cavityRAS/0/k
    fixedWalls
    {
        type            kqRWallFunction;
        value           uniform 0.00375;
    }




noSlip
^^^^^^^^

.. code-block:: C

    // incompressible/icoFoam/cavity/cavityClipped/0/U
    fixedWalls
    {
        type            noSlip;
    }


nutWallFunction
^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    // incompressible/pisoFoam/RAS/cavityRAS/0/nut
    movingWall
    {
        type            nutkWallFunction;
        value           uniform 0;
    }



symmetry
^^^^^^^^^

.. code-block:: 

    // incompressible/pimpleFoam/RAS/elipsekkLOmega/0/p
    up
    {
        type            symmetry;
    }


symmetryPlane
^^^^^^^^^^^^^^^^^

.. code-block:: C

    // stressAnalysis/solidDisplacementFoam/plateHole/0/D
    left
    {
        type            symmetryPlane;
    }



zeroGradient
^^^^^^^^^^^^^^

.. code-block:: C

    // incompressible/icoFoam/cavity/cavity/0/p
    fixedWalls
    {
        type            zeroGradient;
    }




codedFixedValue
^^^^^^^^^^^^^^^^^^

下面是在射流外设置一个线性分布的速度场的例子：

.. code-block:: C

    AirInlet
        {
            type        codedFixedValue;
            value       uniform (0 0 6.10);

            name    linearVelocity;
            code
            #{
                const vectorField& Cf = patch().Cf();   //center of the patch
                vectorField& field = *this;             //the target velocity field

                const scalar Umax = 6.1;
                const scalar r1 = 0.02;                 //radius of the hot coflow
                const scalar r2 = 0.06;                 //radius of the domain

                forAll(Cf, faceI)
                {
                    const scalar x = Cf[faceI][0];
                    const scalar y = Cf[faceI][1];
                    const scalar R = sqrt(x*x+y*y);

                    if(R>r1){
                        field[faceI] = vector(0,0,Umax*(r2-R)/(r2-r1));
                    }
                }
            #};
        }

另外一个应用案例：

.. code-block:: C

    code
    #{
        const fvPatch& boundaryPatch = patch();   
        const vectorField& Cf = boundaryPatch.Cf();
        vectorField& field = *this;

        const scalar pi = constant::mathematical::pi;
        scalar x0=0.654157, z0=0.115013, d=0.004554;
        scalar umax=26.6,   fjet=138.5;
        scalar theta = 18.31163/pi;
           
        forAll(Cf, faceI)
        {
            scalar x  = Cf[faceI].x();
            scalar z  = Cf[faceI].z();
            scalar t  = this->db().time().value();

            scalar kesi  = pow( (x-x0)*(x-x0)+(z-z0)*(z-z0),0.5);
            scalar ujmag = 6*umax*( (kesi/d)-pow(kesi/d,2) )*sin(2*pi*fjet*t);
            scalar ujet  = ujmag*sin(theta);
            scalar vjet  = ujmag*cos(theta);
                
            field[faceI] = vector(ujet,0,vjet);
        }
    #};     


更多的案例：

.. code-block:: C

    inlet
    {
        type            codedFixedValue;
        value           uniform 0;
        name            codeinlet_air;
                    
        code            
        #{
            const vectorField& Cf = patch().Cf(); 

            scalarField& field = *this;

            scalar D = 0.0252;
            scalar ymax = 5.82*D; 

            forAll(Cf,faceI)
            {
                if ( Cf[faceI].y() > ymax ) 
                   {
                     field[faceI] = 1;
                   }
            }

        #};
    
    }


.. code-block:: C

    inlet
    {
        type            codedFixedValue;
        value           uniform (0 0 0);  //default value
        name            powvelocity;      //name of new BC type

        code
        #{
            const fvPatch &boundaryPatch = patch();
            const fvBoundaryMesh &boundaryMesh = boundaryPatch.boundaryMesh();
            const fvMesh &mesh = boundaryMesh.mesh();
            const fvPatchField<vector> &U = boundaryPatch.lookupPatchField<volVectorField, vector>("U");

            const vectorField FC = mesh.Cf();
            const scalarField y = FC&vector(0,1,0);
            
            vectorField U1 (U.size(), Zero);
            // const scalar pi = M_PI;
            const scalar U_0 = 0.5;
            const scalar D = 0.03;

            forAll(boundaryPatch, i)
            {
                U1[i] = vector(U_0*(pow(y[i]/D,1/7)), 0., 0.);
            }

            operator==(U1);
        #};
    }





如需要设置随时间变化的边界条件，可采用如下方法得到OF运行时间：

.. code-block:: C

    scalar t  = this->db().time().value();


添加下面的语句来解决 :code:`error: ‘mesh’ was not declared in this scope` 的问题：

.. code-block:: C

    codeOptions
    #{
    -I$(LIB_SRC)/meshTools/lnInclude
    #};









后处理
========

postProcess
-------------

可以在终端通过下面的命令查看可用的后处理方法：

.. code-block:: 

    postProcess -list

场计算
^^^^^^^^^

+-----------------------+------------------------------------------------------------------+
| functionObject        | 作用                                                             |
+=======================+==================================================================+
| CourantNo             | 输出库郎数                                                       |
+-----------------------+------------------------------------------------------------------+
| Lambda2               | 输出Lambda2                                                      |
+-----------------------+------------------------------------------------------------------+
| MachNo                | 计算马赫数                                                       |
+-----------------------+------------------------------------------------------------------+
| Peclect               | 输出Peclet数                                                     |
+-----------------------+------------------------------------------------------------------+
| Q                     | 计算速度梯度第二不变量                                           |
+-----------------------+------------------------------------------------------------------+
| R                     | 计算雷诺应力张量场                                               |
+-----------------------+------------------------------------------------------------------+
| XiReactionRate        | 写入湍流火焰速度以及反应速率体标量场                             |
+-----------------------+------------------------------------------------------------------+
| add                   | 添加场                                                           |
+-----------------------+------------------------------------------------------------------+
| components            | 写入矢量场的分量                                                 |
+-----------------------+------------------------------------------------------------------+
| ddt                   | 计算场的时间导数                                                 |
+-----------------------+------------------------------------------------------------------+
| div                   | 计算场的散度                                                     |
+-----------------------+------------------------------------------------------------------+
| enstrophy             | 计算场的涡度拟能                                                 |
+-----------------------+------------------------------------------------------------------+
| flowType              | 输出速度场类型，-1 表示有旋流；0 表示剪切流；+1 表示其他类型流动 |
+-----------------------+------------------------------------------------------------------+
| grad                  | 计算场的梯度                                                     |
+-----------------------+------------------------------------------------------------------+
| mag                   | 计算场的模                                                       |
+-----------------------+------------------------------------------------------------------+
| magSqr                | 计算场的模的平方                                                 |
+-----------------------+------------------------------------------------------------------+
| randomize             | 对场添加随机分量，扰动量可以指定                                 |
+-----------------------+------------------------------------------------------------------+
| scale                 | 对场进行缩放                                                     |
+-----------------------+------------------------------------------------------------------+
| streamFunction        | 计算网格点的流函数；计算面通量                                   |
+-----------------------+------------------------------------------------------------------+
| substract             | 从某个场中减去某个场的值                                         |
+-----------------------+------------------------------------------------------------------+
| turbulenceFields      | 计算给定的湍流场                                                 |
+-----------------------+------------------------------------------------------------------+
| turbulenceIntensity   | 计算湍流强度场                                                   |
+-----------------------+------------------------------------------------------------------+
| vorticity             | 计算涡量场，例如速度的旋度                                       |
+-----------------------+------------------------------------------------------------------+
| wallShearStress       | 计算壁面剪切力，输出体矢量场                                     |
+-----------------------+------------------------------------------------------------------+
| wallHeatFlux          | 计算壁面热通量，输出体矢量场                                     |
+-----------------------+------------------------------------------------------------------+
| wallHeatTransferCoeff | 计算边界场的壁面换热系数                                         |
+-----------------------+------------------------------------------------------------------+
| writeCellCenters      | 通过体矢量场的方式输出网格体心矢量                               |
+-----------------------+------------------------------------------------------------------+
| writeCellVolumes      | 通过体标量场的方式输出网格单元体积                               |
+-----------------------+------------------------------------------------------------------+
| writeObjects          | 输出某些特定场                                                   |
+-----------------------+------------------------------------------------------------------+
| yPlus                 | 计算湍流的 y+                                                    |
+-----------------------+------------------------------------------------------------------+


流率计算
^^^^^^^^^

+--------------------+----------------------------------------------------------------------------------+
| functionObject     | 作用                                                                             |
+====================+==================================================================================+
| flowRateFaceZone   | 计算patch特定面区域的流量。有可能是体积通量，也有可能是质量通量                  |
+--------------------+----------------------------------------------------------------------------------+
| flowRatePatch      | 计算patch的流量。有可能是体积通量，也有可能是质量通量                            |
+--------------------+----------------------------------------------------------------------------------+
| volFlowRateSurface | 计算三角面的体积通量，速度的计算采用对面表面进行插值并积分。建议三角的面积足够小 |
+--------------------+----------------------------------------------------------------------------------+


力以及力系数
^^^^^^^^^^^^^^^

+---------------------------+---------------------------------------------------------------------------+
| functionObject            | 作用                                                                      |
+===========================+===========================================================================+
| forceCoeffsCompressible   | 对于可压缩求解器，通过对某patch上的力进行加和汇总计算升力、压力、矩系数   |
+---------------------------+---------------------------------------------------------------------------+
| forceCoeffsIncompressible | 对于不可压缩求解器，通过对某patch上的力进行加和汇总计算升力、压力、矩系数 |
+---------------------------+---------------------------------------------------------------------------+
| forceCompressible         | 对于可压缩求解器，计算某patch上的压力以及粘性力                           |
+---------------------------+---------------------------------------------------------------------------+
| forceIncompressible       | 对于不可压缩求解器，计算某patch上的压力以及粘性力                         |
+---------------------------+---------------------------------------------------------------------------+

提取制图
^^^^^^^^^^

+----------------+----------------------+
| functionObject | 作用                 |
+================+======================+
| singleGraph    | 提取某一条线上的数据 |
+----------------+----------------------+

拉格朗日数据
^^^^^^^^^^^^^^^^

+----------------+------------------------------------------------------------------+
| functionObject | 作用                                                             |
+================+==================================================================+
| dsmcFields     | 从DSMC计算结果中提取UMean、translationalT、internalT以及overallT |
+----------------+------------------------------------------------------------------+


监控极值
^^^^^^^^^

+------------------+----------------------------------------------+
| functionObject   | 作用                                         |
+==================+==============================================+
| cellMax          | 对于一个或多个场，输出最大的值               |
+------------------+----------------------------------------------+
| cellMin          | 对于一个或多个场，输出最小的值               |
+------------------+----------------------------------------------+
| faceMax          | 对于一个或多个场，输出面上最大的值           |
+------------------+----------------------------------------------+
| faceMin          | 对于一个或多个场，输出面上最小的值           |
+------------------+----------------------------------------------+
| minMaxComponents | 通过非标量的形式，输出最大最小值以及位置     |
+------------------+----------------------------------------------+
| MinMaxMagnitude  | 通过非标量的形式，输出最大最小值的模以及位置 |
+------------------+----------------------------------------------+


数据格式
^^^^^^^^^^^^

+----------------+----------------------------------------------------------------------+
| functionObject | 作用                                                                 |
+================+======================================================================+
| residuals      | 对于指定场，输出每个时间步迭代的初始残差。对于矢量场，输出最大的分量 |
+----------------+----------------------------------------------------------------------+
| Time           | 写入运行时间、CPU时间、钟表时间                                      |
+----------------+----------------------------------------------------------------------+


压力工具
^^^^^^^^^^

+-----------------------------+------------------------------------+
| functionObject              | 作用                               |
+=============================+====================================+
| pressureDifferencePatch     | 计算两个patch的平均压力差          |
+-----------------------------+------------------------------------+
| pressureDifferenceSurface   | 将压力插值在三角面并计算平均压力差 |
+-----------------------------+------------------------------------+
| staticPressure              | 通过指定的密度计算动压             |
+-----------------------------+------------------------------------+
| totalPressureCompressible   | 计算可压缩求解器的总压             |
+-----------------------------+------------------------------------+
| totalPressureIncompressible | 计算不可压缩求解器的动力总压       |
+-----------------------------+------------------------------------+

探针
^^^^^^

+-----------------+----------------------------------------------------------------------------+
| functionObject  | 作用                                                                       |
+=================+============================================================================+
| boundaryCloud   | 输出场在某 patch 上指定位置的值                                            |
+-----------------+----------------------------------------------------------------------------+
| interfaceHeight | 对于一系列的点，输出界面的高度。这个高度是在这个点上，界面和壁面的垂直距离 |
+-----------------+----------------------------------------------------------------------------+
| internalCloud   | 输出场在指定位置的值                                                       |
+-----------------+----------------------------------------------------------------------------+
| Probes          | 输出场在指定位置距离最近的网格单元的值                                     |
+-----------------+----------------------------------------------------------------------------+

外挂求解器
^^^^^^^^^^^^^^^

+----------------------------+--------------------+
| functionObject             | 作用               |
+============================+====================+
| scalarTransport            | 求解标量场传输方程 |
+----------------------------+--------------------+
| icoUncoupledKinematicCloud | 求解拉格朗日粒子云 |
+----------------------------+--------------------+

可视化工具
^^^^^^^^^^^^^^

+----------------+---------------------------------+
| functionObject | 作用                            |
+================+=================================+
| streamlines    | 通过VTK格式输出流线数据         |
+----------------+---------------------------------+
| surfaces       | 通过VTK格式输出切割面、等值面等 |
+----------------+---------------------------------+




ParaView
-------------

画截面上的流线
^^^^^^^^^^^^^^^^

paraview的Stream Tracer无法直接作一个截面上的流线。比如，对于OpenFOAM的算例，即使是二维算例，截取一个面后，用 Stream tracer 无法得到流线。解决办法是存在的，本篇介绍如果通过一系列filter的组合来得到截面上的流线。

1. 作出需要查看流线的截面Slice；
2. 对上述截面添加Filters/Alphabetical/Surface Vector，让速度矢量投影到平面上；
3. 对得到的Surface Vector使用Filters/Alphabetical/Mask Points，生成一系列参考点用于绘制流线。
   
在MaskPoints中需要调节On Ratio参数以及Maximum number of points参数。其中，On Ratio控制取点的疏密，表示每多少个点中取一个；Maximum number of points控制总点数的数目；一般会勾选Random Sampling以及Generate Vertices。

4. 开启Filters/Alphabetical/Stream Tracer with Custom Source，分别选择上述的SurfaceVector作为Input，选择上述的MaskPoints作为Seed Source。
   

.. note:: 流线的疏密可以通过MaskPoints的点数量来控制，但是点数的空间分布不容易控制。





求解器代码解读
==================

createTime.H
--------------

.. code-block:: C

    Foam::Info<< "Create time\n" << Foam::endl;              // 打印信息，提示开始创建时间对象

    Foam::Time runTime(Foam::Time::controlDictName, args);   // 在Time这个类下面创建一个runTime对象


createMesh.H
----------------

.. code-block:: C

    Foam::Info
        << "Create mesh for time = "
        << runTime.timeName() << Foam::nl << Foam::endl;   // 打印信息，提示开始创建网格对象

    Foam::fvMesh mesh      // 在fvMesh这个类下面创建一个mesh对象
    (
        Foam::IOobject
        (
            Foam::fvMesh::defaultRegion,
            runTime.timeName(),
            runTime,
            Foam::IOobject::MUST_READ
        )
    );




createPhi.H
---------------

这里给出的是位于src/finiteVolume/lnInclude下的createPhi.H文件内容，部分求解器可能会使用其他文件，可以通过求解器对应的Make/options文件来确认读取的哪个createPhi.H文件。

里面核心的计算步骤为 :code:`fvc::flux(U)` ，相当于 :code:`fvc::interpolate(U) & mesh.Sf()` ，即

.. math::
    \begin{align}
    \phi = \mathbf{U}_{f}\cdot \mathbf{S}_{f}
    \end{align}

.. code-block:: C

    Info<< "Reading/calculating face flux field phi\n" << endl;

    surfaceScalarField phi    // 创建定义在网格面中心的标量场-流量场phi
    (
        IOobject    // 通过IOobject读取phi文件
        (
            "phi",
            runTime.timeName(),           // 存在于时间文件夹下
            mesh,
            IOobject::READ_IF_PRESENT,    // 如果已经存在则进行读取，否则需要计算
            IOobject::AUTO_WRITE          // 会自动进行输出
        ),
        fvc::flux(U)    // 速度矢量与面矢量点乘，速度矢量插值到面上的过程与fvSchemes设置相关
    );





laplacianFoam求解器
---------------------

laplacianFoam的createFields.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    Info<< "Reading field T\n" << endl;

    volScalarField T    // 定义在网格体中心的标量场T
    (
        IOobject
        (
            "T",                      // 场的名称(T),用于确定初始文件名称(T)以及变量名称(T)
            runTime.timeName(),       // 存储位置为运行时间(文件夹)
            mesh,                     // 注册于网格对象mesh中
            IOobject::MUST_READ,      // 该对象通过读取文件创建,必须进行读取
            IOobject::AUTO_WRITE      // 根据controlDict中的设置自动写入结果文件
        ),
        mesh    // 新建体心标量场(T)所用的网格对象,在createMesh.H创建
    );


    Info<< "Reading physicalProperties\n" << endl;

    // IOdictionary用于新建字典文件
    IOdictionary physicalProperties    // 参数控制文件声明通过文件physicalProperties读取
    (
        IOobject
        (
            "physicalProperties",                // 文件名
            runTime.constant(),                  // 文件位置，位于$case/constant
            mesh,                                // 网格对象，主要从事对象注册，以便由runTime.write()控制输出
            IOobject::MUST_READ_IF_MODIFIED,     // 在字典文件被更改的时候进行读取
            IOobject::NO_WRITE                   // 不输出，字典文件不需要输出
        )
    );


    Info<< "Reading diffusivity DT\n" << endl;

    // dimensionedScalar用于新建带单位标量，新建扩散率DT。因为各向同性，DT为常数
    dimensionedScalar DT
    (
        // 通过查询参数控制文件$case/constant/physicalProperties，初始化带单位标量
        // 查询关键字DT并读取
        physicalProperties.lookup("DT")
    );

    #include "createFvModels.H"
    #include "createFvConstraints.H"


laplacianFoam.C
^^^^^^^^^^^^^^^^^


laplacianFoam求解器用于求解热传递温度控制方程：

.. math::
    \begin{align}
    \frac{\partial T}{\partial t} - \nabla^{2}(D_{T}T) = 0 
    \end{align}

其中 :math:`T` 表示温度， :math:`t` 表示时间， :math:`D_{T}` 为热扩散系数，具体表达式为

.. math::
    \begin{align}
    D_{T} = \frac{k}{\rho C_{p}} 
    \end{align}

其中 :math:`k` 表示热传导系数， :math:`\rho` 为密度， :math:`C_{p}` 为比热容。

.. code-block:: C

    #include "fvCFD.H"            // 必备头文件。涉及到时间构建、矩阵组建、有限体积离散、网格组建、量纲设置等
    #include "fvModels.H"
    #include "fvConstraints.H"
    #include "simpleControl.H"    // 定义SIMPLE循环，使用SIMPLE循环必备头文件

    int main(int argc, char *argv[])
    {
        #include "setRootCaseLists.H"    // 必备头文件。根据输入参数argc和argv设置算例根目录rootcase

        #include "createTime.H"          // 创建时间对象，涉及到runTime控制。非定常求解器必备头文件
        #include "createMesh.H"          // 必备头文件。创建网格对象，根据$case/constant/polyMesh文件夹中的网格数据创建对象mesh

        simpleControl simple(mesh);      // 从网格mesh对象构造类simpleControl(基类:solutionControl)的对象simple

        #include "createFields.H"        // 创建场对象，位于求解器根目录

        Info<< "\nCalculating temperature distribution\n" << endl;

        while (simple.loop(runTime))    // 开始时间循环，采用SIMPLE算法必备语句
        {
            Info<< "Time = " << runTime.userTimeName() << nl << endl;

            fvModels.correct();
            
            // 是否进行非正交修正
            // 如果在fvSolution字典文件中设置为0就只求解控制方程一次，如果设置为n则求解控制方程n-1次
            while (simple.correctNonOrthogonal())
            {
                
                fvScalarMatrix TEqn    // 定义热传递温度控制方程
                (
                    fvm::ddt(T) - fvm::laplacian(DT, T)    // fvm表示隐式离散,返回有限体积稀疏矩阵类fvMatrix对象
                 ==                                        // fvMatrix的==操作符执行优先级最低。先将==左右的各项相加，最后执行==。而==操作符被重载了，实际上是-
                    fvModels.source(T)    // 源项
                );

                fvConstraints.constrain(TEqn);
                TEqn.solve();    // 求解方程。solve是FOAM名称空间的全局函数,参数为矩阵fvMatrix
                fvConstraints.constrain(T);
            }

            #include "write.H"    // 额外计算grad(T)并进行输出

            Info<< "ExecutionTime = " << runTime.elapsedCpuTime() << " s"
                << "  ClockTime = " << runTime.elapsedClockTime() << " s"
                << nl << endl;
        }

        Info<< "End\n" << endl;

        return 0;
    }


laplacianFoam的write.H
^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    if (runTime.writeTime())    // 当运行时间步到达输出时间的时候执行下面的内容
    {
        volVectorField gradT(fvc::grad(T));    // 计算T的梯度，结果是定义在网格体中心的向量场。fvc::grad显示离散计算能够直接得到结果

        volScalarField gradTx    // 定义在网格体中心的标量场gradTx
        (
            IOobject
            (
                "gradTx",
                runTime.timeName(),     // 位于时间文件夹
                mesh,
                IOobject::NO_READ,      // 不进行读取
                IOobject::AUTO_WRITE    // 到达输出时间步时自动进行输出
            ),
            gradT.component(vector::X)    // 取计算得到的gradT的x分量赋值给gradTx
        );

        volScalarField gradTy    // 定义在网格体中心的标量场gradTy
        (
            IOobject
            (
                "gradTy",
                runTime.timeName(),     // 位于时间文件夹
                mesh,
                IOobject::NO_READ,      // 不进行读取
                IOobject::AUTO_WRITE    // 到达输出时间步时自动进行输出
            ),
            gradT.component(vector::Y)    // 取计算得到的gradT的y分量赋值给gradTy
        );

        volScalarField gradTz    // 定义在网格体中心的标量场gradTz
        (
            IOobject
            (
                "gradTz",
                runTime.timeName(),     // 位于时间文件夹
                mesh,
                IOobject::NO_READ,      // 不进行读取
                IOobject::AUTO_WRITE    // 到达输出时间步时自动进行输出
            ),
            gradT.component(vector::Z)    // 取计算得到的gradT的z分量赋值给gradTz
        );


        runTime.write();    // 输出计算结果
    }



scalarTransportFoam求解器
---------------------------


scalarTransportFoam的createFields.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    Info<< "Reading field T\n" << endl;

    volScalarField T    // 定义在网格体中心的标量场T
    (
        IOobject
        (
            "T",
            runTime.timeName(),     // 位于时间文件夹
            mesh,
            IOobject::MUST_READ,    // 必须读取
            IOobject::AUTO_WRITE    // 根据controlDict设置自动输出
        ),
        mesh
    );


    Info<< "Reading field U\n" << endl;

    volVectorField U
    (
        IOobject
        (
            "U",
            runTime.timeName(),     // 位于时间文件夹
            mesh,
            IOobject::MUST_READ,    // 必须读取
            IOobject::AUTO_WRITE    // 根据controlDict设置自动输出
        ),
        mesh
    );


    Info<< "Reading physicalProperties\n" << endl;

    IOdictionary physicalProperties    // 创建physicalProperties
    (
        IOobject
        (
            "physicalProperties",               // 读取physicalProperties文件
            runTime.constant(),                 // 位于constant文件夹
            mesh,
            IOobject::MUST_READ_IF_MODIFIED,    // 修改后必须读取
            IOobject::NO_WRITE                  // 不进行输出
        )
    );


    Info<< "Reading diffusivity DT\n" << endl;

    dimensionedScalar DT    // 创建标量DT
    (
        physicalProperties.lookup("DT")    // 从physicalProperties文件中读取DT关键词的值
    );

    #include "createPhi.H"    // 创建通量场

    #include "createFvModels.H"
    #include "createFvConstraints.H"




scalarTransportFoam.C
^^^^^^^^^^^^^^^^^^^^^^^^^^

最基本的控制方程为

.. math::
    \begin{align}
        \frac{\partial (\rho T)}{\partial t} 
      + \nabla \cdot (\rho \mathbf{U}T) 
    =   \nabla \cdot (\Gamma \nabla T)
      + Q
    \end{align}

scalarTransportFoam处理的是 :math:`\rho` 和 :math:`\Gamma` 为常量的情况，因此上述方程可以简化为

.. math::
    \begin{align}
    \frac{\partial T}{\partial T} + \nabla \cdot (\mathbf{U}T) = \nabla \cdot (D_{T}\nabla T) + q
    \end{align}

其中 :math:`D_{T}=\frac{\Gamma}{\rho}` ， :math:`q = \frac{Q}{\rho}` 。


.. code-block:: C

    #include "fvCFD.H"
    #include "fvModels.H"
    #include "fvConstraints.H"
    #include "simpleControl.H"    // 使用SIMPLE算法必备头文件

    int main(int argc, char *argv[])
    {
        #include "setRootCaseLists.H"
        #include "createTime.H"
        #include "createMesh.H"

        simpleControl simple(mesh);

        #include "createFields.H"    // 创建场信息

        Info<< "\nCalculating scalar transport\n" << endl;

        #include "CourantNo.H"

        while (simple.loop(runTime))    // 开始SIMPLE算法循环
        {
            Info<< "Time = " << runTime.userTimeName() << nl << endl;

            fvModels.correct();

            while (simple.correctNonOrthogonal())
            {
                fvScalarMatrix TEqn    // 标量传输方程
                (
                    fvm::ddt(T)              // 非稳态项
                  + fvm::div(phi, T)         // 对流项
                  - fvm::laplacian(DT, T)    // 扩散项
                 ==
                    fvModels.source(T)       // 源项
                );

                TEqn.relax();
                fvConstraints.constrain(TEqn);
                TEqn.solve();    // 求解标量传输方程
                fvConstraints.constrain(T);
            }

            runTime.write();
        }

        Info<< "End\n" << endl;

        return 0;
    }




potentialFoam求解器
---------------------


potentialFoam的createFields.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    Info<< "Reading velocity field U\n" << endl;
    volVectorField U    // 定义在网格体中心的矢量场U
    (
        IOobject
        (
            "U",
            runTime.timeName(),     // 位于时间文件夹
            mesh,
            IOobject::MUST_READ,    // 必须读取
            IOobject::AUTO_WRITE    // 根据controlDict设置自动输出
        ),
        mesh
    );

    U = Zero;

    surfaceScalarField phi    // 定义在网格面中心的标量场phi
    (
        IOobject
        (
            "phi",
            runTime.timeName(),     // 位于时间文件夹
            mesh,
            IOobject::NO_READ,      // 不进行读取
            IOobject::AUTO_WRITE    // 根据controlDict设置自动输出
        ),
        fvc::flux(U)    // 速度场插值到网格面上后点乘面矢量得到通量
    );

    if (args.optionFound("initialiseUBCs"))
    {
        U.correctBoundaryConditions();
        phi = fvc::flux(U);
    }


    // Default name for the pressure field
    word pName("p");    // 使用pName关键字来表示p，只起到替换作用

    // Update name of the pressure field from the command-line option
    args.optionReadIfPresent("pName", pName);

    // Infer the pressure BCs from the velocity
    wordList pBCTypes
    (
        U.boundaryField().size(),
        fixedValueFvPatchScalarField::typeName
    );

    forAll(U.boundaryField(), patchi)
    {
        if (U.boundaryField()[patchi].fixesValue())
        {
            pBCTypes[patchi] = zeroGradientFvPatchScalarField::typeName;
        }
    }

    Info<< "Constructing pressure field " << pName << nl << endl;
    volScalarField p    // 定义在体中心的标量场p
    (
        IOobject
        (
            pName,
            runTime.timeName(),           // 处于时间文件夹
            mesh,
            IOobject::READ_IF_PRESENT,    // 如果存在则进行读取
            IOobject::NO_WRITE            // 不进行输出
        ),
        mesh,
        dimensionedScalar(pName, sqr(dimVelocity), 0),
        pBCTypes
    );

    // Infer the velocity potential BCs from the pressure
    wordList PhiBCTypes
    (
        p.boundaryField().size(),
        zeroGradientFvPatchScalarField::typeName
    );

    forAll(p.boundaryField(), patchi)
    {
        if (p.boundaryField()[patchi].fixesValue())
        {
            PhiBCTypes[patchi] = fixedValueFvPatchScalarField::typeName;
        }
    }

    Info<< "Constructing velocity potential field Phi\n" << endl;
    volScalarField Phi    // 定义在网格体中心的标量场，速度势场Phi
    (
        IOobject
        (
            "Phi",
            runTime.timeName(),           // 处于时间文件夹
            mesh,
            IOobject::READ_IF_PRESENT,    // 如果存在则读取
            IOobject::NO_WRITE            // 不进行读取
        ),
        mesh,
        dimensionedScalar(dimLength*dimVelocity, 0),
        PhiBCTypes
    );

    label PhiRefCell = 0;      // 初始化速度势流参考网格标签
    scalar PhiRefValue = 0;    // 初始化速度势流参考值
    setRefCell
    (
        Phi,
        potentialFlow.dict(),    // 读取potentialFlow子字典
        PhiRefCell,              // 设置速度势流参考网格标签
        PhiRefValue              // 设置速度势流参考值
    );
    mesh.schemes().setFluxRequired(Phi.name());

    #include "createMRF.H"




potentialFoam.C
^^^^^^^^^^^^^^^^^^^

首先有稳态不可压缩流体连续性方程：

.. math::
    \begin{align}
    \nabla \cdot \mathbf{U} = 0
    \end{align}

对于无粘无旋流，则必定存在一个势函数 :math:`\Phi` 使得(速度势与压力同向)

.. math::
    \begin{align}
    -\nabla \cdot \Phi = \mathbf{U}
    \end{align}

将上式代入连续性方程得到

.. math::
    \begin{align}
    -\nabla \cdot (\nabla \Phi) = \nabla \cdot \mathbf{U}
    \end{align}

该方程的离散形式为：

.. math::
    \begin{align}
    -\sum(\nabla \Phi)_{f}\cdot \mathbf{S}_{f} = \sum\mathbf{U}_{f}\cdot \mathbf{S}_{f} = \sum\phi_{f}
    \end{align}


.. attention:: 

    之所以没有直接考虑 :math:`-\nabla \cdot (\nabla \Phi)=0` 是因为这个方程离散后得到 :math:`-\sum(\nabla \Phi)_{f}\cdot \mathbf{S}_{f}=0` ，无法考虑速度边界条件的影响。而由于速度边界条件很可能不等于零，所以不能采用这个方程。

求解流程可以分为以下几步：

- 首先针对计算域，将初始化的 :math:`\mathbf{U}` 内部场设置为0，保证 :math:`\sum\phi_{f}` 在内部场为零。 :math:`\mathbf{U}` 的边界场需要自己给定，且不为零。
- 求解一次所离散的方程，获得 :math:`\Phi` 场。
- 对于内部场，由于 :math:`\sum\phi_{f}=0` ，因此在内部场有 :math:`\phi_{f} = -(\nabla \Phi)_{f}\cdot \mathbf{S}_{f}` 。
- 对于边界场，如果是固定值边界条件，那么 :math:`\sum\phi_{f}` 通过速度计算而来，为一个固定值；如果是零法向梯度边界，边界处有 :math:`\phi_{f} = -(\nabla \Phi)_{f}\cdot \mathbf{S}_{f}` 。
- 获得 :math:`\phi_{f}` 场后可以重组得到速度场 :math:`\mathbf{U}` 。
  
.. note:: 

    同时，在求解所离散的方程的时候，需要边界条件。速度的边界条件通常自行给定。 :math:`\Phi` 的边界条件在进口，因为已经给定速度，因此要给定零法向梯度边界条件。

.. code-block:: C

    #include "fvCFD.H"
    #include "nonOrthogonalSolutionControl.H"

    int main(int argc, char *argv[])
    {
        argList::addOption
        (
            "pName",
            "pName",
            "Name of the pressure field"
        );

        argList::addBoolOption
        (
            "initialiseUBCs",
            "Initialise U boundary conditions"
        );

        argList::addBoolOption
        (
            "writePhi",
            "Write the velocity potential field"
        );

        argList::addBoolOption
        (
            "writep",
            "Calculate and write the pressure field"
        );

        argList::addBoolOption
        (
            "withFunctionObjects",
            "execute functionObjects"
        );

        #include "setRootCaseLists.H"
        #include "createTime.H"
        #include "createMesh.H"

        nonOrthogonalSolutionControl potentialFlow(mesh, "potentialFlow");

        #include "createFields.H"    // 创建场信息

        Info<< nl << "Calculating potential flow" << endl;

        // Since solver contains no time loop it would never execute
        // function objects so do it ourselves
        runTime.functionObjects().start();    // 启动求解

        MRF.makeRelative(phi);
        adjustPhi(phi, U, p);

        // Non-orthogonal velocity potential corrector loop
        while (potentialFlow.correctNonOrthogonal())
        {
            fvScalarMatrix PhiEqn    // 势流方程
            (
                fvm::laplacian(dimensionedScalar(dimless, 1), Phi)    // 势流拉普拉斯项
             ==
                fvc::div(phi)    // 速度梯度项
            );

            PhiEqn.setReference(PhiRefCell, PhiRefValue);    // 设置势流参考网格和参考值
            PhiEqn.solve();    // 求解势流方程得到Phi

            if (potentialFlow.finalNonOrthogonalIter())
            {
                phi -= PhiEqn.flux();    // 通过速度势流得到通量
            }
        }

        Info<< "Continuity error = "
            << mag(fvc::div(phi))().weightedAverage(mesh.V()).value()
            << endl;

        U = fvc::reconstruct(MRF.absolute(phi));    // 通过通量重组出速度场
        U.correctBoundaryConditions();

        Info<< "Interpolated velocity error = "
            << (
                    sqrt(sum(sqr(fvc::flux(U) - MRF.absolute(phi))))
                   /sum(mesh.magSf())
               ).value()
            << endl;

        // Write U and phi
        U.write();      // 输出速度场
        phi.write();    // 输出通量场

        // Optionally write Phi
        if (args.optionFound("writePhi"))    // 如果设置了writePhi
        {
            Phi.write();    // 输出速度势流场
        }

        // Calculate the pressure field
        if (args.optionFound("writep"))    // 如果设置了writep则要计算压力场
        {
            Info<< nl << "Calculating approximate pressure field" << endl;

            label pRefCell = 0;        // 初始化压力参考网格标签
            scalar pRefValue = 0.0;    // 初始化压力参考值
            setRefCell
            (
                p,
                potentialFlow.dict(),    // 读取potentialFlow子字典
                pRefCell,                // 设置压力参考网格标签
                pRefValue                // 设置压力参考值
            );

            // Calculate the flow-direction filter tensor
            /* 计算速度场模长的平方值 |U|^{2} ，是定义在网格体中心的标量场 */
            volScalarField magSqrU(magSqr(U));

            /* 定义在网格体中心的对称张量场
               F为流向滤波张量，表示为 U^{2} / |U|^{2}
               small是一个极小数1.0e-6，用来避免除数为零 */
            volSymmTensorField F(sqr(U)/(magSqrU + small*average(magSqrU)));

            // Calculate the divergence of the flow-direction filtered div(U*U)
            // Filtering with the flow-direction generates a more reasonable
            // pressure distribution in regions of high velocity gradient in the
            // direction of the flow
            /*
               在流动方向的高速度梯度区域，按流动方向进行过滤，可使压力分布更加合理
            */
            volScalarField divDivUU    // 滤波后流向的散度，是定义在网格体中心的标量场
            (
                /*
                   \nabla \cdot (\frac{U^{2}}{|U|^{2}} \cdot \nabla \cdot (UU))
                */
                fvc::div
                (
                    F & fvc::div(phi, U),
                    "div(div(phi,U))"
                )
            );

            // Solve a Poisson equation for the approximate pressure
            while (potentialFlow.correctNonOrthogonal())
            {
                fvScalarMatrix pEqn    // 压力泊松方程，属于标量方程
                (
                    /*
                       \nabla^{2} p + \nabla \cdot (\frac{U^{2}}{|U|^{2}} \cdot \nabla \cdot (UU))
                    */
                    fvm::laplacian(p) + divDivUU
                );

                pEqn.setReference(pRefCell, pRefValue);    // 设置压力参考网格和参考值
                pEqn.solve();    // 求解压力泊松方程得到估计压力场
            }

            p.write();    // 输出压力场
        }

        runTime.functionObjects().end();    // 结束求解

        Info<< "ExecutionTime = " << runTime.elapsedCpuTime() << " s"
            << "  ClockTime = " << runTime.elapsedClockTime() << " s"
            << nl << endl;

        Info<< "End\n" << endl;

        return 0;
    }



potentialFoam的createControls.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

在求解器目录中还存在这个头文件，但是在potentialFoam.C中并没有调用。

.. code-block:: C

    const dictionary& potentialFlow
    (
        mesh.solution().dict().subDict("potentialFlow")
    );

    const int nNonOrthCorr
    (
        potentialFlow.lookupOrDefault<int>("nNonOrthogonalCorrectors", 0)
    );





icoFoam求解器
----------------


icoFoam的createFields.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    // 在此之前已经创建了runTime和mesh对象，可以直接使用runTime和mesh进行操作
    Info<< "Reading physicalProperties\n" << endl;      // 打印信息，提示要读取physicalProperties这个文件

    IOdictionary physicalProperties    // 创建physicalProperties对象
    (
        IOobject     // 通过IOobject读取physicalProperties文件内的信息
        (
            "physicalProperties",
            runTime.constant(),                   // 存在于constant文件夹下
            mesh,
            IOobject::MUST_READ_IF_MODIFIED,
            IOobject::NO_WRITE                    // 位于constant文件夹内的属性不进行输出
        )
    );

    dimensionedScalar nu    // 创建有量纲标量场-动力粘度场nu
    (
        "nu",                                           
        dimViscosity,
        physicalProperties.lookup("nu")    // 通过读取关键词nu的值进行创建
    );

    Info<< "Reading field p\n" << endl;
    volScalarField p    // 创建定义在网格体中心的标量场-压力场p
    (
        IOobject    // 通过IOobject读取p文件内的信息
        (
            "p",
            runTime.timeName(),     // 存在于时间文件夹下
            mesh,
            IOobject::MUST_READ,    // 必须进行读取
            IOobject::AUTO_WRITE    // 会自动进行输出
        ),
        mesh
    );


    Info<< "Reading field U\n" << endl;
    volVectorField U    // 创建定义在网格体中心的矢量场-速度场U
    (
        IOobject    // 通过IOobject读取U文件内的信息
        (
            "U",
            runTime.timeName(),     // 存在于时间文件夹下
            mesh,
            IOobject::MUST_READ,    // 必须进行读取
            IOobject::AUTO_WRITE    // 会自动进行输出
        ),
        mesh
    );


    #include "createPhi.H"    // 创建面通量场phi


    label pRefCell = 0;         // 标定网格参考的编号，首先初始化为了0
    scalar pRefValue = 0.0;     // 标定网格的参考值，首先初始化为了0。不可压缩流有意义的是参考压力值
    // 进入fvSolution文件查找PISP子字典，读取其中的pRefCell与pRefValue的值并进行更新
    setRefCell(p, mesh.solution().dict().subDict("PISO"), pRefCell, pRefValue);
    mesh.schemes().setFluxRequired(p.name());






icoFoam.C
^^^^^^^^^^^^^^^

icoFoam的控制方程有两个：

.. math::
    \begin{align}
    \nabla \cdot \mathbf{U} = 0
    \end{align}

.. math::
    \begin{align}
    \frac{\partial \mathbf{U}}{\partial t} + \nabla\cdot\mathbf{U}\mathbf{U} - \nabla\cdot[\nu(\nabla\mathbf{U})] = -\nabla p
    \end{align}

其中第二个方程等号左边的式子的每一项进行隐式离散后将会得到一系列线性方程组 :math:`A` ，通常可以写为 :math:`A_{A}\mathbf{U}=A_{S}` 。 :math:`A_{A}` 这一个矩阵的结构可以进一步划分：记它的主对角线矩阵为 :math:`A_{D}` ，非主对角线的部分记为 :math:`A_{N}` 。从而可以定义出一个H运算： :math:`A_{H} = A_{S} - A_{N}\mathbf{U} = A_{D}\mathbf{U}` 。于是，离散后的动量方程有下面这样的形式：

.. math::
    \begin{align}
    A_{A}\mathbf{U} = A_{D}\mathbf{U} + A_{N}\mathbf{U} = A_{S} - \nabla p
    \end{align}

引入H运算符之后可以进一步改写成

.. math::
    \begin{align}
    A_{D}\mathbf{U} = A_{H} - \nabla p
    \end{align}

于是速度场可以重新表示为

.. math::
    \begin{align}
    \mathbf{U} = \frac{A_{H}}{A_{D}} - \frac{\nabla p}{A_{D}}  
    \end{align}

根据速度场散度为零可以重新得到一个关于压力场的方程：

.. math::
    \begin{align}
    \nabla \cdot \left ( \frac{\nabla p}{A_{D}} \right ) = \nabla \cdot \left ( \frac{A_{H}}{A_{D}} \right ) 
    \end{align}

对上述压力方程进行求解，我们就能得到一个满足连续性条件的通量：

.. math::
    \begin{align}
    \phi &= \left ( \frac{A_{H}}{A_{D}} \right )_{f} \cdot \mathbf{S}_{f} 
           - |\mathbf{S}_{f}| \cdot \left ( \left ( \frac{1}{A_{D}} \right )_{f} \nabla_{f}^{\perp}p \right )  \\
         &= \phi^{*} - \phi^{**}
    \end{align}

.. note:: 

    在OpenFOAM中的通量计算有一点不同，主要差别在于 :math:`\phi^{*}` 被定义为了 :math:`\left ( \frac{A_{H}}{A_{D}} \right )_{f} \cdot \mathbf{S}_{f} + \phi_{e}` ，其中添加的 :math:`\phi_{e}` 为

    .. math::
        \begin{align}
        \phi_{e} = \frac{\gamma \rho}{A_{D}\Delta t}(\phi_{0}-\mathbf{S}_{f}\cdot\mathbf{U}_{f,0})
        \end{align}

    而 :math:`\gamma` 参数具体含义为

    .. math::
        \begin{align}
        \gamma = 1- \min\left ( \frac{|\phi_{0}-\mathbf{U}_{f,0}|\cdot\mathbf{S}_{f}}{|\phi_{0}|+\varepsilon},1  \right ) 
        \end{align}

icoFoam使用PISO算法求解NS方程，基本的步骤如下：

1. 根据初始条件(压力场、速度场等)求解预测速度场；
2. 根据预测速度求无压力梯度项的速度场；
3. 根据无压力梯度项的速度场求解压力(泊松)方程，得到压力场；
4. 根据压力场修正预测速度场以满足连续性方程；
5. 返回第二步，循环直到满足收敛要求。




.. note:: 

    - 使用 :code:`UEqn` 表示 :math:`\frac{\partial \mathbf{U}}{\partial t} + \nabla\cdot\mathbf{U}\mathbf{U} - \nabla\cdot[\nu(\nabla\mathbf{U})]` ；
    - 使用 :code:`rAU` 表示 :math:`\frac{1}{A_{D}}` ；
    - 使用 :code:`rAUf` 表示 :math:`\left ( \frac{1}{A_{D}}\right )_{f}` ；
    - 使用 :code:`HbyA` 表示 :math:`\frac{A_{H}}{A_{D}}` ；
    - 使用 :code:`phiHbyA` 表示 :math:`\left ( \frac{A_{H}}{A_{D}}\right )_{f}\cdot \mathbf{S}_{f} + \phi_{e}` ；
    - 使用 :code:`pEqn` 表示 :math:`\nabla \cdot ( \frac{\nabla[p]}{A_{D}} ) = \nabla \cdot (\frac{A_{H}}{A_{D}})` ；
    - 使用 :code:`pEqn.flux()` 表示 :math:`\phi^{**}` ；


.. code-block:: C

    #include "fvCFD.H"
    #include "pisoControl.H"    // 包含参数nCorrPiso_来记录PISO压力修正的次数，
                                // 通过system/fvSolution中PISO字典中的nCorrectors关键词来指定。

    int main(int argc, char *argv[])
    {
        #include "setRootCaseLists.H"     // 用于检查算例文件的结构是否正确
        #include "createTime.H"           // 创建runTime时间对象
        #include "createMesh.H"           // 创建mesh网格对象

        pisoControl piso(mesh);

        #include "createFields.H"         // 对场量进行初始化
        #include "initContinuityErrs.H"


        Info<< "\nStarting time loop\n" << endl;

        while (runTime.loop())
        {
            Info<< "Time = " << runTime.userTimeName() << nl << endl;

            #include "CourantNo.H"

            // Momentum predictor

            fvVectorMatrix UEqn    // 创建了一个关于U的式子(U方程)，即动量方程等号左边的部分
            (
            /*
               \frac{\partial \mathbf{U}}{\partial t} + \nabla \cdot \mathbf{U}\mathbf{U} - \nabla \cdot [ \nu (\nabla\mathbf{U}) ]
            */
                fvm::ddt(U)              // 隐式离散时间导数项
              + fvm::div(phi, U)         // 隐式离散对流项
              - fvm::laplacian(nu, U)    // 隐式离散扩散项
            );

            if (piso.momentumPredictor())        // 根据fvSolution中momentumPredictor的赋值判断是否求解，默认值是yes
            {
                // 求解动量方程，使用上一步的压力场，得到预测速度场
                solve(UEqn == -fvc::grad(p));    // 显式离散压强梯度项
            }

            // --- PISO loop
            while (piso.correct())
            {
                /* 创建一个定义在体中心的标量场rAU，UEqn.A()进行了A运算，返回的是A_{D}，
                   因此rAU实际上是1/A_{D}。*/
                volScalarField rAU(1.0/UEqn.A()); 

                /* 创建一个定义在体中心的向量场HbyA，UEqn.H()进行了H运算返回的是A_{H}，
                   因此HbyA实际上是A_{H}/A_{D}，constrainHbyA函数将U固定值边界条件赋给HbyA。 */
                volVectorField HbyA(constrainHbyA(rAU*UEqn.H(), U, p)); 

                surfaceScalarField phiHbyA    // 创建一个定义在面中心的标量场，这是一个中间通量\phi^{*}
                (
                    /*
                       (A_{H}/A_{D})_{f} \cdot \mathbf{S}_{f} + \phi_{e}
                    */
                    "phiHbyA",
                    fvc::flux(HbyA)                               // 将HbyA差分到面上，并点乘面矢量
                  + fvc::interpolate(rAU)*fvc::ddtCorr(U, phi)    // 这一项是OpenFOAM自己添加的项 \phi_{e}
                );

                /* 确保整个区域的净通量为0，即流入等于流出，
                   函数先统计流入和流出的量，如果两者不相等，那么调整速度assignable边界，
                   通过改动边界上的值使得整个体系通量守恒。
                   也就是要修正压力边界（梯度为0）上的phi，使其满足连续性方程。 */
                adjustPhi(phiHbyA, U, p);

                // Update the pressure BCs to ensure flux consistency
                constrainPressure(p, U, phiHbyA, rAU);    // 用于修正fixedFluxPressure类压力边界条件

                // Non-orthogonal pressure corrector loop
                while (piso.correctNonOrthogonal())
                {
                    // Pressure corrector

                    fvScalarMatrix pEqn    // 定义一个p方程
                    (
                        /* 方程等号左边使用隐式离散，方程等号右边使用显式离散
                           \nabla \cdot ( \frac{\nabla[p]}{A_{D}} ) = \nabla \cdot (\frac{A_{H}}{A_{D}})
                        */
                        fvm::laplacian(rAU, p) == fvc::div(phiHbyA)
                    );

                    pEqn.setReference(pRefCell, pRefValue);    // 设置压力参考值

                    pEqn.solve();    // 求解上述p方程，可以得到p的值

                    if (piso.finalNonOrthogonalIter())    // 非正交修正的总迭代残差
                    {
                        /* 更新通量，即 \phi = \phi^{*} - \phi^{**}，其中pEqn.flux()返回的\phi^{**}为：
                           |\mathbf{S}_{f}| \cdot ( (\frac{1}{A_{D}})_{f} \nabla_{f}^{\perp}p )
                           最终得到统一的、能够满足连续性方程的通量  */
                        phi = phiHbyA - pEqn.flux();
                    }
                }

                #include "continuityErrs.H"

                /* 使用求解出的压力场反过来求解出最终正确的速度场，即
                   \mathbf{U} = \frac{A_{H}}{A_{D}} - \frac{\nabla p}{A_{D}}
                */
                U = HbyA - rAU*fvc::grad(p);

                /* 上述隐式求解过程中U的边界条件不会参与，调用该函数之后才得到边界值，
                   该函数的主要作用是将GeometricField中的变量及时更新，
                   通常会在每一时间步的结束时刻调用一次，多次调用也不会出错。 */
                U.correctBoundaryConditions();
            }

            runTime.write();    // 输出时间

            Info<< "ExecutionTime = " << runTime.elapsedCpuTime() << " s"
                << "  ClockTime = " << runTime.elapsedClockTime() << " s"
                << nl << endl;
        }

        Info<< "End\n" << endl;

        return 0;
    }


.. note:: 

    更新通量phi采用 :code:`phi = phiHbyA - pEqn.flux()` 的方法，而不是在求解出正确速度场之后通过 :code:`phi = fvc::flux(U)` 来更新，这样可以保证通量phi是严格守恒的。由于U不存在守恒的概念，即使是通过正确的U插值求解通量也不能保证一定守恒。






pisoFoam求解器
------------------

pisoFoam的createFields.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    Info<< "Reading field p\n" << endl;
    volScalarField p    // 创建定义在网格体中心的标量场-压力场p
    (
        IOobject    // 通过IOobject读取p文件内的信息
        (
            "p",
            runTime.timeName(),     // 存在于时间文件夹下
            mesh,
            IOobject::MUST_READ,    // 必须进行读取
            IOobject::AUTO_WRITE    // 会自动进行输出
        ),
        mesh
    );

    Info<< "Reading field U\n" << endl;
    volVectorField U    // 创建定义在网格体中心的矢量场-速度场U
    (
        IOobject    // 通过IOobject读取U文件内的信息
        (
            "U",
            runTime.timeName(),     // 存在于时间文件夹下
            mesh,
            IOobject::MUST_READ,    // 必须读取
            IOobject::AUTO_WRITE    // 会自动进行输出
        ),
        mesh
    );

    #include "createPhi.H"    // 创建面通量场phi


    pressureReference pressureReference(p, piso.dict());

    mesh.schemes().setFluxRequired(p.name());

    // autoPtr是一个智能指针，不需要用户考虑内存释放等问题
    autoPtr<viscosityModel> viscosity(viscosityModel::New(mesh));    // 创建一个viscosity指针

    autoPtr<incompressible::momentumTransportModel> turbulence    // 创建一个turbulence指针
    (
        incompressible::momentumTransportModel::New(U, phi, viscosity)
    );

    #include "createMRF.H"
    #include "createFvModels.H"
    #include "createFvConstraints.H"


pisoFoam.C
^^^^^^^^^^^^^^

.. code-block:: C

    #include "fvCFD.H"
    #include "viscosityModel.H"
    #include "incompressibleMomentumTransportModels.H"   // 引入湍流模型
    #include "pisoControl.H"
    #include "pressureReference.H"
    #include "fvModels.H"
    #include "fvConstraints.H"

    int main(int argc, char *argv[])
    {
        #include "postProcess.H"

        #include "setRootCaseLists.H"
        #include "createTime.H"
        #include "createMesh.H"
        #include "createControl.H"
        #include "createFields.H"          // 创建场信息与粘度湍流指针
        #include "initContinuityErrs.H"    //定义标量的连续性误差为0

        turbulence->validate();

        Info<< "\nStarting time loop\n" << endl;

        while (runTime.loop())
        {
            Info<< "Time = " << runTime.userTimeName() << nl << endl;

            #include "CourantNo.H"

            // Pressure-velocity PISO corrector
            {
                fvModels.correct();

                #include "UEqn.H"    // 求解速度场

                // --- PISO loop
                while (piso.correct())
                {
                    #include "pEqn.H"    // 求解压力场
                }
            }

            viscosity->correct();     // 更新与粘度有关的量，涉及非牛顿流体系数
            turbulence->correct();    // 更新与所选湍流模型有关的量

            runTime.write();    // 输出时间

            Info<< "ExecutionTime = " << runTime.elapsedCpuTime() << " s"
                << "  ClockTime = " << runTime.elapsedClockTime() << " s"
                << nl << endl;
        }

        Info<< "End\n" << endl;

        return 0;
    }


pisoFoam的UEqn.H
^^^^^^^^^^^^^^^^^^

.. code-block:: C

    MRF.correctBoundaryVelocity(U);

    fvVectorMatrix UEqn
    (
        fvm::ddt(U) + fvm::div(phi, U)    // 隐式离散时间导数项和隐式离散对流项
      + MRF.DDt(U)                        // MRF方法旋转坐标系的额外项，用于动网格系统，
                                          // 这里表示\mathbf{\Omega } \times \mathbf{U}_{I} 。
      + turbulence->divDevSigma(U)        // 考虑湍流扩散效应的拉普拉斯项，
                                          // 不仅有基于分子间的粘性mu还有基于湍流的粘性mu_t 。
     ==
        fvModels.source(U)    // 动量方程的源项
    );

    UEqn.relax();    // 松弛技术，
                     // 对方程进行隐形松弛，用来提高矩阵的对角占优有利解；
                     // 对场进行显性松弛。

    fvConstraints.constrain(UEqn);

    if (piso.momentumPredictor())
    {
        // 求解动量方程
        // p是上一个时间步的压强，求解将会更新U，下面所有的U都将是这一步求解出来的U
        solve(UEqn == -fvc::grad(p));    // 显式离散压强梯度项

        fvConstraints.constrain(U);
    }

    //到了这里就得到了预测速度


pisoFoam的pEqn.H
^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    /* 创建一个定义在体中心的标量场rAU，
       UEqn.A()进行了A运算，返回的是A_{D}，
       因此rAU实际上是1/A_{D}。 */
    volScalarField rAU(1.0/UEqn.A());
    
    /* 创建一个定义在体中心的向量场HbyA，UEqn.H()进行了H运算返回的是A_{H}，
       因此HbyA实际上是A_{H}/A_{D}，constrainHbyA函数将U固定值边界条件赋给HbyA。 */
    volVectorField HbyA(constrainHbyA(rAU*UEqn.H(), U, p));
    
    surfaceScalarField phiHbyA    // 创建一个定义在面中心的标量场，这是一个中间通量\phi^{*}
    (          
        "phiHbyA",
        fvc::flux(HbyA)    // 将HbyA差分到面上，并点乘面矢量
      + MRF.zeroFilter(fvc::interpolate(rAU)*fvc::ddtCorr(U, phi))
    );
    
    MRF.makeRelative(phiHbyA);

    adjustPhi(phiHbyA, U, p);

    // Update the pressure BCs to ensure flux consistency
    constrainPressure(p, U, phiHbyA, rAU, MRF);    // 用于修正fixedFluxPressure类压力边界条件
    
    // Non-orthogonal pressure corrector loop
    while (piso.correctNonOrthogonal())    // 默认非正交修正为0
    {
        // Pressure corrector

        fvScalarMatrix pEqn
        (
            // 方程等号左边使用隐式离散，方程等号右边使用显式离散
            fvm::laplacian(rAU, p) == fvc::div(phiHbyA)
        );

        pEqn.setReference    // 设置压力参考值
        (
            pressureReference.refCell(),
            pressureReference.refValue()
        );

        pEqn.solve();     // 求解上述p方程，可以得到p的值

        if (piso.finalNonOrthogonalIter())    // 非正交修正的总迭代残差
        {
            /* 即 \phi = \phi^{*} - \phi^{**}，其中pEqn.flux()返回的\phi^{**}
               最终得到统一的、能够满足连续性方程的通量 */
            phi = phiHbyA - pEqn.flux();
        }
    }
    
    #include "continuityErrs.H"
    
    /* 使用修正后的压力场求解出正确的速度场，即
       \mathbf{U} = \frac{A_{H}}{A_{D}} - \frac{\nabla p}{A_{D}}
    */
    U = HbyA - rAU*fvc::grad(p);
    U.correctBoundaryConditions();
    fvConstraints.constrain(U);




rhoSimpleFoam求解器
----------------------

rhoSimpleFoam的createFields.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    Info<< "Reading thermophysical properties\n" << endl;

    autoPtr<fluidThermo> pThermo
    (
        fluidThermo::New(mesh)
    );
    fluidThermo& thermo = pThermo();
    thermo.validate(args.executable(), "h", "e");

    volScalarField& p = thermo.p();

    volScalarField rho    // 定义在网格体中心的标量场，密度场rho
    (
        IOobject
        (
            "rho",
            runTime.timeName(),           // 位于时间文件夹
            mesh,
            IOobject::READ_IF_PRESENT,    // 如果存在则读取
            IOobject::AUTO_WRITE          // 自动输出
        ),
        thermo.rho()
    );

    Info<< "Reading field U\n" << endl;
    volVectorField U    // 定义在网格体中心的矢量场，速度场U
    (
        IOobject
        (
            "U",
            runTime.timeName(),     // 位于时间文件夹
            mesh,
            IOobject::MUST_READ,    // 必须读取
            IOobject::AUTO_WRITE    // 自动输出
        ),
        mesh
    );

    #include "compressibleCreatePhi.H"

    pressureReference pressureReference
    (
        p,
        simple.dict(),
        thermo.incompressible()
    );

    mesh.schemes().setFluxRequired(p.name());

    Info<< "Creating turbulence model\n" << endl;
    autoPtr<compressible::momentumTransportModel> turbulence    // 创建湍流指针
    (
        compressible::momentumTransportModel::New
        (
            rho,
            U,
            phi,
            thermo
        )
    );

    Info<< "Creating thermophysical transport model\n" << endl;
    autoPtr<fluidThermophysicalTransportModel> thermophysicalTransport
    (
        fluidThermophysicalTransportModel::New(turbulence(), thermo)
    );

    dimensionedScalar initialMass = fvc::domainIntegrate(rho);

    #include "createMRF.H"
    #include "createFvModels.H"
    #include "createFvConstraints.H"


rhoSimpleFoam的createFieldRefs.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    const volScalarField& psi = thermo.psi();


rhoSimpleFoam.C
^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    #include "fvCFD.H"
    #include "fluidThermo.H"    // 引入热物理物料模型
    #include "compressibleMomentumTransportModels.H"    // 引入可压缩流体湍流模型
    #include "fluidThermophysicalTransportModel.H"      // 引入热物理能量模型
    #include "simpleControl.H"    // SIMPLE算法必要头文件
    #include "pressureReference.H"
    #include "fvModels.H"
    #include "fvConstraints.H"

    int main(int argc, char *argv[])
    {
        #include "postProcess.H"

        #include "setRootCaseLists.H"
        #include "createTime.H"
        #include "createMesh.H"
        #include "createControl.H"
        #include "createFields.H"         // 创建场信息与热物理模型
        #include "createFieldRefs.H"
        #include "initContinuityErrs.H"

        turbulence->validate();

        Info<< "\nStarting time loop\n" << endl;

        while (simple.loop(runTime))
        {
            Info<< "Time = " << runTime.userTimeName() << nl << endl;

            fvModels.correct();

            // Pressure-velocity SIMPLE corrector
            #include "UEqn.H"    // 求解U方程，得到速度场
            #include "EEqn.H"    // 求解能量方程
            #include "pEqn.H"    // 求解压力方程，得到压力场

            turbulence->correct();    // 更新湍流模型相关参数
            thermophysicalTransport->correct();    // 更新热物理模型相关参数

            runTime.write();

            Info<< "ExecutionTime = " << runTime.elapsedCpuTime() << " s"
                << "  ClockTime = " << runTime.elapsedClockTime() << " s"
                << nl << endl;
        }

        Info<< "End\n" << endl;

        return 0;
    }


rhoSimpleFoam的UEqn.H
^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    // Solve the Momentum equation

    MRF.correctBoundaryVelocity(U);

    tmp<fvVectorMatrix> tUEqn
    (
        fvm::div(phi, U)
      + MRF.DDt(rho, U)
      + turbulence->divDevTau(U)
     ==
        fvModels.source(rho, U)
    );
    fvVectorMatrix& UEqn = tUEqn.ref();

    UEqn.relax();

    fvConstraints.constrain(UEqn);

    solve(UEqn == -fvc::grad(p));

    fvConstraints.constrain(U);


rhoSimpleFoam的EEqn.H
^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    {
        volScalarField& he = thermo.he();

        fvScalarMatrix EEqn
        (
            fvm::div(phi, he)
          + (
                he.name() == "e"
              ? fvc::div(phi, volScalarField("Ekp", 0.5*magSqr(U) + p/rho))
              : fvc::div(phi, volScalarField("K", 0.5*magSqr(U)))
            )
          + thermophysicalTransport->divq(he)
         ==
            fvModels.source(rho, he)
        );

        EEqn.relax();

        fvConstraints.constrain(EEqn);

        EEqn.solve();

        fvConstraints.constrain(he);

        thermo.correct();
    }


rhoSimpleFoam的pEqn.H
^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    rho = thermo.rho();
    rho.relax();

    const volScalarField rAU("rAU", 1.0/UEqn.A());
    const surfaceScalarField rhorAUf("rhorAUf", fvc::interpolate(rho*rAU));

    tmp<volScalarField> rAtU
    (
        simple.consistent()
      ? volScalarField::New("rAtU", 1.0/(1.0/rAU - UEqn.H1()))
      : tmp<volScalarField>(nullptr)
    );
    tmp<surfaceScalarField> rhorAtUf
    (
        simple.consistent()
      ? surfaceScalarField::New("rhoRAtUf", fvc::interpolate(rho*rAtU()))
      : tmp<surfaceScalarField>(nullptr)
    );

    const volScalarField& rAAtU = simple.consistent() ? rAtU() : rAU;
    const surfaceScalarField& rhorAAtUf =
        simple.consistent() ? rhorAtUf() : rhorAUf;

    volVectorField HbyA(constrainHbyA(rAU*UEqn.H(), U, p));

    tUEqn.clear();

    surfaceScalarField phiHbyA
    (
        "phiHbyA",
        fvc::interpolate(rho)*fvc::flux(HbyA)
    );

    MRF.makeRelative(fvc::interpolate(rho), phiHbyA);

    bool closedVolume = false;

    // Update the pressure BCs to ensure flux consistency
    constrainPressure(p, rho, U, phiHbyA, rhorAAtUf, MRF);

    if (simple.transonic())
    {
        const surfaceScalarField phid
        (
            "phid",
            fvc::interpolate(psi)*phiHbyA/fvc::interpolate(rho)
        );

        const fvScalarMatrix divPhidp(fvm::div(phid, p));
        phiHbyA -= divPhidp.flux();

        if (simple.consistent())
        {
            phiHbyA += (rhorAAtUf - rhorAUf)*fvc::snGrad(p)*mesh.magSf();
            HbyA += (rAAtU - rAU)*fvc::grad(p);
        }

        while (simple.correctNonOrthogonal())
        {
            fvScalarMatrix pEqn
            (
                fvc::div(phiHbyA) + divPhidp
              - fvm::laplacian(rhorAAtUf, p)
              ==
                fvModels.source(psi, p, rho.name())
            );

            // Relax the pressure equation to ensure diagonal-dominance
            pEqn.relax();

            pEqn.setReference
            (
                pressureReference.refCell(),
                pressureReference.refValue()
            );

            pEqn.solve();

            if (simple.finalNonOrthogonalIter())
            {
                phi = phiHbyA + pEqn.flux();
            }
        }
    }
    else
    {
        closedVolume = adjustPhi(phiHbyA, U, p);

        if (simple.consistent())
        {
            phiHbyA += (rhorAAtUf - rhorAUf)*fvc::snGrad(p)*mesh.magSf();
            HbyA += (rAAtU - rAU)*fvc::grad(p);
        }

        while (simple.correctNonOrthogonal())
        {
            fvScalarMatrix pEqn
            (
                fvc::div(phiHbyA)
              - fvm::laplacian(rhorAAtUf, p)
              ==
                fvModels.source(psi, p, rho.name())
            );

            pEqn.setReference
            (
                pressureReference.refCell(),
                pressureReference.refValue()
            );

            pEqn.solve();

            if (simple.finalNonOrthogonalIter())
            {
                phi = phiHbyA + pEqn.flux();
            }
        }
    }

    #include "incompressible/continuityErrs.H"

    // Explicitly relax pressure for momentum corrector
    p.relax();

    U = HbyA - rAAtU*fvc::grad(p);
    U.correctBoundaryConditions();
    fvConstraints.constrain(U);

    fvConstraints.constrain(p);

    // For closed-volume cases adjust the pressure and density levels
    // to obey overall mass continuity
    if (closedVolume && !thermo.incompressible())
    {
        p += (initialMass - fvc::domainIntegrate(psi*p))
            /fvc::domainIntegrate(psi);
        p.correctBoundaryConditions();
    }

    rho = thermo.rho();
    rho.relax();



interFoam求解器
-----------------

interFoam涉及的控制方程有：

.. math::
    \begin{align}
    \nabla \cdot \mathbf{U} = 0
    \end{align}

.. math::
    \begin{align}
      \frac{\partial \rho\mathbf{U}}{\partial t}
      + \nabla \cdot (\rho\mathbf{U})\mathbf{U}
      - \nabla \cdot [ \mu (\nabla\mathbf{U}) ]
    = - \nabla p
      -  (\mathbf{g} \cdot \mathbf{x})\nabla\rho
      + \sigma_{T}\kappa_{\alpha}\nabla\alpha 
    \end{align}

.. math::
    \begin{align}
      \frac{\partial \alpha }{\partial t}
      + \nabla \cdot \mathbf{U}\alpha 
    = 0 
    \end{align}

.. math::
    \begin{align}
    & \rho = \alpha \rho_{1} + (1 - \alpha )\rho_{2}  \\
    & \mu = \alpha \mu_{1} + (1 - \alpha )\mu_{2}
    \end{align}

两相流系统被当成一个混合系统，它的密度场和粘度系数场都不再是常数，两相交界面也必须足够尖锐与足够大才能通过网格捕捉到，同时假设了两相交界面处速度场是连续的。可以看到，方程中考虑了重力场和表面张力的作用。

实际上，上面给出的第二个方程与平常看到的有所不同。一般看到的形式为

.. math::
    \begin{align}
      \frac{\partial \rho\mathbf{U}}{\partial t}
      + \nabla \cdot (\rho\mathbf{U})\mathbf{U}
      - \nabla \cdot [ \mu (\nabla\mathbf{U}) ]
    = - \nabla P
      + \rho\mathbf{g}
      + \sigma_{T}\kappa_{\alpha}\nabla\alpha 
    \end{align}

其中 :math:`P` 是总压(total pressure)，而在OpenFOAM中采用的压强 :math:`p` 表示为总压减去液体静压：

.. math::
    \begin{align}
    p = P - \rho \mathbf{g}\cdot\mathbf{x}
    \end{align}

使用动压 :math:`p` 的表达形式改写上面的方程：

.. math::
    \begin{align}
    - \nabla P = - \nabla p - \nabla [\rho(\mathbf{g}\cdot\mathbf{x})]
               = - \nabla p - (\mathbf{g}\cdot\mathbf{x})\nabla \rho - \rho \nabla (\mathbf{g}\cdot\mathbf{x})
    \end{align}

.. math::
    \begin{align}
    \nabla (\mathbf{g}\cdot\mathbf{x}) 
    = \mathbf{g} \times (\nabla \times \mathbf{x})
      + \mathbf{x} \times (\nabla \times \mathbf{g})
      + (\mathbf{g} \cdot \nabla )\mathbf{x}
      + (\mathbf{x} \cdot \nabla )\mathbf{g}  
    \end{align}

根据 :math:`\mathbf{g} \times (\nabla \times \mathbf{x})=0` ， :math:`\mathbf{x} \times (\nabla \times \mathbf{g})=0` ， :math:`(\mathbf{g} \cdot \nabla )\mathbf{x}=\mathbf{g}` ， :math:`(\mathbf{x} \cdot \nabla )\mathbf{g}=0` 可知 :math:`\nabla (\mathbf{g}\cdot\mathbf{x}) = \mathbf{g}` ，从而

.. math::
    \begin{align}
    -\nabla P = -\nabla p - \nabla [\rho(\mathbf{g}\cdot \mathbf{x})]
              = -\nabla p - (\mathbf{g}\cdot \mathbf{x}) \nabla \rho - \rho\mathbf{g}
    \end{align}

最终就得到了OpenFOAM中所采用的方程形式。

.. note:: 正因为使用了 :math:`\nabla \rho` 的形式来描述重力项，在遇到水气界面等密度剧烈变化的情况时，会产生非常明显的数值耗散和误差。除此之外，在表面张力项，由于曲率 :math:`\kappa_{\alpha}` 的评估有时会有较大的误差，从而导致有时会在周边产生额外的速度场来平衡表面曲率误差。


interFoam求解器求解的步骤可以概括为：

1. 求解输运方程得到体积相分数 :math:`\alpha` ，不过在实现的时候方程额外添加了一项，修改成了
   
.. math::
    \begin{align}
      \frac{\partial \alpha }{\partial t}
    + \nabla \cdot \mathbf{U}\alpha 
    + \nabla \cdot (\mathbf{U}_{r}\alpha (1-\alpha ) )
    = 0  
    \end{align}

2. 修正流体和界面的参数，即计算 :math:`\rho` 和 :math:`\mu` 。
3. 使用PISO算法求解速度场和压力场，但与icoFoam不同的是添加了体积力。
   





interFoam.C
^^^^^^^^^^^^^^^^

.. code-block:: C

    #include "fvCFD.H"
    #include "interfaceCompression.H"
    #include "CMULES.H"                    // MULS算法
    #include "EulerDdtScheme.H"            // 欧拉离散格式
    #include "localEulerDdtScheme.H"       // 局部欧拉离散格式
    #include "CrankNicolsonDdtScheme.H"    // CrankNicolson离散格式
    #include "subCycle.H"                  // 亚循环。由于alpha是显式离散的，为了减少计算时间而引入
    #include "immiscibleIncompressibleTwoPhaseMixture.H"    // 物理模型
    #include "noPhaseChange.H"
    #include "incompressibleInterPhaseTransportModel.H"     // 湍流头文件
    #include "pimpleControl.H"
    #include "pressureReference.H"
    #include "fvModels.H"
    #include "fvConstraints.H"
    #include "CorrectPhi.H"          // 动量修正
    #include "fvcSmooth.H"


    int main(int argc, char *argv[])
    {
        #include "postProcess.H"

        #include "setRootCaseLists.H"
        #include "createTime.H"
        #include "createMesh.H"
        #include "initContinuityErrs.H"
        #include "createDyMControls.H"
        #include "createFields.H"
        #include "createFieldRefs.H"
        #include "initCorrectPhi.H"
        #include "createUfIfPresent.H"

        if (!LTS)    // 如果不采用局部欧拉格式
        {
            #include "CourantNo.H"           // 读取库朗数
            #include "setInitialDeltaT.H"    // 设置初始的DeltaT
        }

        Info<< "\nStarting time loop\n" << endl;

        while (pimple.run(runTime))
        {
            #include "readDyMControls.H"

            if (LTS)    // 如果使用局部欧拉格式
            {
                #include "setRDeltaT.H"
            }
            else        // 如果不使用局部欧拉格式
            {
                #include "CourantNo.H"
                #include "alphaCourantNo.H"
                #include "setDeltaT.H"
            }

            fvModels.preUpdateMesh();

            // Store divU from the previous mesh so that it can be mapped
            // and used in correctPhi to ensure the corrected phi has the
            // same divergence
            tmp<volScalarField> divU;

            if
            (
                correctPhi
             && !isType<twoPhaseChangeModels::noPhaseChange>(phaseChange)
             && mesh.topoChanged()
            )
            {
                // Construct and register divU for correctPhi
                divU = new volScalarField
                (
                    "divU0",
                    fvc::div(fvc::absolute(phi, U))
                );
            }

            // Update the mesh for topology change, mesh to mesh mapping
            bool topoChanged = mesh.update();

            // Do not apply previous time-step mesh compression flux
            // if the mesh topology changed
            if (topoChanged)
            {
                talphaPhi1Corr0.clear();
            }

            runTime++;

            Info<< "Time = " << runTime.userTimeName() << nl << endl;

            // --- Pressure-velocity PIMPLE corrector loop
            while (pimple.loop())
            {
                if (pimple.firstPimpleIter() || moveMeshOuterCorrectors)
                {
                    if
                    (
                        correctPhi
                     && !isType<twoPhaseChangeModels::noPhaseChange>(phaseChange)
                     && !divU.valid()
                    )
                    {
                        // Construct and register divU for correctPhi
                        divU = new volScalarField
                        (
                            "divU0",
                            fvc::div(fvc::absolute(phi, U))
                        );
                    }

                    // Move the mesh
                    mesh.move();

                    if (mesh.changing())
                    {
                        gh = (g & mesh.C()) - ghRef;
                        ghf = (g & mesh.Cf()) - ghRef;

                        MRF.update();

                        if (correctPhi)
                        {
                            #include "correctPhi.H"
                        }

                        mixture.correct();

                        if (checkMeshCourantNo)
                        {
                            #include "meshCourantNo.H"
                        }
                    }

                    divU.clear();
                }

                fvModels.correct();

                surfaceScalarField rhoPhi
                (
                    IOobject
                    (
                        "rhoPhi",
                        runTime.timeName(),
                        mesh
                    ),
                    mesh,
                    dimensionedScalar(dimMass/dimTime, 0)
                );

                #include "alphaControls.H"
                #include "alphaEqnSubCycle.H"    // 求解alpha

                turbulence.correctPhasePhi();

                mixture.correct();

                #include "UEqn.H"    // 求解U

                // --- Pressure corrector loop
                while (pimple.correct())
                {
                    #include "pEqn.H"    // 求解p
                }

                if (pimple.turbCorr())
                {
                    turbulence.correct();
                }
            }

            runTime.write();

            Info<< "ExecutionTime = " << runTime.elapsedCpuTime() << " s"
                << "  ClockTime = " << runTime.elapsedClockTime() << " s"
                << nl << endl;
        }

        Info<< "End\n" << endl;

        return 0;
    }


interFoam的UEqn.H
^^^^^^^^^^^^^^^^^^^

动量预测步中，考虑线性方程组：

.. math::
    \begin{align}
    A := \frac{\partial \rho[\mathbf{U}]}{\partial t} 
         + \nabla \cdot (\phi [\mathbf{U}]_{f})
         - \nabla \cdot (\mu \nabla [\mathbf{U}])
    \end{align}

于是动量方程可以离散成

.. math::
    \begin{align}
    A_{D}\mathbf{U} = A_{H} + \text{reconstruct}\bigg [ |\mathbf{S}_{f}| \Big( (\sigma_{T}\kappa_{\alpha })_{f}\nabla _{f}^{\perp}\alpha -(\mathbf{g}\cdot\mathbf{x})_{f}\nabla _{f}^{\perp}\rho -\nabla _{f}^{\perp}\rho  \Big) \bigg ]   
    \end{align}

可以看到，为了避免两相密度差距大造成速度场的奇怪振荡，使用了reconstruct操作。这个操作显式地通过面通量 :math:`a_{f}` 建立了网格面中心的场 :math:`\mathbf{a}` ，具体计算方法为

.. math::
    \begin{align}
    \mathbf{a} = \left ( \sum_{f}\mathbf{n}_{f} \otimes \mathbf{S}_{f} \right )^{-1}\cdot \left ( \sum_{f}\mathbf{n}_{f}(\mathbf{S}_{f}\cdot \mathbf{a}_{f} ) \right ) 
    \end{align}

其中 :math:`\mathbf{n}_{f}` 是网格面的单位矢量， :math:`\otimes` 表示外积。

上面的式子是基于这样的假设：

.. math::
    \begin{align}
    \sum_{f}\mathbf{n}_{f}(\mathbf{S}_{f}\cdot\mathbf{a})
    =  \sum_{f}\mathbf{n}_{f}(\mathbf{S}_{f}\cdot\mathbf{a}_{f})
    \end{align}

结合关系 :math:`\mathbf{n}_{f}(\mathbf{S}_{f}\cdot\mathbf{a}) = (\mathbf{n}_{f}\otimes\mathbf{S}_{f})\cdot\mathbf{a}` ，从而上面这个方程可以写成

.. math::
    \begin{align}
    \sum_{f}(\mathbf{n}_{f}\otimes\mathbf{S}_{f})\cdot\mathbf{a}
    =  \sum_{f}\mathbf{n}_{f}(\mathbf{S}_{f}\cdot\mathbf{a}_{f})
    \end{align}

根据外积与内积的性质，可以将求和符号放到括号内部：

.. math::
    \begin{align}
    \sum_{f}\big( (\mathbf{n}_{f} \otimes \mathbf{S}_{f})\cdot \mathbf{a} \big)
    = \left ( \sum_{f}(\mathbf{n}_{f} \otimes \mathbf{S}_{f}) \right ) \cdot \mathbf{a} 
    \end{align}

求逆矩阵移项就得到了 :math:`\mathbf{a}` 的表达式。


.. code-block:: C

    MRF.correctBoundaryVelocity(U);

    fvVectorMatrix UEqn
    (
        fvm::ddt(rho, U) + fvm::div(rhoPhi, U)
      + MRF.DDt(rho, U)
      + turbulence.divDevTau(rho, U)
     ==
       phaseChange.SU(rho, rhoPhi, U)
     + fvModels.source(rho, U)
    );

    UEqn.relax();

    fvConstraints.constrain(UEqn);

    if (pimple.momentumPredictor())
    {
        solve
        (
            UEqn
         ==
            fvc::reconstruct
            (
                (
                    mixture.surfaceTensionForce()    // 表面张力项
                  - ghf*fvc::snGrad(rho)             // 重力项
                  - fvc::snGrad(p_rgh)               // 压强梯度项
                ) * mesh.magSf()                     // 面矢量绝对值
            )
        );

        fvConstraints.constrain(U);
    }



interFoam的pEqn.H
^^^^^^^^^^^^^^^^^^^^

压力方程离散成了

.. math::
    \begin{align}
    \nabla \cdot \left ( \frac{1}{A_{D}} \big(\nabla p + (\mathbf{g}\cdot\mathbf{x})\nabla \rho - \sigma_{T}\kappa_{\alpha}\nabla \alpha \big)\right ) 
    = \nabla \cdot \left ( \frac{A_{H}}{A_{D}} \right )
    \end{align}

在求解动量方程时先不考虑压强的贡献得到通量：

.. math::
    \begin{align}
    \phi^{*} = \left ( \frac{A_{H}}{A_{D}}\right )_{f}\cdot \mathbf{S}_{f}
    + \phi_{g}
    + \phi_{e}
    \end{align}

.. math::
    \begin{align}
    \phi_{g}=\left ( \frac{1}{A_{D}}\right )_{f}|\mathbf{S}_{f}| \bigg( (\sigma _{T}\kappa_{\alpha})_{f} \nabla _{f}^{\perp}\alpha - (\mathbf{g}\cdot\mathbf{x})_{f}\nabla_{f}^{\perp}\rho \bigg)
    \end{align}

.. math::
    \begin{align}
    \phi_{e} = \frac{\gamma \rho}{A_{D}\Delta t}(\phi_{o}-\mathbf{S}_{f}\cdot\mathbf{U}_{f,o} ) 
    \end{align}

.. math::
    \begin{align}
    \gamma = 1 - \min\left ( \frac{|\phi_{o}-\mathbf{U}_{f,o}\cdot\mathbf{S}_{f}|}{|\phi_{o}|+\varepsilon } ,1 \right ) 
    \end{align}

此时的 :math:`\phi^{*}` 还不满足连续性方程，接下来需要进行压力修正，也就需要求解压力方程：

.. math::
    \begin{align}
    \nabla \cdot \left ( \frac{\nabla [p]}{A_{D}}\right ) 
    = \nabla \cdot \left ( \frac{A_{H}}{A_{D}} - (\mathbf{g} \cdot \mathbf{x})\nabla \rho +\sigma_{T}\kappa_{\alpha}\nabla \alpha  \right ) 
    \end{align}

于是可以修正通量为 :math:`\phi=\phi^{*}+\phi^{**}` ，其中

.. math::
    \begin{align}
    \phi^{**}=-|\mathbf{S}_{f}|\cdot \bigg( \big( \frac{1}{A_{D}}\big)_{f}\nabla _{f}^{\perp}p \bigg)
    \end{align}



.. note:: 

    - 使用 :code:`rAU` 表示 :math:`\frac{1}{A_{D}}` ；
    - 使用 :code:`rAUf` 表示 :math:`\left ( \frac{1}{A_{D}}\right )_{f}` ；
    - 使用 :code:`HbyA` 表示 :math:`\frac{A_{H}}{A_{D}}` ；
    - 使用 :code:`phiHbyA` 表示 :math:`\left ( \frac{A_{H}}{A_{D}}\right )_{f}\cdot \mathbf{S}_{f} + \phi_{e}` ；
    - 使用 :code:`phig` 表示 :math:`\phi_{g}` ；
    - 使用 :code:`p_rghEqn` 表示 :math:`\nabla \cdot \left ( \frac{A_{H}}{A_{D}} - (\mathbf{g} \cdot \mathbf{x})\nabla \rho +\sigma_{T}\kappa_{\alpha}\nabla \alpha  \right ) - \nabla \cdot \left ( \frac{\nabla [p]}{A_{D}}\right ) = S_{p}` ，注意这里添加了额外项 :code:`Sp_rgh` ；
    - 使用 :code:`p_rghEqn.flux()` 表示 :math:`\phi^{**}` ；




.. code-block:: C

    {
        if (rAU.valid())
        {
            rAU.ref() = 1.0/UEqn.A();
        }
        else
        {
            rAU = 1.0/UEqn.A();
        }

        surfaceScalarField rAUf("rAUf", fvc::interpolate(rAU()));
        volVectorField HbyA(constrainHbyA(rAU()*UEqn.H(), U, p_rgh));
        surfaceScalarField phiHbyA
        (
            "phiHbyA",
            fvc::flux(HbyA)    // phi^{*}的第一项
          + MRF.zeroFilter(fvc::interpolate(rho*rAU())*fvc::ddtCorr(U, phi, Uf))    // 表示的是\phi_{e}
        );
        MRF.makeRelative(phiHbyA);

        if (p_rgh.needReference())
        {
            fvc::makeRelative(phiHbyA, U);
            adjustPhi(phiHbyA, U, p_rgh);
            fvc::makeAbsolute(phiHbyA, U);
        }

        surfaceScalarField phig
        (
            (
                mixture.surfaceTensionForce()
              - ghf*fvc::snGrad(rho)
            )*rAUf*mesh.magSf()
        );

        phiHbyA += phig;    // 此时phiHbyA就表示成了完整的phi^{*}

        // Update the pressure BCs to ensure flux consistency
        constrainPressure(p_rgh, U, phiHbyA, rAUf, MRF);

        // Cache the phase change pressure source
        fvScalarMatrix Sp_rgh(phaseChange.Sp_rgh(rho, gh, p_rgh));

        while (pimple.correctNonOrthogonal())
        {
            fvScalarMatrix p_rghEqn    // 构建压力方程
            (
                fvc::div(phiHbyA) - fvm::laplacian(rAUf, p_rgh)
             == Sp_rgh
            );

            p_rghEqn.setReference
            (
                pressureReference.refCell(),
                getRefCellValue(p_rgh, pressureReference.refCell())
            );

            p_rghEqn.solve();    // 求解出压力p_rgh

            if (pimple.finalNonOrthogonalIter())
            {
                phi = phiHbyA + p_rghEqn.flux();    // 得到最终修正后的满足连续性方程的通量

                p_rgh.relax();

                U = HbyA + rAU()*fvc::reconstruct((phig + p_rghEqn.flux())/rAUf);    // 求解最终的速度场
                U.correctBoundaryConditions();
                fvConstraints.constrain(U);
            }
        }

        #include "continuityErrs.H"

        // Correct Uf if the mesh is moving
        fvc::correctUf(Uf, U, phi, MRF);

        // Make the fluxes relative to the mesh motion
        fvc::makeRelative(phi, U);

        p == p_rgh + rho*gh;

        if (p_rgh.needReference())
        {
            p += dimensionedScalar
            (
                "p",
                p.dimensions(),
                pressureReference.refValue()
              - getRefCellValue(p, pressureReference.refCell())
            );
            p_rgh = p - rho*gh;
        }

        if (!correctPhi)
        {
            rAU.clear();
        }
    }





自定义求解器
=================


passiveScalarFoam
-------------------

该求解器基于icoFoam进行修改。icoFoam求解器涉及的控制方程如下：

.. math::
    \begin{align}
    \nabla \cdot \mathbf{U} = 0
    \end{align}

.. math::
    \begin{align}
    \frac{\partial \mathbf{U}}{\partial t}
    + \nabla \mathbf{U}\mathbf{U}
    - \nabla \cdot [ \nu (\nabla\mathbf{U}) ] 
    = - \nabla p
    \end{align}

现在额外添加一个基于求解出的速度场的无源标量传输方程：

.. math::
    \begin{align}
    \frac{\partial s}{\partial t} + \nabla \cdot (\mathbf{U}s) = 0
    \end{align}


为了不污染OpenFOAM源程序，需要在自己的run文件夹内建立与OpenFOAM相同的求解器文件结构。在run文件夹内，建立applications/solvers/incompressible文件结构，然后将icoFoam文件夹复制到自己建立的该结构当中。

接下来修改各文件名字：修改该文件夹的名字为passiveScalarFoam，修改icoFoam.C为passiveScalarFoam.C，然后进入Make/files进行修改，其中第一句指定所需编译文件，第二句指定求解器存放位置：

.. code-block:: 

    passiveScalarFoam.C

    EXE = $(FOAM_USER_APPBIN)/passiveScalarFoam

此时进入终端运行wclean和wmake验证更改名字没有导致编译错误。

接下来进入createFields.H添加定义在体中心的标量场 :math:`s` 。由于定义在体中心的标量场与压力场p是类似的，所以可以直接复制p的内容并修改名字为s作为标量场s的信息(直接放到原文件所有内容的最后即可)：


.. code-block:: C

    Info<< "Reading field s\n" << endl;
    volScalarField s
    (
        IOobject
        (
            "s",
            runTime.timeName(),
            mesh,
            IOobject::MUST_READ,
            IOobject::AUTO_WRITE
        ),
        mesh
    );

保险起见可以再次运行wmake进行编译验证没有任何错误发生。

接下来进入passiveScalarFoam.C进行求解方程的修改。在原PISO算法求解完U和p之后，进行runTime.write()之前，添加下面所需求解的方程：

.. code-block:: C

    solve(fvm::ddt(s)+fvm::div(phi,s));

然后运行wmake进行编译，如此就完成了求解器的修改。接下来可以使用cavity算例来验证一下求解情况。

修改cavity的名字为passiveCavity以区分原本用于icoFoam的算例。进入0文件建立s文件，因为s和p相似，可以直接复制p文件并修改其相应的名字，而量纲可以修改为无量纲，初始条件与边界条件保持相同：

.. code-block:: C

    FoamFile
    {
        format      ascii;
        class       volScalarField;
        object      s;
    }

    dimensions      [0 0 0 0 0 0 0];

    internalField   uniform 0;

    boundaryField
    {
        movingWall
        {
            type            zeroGradient;
        }

        fixedWalls
        {
            type            zeroGradient;
        }

        frontAndBack
        {
            type            empty;
        }
    }


接下来进入fvSchemes设置额外添加方程的离散格式：

.. code-block:: C

    divSchemes
    {
        default         none;
        div(phi,U)      Gauss linear;
        div(phi,s)      Gauss linearUpwind grad(s);
    }

然后进入fvSolution设置所添加方程离散后线性方程组的求解方法：

.. code-block:: C

    s
    {
        solver          smoothSolver;
        smoother        symGaussSeidel;
        tolerance       1e-05;
        relTol          0;
    }


同时修改controlDict的相关内容，然后运行blockMesh和passiveScalarFoam即可。

.. note:: 在后处理过程中可以发现，虽然所添加方程只有对流项，但是结果却呈现出扩散项的现象。这其实是数值耗散的问题。针对这一问题可以参考interFoam求解器是如何应对数值耗散问题的。



temInterFoam
--------------

该求解基于interFoam进行修改。interFoam涉及的控制方程有：

.. math::
    \begin{align}
    \nabla \cdot \mathbf{U} = 0
    \end{align}

.. math::
    \begin{align}
      \frac{\partial \rho\mathbf{U}}{\partial t}
      + \nabla \cdot (\rho\mathbf{U})\mathbf{U}
      - \nabla \cdot [ \mu (\nabla\mathbf{U}) ]
    = - \nabla p
      -  (\mathbf{g} \cdot \mathbf{x})\nabla\rho
      + \sigma_{T}\kappa_{\alpha}\nabla\alpha 
    \end{align}

.. math::
    \begin{align}
      \frac{\partial \alpha }{\partial t}
      + \nabla \cdot \mathbf{U}\alpha 
    = 0 
    \end{align}

.. math::
    \begin{align}
    & \rho = \alpha \rho_{1} + (1 - \alpha )\rho_{2}  \\
    & \mu = \alpha \mu_{1} + (1 - \alpha )\mu_{2}
    \end{align}

将要添加的控制方程需要求解温度的输运过程：

.. math::
    \begin{align}
      \frac{\partial \rho T}{\partial t}
      + \nabla \cdot (\rho \mathbf{U} T)
      - \nabla \cdot (D_{\text{eff}} \nabla T)
    = 0 
    \end{align}

有效扩散系数 :math:`D_{\text{eff}}` 表示为

.. math::
    \begin{align}
      D_{\text{eff}}
    = \frac{\alpha k_{1}}{C_{\text{v1}}}
      + \frac{(1 - \alpha )k_{2}}{C_{\text{v2}}}  
    \end{align}

其中 :math:`k_{1},k_{2},C_{v1},C_{v2}` 代表传导系数和两种流相的热容量。


新建文件结构applications/solvers/multiphase，将OpenFOAM的interFoam文件夹复制到该处，并修改名字为temInterFoam。进入该文件夹，修改interFoam.C名字为temInterFoam.C，并修改Make/files文件的内容为：

.. code-block:: 

    temInterFoam.C

    EXE = $(FOAM_USER_APPBIN)/temInterFoam

然后运行wclean和wmake验证更改名字没有造成编译错误。

进入createFields.H文件，在最后添加传导系数的内容：

.. code-block:: C

    dimensionedScalar k1
    (
        "k",
        dimensionSet(1,1,-3,-1,0),
        mixture.subDict
        (
            mixture.phase1Name()
        ).lookup("k")
    );

    dimensionedScalar k2
    (
        "k",
        dimensionSet(1,1,-3,-1,0),
        mixture.subDict
        (
            mixture.phase2Name()
        ).lookup("k")
    );

    dimensionedScalar Cv1
    (
        "Cv",
        dimensionSet(0,2,-2,-1,0),
        mixture.subDict
        (
            mixture.phase1Name()
        ).lookup("Cv")
    );

    dimensionedScalar Cv2
    (
        "Cv",
        dimensionSet(0,2,-2,-1,0),
        mixture.subDict
        (
            mixture.phase2Name()
        ).lookup("Cv")
    );

.. note:: 这里可以运行wmake验证没有编译错误。如果只书写了phase1的信息就编译则会提示与phase2相关的错误。



同时复制p_rgh的内容修改得到T的信息：

.. code-block:: C

    Info<< "Reading field T\n" << endl;
    volScalarField T
    (
        IOobject
        (
            "T",
            runTime.timeName(),
            mesh,
            IOobject::MUST_READ,
            IOobject::AUTO_WRITE
        ),
        mesh
    );

运行wmake验证没有编译错误。

为了更好地组织代码，我们将与T相关的方程求解提取到TEqn.H当中。复制UEqn.H并清除其内容改名为TEqn.H，书写其内容：

.. code-block:: C

    volScalarField Deff
    (
        "Deff",
        (alpha1*k1/Cv1 + (scalar(1) - alpha1)*k2/Cv2)
    );

    solve
    (
          fvm::ddt(rho, T)
        + fvm::div(rhoPhi, T)
        - fvm::laplacian(Deff, T)
    );

然后需要将TEqn.H添加到temInterFoam.C里面。需要注意的是，添加位置在pimple loop内部但是在piso loop后面：

.. code-block:: C

    #include "TEqn.H"

进行wmake编译成功后就完成了temInterFoam求解器的编写，后续可以设置算例进行验证。



运行错误报告
============


一般运行过程中出错可能是网格问题或边界设置问题造成的。可以查看运行过程中库朗数的变化情况，如果maxCourant超过1很多则很有可能出错，这也许是部分网格太小或者雷诺数较高的问题。


.. code-block:: C

    SigFpe : Enabling floating point exception trapping (FOAM_SIGFPE).

上面这句报错说明存在浮点数溢出问题。



.. code-block:: C

    #1  Foam::sigFpe::sigHandler(int) at ??:?

上面这句报错说明在数学运算过程中出现了类似除以无穷或除以零之类的运算错误。
