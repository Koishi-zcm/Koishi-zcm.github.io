********
OpenFOAM
********


网格生成
========


blockMesh
---------

blockMesh能够创建具有分级和弯曲边缘的参数网格，其运行根据式位于 :code:`constant/polyMesh` 文件中的 :code:`blockMeshDict` 字典文件。 :code:`blockMeshDict` 文件的包含的关键词如下所示：

+-------------------------+----------------------------+---------------------------------------------------------------------------+
| 关键词                  | 含义                       | 例子                                                                      |
+=========================+============================+===========================================================================+
| :code:`convertToMeters` | 顶点坐标的放缩比例         | 取0.01时长度单位为毫米                                                    |
+-------------------------+----------------------------+---------------------------------------------------------------------------+
| :code:`vertices`        | 顶点坐标集合               | 原点坐标为 :code:`(0 0 0)`                                                |
+-------------------------+----------------------------+---------------------------------------------------------------------------+
| :code:`edges`           | 用来指定圆弧或样条曲线边缘 | 用两个顶点标签和中间经过点坐标指定圆弧 :code:`arc 1 4 (0.939 0.342 -0.5)` |
+-------------------------+----------------------------+---------------------------------------------------------------------------+
| :code:`block`           | 顶点标签集合和网格大小     | :code:`hex (0 1 2 3 4 5 6 7) (10 10 1) simpleGrading (1 1 1)`             |
+-------------------------+----------------------------+---------------------------------------------------------------------------+
| :code:`patches`         | 面的集合                   | :code:`symmetryPlan base ( (0 1 2 3) )`                                   |
+-------------------------+----------------------------+---------------------------------------------------------------------------+
| :code:`mergePatchPairs` | 合并的面的集合             |                                                                           |
+-------------------------+----------------------------+---------------------------------------------------------------------------+

 

顶点的描述是按照坐标点列表的方式进行的，从上往下依次表示顶点标签的递增，例如下面是一个block的顶点集合表示方式：

.. code-block:: C

    vertices
    (
            (0     0     0  )    // 标签0
            (1     0     0.1)    // 标签1
            (1.1   1     0.1)    // 标签2
            (0     1     0.1)    // 标签3
            (-0.1  -0.1  1  )    // 标签4
            (1.3   0     1.2)    // 标签5
            (1.4   1.1   1.3)    // 标签6
            (0     1     1.1)    // 标签7
    );


边缘的描述需要使用两个顶点标签，不过同样要用关键词指定边缘类型，不同类型还要求更进一步的补充点坐标信息，下面是可用的关键词：

+----------------------+--------------+--------------------+
| 关键词               | 含义         | 补充信息           |
+======================+==============+====================+
| :code:`arc`          | 圆弧         | 一个中间插值点坐标 |
+----------------------+--------------+--------------------+
| :code:`simpleSpline` | 样条曲线     | 一系列插值点坐标   |
+----------------------+--------------+--------------------+
| :code:`polyLine`     | 一组线       | 一系列插值点坐标   |
+----------------------+--------------+--------------------+
| :code:`polySpline`   | 一组样条曲线 | 一系列插值点坐标   |
+----------------------+--------------+--------------------+
| :code:`line`         | 直线         |                    |
+----------------------+--------------+--------------------+

下面是通过标签1顶点和标签5顶点定义的圆弧边缘，该圆弧通过了坐标为 :code:`(1.1  0.0  0.5)` 的点：

.. code-block:: C

    edges
    (
            arc  1  5  (1.1  0.0  0.5)
    );


网格块的定义涉及到点标签集、三个方向的网格数量、非均匀化比例的定义。一个block将会涉及到8个顶点标签，顶点标签的顺序决定了该网格块的坐标方向，也就会影响加密的设置顺序。顶点标签与坐标方向有下面的关系：

- 第一个顶点标签决定了坐标系的原点；
- 从第一个顶点标签位置指向第二个顶点标签位置决定了 :math:`x_{1}` 方向；
- 从第二个顶点标签位置到第三个顶点标签位置决定了 :math:`x_{2}` 方向；
- 前四个顶点标签位置决定了 :math:`x_{3}=0` 的平面位置；
- 从第一个标签位置指向第五个标签位置决定了 :math:`x_{3}` 方向；
- 剩余三个标签类似地依次从第二、三、四个标签位置沿 :math:`x_{3}` 方向移动得到。



snappyHexMesh
---------------

生成背景网格
^^^^^^^^^^^^

该功能可以通过三角面片模型文件(stl,obj,vtk,...)来创建网格，该模型文件应当放置在constant/triSurface文件夹内。同时还需要背景网格来决定计算域和基本网格密度，通常通过blockMesh来生成，而由于一般来说都是要生成长方体规则网格，所以可以按照下面的格式来书写blockMeshDict文件（根据需要修改大小以及边界面类型）：

.. code-block:: C

    convertToMeters 1;

        xmin      -3;
        xmax      3;
        ymin      -3;
        ymax      3;
        zmin      0;
        zmax      10;
        
        xcells    40;
        ycells    40;
        zcells    40;

    vertices
    (
        ($xmin $ymin $zmin)
        ($xmax $ymin $zmin)
        ($xmax $ymax $zmin)
        ($xmin $ymax $zmin)
        
        ($xmin $ymin $zmax)
        ($xmax $ymin $zmax)
        ($xmax $ymax $zmax)
        ($xmin $ymax $zmax)
    );

    blocks
    (
        hex (0 1 2 3 4 5 6 7) ($xcells $ycells $zcells) simpleGrading (1 1 1)
    );

    boundary
    (
        inlet
        {
            type patch;
            faces
            (
                (0 4 7 3)
            );
        }
        outlet
        {
            type patch;
            faces
            (
                (1 2 6 5)
            );
        }
        ground
        {
            type patch;
            faces
            (
                (0 3 2 1)
            );
        }
        top
        {
            type patch;
            faces
            (
                (4 5 6 7)
            );
        }
        side1
        {
            type patch;
            faces
            (
                (0 1 5 4)
            );
        }
        side2
        {
            type patch;
            faces
            (
                (3 7 6 2)
            );
        }
    );


    mergePatchPairs
    (
    );


surfaceFeaturesDict
^^^^^^^^^^^^^^^^^^^

然后需要设置位于system文件夹中的surfaceFeaturesDict文件、snappyHexMeshDict文件以及meshQualityDict文件，这三个文件的模板可以从教程案例中复制得到。

首先说明surfaceFeaturesDict文件，它用来提取模型文件的表面特征，需要指定模型文件以及调用的程序，其模板为：

.. code-block:: C

    /*--------------------------------*- C++ -*----------------------------------*\
      =========                 |
      \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
       \\    /   O peration     | Website:  https://openfoam.org
        \\  /    A nd           | Version:  10
         \\/     M anipulation  |
    \*---------------------------------------------------------------------------*/
    FoamFile
    {
        format      ascii;
        class       dictionary;
        object      surfaceFeaturesDict;
    }
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    surfaces ("combined.stl");
    includedAngle 150;

    #includeEtc "caseDicts/surface/surfaceFeaturesDict.cfg"

    // ************************************************************************* //

完成后就可以在算例目录下在终端输入：

.. code-block:: shell

    surfaceFeatures

如此就能从几何文件中提取出特征边缘，并在triSurface文件夹内生成cylinder.eMesh文件。



meshQualityDict
^^^^^^^^^^^^^^^

meshQualityDict文件几乎不需要改动，其内容只有调用相应程序：

.. code-block:: C

    /*--------------------------------*- C++ -*----------------------------------*\
      =========                 |
      \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
       \\    /   O peration     | Website:  https://openfoam.org
        \\  /    A nd           | Version:  10
         \\/     M anipulation  |
    \*---------------------------------------------------------------------------*/
    FoamFile
    {
        format      ascii;
        class       dictionary;
        object      meshQualityDict;
    }
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    #includeEtc "caseDicts/mesh/generation/meshQualityDict.cfg"

    //- minFaceWeight (0 -> 0.5)
    //minFaceWeight 0.02;

    // ************************************************************************* //


snappyHexMeshDict
^^^^^^^^^^^^^^^^^

完成上述文件后就可以开始对snappyHexMeshDict文件进行修改。该文件中涉及的关键词如下：

+-------------------------+-----------------------------------------+----------+
| 关键词                  | 含义                                    | 常见赋值 |
+=========================+=========================================+==========+
| castellatedMesh         | 是否创建堞状网格                        | true     |
+-------------------------+-----------------------------------------+----------+
| snap                    | 是否进行表面贴合                        | true     |
+-------------------------+-----------------------------------------+----------+
| addLayers               | 是否添加表面边界层                      | false    |
+-------------------------+-----------------------------------------+----------+
| mergeTolerance          | 合并公差作为初始网格边界框的分数        | 1e-6     |
+-------------------------+-----------------------------------------+----------+
| debug                   | 控制中间网格和网线打印的写入            |          |
+                         +-----------------------------------------+----------+
|                         | 只写最终网格                            | 0        |
+                         +-----------------------------------------+----------+
|                         | 写中间网格                              | 1        |
+                         +-----------------------------------------+----------+
|                         | 用cellLevel写volScalarField进行后期处理 | 2        |
+                         +-----------------------------------------+----------+
|                         | 将当前交叉点写入.obj文件                | 4        |
+-------------------------+-----------------------------------------+----------+
| geometry                | 所使用的表面图形的信息                  |          |
+-------------------------+-----------------------------------------+----------+
| castellatedMeshControls | 生成蜂窝网格的控制信息                  |          |
+-------------------------+-----------------------------------------+----------+
| snapControls            | 表面贴合的控制信息                      |          |
+-------------------------+-----------------------------------------+----------+
| addLayersControls       | 表面边界层添加的控制信息                |          |
+-------------------------+-----------------------------------------+----------+
| meshQualityControls     | 网格质量的控制信息                      |          |
+-------------------------+-----------------------------------------+----------+


geometry
""""""""

在geometry关键词内设置所需的几何文件以及体加密信息。下面是一个简单的案例：

.. code-block:: C

    geometry
    {
        cylinder    // 模型边界面的自定义命名
        {
            type triSurfaceMesh;
            file "cylinder.stl";    // 所用文件
        }

        refinementBox    // 体加密区域的自定义命名
        {
            type searchableBox;    // 体加密类型
            min  (  -5   -5   -1);
            max  (15 15  5);
        }
    };  


如果在stl文件中已经自行定义了各个solid的名字，那么就可以添加 :code:`regions` 关键字来提取这些面域，进而在后续的面加密中各自进行处理。例如：

.. code-block:: C

    geometry
    {
        cylinder    // 模型边界面的自定义命名
        {
            type triSurfaceMesh;
            file "cylinder.stl";    // 所用文件

            regions
            {
                top { name top; }
                bottom { name bottom; }
                wall { name wall; }
            }
        }

        refinementBox    // 体加密区域的自定义命名
        {
            type searchableBox;    // 体加密类型
            min  (  -5   -5   -1);
            max  (15 15  5);
        }
    };  







体加密除了上述方块体加密设置，还有其他可选加密方式：

+--------------------------+----------------+--------------+-----------------+
| 加密类型                 | 类型含义       | 所需参数     | 参数解释        |
+==========================+================+==============+=================+
| searchableBox            | 立方体         | min          | 最小对角点坐标  |
+                          +                +--------------+-----------------+
|                          |                | max          | 最大对角点坐标  |
+--------------------------+----------------+--------------+-----------------+
| searchableCylinder       | 圆柱           | point1       | 中轴线端点1     |
+                          +                +--------------+-----------------+
|                          |                | point2       | 中轴线端点2     |
+                          +                +--------------+-----------------+
|                          |                | radius       | 外圆半径        |
+--------------------------+----------------+--------------+-----------------+
| searchableSphere         | 球             | Centre       | 中心点坐标      |
+                          +                +--------------+-----------------+
|                          |                | radius       | 球半径          |
+--------------------------+----------------+--------------+-----------------+
| searchableCone           | 圆锥体（空心） | point1       | 中轴线端点1     |
+                          +                +--------------+-----------------+
|                          |                | point2       | 中轴线端点2     |
+                          +                +--------------+-----------------+
|                          |                | radius1      | 断面1外圆半径   |
+                          +                +--------------+-----------------+
|                          |                | radius2      | 断面2外圆半径   |
+                          +                +--------------+-----------------+
|                          |                | innerRadius1 | 断面1内圆半径   |
+                          +                +--------------+-----------------+
|                          |                | innerRadius2 | 断面2内圆半径   |
+--------------------------+----------------+--------------+-----------------+
| searchableRotatedBox     | 旋转立方体     | origin       | 最小对角点坐标  |
+                          +                +--------------+-----------------+
|                          |                | span         | XYZ方向尺寸长度 |
+                          +                +--------------+-----------------+
|                          |                | e1           | 几何i方向向量   |
+                          +                +--------------+-----------------+
|                          |                | e2           | 几何j方向向量   |
+                          +                +--------------+-----------------+
|                          |                | e3           | 几何k方向向量   |
+--------------------------+----------------+--------------+-----------------+
| searchableExtrudedCircle | 圆管           | file         | 导入曲线文件    |
+                          +                +--------------+-----------------+
|                          |                | radius       | 圆管半径        |
+--------------------------+----------------+--------------+-----------------+



castellatedMeshControls
"""""""""""""""""""""""

全局网格细化参数在castellatedMeshControls中设置，其目的为细化背景网格，通过细化背景网格以使几何特征与几何表面上拥有一定网格量，以提高几何特征捕捉的准确性。同时通过参数设置，保证网格细化时尺寸变化尽量平缓。在该关键词内需要设置的内容包括：

+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| 关键词                     | 含义                 | 常用赋值           | 备注                                                                                                                                                                                                                                                                        |
+============================+======================+====================+=============================================================================================================================================================================================================================================================================+
| maxGlobalCells             | 全局最大网格量       | 2e+06              | 该功能主要目的是保证网格细化过程中，避免划分网格量太大，导致计算机内存溢出。当划分网格量超过此值时，细化过程将立即终止。此时，局部细化功能可能终止运行。                                                                                                                    |
+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| maxLocalCells              | 单核最大网格量       | 1e+06              | 该参数主要应用于网格并行计算，其指定了细化网格过程中每个处理器处理的最大数量网格数。设置该参数时请保证一定的富余量，经常重新平衡每个处理器计算量将减慢网格生成过程。                                                                                                        |
+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| maxLoadUnbalance           | 最大负载平衡参数     | 0.1                | 该参数主要应用于网格并行计算。当该参数值为0时，即强制负载平衡，即各处理器间处理的网格量严格保持单元总数/计算核数。较低的值可能会导致系统频繁的均衡网格负载量。而参数值设置为1时，则完全禁用网格均衡操作。                                                                   |
+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minRefinementCells         | 最小细化单元数       | 0                  | 该参数指定了需细化特征的最小单元数。若特征上网格单元数量小于该参数，则停止对其细化。                                                                                                                                                                                        |
+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nCellsBetweenLevels        | 缓冲层数             | 3                  | 若用户设置参数值为1，则表示不添加过渡区域。越大的值可使得网格大小过渡越平缓，但将导致网格量增加。                                                                                                                                                                           |
+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| resolveFeatureAngle        | 自动检测角           | 30                 | 当曲率变化角超过该参数值时，特征区域网格使用最大面细化等级，而低于此角度的特征均采用最小面细化级别。默认参数值为30，参数值设置为360时，表示关闭此功能。该参数生效的前置条件：(1)面细化参数中最小和最大细化等级需不同。(2)面贴合过程中特征捕捉需采用隐式方法。               |
+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| locationInMesh             | 网格域控制点         | (-3.25 -2.25 1.25) | 指定需要保留背景网格表面与封闭几何表面之间的网格，还是封闭几何内部的网格。保留区域网格中需包含指定的参数点，该点的位置不能和网格单元的面或边重合。                                                                                                                          |
+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| allowFreeStandingZoneFaces | 允许有独立面         | false              | 该参数定义是否允许几何中有独立的面存在。若设置参数值为false，则表示在refinementSurfaces中指定的faceZones仅位于相应cellZones的边界上，作为不同域之间交界面。若该参数值为true，则允许此faceZones作为独立面域（例如：挡板界面等）。如果用户没有指定faceZones，则该参数不生效。 |
+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| features                   | 需要细化的特性信息   |                    |                                                                                                                                                                                                                                                                             |
+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| refinementRegions          | 用于细化的区域的信息 |                    |                                                                                                                                                                                                                                                                             |
+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| refinementSurfaces         | 用于细化的曲面的信息 |                    |                                                                                                                                                                                                                                                                             |
+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+



一般情况下，castellatedMeshControls可以按照如下方式设置：

.. code-block:: C

    castellatedMeshControls
    {
        features
        (
          { file  "cylinder.eMesh"; level 1; }
        );

        refinementSurfaces
        {
            cylinder    // 对应之前定义的几何表面名称
            {
                level (3 3);
                patchInfo { type wall; }
            }
        }

        refinementRegions
        {
            refinementBox    // 对应之前定义的加密区域名称
            {
                mode    inside;
                level   2;
            }
        }

        locationInMesh (-3.25 -2.25 1.25);
    }



如果在之前 :code:`geometry` 部分指明了不同的regions，那么在 :code:`refinementSurfaces` 就可以针对不同的面域进行不同程度的细化，同时赋予不同的边界类型：

.. code-block:: C

    castellatedMeshControls
    {
        features
        (
          { file  "cylinder.eMesh"; level 1; }
        );

        refinementSurfaces
        {
            cylinder    // 对应之前定义的几何表面名称
            {
                level (0 0);

                regions
                {
                    top
                    {
                        level (1 1);
                        patchInfo { type patch; }
                    }
                    bottom
                    {
                        level (1 1);
                        patchInfo { type patch; }
                    }
                    wall
                    {
                        level (2 2);
                        patchInfo { type wall; }
                    }
                }
            }
        }

        refinementRegions
        {
            refinementBox    // 对应之前定义的加密区域名称
            {
                mode    inside;
                level   2;
            }
        }

        locationInMesh (-3.25 -2.25 1.25);
    }



snapControls
""""""""""""

面贴合参数在snapControls中设置，主要目的是将体网格节点移动到几何表面上，贴合体网格中锯齿状表面。在该关键词内需要设置的内容包括：

+------------------------+----------------------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| 关键词                 | 含义                 | 常用赋值 | 备注                                                                                                                                                                                                                                                                                                                                                                                 |
+========================+======================+==========+======================================================================================================================================================================================================================================================================================================================================================================================+
| tolerance              | 捕捉点最大相对距离   | 5        | 建议2-5之间。该参数指定贴合算法中捕捉与特征面相关网格节点的最大相对距离，实际捕捉距离为tolerance参数值乘以相邻体网格尺寸。参数值必须大于或等于1，如果值太低，则可能无法使偏差较大的网格节点移动到几何表面上。较高的值有助于增加几何的捕捉范围，但如果参数值设置过高，则有可能捕捉到与表面无关的网格节点。                                                                            |
+------------------------+----------------------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nSolveIter             | 网格贴合最大迭代次数 | 100      | 该参数指定了网格贴合算法的最大迭代次数。较高的值会提高网格的质量，网格一致性更好，但网格划分时间会更长。简单模型可以将该参数值设置为100，若贴合后网格质量不太理想，可尝试将该参数值增加到300。                                                                                                                                                                                       |
+------------------------+----------------------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nSmoothPatch           | 面平滑迭代次数       | 0        | 0表示初始网格外形。该参数指定了表面上网格贴合的平滑迭代次数。增加迭代次数可以使曲面上网格平滑、贴合性更好，且能降低曲面上网格的歪斜率，但可能导致曲率突变特征（如直角等）弱化。                                                                                                                                                                                                      |
+------------------------+----------------------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nSmoothInternal        | 体网格平滑迭代次数   | 0        | 建议参数值与nSmoothPatch参数值一致。在执行网格平滑迭代时，边界面网格平滑迭代nSmoothPatch将与内部体网格平滑迭代nSmoothInternal联合使用。平滑迭代顺序为优先执行一次面平滑迭代（nSmoothPatch），再执行一次体网格平滑迭代（nSmoothInterna），以此循环。若用户设置nSmoothInternal参数值大于nSmoothPatch值时，平滑迭代次数统一采用nSmoothPatch参数值。默认值为零，表示禁用体网格平滑迭代。 |
+------------------------+----------------------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nRelaxIter             | 贴合松弛迭代次数     | 8        | 一般为5-8之间。该参数指定贴合过程中松弛迭代次数，用以消除质量较差的单元或网格节点。如果迭代完成后网格仍存在质量较差单元，则用户可以尝试增加此迭代次数，较高的值将确保更好的网格质量，但会花费更多计算时间。                                                                                                                                                                          |
+------------------------+----------------------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nFeatureSnapIter       | 特征边捕捉迭代次数   | 10       | 该参数指定了特征捕捉迭代次数，以将网格点捕捉到表面边缘。如果在nFeatureSnaplter迭代后局部特征区域网格没有达到足够的质量标准，则取消该区域特征边捕捉并恢复到之前状态。未指定该参数，特征捕捉功能将被禁用。                                                                                                                                                                             |
+------------------------+----------------------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nFaceSplitInterval     | 面拆分迭代           | 5        | 当系统执行完特征边捕捉迭代步骤后，若网格边缘与特征边未完全对齐，则有可能在特征边处网格产生凹面。从而导致在添加边界层时，其投影体网格的非正交性增大。如果体网格不满足质量要求，则取消该处边界层生成。nFaceSplitInterval参数默认值为-1（禁用），使用建议参数值设置为特征边捕捉迭代（nFeatureSnaplter）次数的一半。                                                                     |
+------------------------+----------------------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| explicitFeatureSnap    | 显式特征捕捉         | true     | 显示特征捕捉方法需要用户自定义特征边文件（.eMesh），并且指定特征边的细化等级（通过castellatedMeshControls子字典中features参数指定）。                                                                                                                                                                                                                                                |
+------------------------+----------------------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| implicitFeatureSnap    | 隐式特征捕捉         | false    | 隐式方法不需要用户提取几何特征边，其特征识别自动化程度优于显示特征捕捉方法。它使用全局细化参数中resolveFeatureAngle参数识别曲面几何特征（例如：面的相交线、曲率变化较大的曲面特征）。但在尖角特征或者挡板界面处，显示方法捕捉特征效果优于隐式方法。                                                                                                                                  |
+------------------------+----------------------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| multiRegionFeatureSnap | 多域特征捕捉         | false    | 该参数用于捕捉多域网格间的特征面，这对于具有多个区域（例如流体区域和固体区域）的网格进行共轭传热模拟或类似操作很重要。该参数生效的前置条件为采用显示特征捕捉方法explicitFeatureSnap。使用该参数时，它会加强特征面两边网格贴合，即内部区域和外部区域，这可能会导致特征面处网格歪斜率上升。                                                                                            |
+------------------------+----------------------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+


一般情况下，snapControls采用下面的设置就已经能够得到相对可以接受的网格了：

.. code-block:: C

    snapControls
    {
        explicitFeatureSnap    true;
        implicitFeatureSnap    false;
        multiRegionFeatureSnap false;
        
        tolerance           5;
        nSolveIter          100;
        nSmoothPatch        0;
        nSmoothInternal     0;
        nRelaxIter          8;
        nFeatureSnapIter    10;
        nFaceSplitInterval  5;
    }


addLayersControls
"""""""""""""""""""

在划分边界层时，需要在全局参数设置中激活边界层划分功能，即将addLayers值设置为true。边界层配置参数在addLayersControls子字典中设置，其参数类型可分为基本参数与高级控制参数：


+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| 关键词                    | 含义                           | 备注                                                                                                                                                                                                                                                  |
+===========================+================================+=======================================================================================================================================================================================================================================================+
| relativeSizes             | 是否采用相对临近单元尺寸比值   | 设置为true时，边界层厚度参数值为相对于邻近曲面上的体网格单元大小的比值；设置为false时，边界层厚度参数值直接由绝对单位的值(单位.米)定义                                                                                                                |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| expansionRatio            | 边界层膨胀比                   | 两个相邻层的厚度比，该值越大，各层间的高度差越大                                                                                                                                                                                                      |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| finalLayerThickness       | 边界层最后一层厚度             | 确保边界层最后一层网格不大于该值                                                                                                                                                                                                                      |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| firstLayerThickness       | 边界层第一层的厚度             | 指定距离曲面最近的边界层的高度，确保边界层第一层网格不大于该值                                                                                                                                                                                        |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| thickness                 | 边界层总厚度                   | 所有边界层的最大厚度。设置较大的边界层总厚度值会导致体网格收缩位移相应增大，体网格变形量增加将导致网格质量降低。当网格质量小于用户设置网格质量控制参数时，系统将取消此处边界层网格划分。                                                              |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minThickness              | 最小总层厚度                   | 所有边界层的总体最小厚度。若边界层挤出区域厚度小于该值，则该区域将不会生成边界层                                                                                                                                                                      |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nGrow                     | 最大取消边界层单元数           | 指定未设置边界层的相邻面相交处边界层的过渡层数。这有助于将边界层过渡到特征边附近                                                                                                                                                                      |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nSurfaceLayers            | 边界层层数                     | 需在指定面设置边界层基本参数中输入，为强制性参数                                                                                                                                                                                                      |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| maxFaceThicknessRatio     | 表面网格最大纵横比             | 当要在高度扭曲的单元上（特别是在角落）生成边界层时，纵横比高于此值的单元上边界层停止生成，以保证边界层网格质量                                                                                                                                        |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| featureAngle              | 边界层最大面夹角               | 当两个曲面之间的法向夹角小于参数featureAngle值时，允许两个曲面的相交边处体网格向域内收缩，形成边界层划分区域                                                                                                                                          |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| slipFeatureAngle          | 边界层滑移角度                 | 使边界层面边缘处顶点延边界面滑动，以保证边界层在边缘处的划分空间。建议使用70-80之间的最佳值来限制层的滑动，默认值为featureAngle的一半                                                                                                                 |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nBufferCellsNoExtrude     | 边界层终止面的缓冲单元数       | 为边界层终止端创建缓冲收缩区，即逐渐降低边界层数。设置值小于0，则表示在终止端立即停止边界层                                                                                                                                                           |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nSmoothThickness          | 边界层厚度平滑迭代次数         | 边界层网格生成前，需要根据投影厚度值收缩现有体网格，可通过nSmoothThickness值设置投影厚度值的迭代次数                                                                                                                                                  |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nSmoothSurfaceNormals     | 边界层曲面法线平滑迭代次数     | 边界层网格生成前，需要根据曲面法线方向收缩现有体网格，可通过nSmoothSurfaceNormals指定曲面法线平滑迭代次数                                                                                                                                             |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minMedianAxisAngle        | 拾取中间轴点的角度             | 这指定用于拾取中间轴点的角度。建议值为90度                                                                                                                                                                                                            |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| maxThicknessToMedialRatio | 层厚度与中间轴长度的最大比率   | 当比率大于指定值时，层生长减少。建议值为0.3                                                                                                                                                                                                           |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nRelaxIter                | 体网格收缩迭代次数             | 单步投影厚度值的迭代中，系统需根据投影厚度值计算体网格收缩松弛系数。该值越大越有利于提高体网格网格质量。建议值为5                                                                                                                                     |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nSmoothNormals            | 体网格平滑迭代次数             | 体网格收缩时，可通过nSmoothNormals指定体网格间移动方向的迭代次数。该值越高，体网格间平滑性越好，但网格划分时间越长。建议值为3                                                                                                                         |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nLayerIter                | 边界层添加的最大总迭代次数     | 如果达到此迭代次数，边界层网格划分将立即停止，并保留最后一次迭代生成的边界层。建议值为50-60                                                                                                                                                           |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nRelaxedIter              | 宽松质量控制标准的起始迭代次数 | 划分边界层网格时会优先使用meshQualityControls中基础质量控制参数，检测网格是否满足要求。若边界层添加算法迭代次数达到用户设置nRelaxedIter参数值后，网格依然不能达到质量控制要求，则在此后的迭代中软件将采用用户设置的宽松质量控制标准值。参数建议值为20 |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+



meshQualityControls
"""""""""""""""""""

meshQualityControls关键词中设置网格质量控制参数。在snappyHexMesh执行全局参数控制、面贴合、局部细化以及边界层生成时，程序都会依据网格质量控制参数不断调整网格迭代，同时，当网格位移或拓扑更改操作导致单元或面网格质量降低时，可根据控制参数撤消移动或拓扑更改操作以将网格还原为之前满足网格质量标准的状态。在该关键词内需要设定的内容如下：

+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| 关键词              | 含义                             | 常见赋值 | 备注                                                                                                                                                                                                                                                                        |
+=====================+==================================+==========+=============================================================================================================================================================================================================================================================================+
| maxNonOrtho         | 最大非正交角                     | 65       | 该参数指定允许的最大非正交角，其通过计算相邻两单元中心点向量与公共面法向量的夹角，此值为0时表示相邻两个网格完全正交。默认参考值为65，当设置为180时，表示关闭此项控制。该参数是衡量网格质量的主要指标之一。                                                                  |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| maxBoundarySkewness | 最大边界面网格偏斜度             | 20       | 此参数指定边界面网格允许的最大偏斜度。其定义一个面或体与理想几何(即等边或等角)的接近程度。默认参考值为20，当设置小于0的值时，表示关闭此项控制。                                                                                                                             |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| maxInternalSkewness | 最大内部面网格偏斜度             | 4        | 参数计算方式与最大边界面网格偏斜度一致，不过其主要测试内部网格质量。默认参考值为4，当设置小于0的值时，表示关闭此项控制。该参数是衡量网格质量的主要指标之一。                                                                                                                |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| maxConcave          | 最大凹度                         | 80       | 该参数用于检查构成面的内凹角度，以允许低于该角度的凹面。0表示直面，小于0表示凸面。默认参考值为80，当设置为180时，表示关闭此项控制。                                                                                                                                         |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minFlatness         | 最小平整值                       | 0.5      | 最小投影面积和实际面积的比值，该参数值为1时，表示检测面为平面。默认参数为0.5，设置为-1时，表示禁用此项控制。                                                                                                                                                                |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minVol              | 最小单元体积                     | 1e-13    | 该参数为允许最小金字塔单元体积，其为网格绝对体积参数（单位m3），默认参数为1e-13。设置为较大的负值时（例如-1e30），表示禁用此项控制。该参数是衡量网格质量的主要指标之一。                                                                                                    |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minArea             | 最小网格面面积                   | -1       | 该参数为允许最小网格面的面积，默认为-1，该参数设置为负值时，表示禁用此项控制。                                                                                                                                                                                              |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minTwist            | 最小面扭曲                       | 0.05     | 使用面中心将面分解为三角形单元，并通过相邻两个单元中心点向量与分解后三角形面法向量的点积计算面扭曲值。默认参考值为0.05，当设置参数小于-1时，表示关闭此项控制。                                                                                                              |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minDeterminant      | 最小归一化单元行列式值           | 0.001    | 通过计算每一个六面体的雅可比行列式值，然后标准化行列式的矩阵来表征单元的变形。参数值取值范围为0到1，参数值设置为1 表示只允许有理想六面体网格；如果某单元行列式的值为0，则这个立方体有一个或多个退化的边。参数值设置小于或等于0表示允许有负体积单元，默认参数值为0.001。     |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minFaceWeight       | 相邻网格间面权重最小值           | 0.05     | 其定义了面相对于相邻单元间中心的相对位置（正交时为0.5），计算方法是先计算出单元中心到公共面中心长度L1，再计算出相邻单元中心到公共面中心长度L2，面权重值等于L1与L2的最小值除以L1与L2之和。较小的面权重值表示相邻网格尺寸相差较大。参数值取值范围为0到0.5，默认参考值为0.05。 |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minVolRatio         | 相邻网格间的最小体积膨胀率       | 0.01     | 该参数指定允许相邻网格间的最小体积膨胀率, 参数值取值范围为0到1， 默认参考值为0.01。较大的比值会导致插值结果误差较大。                                                                                                                                                       |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minTriangleTwist    | 最小三角单元扭曲值               | -1       | 该参数表示允许最小三角单元扭曲值，通过使用面中心将面分解为三角形单元，然后依据相邻的三角形单元法向量的点积计算出三角形面扭曲值。默认参数值为-1，表示禁用此功能。若参数值大于0，则启用此功能项。其主要目的为确保生成网格与Fluent网格的兼容性。                               |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minTetQuality       | ?                                | 1e-30    | 通过网格单元中心和面中心将单元分解为四面体，然后根据圆周半径（Rc）和四面体体积（Vtet）计算四面体单元质量。对于一些跟踪算例时（如流线计算），该参数需要设置为一个较小正值，以确保内部单元质量检查正常运行。默认参数值为1e-30。                                               |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nSmoothScale        | 每次网格缩放恢复迭代时的平滑次数 | 4        | snappyHexMesh网格划分过程中可将局部网格缩放到之前网格质量满足标准的状态。可通过nSmoothScale参数指定每次网格缩放恢复迭代时的平滑次数，参数默认值为4。                                                                                                                        |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| errorReduction      | 误差点处的缩放位移量             | 0.75     | errorReduction参数同nSmoothScale参数一样应用于网格缩放恢复迭代，用户可通过该参数减小误差点处的缩放位移量，参数默认值为0.75。                                                                                                                                                |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| relaxed             | 相对宽松的上述标准列表           | ?        | 在划分边界层网格时会优先使用meshQualityControls中基础质量控制参数，检测网格是否满足要求。若边界层添加算法迭代次数达到用户设置nRelaxedIter参数值后，网格依然不能达到质量控制要求，则在此后的迭代中软件将采用设置的宽松质量控制标准值，以提高边界层网格的覆盖率。             |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+


snappyHexMeshDict模板
^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    /*--------------------------------*- C++ -*----------------------------------*\
      =========                 |
      \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
       \\    /   O peration     | Website:  https://openfoam.org
        \\  /    A nd           | Version:  10
         \\/     M anipulation  |
    \*---------------------------------------------------------------------------*/
    FoamFile
    {
        format      ascii;
        class       dictionary;
        object      snappyHexMeshDict;
    }
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    #includeEtc "caseDicts/mesh/generation/snappyHexMeshDict.cfg"

    castellatedMesh true;
    snap            true;
    addLayers       true;  // create boundary layers

    geometry
    {
        combined
        {
            type triSurfaceMesh;
            file "combined.stl";
            
            regions
            {
                sideFace { name sideFace; }
                topFace { name topFace; }
                leftFace { name leftFace; }
                rightFace { name rightFace; }
            }
        }
        
        /*
        refinementBox    
        {
            type searchableBox;    
            min  (-4 -4 -1);
            max  ( 4  4  4);
        }
        */
    };

    castellatedMeshControls
    {
        features
        (
          { file  "combined.eMesh"; level 0; }
        );

        refinementSurfaces
        {
            combined
            {
            level (0 0);
            
                regions
                {
                sideFace
                {
                    level (0 0);
                    patchInfo { type patch; }
                }
                topFace
                {
                    level (0 0);
                    patchInfo { type patch; }
                }
                leftFace
                {
                    level (0 0);
                    patchInfo { type patch; }
                }
                rightFace
                {
                    level (0 0);
                    patchInfo { type patch; }
                }
                }
            }
        }
        /*
        refinementRegions
        {
            refinementBox  
            {
                mode    inside;
                level   1;
            }
        }
        */
        


        locationInMesh (0 0 2.25);
        
        resolveFeatureAngle    15;
        nCellsBetweenLevels    2;
    }

    snapControls
    {
        explicitFeatureSnap    true;
        implicitFeatureSnap    false;
        multiRegionFeatureSnap false;
        
        nSmoothPatch        0;
        nSmoothInternal     0;
        tolerance           5;
        nSolveIter          100;
        nRelaxIter          10;
        nFeatureSnapIter    10;
        nFaceSplitInterval  5;
    }

    addLayersControls
    {
        layers
        {
            sideFace
            {
                nSurfaceLayers 3;
            }
        }

        relativeSizes       false;
        expansionRatio      1.2;
        finalLayerThickness 0.15;
        minThickness        0.0;
        nGrow               0;
        
        featureAngle             130;
        nRelaxIter               30;
        nSmoothSurfaceNormals    3;
        nSmoothNormals           8;
        nSmoothThickness         10;
        maxFaceThicknessRatio    0.5;
        maxThicknessToMedialRatio  1;
        minMedianAxisAngle       130;
        nBufferCellsNoExtrude    0;
        nLayerIter               50;
    }

    meshQualityControls
    {
        #include "meshQualityDict"
        
        maxNonOrtho             65;
        maxBoundarySkewness     20;
        maxInternalSkewness     4;
        maxConcave              80;
        minFlatness             0.5;
        minArea                 0.01;
    }

    /*
    writeFlags
    (
        scalarLevels
        layerSets
        layerFields
    );
    */

    mergeTolerance 1e-6;

    // ************************************************************************* //






网格检查
--------

在通过blockMesh或snappyHexMesh生成网格之后，可以在算例目录下运行下面的命令来查看网格质量是否合格：

.. code-block:: shell

    checkMesh






残差监控
========


在算例目录下输入下面的命令：

.. code-block:: shell

    foamGet residuals

选择第一个文件，就会在system文件夹内创建residuals文件，其基本内容如下所示：

.. code-block:: C

    #includeEtc "caseDicts/postProcessing/numerical/residuals.cfg"

    fields (p U);

其中 :code:`fields` 关键词决定了之后运行的时候需要检测残差变化的变量，可以根据需要自行添加变量名。在写好residuals文件之后，还需要进入controlDict文件中添加下面的内容：

.. code-block:: C

    functions
    {
            #includeFunc    residuals
    }


如此就设定好了残差检测。运行算例之后，就会创建postProcessing/residuals/0/residuals.dat文件，其中记录了之前设置变量的残差变化数据集。

该数据文件的数据是右对齐的，而且通过空格分隔。如果将其转换为csv文件然后用Python来读取，则可以通过下面的方式来进行：（核心是指定分隔符为多位空格"\s+"）

.. code-block:: python

    df = pd.read_csv("line.csv", sep="\s+")






physicalProperties文件
========================

physicalProperties文件给定所有流体属性的参数值，按照“物理量名+量纲+数值”的形式进行定义。量纲由方括号内的七个数定义，七个数代表SI标准和USCS标准的量纲的幂：

+------+----------+--------+-----------+
| 编号 | 名称     | SI单位 | USCS单位  |
+======+==========+========+===========+
| 1    | 质量     | kg     | lbm       |
+------+----------+--------+-----------+
| 2    | 长度     | m      | ft        |
+------+----------+--------+-----------+
| 3    | 时间     | s      | s         |
+------+----------+--------+-----------+
| 4    | 温度     | K      | °R        |
+------+----------+--------+-----------+
| 5    | 物质的量 | kg/mol | lbmol     |
+------+----------+--------+-----------+
| 6    | 电流     | A      | A         |
+------+----------+--------+-----------+
| 7    | 光强     | cd     | cd        |
+------+----------+--------+-----------+



常见的物理特性参数的关键字与其对应的量纲如下：

+----------+--------------+-------------+------------------------------------+--------------------------+
| 物理特性 | 符号         | 关键字      | 量纲                               | dimensionSet             |
+==========+==============+=============+====================================+==========================+
| 运动粘度 | :math:`\nu`  | :code:`nu`  | :math:`\mathrm{m^{2}\cdot s^{-1}}` | :code:`[0 2 -1 0 0 0 0]` |
+----------+--------------+-------------+------------------------------------+--------------------------+
| 密度     | :math:`\rho` | :code:`rho` | :math:`\mathrm{kg\cdot m^{-3}}`    | :code:`[1 -3 0 0 0 0 0]` |
+----------+--------------+-------------+------------------------------------+--------------------------+




应力分析是会用到的物理特性参数：


+------------+----------------+----------------+---------------------------------------------+---------------------------+
| 物理特性   | 符号           | 关键字         | 量纲                                        | dimensionSet              |
+============+================+================+=============================================+===========================+
| 密度       | :math:`\rho`   | :code:`rho`    | :math:`\mathrm{kg\cdot m^{-3}}`             | :code:`[1 -3 0 0 0 0 0]`  |
+------------+----------------+----------------+---------------------------------------------+---------------------------+
| 杨氏模量   | :math:`E`      | :code:`E`      | :math:`\mathrm{Pa}`                         | :code:`[1 -1 -2 0 0 0 0]` |
+------------+----------------+----------------+---------------------------------------------+---------------------------+
| 泊松比     | :math:`\nu`    | :code:`nu`     |                                             | :code:`[0 0 0 0 0 0 0]`   |
+------------+----------------+----------------+---------------------------------------------+---------------------------+
| 比热容     | :math:`C_{p}`  | :code:`Cp`     | :math:`\mathrm{J\cdot kg^{-1}\cdot K^{-1}}` | :code:`[0 2 -2 -1 0 0 0]` |
+------------+----------------+----------------+---------------------------------------------+---------------------------+
| 热导率     | :math:`\kappa` | :code:`kappa`  | :math:`\mathrm{W\cdot m^{-1}\cdot K^{-1}}`  | :code:`[1 1 -3 -1 0 0 0]` |
+------------+----------------+----------------+---------------------------------------------+---------------------------+
| 热膨胀系数 | :math:`\alpha` | :code:`alphav` | :math:`\mathrm{K^{-1}}`                     | :code:`[0 0 0 -1 0 0 0]`  |
+------------+----------------+----------------+---------------------------------------------+---------------------------+





热物理模型
=============


每个调用热物理模型库的求解器均会构建一个具体的热物理模型类。每个组分都需要输入基本的热物理参数。他们必须以组分名作为关键词，其后是子字典，包含的参数主要有specie、thermoDynamics、transport。下面是一个经典的设置案例：

.. code-block:: C

    thermoType
    {
        type            hePsiThermo;
        mixture         pureMixture;
        transport       const;
        thermo          hConst;
        equationOfState perfectGas;
        specie          specie;
        energy          sensibleInternalEnergy;
    }

    mixture
    {
        specie
        {
            molWeight       352;  // 摩尔质量g/mol
        }
        thermodynamics
        {
            Cp              385;  // J/(kg.K)
            Hf              0;
        }
        transport
        {
            mu              1.83e-5;  // Pa.s
            Pr              1.155;    // 普朗特数
        }
    }


thermoType
------------

在physicalProperties文件中的thermoType关键词下指定运行中的热物理模型。

+-------------------------+--------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| 热物理模型类            | 简介                                                                                                         | 涉及求解器                                                                                                                                                                              |
+=========================+==============================================================================================================+=========================================================================================================================================================================================+
| psiThermo               | 固定组分、基于可压缩性 :math:`\psi = (RT)^{-1}` 的热物理模型库， :math:`R` 为理想气体常数， :math:`T` 为温度 | 调用该类的求解器主要为可压缩求解器，例如rhoCentralFoam、uncoupledKinematicParcelFoam以及coldEngineFoam                                                                                  |
+-------------------------+--------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| rhoThermo               | 固定组分、基于密度 :math:`\rho` 的热物理模型库                                                               | 调用该类的求解器主要为传热类求解器，例如 buoyantSimpleFoam、buoyantPimpleFoam、rhoPorousSimpleFoam、twoPhaseEulerFoam以及thermoFoam                                                     |
+-------------------------+--------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| psiReactionThermo       | 基于可压缩性 :math:`\psi` 的附加反应的热物理模型库                                                           | 调用该类的求解器主要为燃烧求解器，例如sprayFoam、engineFoam、fireFoam、reactingFoam，以及一些拉格朗日求解器，例如coalChemistryFoam                                                      |
+-------------------------+--------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| psiuReactionThermo      | 基于未燃气体可压缩性 :math:`\psi u` 的反应混合热物理模型库                                                   | 调用该类的求解器主要为燃烧求解器，这些求解器的物理模型基于层流火焰速度以及回归变量，如XiFoam、XiEngineFoam和PDRFoam                                                                     |
+-------------------------+--------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| rhoReactionThermo       | 基于密度 :math:`\rho` 的反应混合热物理模型库                                                                 | 调用该类的求解器主要为chtMultiRegionFoam以及一些燃烧求解器，如chemFoam、rhoReactinFoam、rhoReactingBuoyantFoam， 以及一些拉格朗日求解器，如reactingParcelFoam和simpleReactingParcelFoam |
+-------------------------+--------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| multiPhaseMixtureThermo | 多相流热物理模型库                                                                                           | 调用该类的求解器主要为可压缩多相界面捕获求解器，如compressibleInterFoam、compressibleMultiphaseInterFoam                                                                                |
+-------------------------+--------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+


heThermo
^^^^^^^^^^^

.. code-block:: C
    :caption: src/thermophysicalModels/basic/heThermo/heThermo.C

    template<class BasicThermo, class MixtureType>
    template
    <
        class CellMixture,
        class PatchFaceMixture,
        class Method,
        class ... Args
    >
    Foam::tmp<Foam::volScalarField>
    Foam::heThermo<BasicThermo, MixtureType>::volScalarFieldProperty
    (
        const word& psiName,
        const dimensionSet& psiDim,
        CellMixture cellMixture,
        PatchFaceMixture patchFaceMixture,
        Method psiMethod,
        const Args& ... args
    ) const
    {
        tmp<volScalarField> tPsi    // 利用传入的名称和量纲创建该物理量对象
        (
            volScalarField::New
            (
                IOobject::groupName(psiName, this->group()),
                this->T_.mesh(),
                psiDim
            )
        );

        volScalarField& psi = tPsi.ref();

        forAll(this->T_, celli)    // 利用传入的cellMixture规定的psiMethod来计算网格体心处该物理量的值
        {
            psi[celli] = ((this->*cellMixture)(celli).*psiMethod)(args[celli] ...);
        }

        volScalarField::Boundary& psiBf = psi.boundaryFieldRef();

        forAll(psiBf, patchi)    // 利用传入的patchFaceMixture规定的psiMethod来计算边界处该物理量的值
        {
            fvPatchScalarField& pPsi = psiBf[patchi];

            forAll(this->T_.boundaryField()[patchi], facei)
            {
                pPsi[facei] = ((this->*patchFaceMixture)(patchi, facei).*psiMethod)(args.boundaryField()[patchi][facei] ...);
            }
        }

        return tPsi;
    }


    template<class BasicThermo, class MixtureType>
    template<class CellMixture, class Method, class ... Args>
    Foam::tmp<Foam::scalarField>
    Foam::heThermo<BasicThermo, MixtureType>::cellSetProperty
    (
        CellMixture cellMixture,
        Method psiMethod,
        const labelList& cells,
        const Args& ... args
    ) const
    {
        // Note: Args are fields for the set, not for the mesh as a whole. The cells list is only used to get the mixture.
        tmp<scalarField> tPsi(new scalarField(cells.size()));    // 在传入的网格位置创建该物理量的对象
        scalarField& psi = tPsi.ref();

        forAll(cells, celli)    // 利用传入的cellMixture规定的psiMethod来计算该物理量的值
        {
            psi[celli] = ((this->*cellMixture)(cells[celli]).*psiMethod)(args[celli] ...);
        }

        return tPsi;
    }


    template<class BasicThermo, class MixtureType>
    template<class PatchFaceMixture, class Method, class ... Args>
    Foam::tmp<Foam::scalarField>
    Foam::heThermo<BasicThermo, MixtureType>::patchFieldProperty
    (
        PatchFaceMixture patchFaceMixture,
        Method psiMethod,
        const label patchi,
        const Args& ... args
    ) const
    {
        tmp<scalarField> tPsi    // 在网格边界处新建该物理量的对象
        (
            new scalarField(this->T_.boundaryField()[patchi].size())
        );
        scalarField& psi = tPsi.ref();

        forAll(this->T_.boundaryField()[patchi], facei)    // 利用传入的patchFaceMixture规定的psiMethod来计算该物理量的值
        {
            psi[facei] = ((this->*patchFaceMixture)(patchi, facei).*psiMethod)(args[facei] ...);
        }

        return tPsi;
    }


    template<class BasicThermo, class MixtureType>
    Foam::UIndirectList<Foam::scalar>
    Foam::heThermo<BasicThermo, MixtureType>::cellSetScalarList
    (
        const volScalarField& psi,
        const labelList& cells
    )
    {
        return UIndirectList<scalar>(psi, cells);
    }


    template<class BasicThermo, class MixtureType>
    Foam::UniformField<Foam::scalar>
    Foam::heThermo<BasicThermo, MixtureType>::cellSetScalarList
    (
        const uniformGeometricScalarField& psi,
        const labelList&
    )
    {
        return psi.primitiveField();
    }


    template<class BasicThermo, class MixtureType>
    void Foam::heThermo<BasicThermo, MixtureType>::
    heBoundaryCorrection(volScalarField& h)
    {
        volScalarField::Boundary& hBf = h.boundaryFieldRef();

        forAll(hBf, patchi)
        {
            if (isA<gradientEnergyFvPatchScalarField>(hBf[patchi]))
            {
                refCast<gradientEnergyFvPatchScalarField>(hBf[patchi]).gradient() = hBf[patchi].fvPatchField::snGrad();
            }
            else if (isA<mixedEnergyFvPatchScalarField>(hBf[patchi]))
            {
                refCast<mixedEnergyFvPatchScalarField>(hBf[patchi]).refGrad() = hBf[patchi].fvPatchField::snGrad();
            }
        }
    }


    // * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //

    template<class BasicThermo, class MixtureType>
    Foam::heThermo<BasicThermo, MixtureType>::heThermo
    (
        const fvMesh& mesh,
        const word& phaseName
    )
    :
        BasicThermo(mesh, phaseName),
        MixtureType(*this, mesh, phaseName),

        he_
        (
            IOobject
            (
                BasicThermo::phasePropertyName
                (
                    MixtureType::thermoType::heName(),
                    phaseName
                ),
                mesh.time().timeName(),
                mesh,
                IOobject::NO_READ,
                IOobject::NO_WRITE
            ),
            volScalarFieldProperty
            (
                "he",
                dimEnergy/dimMass,
                &MixtureType::cellThermoMixture,
                &MixtureType::patchFaceThermoMixture,
                &MixtureType::thermoMixtureType::HE,
                this->p_,
                this->T_
            ),
            this->heBoundaryTypes(),
            this->heBoundaryBaseTypes()
        ),

        Cp_
        (
            IOobject
            (
                BasicThermo::phasePropertyName("Cp", phaseName),
                mesh.time().timeName(),
                mesh
            ),
            mesh,
            dimensionedScalar(dimEnergy/dimMass/dimTemperature, Zero)
        ),

        Cv_
        (
            IOobject
            (
                BasicThermo::phasePropertyName("Cv", phaseName),
                mesh.time().timeName(),
                mesh
            ),
            mesh,
            dimensionedScalar(dimEnergy/dimMass/dimTemperature, Zero)
        )
    {
        heBoundaryCorrection(he_);
    }


    // * * * * * * * * * * * * * * * * Destructor  * * * * * * * * * * * * * * * //

    template<class BasicThermo, class MixtureType>
    Foam::heThermo<BasicThermo, MixtureType>::~heThermo()
    {}


    // * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //

    template<class BasicThermo, class MixtureType>
    Foam::tmp<Foam::volScalarField> Foam::heThermo<BasicThermo, MixtureType>::he    // 焓或者内能
    (
        const volScalarField& p,
        const volScalarField& T
    ) const
    {
        return volScalarFieldProperty
        (
            "he",
            dimEnergy/dimMass,
            &MixtureType::cellThermoMixture,         // mixture定义
            &MixtureType::patchFaceThermoMixture,    // mixture定义
            &MixtureType::thermoMixtureType::HE,     // energy定义
            p,
            T
        );
    }


    template<class BasicThermo, class MixtureType>
    Foam::tmp<Foam::scalarField> Foam::heThermo<BasicThermo, MixtureType>::he    // 焓或者内能
    (
        const scalarField& T,
        const labelList& cells
    ) const
    {
        return cellSetProperty
        (
            &MixtureType::cellThermoMixture,        // mixture定义
            &MixtureType::thermoMixtureType::HE,    // energy定义
            cells,
            cellSetScalarList(this->p_, cells),
            T
        );
    }


    template<class BasicThermo, class MixtureType>
    Foam::tmp<Foam::scalarField> Foam::heThermo<BasicThermo, MixtureType>::he    // 焓或者内能
    (
        const scalarField& T,
        const label patchi
    ) const
    {
        return patchFieldProperty
        (
            &MixtureType::patchFaceThermoMixture,
            &MixtureType::thermoMixtureType::HE,
            patchi,
            this->p_.boundaryField()[patchi],
            T
        );
    }


    template<class BasicThermo, class MixtureType>
    Foam::tmp<Foam::volScalarField>
    Foam::heThermo<BasicThermo, MixtureType>::hs() const    // 显焓
    {
        return volScalarFieldProperty
        (
            "hs",
            dimEnergy/dimMass,
            &MixtureType::cellThermoMixture,
            &MixtureType::patchFaceThermoMixture,
            &MixtureType::thermoMixtureType::Hs,
            this->p_,
            this->T_
        );
    }


    template<class BasicThermo, class MixtureType>
    Foam::tmp<Foam::volScalarField> Foam::heThermo<BasicThermo, MixtureType>::hs    // 显焓
    (
        const volScalarField& p,
        const volScalarField& T
    ) const
    {
        return volScalarFieldProperty
        (
            "hs",
            dimEnergy/dimMass,
            &MixtureType::cellThermoMixture,
            &MixtureType::patchFaceThermoMixture,
            &MixtureType::thermoMixtureType::Hs,
            p,
            T
        );
    }


    template<class BasicThermo, class MixtureType>
    Foam::tmp<Foam::scalarField> Foam::heThermo<BasicThermo, MixtureType>::hs    // 显焓
    (
        const scalarField& T,
        const labelList& cells
    ) const
    {
        return cellSetProperty
        (
            &MixtureType::cellThermoMixture,
            &MixtureType::thermoMixtureType::Hs,
            cells,
            cellSetScalarList(this->p_, cells),
            T
        );
    }


    template<class BasicThermo, class MixtureType>
    Foam::tmp<Foam::scalarField> Foam::heThermo<BasicThermo, MixtureType>::hs    // 显焓
    (
        const scalarField& T,
        const label patchi
    ) const
    {
        return patchFieldProperty
        (
            &MixtureType::patchFaceThermoMixture,
            &MixtureType::thermoMixtureType::Hs,
            patchi,
            this->p_.boundaryField()[patchi],
            T
        );
    }


    template<class BasicThermo, class MixtureType>
    Foam::tmp<Foam::volScalarField>
    Foam::heThermo<BasicThermo, MixtureType>::ha() const    // 绝对焓
    {
        return volScalarFieldProperty
        (
            "ha",
            dimEnergy/dimMass,
            &MixtureType::cellThermoMixture,
            &MixtureType::patchFaceThermoMixture,
            &MixtureType::thermoMixtureType::Ha,
            this->p_,
            this->T_
        );
    }


    template<class BasicThermo, class MixtureType>
    Foam::tmp<Foam::volScalarField> Foam::heThermo<BasicThermo, MixtureType>::ha    // 绝对焓
    (
        const volScalarField& p,
        const volScalarField& T
    ) const
    {
        return volScalarFieldProperty
        (
            "ha",
            dimEnergy/dimMass,
            &MixtureType::cellThermoMixture,
            &MixtureType::patchFaceThermoMixture,
            &MixtureType::thermoMixtureType::Ha,
            p,
            T
        );
    }


    template<class BasicThermo, class MixtureType>
    Foam::tmp<Foam::scalarField> Foam::heThermo<BasicThermo, MixtureType>::ha    // 绝对焓
    (
        const scalarField& T,
        const labelList& cells
    ) const
    {
        return cellSetProperty
        (
            &MixtureType::cellThermoMixture,
            &MixtureType::thermoMixtureType::Ha,
            cells,
            cellSetScalarList(this->p_, cells),
            T
        );
    }


    template<class BasicThermo, class MixtureType>
    Foam::tmp<Foam::scalarField> Foam::heThermo<BasicThermo, MixtureType>::ha    // 绝对焓
    (
        const scalarField& T,
        const label patchi
    ) const
    {
        return patchFieldProperty
        (
            &MixtureType::patchFaceThermoMixture,
            &MixtureType::thermoMixtureType::Ha,
            patchi,
            this->p_.boundaryField()[patchi],
            T
        );
    }


    template<class BasicThermo, class MixtureType>
    Foam::tmp<Foam::volScalarField>
    Foam::heThermo<BasicThermo, MixtureType>::hc() const    // 生成焓
    {
        return volScalarFieldProperty
        (
            "hc",
            dimEnergy/dimMass,
            &MixtureType::cellThermoMixture,
            &MixtureType::patchFaceThermoMixture,
            &MixtureType::thermoMixtureType::Hf
        );
    }


    template<class BasicThermo, class MixtureType>
    Foam::tmp<Foam::scalarField> Foam::heThermo<BasicThermo, MixtureType>::Cp    // 定压比热容
    (
        const scalarField& T,
        const label patchi
    ) const
    {
        return patchFieldProperty
        (
            &MixtureType::patchFaceThermoMixture,
            &MixtureType::thermoMixtureType::Cp,
            patchi,
            this->p_.boundaryField()[patchi],
            T
        );
    }


    template<class BasicThermo, class MixtureType>
    Foam::tmp<Foam::scalarField>
    Foam::heThermo<BasicThermo, MixtureType>::Cv    // 定体比热容
    (
        const scalarField& T,
        const label patchi
    ) const
    {
        return patchFieldProperty
        (
            &MixtureType::patchFaceThermoMixture,
            &MixtureType::thermoMixtureType::Cv,
            patchi,
            this->p_.boundaryField()[patchi],
            T
        );
    }


    template<class BasicThermo, class MixtureType>
    Foam::tmp<Foam::scalarField> Foam::heThermo<BasicThermo, MixtureType>::gamma    // 比热容比
    (
        const scalarField& T,
        const label patchi
    ) const
    {
        return patchFieldProperty
        (
            &MixtureType::patchFaceThermoMixture,
            &MixtureType::thermoMixtureType::gamma,
            patchi,
            this->p_.boundaryField()[patchi],
            T
        );
    }


    template<class BasicThermo, class MixtureType>
    Foam::tmp<Foam::volScalarField>
    Foam::heThermo<BasicThermo, MixtureType>::gamma() const    // 比热容比
    {
        return volScalarField::New("gamma", Cp_/Cv_);
    }


    template<class BasicThermo, class MixtureType>
    Foam::tmp<Foam::scalarField> Foam::heThermo<BasicThermo, MixtureType>::Cpv    // 定压比热容或定体比热容
    (
        const scalarField& T,
        const label patchi
    ) const
    {
        if (MixtureType::thermoType::enthalpy())
        {
            return Cp(T, patchi);
        }
        else
        {
            return Cv(T, patchi);
        }
    }


    template<class BasicThermo, class MixtureType>
    Foam::tmp<Foam::volScalarField>
    Foam::heThermo<BasicThermo, MixtureType>::Cpv() const    // 定压比热容或定体比热容
    {
        if (MixtureType::thermoType::enthalpy())
        {
            return Cp_;
        }
        else
        {
            return Cv_;
        }
    }


    template<class BasicThermo, class MixtureType>
    Foam::tmp<Foam::volScalarField> Foam::heThermo<BasicThermo, MixtureType>::THE    // 由焓或内能得到的温度
    (
        const volScalarField& h,
        const volScalarField& p,
        const volScalarField& T0
    ) const
    {
        return volScalarFieldProperty
        (
            "T",
            dimTemperature,
            &MixtureType::cellThermoMixture,
            &MixtureType::patchFaceThermoMixture,
            &MixtureType::thermoMixtureType::THE,
            h,
            p,
            T0
        );
    }


    template<class BasicThermo, class MixtureType>
    Foam::tmp<Foam::scalarField> Foam::heThermo<BasicThermo, MixtureType>::THE    // 由焓或内能得到的温度
    (
        const scalarField& h,
        const scalarField& T0,
        const labelList& cells
    ) const
    {
        return cellSetProperty
        (
            &MixtureType::cellThermoMixture,
            &MixtureType::thermoMixtureType::THE,
            cells,
            h,
            cellSetScalarList(this->p_, cells),
            T0
        );
    }


    template<class BasicThermo, class MixtureType>
    Foam::tmp<Foam::scalarField> Foam::heThermo<BasicThermo, MixtureType>::THE    // 由焓或内能得到的温度
    (
        const scalarField& h,
        const scalarField& T0,
        const label patchi
    ) const
    {
        return patchFieldProperty
        (
            &MixtureType::patchFaceThermoMixture,
            &MixtureType::thermoMixtureType::THE,
            patchi,
            h,
            this->p_.boundaryField()[patchi],
            T0
        );
    }


    template<class BasicThermo, class MixtureType>
    Foam::tmp<Foam::volScalarField>
    Foam::heThermo<BasicThermo, MixtureType>::W() const    // 分子量
    {
        return volScalarFieldProperty
        (
            "W",
            dimMass/dimMoles,
            &MixtureType::cellThermoMixture,
            &MixtureType::patchFaceThermoMixture,
            &MixtureType::thermoMixtureType::W
        );
    }


    template<class BasicThermo, class MixtureType>
    Foam::tmp<Foam::scalarField> Foam::heThermo<BasicThermo, MixtureType>::W    // 分子量
    (
        const label patchi
    ) const
    {
        return patchFieldProperty
        (
            &MixtureType::patchFaceThermoMixture,
            &MixtureType::thermoMixtureType::W,
            patchi
        );
    }


    template<class BasicThermo, class MixtureType>
    Foam::tmp<Foam::volScalarField>
    Foam::heThermo<BasicThermo, MixtureType>::alphahe() const    // 混合物能量的热扩散率
    {
        if (MixtureType::thermoType::enthalpy())
        {
            return volScalarField::New("alphahe", this->kappa_/Cp_);
        }
        else
        {
            return volScalarField::New("alphahe", this->kappa_/Cv_);
        }
    }


    template<class BasicThermo, class MixtureType>
    Foam::tmp<Foam::scalarField>
    Foam::heThermo<BasicThermo, MixtureType>::alphahe(const label patchi) const    // 混合物能量的热扩散率
    {
        if (MixtureType::thermoType::enthalpy())
        {
            return this->kappa_.boundaryField()[patchi]/Cp_.boundaryField()[patchi];
        }
        else
        {
            return this->kappa_.boundaryField()[patchi]/Cv_.boundaryField()[patchi];
        }
    }


    template<class BasicThermo, class MixtureType>
    Foam::tmp<Foam::volScalarField>
    Foam::heThermo<BasicThermo, MixtureType>::kappaEff    // 混合物的有效湍流热导率
    (
        const volScalarField& alphat
    ) const
    {
        return volScalarField::New("kappaEff", this->kappa_ + Cp_*alphat);
    }


    template<class BasicThermo, class MixtureType>
    Foam::tmp<Foam::scalarField>
    Foam::heThermo<BasicThermo, MixtureType>::kappaEff    // 混合物的有效湍流热导率
    (
        const scalarField& alphat,
        const label patchi
    ) const
    {
        return this->kappa_.boundaryField()[patchi] + Cp(this->T_.boundaryField()[patchi], patchi)*alphat;
    }


    template<class BasicThermo, class MixtureType>
    Foam::tmp<Foam::volScalarField>
    Foam::heThermo<BasicThermo, MixtureType>::alphaEff    // 混合物的有效湍流热扩散系数
    (
        const volScalarField& alphat
    ) const
    {
        if (MixtureType::thermoType::enthalpy())
        {
            return volScalarField::New("alphaEff", this->kappa_/Cp_ + alphat);
        }
        else
        {
            return volScalarField::New
            (
                "alphaEff",
                (this->kappa_ + Cp_*alphat)/Cv_
            );
        }
    }


    template<class BasicThermo, class MixtureType>
    Foam::tmp<Foam::scalarField>
    Foam::heThermo<BasicThermo, MixtureType>::alphaEff    // 混合物的有效湍流热扩散系数
    (
        const scalarField& alphat,
        const label patchi
    ) const
    {
        if (MixtureType::thermoType::enthalpy())
        {
            return this->kappa_.boundaryField()[patchi]/Cp_.boundaryField()[patchi] + alphat;
        }
        else
        {
            return (this->kappa_.boundaryField()[patchi] + Cp_.boundaryField()[patchi]*alphat)/Cv_.boundaryField()[patchi];
        }
    }


    template<class BasicThermo, class MixtureType>
    bool Foam::heThermo<BasicThermo, MixtureType>::read()
    {
        if (BasicThermo::read())
        {
            MixtureType::read(*this);
            return true;
        }
        else
        {
            return false;
        }
    }


使用上述的构建模板，heThermo建立了如下的场：

+----------+------------------------------------------------------------------------------------------------------------------------------------------+
| 符号     | 含义                                                                                                                                     |
+==========+==========================================================================================================================================+
| he       | 焓/内能                                                                                                                                  |
+----------+------------------------------------------------------------------------------------------------------------------------------------------+
| Cp       | 定压比热容                                                                                                                               |
+----------+------------------------------------------------------------------------------------------------------------------------------------------+
| Cv       | 定体比热容                                                                                                                               |
+----------+------------------------------------------------------------------------------------------------------------------------------------------+
| hs       | 显焓                                                                                                                                     |
+----------+------------------------------------------------------------------------------------------------------------------------------------------+
| ha       | 绝对焓                                                                                                                                   |
+----------+------------------------------------------------------------------------------------------------------------------------------------------+
| hc       | 生成焓                                                                                                                                   |
+----------+------------------------------------------------------------------------------------------------------------------------------------------+
| THE      | 由焓/内能得到的温度                                                                                                                      |
+----------+------------------------------------------------------------------------------------------------------------------------------------------+
| gamma    | 比热容比，为 :math:`c_{p}/c_{v}`                                                                                                         |
+----------+------------------------------------------------------------------------------------------------------------------------------------------+
| Cpv      | 在恒压/恒容条件下的比热容，当使用焓时为 :math:`c_{p}` ；当使用内能时为 :math:`c_{v}`                                                     |
+----------+------------------------------------------------------------------------------------------------------------------------------------------+
| W        | 分子量                                                                                                                                   |
+----------+------------------------------------------------------------------------------------------------------------------------------------------+
| alphahe  | 混合物能量的热扩散率，当使用焓时为 :math:`\kappa/c_{p}` ；当使用内能时为 :math:`\kappa/c_{v}`                                            |
+----------+------------------------------------------------------------------------------------------------------------------------------------------+
| kappaEff | 混合物的有效热湍导率，为 :math:`\kappa + c_{p}\alpha_{t}`                                                                                |
+----------+------------------------------------------------------------------------------------------------------------------------------------------+
| alphaEff | 混合物能量的有效湍流热扩散系数，当使用焓时为 :math:`\kappa/c_{p} + \alpha_{t}` ；当使用内能时为 :math:`(\kappa + c_{p}\alpha_{t})/c_{v}` |
+----------+------------------------------------------------------------------------------------------------------------------------------------------+





psiThermo
^^^^^^^^^^^

进入src/thermophysicalModels/basic/psiThermo/psiThermo.C文件，可以看到如下代码：

.. code-block:: C

    void Foam::psiThermo::correctRho(const Foam::volScalarField& deltaRho)
    {}

    Foam::tmp<Foam::volScalarField> Foam::psiThermo::implementation::rho() const
    {
        return p()*psi_;    // 利用可压缩性计算密度场的方式为 p*psi
    }

    Foam::tmp<Foam::scalarField> Foam::psiThermo::implementation::rho
    (
        const label patchi
    ) const
    {
        return p().boundaryField()[patchi]*psi_.boundaryField()[patchi];    // 边界处的密度场计算方式
    }

    Foam::tmp<Foam::volScalarField> Foam::psiThermo::implementation::rho0() const
    {
        return p().oldTime()*psi_.oldTime();    // 上一个时间步的密度场
    }

    const Foam::volScalarField& Foam::psiThermo::implementation::psi() const
    {
        return psi_;    // 可压缩性场
    }

    Foam::tmp<Foam::volScalarField> Foam::psiThermo::implementation::mu() const
    {
        return mu_;    // 动力粘度场
    }

    Foam::tmp<Foam::scalarField> Foam::psiThermo::implementation::mu
    (
        const label patchi
    ) const
    {
        return mu_.boundaryField()[patchi];    // 边界处的动力粘度场
    }




type
------

type关键词用来指定具体的热物理模型库：

+----------------+-------------------------------------------------------------------------------+
| 热物理模型库   | 使用场景                                                                      |
+================+===============================================================================+
| hePsiThermo    | 调用fluidThermo，fluidReactionThermo以及psiThermo的求解器需指定               |
+----------------+-------------------------------------------------------------------------------+
| heRhoThermo    | 调用fluidThermo，fluidReactionThermo以及multiphaseMixtureThermo的求解器需指定 |
+----------------+-------------------------------------------------------------------------------+
| heheuPsiThermo | 调用psiuReactionThermo的求解器需指定                                          |
+----------------+-------------------------------------------------------------------------------+



hePsiThermo
^^^^^^^^^^^^^^

这是一个基于压缩性的混合物能量类，它决定了使用hePsiThermo的求解器中thermo.correct()函数所做的内容：

.. code-block:: C
    :caption: src/thermophysicalModels/basic/psiThermo/hePsiThermo.C

    template<class BasicPsiThermo, class MixtureType>
    void Foam::hePsiThermo<BasicPsiThermo, MixtureType>::calculate()
    {
        const scalarField& hCells = this->he_;    // 焓或内能
        const scalarField& pCells = this->p_;     // 压强

        scalarField& TCells = this->T_.primitiveFieldRef();            // 温度
        scalarField& CpCells = this->Cp_.primitiveFieldRef();          // 定压比热容
        scalarField& CvCells = this->Cv_.primitiveFieldRef();          // 定体比热容
        scalarField& psiCells = this->psi_.primitiveFieldRef();        // 可压缩性
        scalarField& muCells = this->mu_.primitiveFieldRef();          // 动力粘度
        scalarField& kappaCells = this->kappa_.primitiveFieldRef();    // 热导率

        forAll(TCells, celli)    // 在温度场内的网格单元内的计算
        {
            const typename MixtureType::thermoMixtureType& thermoMixture = this->cellThermoMixture(celli);
            const typename MixtureType::transportMixtureType& transportMixture = this->cellTransportMixture(celli, thermoMixture);

            TCells[celli] = thermoMixture.THE(hCells[celli], pCells[celli], TCells[celli]);  // 由焓或内能计算温度T，该函数定义在thermoI.H文件中
            CpCells[celli] = thermoMixture.Cp(pCells[celli], TCells[celli]);                 // 根据thermo设置方式计算定压比热容Cp
            CvCells[celli] = thermoMixture.Cv(pCells[celli], TCells[celli]);                 // 根据thermo设置方式计算定体比热容Cv
            psiCells[celli] = thermoMixture.psi(pCells[celli], TCells[celli]);               // 根据thermo设置方式计算可压缩性psi
            muCells[celli] = transportMixture.mu(pCells[celli], TCells[celli]);              // 根据transport设置方式计算动力粘度mu
            kappaCells[celli] = transportMixture.kappa(pCells[celli], TCells[celli]);        // 根据transport设置方式计算热导率kappa
        }

        volScalarField::Boundary& pBf = this->p_.boundaryFieldRef();            // 边界处的压强
        volScalarField::Boundary& TBf = this->T_.boundaryFieldRef();            // 边界处的温度
        volScalarField::Boundary& CpBf = this->Cp_.boundaryFieldRef();          // 边界处的定压比热容
        volScalarField::Boundary& CvBf = this->Cv_.boundaryFieldRef();          // 边界处的定体比热容
        volScalarField::Boundary& psiBf = this->psi_.boundaryFieldRef();        // 边界处的可压缩性
        volScalarField::Boundary& heBf = this->he().boundaryFieldRef();         // 边界处的焓或内能
        volScalarField::Boundary& muBf = this->mu_.boundaryFieldRef();          // 边界处的动力粘度
        volScalarField::Boundary& kappaBf = this->kappa_.boundaryFieldRef();    // 边界处的热导率

        forAll(this->T_.boundaryField(), patchi)    // 在温度场的边界处的计算
        {
            fvPatchScalarField& pp = pBf[patchi];            // 边界处的压强
            fvPatchScalarField& pT = TBf[patchi];            // 边界处的温度
            fvPatchScalarField& pCp = CpBf[patchi];          // 边界处的定压比热容
            fvPatchScalarField& pCv = CvBf[patchi];          // 边界处的定体比热容
            fvPatchScalarField& ppsi = psiBf[patchi];        // 边界处的可压缩性
            fvPatchScalarField& phe = heBf[patchi];          // 边界处的焓或内能
            fvPatchScalarField& pmu = muBf[patchi];          // 边界处的动力粘度
            fvPatchScalarField& pkappa = kappaBf[patchi];    // 边界处的热导率

            if (pT.fixesValue())    // 如果边界处的温度设置为了固定值
            {
                forAll(pT, facei)
                {
                    const typename MixtureType::thermoMixtureType& thermoMixture = this->patchFaceThermoMixture(patchi, facei);
                    const typename MixtureType::transportMixtureType& transportMixture = this->patchFaceTransportMixture(patchi, facei, thermoMixture);

                    phe[facei] = thermoMixture.HE(pp[facei], pT[facei]);             // 根据thermo的设置方式计算边界处的焓或内能
                    pCp[facei] = thermoMixture.Cp(pp[facei], pT[facei]);             // 根据thermo的设置方式计算边界处的定压比热容
                    pCv[facei] = thermoMixture.Cv(pp[facei], pT[facei]);             // 根据thermo的设置方式计算边界处的定体比热容
                    ppsi[facei] = thermoMixture.psi(pp[facei], pT[facei]);           // 根据thermo的设置方式计算边界处的可压缩性
                    pmu[facei] = transportMixture.mu(pp[facei], pT[facei]);          // 根据tansport的设置方式计算边界处的动力粘度
                    pkappa[facei] = transportMixture.kappa(pp[facei], pT[facei]);    // 根据transport的设置方式计算边界处的热导率
                }
            }
            else    // 如果边界处的温度没有设置为固定值
            {
                forAll(pT, facei)
                {
                    const typename MixtureType::thermoMixtureType& thermoMixture = this->patchFaceThermoMixture(patchi, facei);

                    const typename MixtureType::transportMixtureType& transportMixture = this->patchFaceTransportMixture(patchi, facei, thermoMixture);

                    pT[facei] = thermoMixture.THE(phe[facei], pp[facei], pT[facei]);    // 根据thermo的设置方式计算边界处的由焓或内能得到的温度
                    pCp[facei] = thermoMixture.Cp(pp[facei], pT[facei]);                // 根据thermo的设置方式计算边界处的定压比热容
                    pCv[facei] = thermoMixture.Cv(pp[facei], pT[facei]);                // 根据thermo的设置方式计算边界处的定体比热容
                    ppsi[facei] = thermoMixture.psi(pp[facei], pT[facei]);              // 根据thermo的设置方式计算边界处的可压缩性
                    pmu[facei] = transportMixture.mu(pp[facei], pT[facei]);             // 根据tansport的设置方式计算边界处的动力粘度
                    pkappa[facei] = transportMixture.kappa(pp[facei], pT[facei]);       // 根据transport的设置方式计算边界处的热导率
                }
            }
        }
    }




mixture
-----------

mixture关键词指定混合组分。无反应的热物理模型库通常使用pureMixture，也即固定组分。当指定pureMixture的时候，相关的热物理模型系数在mixture子字典中指定。


pureMixture
^^^^^^^^^^^^^

.. code-block:: C
    :caption: src/thermophysicalModels/basic/mixtures/pureMixture/pureMixture.C

    template<class ThermoType>
    Foam::pureMixture<ThermoType>::pureMixture
    (
        const dictionary& thermoDict,
        const fvMesh& mesh,
        const word& phaseName
    )
    :
        basicMixture(thermoDict, mesh, phaseName),
        mixture_(thermoDict.subDict("mixture"))
    {}

    template<class ThermoType>
    void Foam::pureMixture<ThermoType>::read(const dictionary& thermoDict)
    {
        mixture_ = ThermoType(thermoDict.subDict("mixture"));    // 读取thermoType字典中mixture关键词的设置
    }




transport
-------------


transport传递模型需要计算动力粘度 :math:`\mu` 、热导率 :math:`\kappa` 、扩散率(用于内能方程或焓方程中) :math:`\alpha` 。可选的transport模型有：

+---------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| transport模型 | 含义                                                                                                                                                                                     |
+===============+==========================================================================================================================================================================================+
| const         | 粘度 :math:`\mu` 为常数，普朗特数由 :math:`P_{r} = C_{p}\mu / \kappa` 来计算，需要指定 :math:`\mu` 和 :math:`P_{r}`                                                                      |
+---------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| sutherland    | 通过温度 :math:`T` 和两个系数 :math:`A_{s},T_{s}` 的函数来计算粘度 :math:`\mu` ，即 :math:`\mu = \frac{A_{s}\sqrt{T}}{1+T_{s}/T}` ，需要指定 :math:`A_{s}` 和 :math:`T_{s}`              |
+---------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| polynomial    | 从一个可以指定任意阶数的函数通过温度 :math:`T` 来计算粘度 :math:`\mu` 和热导率 :math:`\varepsilon` ，即 :math:`\mu = \sum\limits_{i=0}^{N-1}a_{i}T^{i}`                                  |
+---------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| logPolynomial | 从任意阶数依据 :math:`\ln(T)` 来计算 :math:`\ln(\mu)` 和 :math:`\ln(k)` ，即 :math:`\ln(\mu)=\sum\limits_{i=0}^{N-1}a_{i}(\ln T)^{i}`                                                    |
+---------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| icoTabulated  | 使用粘度和热导率的非均匀列表数据作为温度函数                                                                                                                                             |
+---------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| WLF           | 计算 :math:`\ln(\mu)` 和 :math:`\ln(\kappa)` 作为 :math:`\ln(T)` 的函数由任意阶N的多项式通过指数来计算 :math:`\mu,\kappa` ，即 :math:`\ln(\mu)=\sum\limits_{i=0}^{N-1}a_{i}[\ln(T)]^{i}` |
+---------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+


const
^^^^^^^^


.. code-block:: C
    :caption: src/thermophysicalModels/specie/transport/const/constTransport.C

    template<class Thermo>
    void Foam::constTransport<Thermo>::constTransport::write(Ostream& os) const
    {
        os  << this->name() << endl;
        os  << token::BEGIN_BLOCK  << incrIndent << nl;

        Thermo::write(os);

        dictionary dict("transport");
        dict.add("mu", mu_);
        if (constPr_)
        {
            dict.add("Pr", 1.0/rPr_);
        }
        else
        {
            dict.add("kappa", kappa_);
        }

        os  << indent << dict.dictName() << dict;

        os  << decrIndent << token::END_BLOCK << nl;
    }

上面的代码表明，设置为const时将会查看transport字典中的mu关键词，并会检查是否存在Pr关键词，如果存在该关键词，则读取Pr关键词的值来计算普朗特数的倒数rPr；如果不存在该关键词，则会读取kappa关键词。

.. code-block:: C
    :caption: src/thermophysicalModels/specie/transport/const/constTransportI.H

    template<class Thermo>
    inline Foam::scalar Foam::constTransport<Thermo>::mu
    (
        const scalar p,
        const scalar T
    ) const
    {
        return mu_;    // 直接返回mu值
    }


    template<class Thermo>
    inline Foam::scalar Foam::constTransport<Thermo>::kappa
    (
        const scalar p,
        const scalar T
    ) const
    {
        return constPr_ ? this->Cp(p, T)*mu(p, T)*rPr_ : kappa_;    // 判断是否设置Pr关键词计算kappa
    }


    template<class Thermo>
    inline void Foam::constTransport<Thermo>::operator+=
    (
        const constTransport<Thermo>& st
    )
    {
        scalar Y1 = this->Y();

        Thermo::operator+=(st);

        if (mag(this->Y()) > small)
        {
            if
            (
                constTransport<Thermo>::debug
             && (constPr_ != st.constPr_)
            )
            {
                FatalErrorInFunction
                    << "Constant " << (constPr_ ? "Pr" : "kappa") << " for "
                    << (this->name().size() ? this->name() : "others") << " but "
                    << "constant " << (st.constPr_ ? "Pr" : "kappa") << " for "
                    << (st.name().size() ? st.name() : "others")
                    << exit(FatalError);
            }

            Y1 /= this->Y();                 // 第一组分的质量分数
            scalar Y2 = st.Y()/this->Y();    // 第二组分的质量分数

            mu_ = Y1*mu_ + Y2*st.mu_;
            rPr_ = constPr_ ? 1/(Y1/rPr_ + Y2/st.rPr_) : NaN;
            kappa_ = constPr_ ? NaN : Y1*kappa_ + Y2*st.kappa_;
        }
    }

从上面的代码可知，设置为const时，单组分的热传导率的计算方式为

.. math::
    \begin{align}
    \kappa = 
    \left \{ \begin{array}{l}
    \frac{c_{p}\mu}{\text{Pr}} ,\quad \text{if Pr exists} \\
    \kappa_{0},  \quad \text{if Pr not exists} 
    \end{array} \right .
    \end{align}

双组分的动力粘度计算方式为

.. math::
    \begin{align}
    \mu = Y_{1}\mu_{1} + Y_{2}\mu_{2}
    \end{align}

如果设置了Pr值，那么Pr值的倒数的计算方式为

.. math::
    \begin{align}
    \frac{1}{\mathrm{Pr}} = \frac{1}{Y_{1}\mathrm{Pr} + Y_{2}\mathrm{Pr}}
    \end{align}

如果没有设置Pr值，而是设置了kappa值，则双组分的热传导率的计算方式为

.. math::
    \begin{align}
    \kappa = Y_{1}\kappa_{1} + Y_{2}\kappa_{2}
    \end{align}



thermo
---------

thermo热力模型参数和比热容 :math:`C_{p}` 有关，别的相关特性可以从比热容计算而来。可选的模型有：

+---------------+-------------------------------------------------------------------------------------------------------------------+
| thermo模型    | 含义                                                                                                              |
+===============+===================================================================================================================+
| hConst        | 指定 :math:`C_{p}` 以及 :math:`H_{f}` 为常量                                                                      |
+---------------+-------------------------------------------------------------------------------------------------------------------+
| eConst        | 指定 :math:`C_{\nu}` 以及 :math:`H_{f}` 为常量                                                                    |
+---------------+-------------------------------------------------------------------------------------------------------------------+
| eIcoTabulated | 通过插值 :math:`(T,C_{p})` 键值对的非均匀数据列表计算 :math:`C_{\nu}`                                             |
+---------------+-------------------------------------------------------------------------------------------------------------------+
| hIcoTabulated | 通过插值 :math:`(T,C_{p})` 键值对的均匀数据列表计算 :math:`C_{\nu}`                                               |
+---------------+-------------------------------------------------------------------------------------------------------------------+
| ePolynomial   | 通过任意N阶多项式计算 :math:`C_{\nu}` 作为温度的函数，即 :math:`C_{\nu}=\sum\limits_{i=0}^{N-1}a_{i}T^{i}`        |
+---------------+-------------------------------------------------------------------------------------------------------------------+
| hPower        | 将 :math:`C_{p}` 作为温度的指数来计算，即 :math:`C_{p}=c_{0}\left ( \frac{T}{T_{\text{ref}}}\right )^{n_{0}}`     |
+---------------+-------------------------------------------------------------------------------------------------------------------+
| ePower        | 将 :math:`C_{\nu}` 作为温度的指数来计算，即 :math:`C_{\nu}=c_{0}\left ( \frac{T}{T_{\text{ref}}}\right )^{n_{0}}` |
+---------------+-------------------------------------------------------------------------------------------------------------------+
| janaf         | 从JANAF热力学表来选择参数，以温度的函数来计算                                                                     |
+---------------+-------------------------------------------------------------------------------------------------------------------+


thermo能够调用的各物理量计算函数如下所示：


.. code-block:: C
    :caption: src/thermophysicalModels/specie/thermo/thermo/thermoI.H

    template<class Thermo, template<class> class Type>
    inline bool
    Foam::species::thermo<Thermo, Type>::enthalpy()    // 返回一个bool值，标识是否要使用焓作为能量。
    {
        return Type<thermo<Thermo, Type>>::enthalpy();    // 具体执行内容由energy的设置决定
    }


    template<class Thermo, template<class> class Type>
    inline Foam::word
    Foam::species::thermo<Thermo, Type>::heName()    // 返回所设定的energyName名称
    {
        return Type<thermo<Thermo, Type>>::energyName();    // 具体执行内容由energy的设置决定
    }


    template<class Thermo, template<class> class Type>
    inline Foam::scalar
    Foam::species::thermo<Thermo, Type>::Cpv(const scalar p, const scalar T) const    // 定压比热容或定体比热容
    {
        return Type<thermo<Thermo, Type>>::Cpv(*this, p, T);
    }


    template<class Thermo, template<class> class Type>
    inline Foam::scalar
    Foam::species::thermo<Thermo, Type>::gamma(const scalar p, const scalar T) const    // 比热容比
    {
        const scalar Cp = this->Cp(p, T);
        return Cp/(Cp - this->CpMCv(p, T));
    }


    template<class Thermo, template<class> class Type>
    inline Foam::scalar
    Foam::species::thermo<Thermo, Type>::HE(const scalar p, const scalar T) const    // 焓或内能
    {
        return Type<thermo<Thermo, Type>>::HE(*this, p, T);
    }


    template<class Thermo, template<class> class Type>
    inline Foam::scalar
    Foam::species::thermo<Thermo, Type>::G(const scalar p, const scalar T) const    // 吉布斯自由能
    {
        return this->Ha(p, T) - T*this->S(p, T);
    }


    template<class Thermo, template<class> class Type>
    inline Foam::scalar
    Foam::species::thermo<Thermo, Type>::A(const scalar p, const scalar T) const    // 亥姆霍兹自由能
    {
        return this->Ea(p, T) - T*this->S(p, T);
    }


    template<class Thermo, template<class> class Type>
    inline Foam::scalar
    Foam::species::thermo<Thermo, Type>::cp(const scalar p, const scalar T) const    // 乘以摩尔质量的定压比热容
    {
        return this->Cp(p, T)*this->W();
    }


    template<class Thermo, template<class> class Type>
    inline Foam::scalar
    Foam::species::thermo<Thermo, Type>::ha(const scalar p, const scalar T) const    // 乘以摩尔质量的绝对焓
    {
        return this->Ha(p, T)*this->W();
    }


    template<class Thermo, template<class> class Type>
    inline Foam::scalar
    Foam::species::thermo<Thermo, Type>::hs(const scalar p, const scalar T) const    // 乘以摩尔质量的显焓
    {
        return this->Hs(p, T)*this->W();
    }


    template<class Thermo, template<class> class Type>
    inline Foam::scalar
    Foam::species::thermo<Thermo, Type>::hc() const    // 乘以摩尔质量的生成焓
    {
        return this->Hf()*this->W();
    }


    template<class Thermo, template<class> class Type>
    inline Foam::scalar
    Foam::species::thermo<Thermo, Type>::s(const scalar p, const scalar T) const    // 乘以摩尔质量的熵
    {
        return this->S(p, T)*this->W();
    }


    template<class Thermo, template<class> class Type>
    inline Foam::scalar
    Foam::species::thermo<Thermo, Type>::he(const scalar p, const scalar T) const    // 乘以摩尔质量的焓或内能
    {
        return this->HE(p, T)*this->W();
    }


    template<class Thermo, template<class> class Type>
    inline Foam::scalar
    Foam::species::thermo<Thermo, Type>::cv(const scalar p, const scalar T) const    // 乘以摩尔质量的定体比热容
    {
        return this->Cv(p, T)*this->W();
    }


    template<class Thermo, template<class> class Type>
    inline Foam::scalar
    Foam::species::thermo<Thermo, Type>::es(const scalar p, const scalar T) const    // Sensible internal energy
    {
        return this->Es(p, T)*this->W();
    }


    template<class Thermo, template<class> class Type>
    inline Foam::scalar
    Foam::species::thermo<Thermo, Type>::ea(const scalar p, const scalar T) const    // Absolute internal energy
    {
        return this->Ea(p, T)*this->W();
    }


    template<class Thermo, template<class> class Type>
    inline Foam::scalar
    Foam::species::thermo<Thermo, Type>::g(const scalar p, const scalar T) const    // 乘以摩尔质量的吉布斯自由能
    {
        return this->G(p, T)*this->W();
    }


    template<class Thermo, template<class> class Type>
    inline Foam::scalar
    Foam::species::thermo<Thermo, Type>::a(const scalar p, const scalar T) const    // 乘以摩尔质量的亥姆霍兹自由能
    {
        return this->A(p, T)*this->W();
    }


    template<class Thermo, template<class> class Type>
    inline Foam::scalar
    Foam::species::thermo<Thermo, Type>::K(const scalar p, const scalar T) const    // Equilibrium constant [] i.t.o fugacities
    {
        scalar arg = -this->Y()*this->Gstd(T)/(RR*T);

        if (arg < 600)
        {
            return exp(arg);
        }
        else
        {
            return rootVGreat;
        }
    }


    template<class Thermo, template<class> class Type>
    inline Foam::scalar
    Foam::species::thermo<Thermo, Type>::Kp(const scalar p, const scalar T) const    // Equilibrium constant [] i.t.o. partial pressures
    {
        return K(p, T);
    }


    template<class Thermo, template<class> class Type>
    inline Foam::scalar
    Foam::species::thermo<Thermo, Type>::Kc(const scalar p, const scalar T) const    // Equilibrium constant i.t.o. molar concentration
    {
        const scalar nm = this->Y()/this->W();

        if (equal(nm, small))
        {
            return Kp(p, T);
        }
        else
        {
            return Kp(p, T)*pow(Pstd/(RR*T), nm);
        }
    }


    template<class Thermo, template<class> class Type>
    inline Foam::scalar Foam::species::thermo<Thermo, Type>::Kx    // Equilibrium constant [] i.t.o. mole-fractions
    (
        const scalar p,
        const scalar T
    ) const
    {
        const scalar nm = this->Y()/this->W();

        if (equal(nm, small))
        {
            return Kp(p, T);
        }
        else
        {
            return Kp(p, T)*pow(Pstd/p, nm);
        }
    }


    template<class Thermo, template<class> class Type>
    inline Foam::scalar Foam::species::thermo<Thermo, Type>::Kn    // Equilibrium constant [] i.t.o. number of moles
    (
        const scalar p,
        const scalar T,
        const scalar n
    ) const
    {
        const scalar nm = this->Y()/this->W();

        if (equal(nm, small))
        {
            return Kp(p, T);
        }
        else
        {
            return Kp(p, T)*pow(n*Pstd/p, nm);
        }
    }



    template<class Thermo, template<class> class Type>
    template<class ThermoType, class FType, class dFdTType, class LimitType>
    inline Foam::scalar Foam::species::thermo<Thermo, Type>::T    // 计算温度
    (
        const ThermoType& thermo,
        const scalar f,     // 混合物的能量
        const scalar p,     // 混合物的压强
        const scalar T0,    // 温度的初始猜测值
        FType F,            // 温度表示的能量函数
        dFdTType dFdT,      // 温度表示的能量函数对温度的导函数
        LimitType limit,    // 温度范围限制
        const bool diagnostics
    )
    {
        if (T0 < 0)
        {
            FatalErrorInFunction
                << "Negative initial temperature T0: " << T0
                << abort(FatalError);
        }

        scalar Test = T0;
        scalar Tnew = T0;
        scalar Ttol = T0*tol_;
        int    iter = 0;

        if (diagnostics)
        {
            const unsigned int width = IOstream::defaultPrecision() + 8;

            InfoInFunction
                << "Energy -> temperature conversion failed to converge:" << endl;
            Pout<< setw(width) << "iter"
                << setw(width) << "Test"
                << setw(width) << "e/h"
                << setw(width) << "Cv/p"
                << setw(width) << "Tnew"
                << endl;
        }
        do    // 通过欧拉迭代法求解温度场
        {
            Test = Tnew;
            Tnew = (thermo.*limit)(Test - ((thermo.*F)(p, Test) - f)/(thermo.*dFdT)(p, Test));

            if (diagnostics)
            {
                const unsigned int width = IOstream::defaultPrecision() + 8;

                Pout<< setw(width) << iter
                    << setw(width) << Test
                    << setw(width) << ((thermo.*F)(p, Test))
                    << setw(width) << ((thermo.*dFdT)(p, Test))
                    << setw(width) << Tnew
                    << endl;
            }

            if (iter++ > maxIter_)
            {
                if (!diagnostics)
                {
                    T(thermo, f, p, T0, F, dFdT, limit, true);
                }

                FatalErrorInFunction
                    << "Maximum number of iterations exceeded: " << maxIter_
                    << abort(FatalError);
            }

        } while (mag(Tnew - Test) > Ttol);

        return Tnew;
    }


    template<class Thermo, template<class> class Type>
    inline Foam::scalar Foam::species::thermo<Thermo, Type>::THE    // 由焓或内能计算温度
    (
        const scalar he,
        const scalar p,
        const scalar T0
    ) const
    {
        return Type<thermo<Thermo, Type>>::THE(*this, he, p, T0);
    }


    template<class Thermo, template<class> class Type>
    inline Foam::scalar Foam::species::thermo<Thermo, Type>::THs    // 通过显焓计算温度
    (
        const scalar hs,
        const scalar p,
        const scalar T0
    ) const
    {
        return T
        (
            *this,
            hs,
            p,
            T0,
            &thermo<Thermo, Type>::Hs,
            &thermo<Thermo, Type>::Cp,
            &thermo<Thermo, Type>::limit
        );
    }


    template<class Thermo, template<class> class Type>
    inline Foam::scalar Foam::species::thermo<Thermo, Type>::THa    // 由绝对焓计算温度
    (
        const scalar ha,
        const scalar p,
        const scalar T0
    ) const
    {
        return T
        (
            *this,
            ha,
            p,
            T0,
            &thermo<Thermo, Type>::Ha,
            &thermo<Thermo, Type>::Cp,
            &thermo<Thermo, Type>::limit
        );
    }


    template<class Thermo, template<class> class Type>
    inline Foam::scalar Foam::species::thermo<Thermo, Type>::TEs    // Temperature from sensible internal energy
    (
        const scalar es,
        const scalar p,
        const scalar T0
    ) const
    {
        return T
        (
            *this,
            es,
            p,
            T0,
            &thermo<Thermo, Type>::Es,
            &thermo<Thermo, Type>::Cv,
            &thermo<Thermo, Type>::limit
        );
    }


    template<class Thermo, template<class> class Type>
    inline Foam::scalar Foam::species::thermo<Thermo, Type>::TEa    // Temperature from absolute internal energy
    (
        const scalar ea,
        const scalar p,
        const scalar T0
    ) const
    {
        return T
        (
            *this,
            ea,
            p,
            T0,
            &thermo<Thermo, Type>::Ea,
            &thermo<Thermo, Type>::Cv,
            &thermo<Thermo, Type>::limit
        );
    }


    template<class Thermo, template<class> class Type>
    inline Foam::scalar
    Foam::species::thermo<Thermo, Type>::dKcdTbyKc    // Derivative of B (according to Niemeyer et al.) w.r.t. temperature
    (
        const scalar p,
        const scalar T
    ) const
    {
        const scalar dKcdTbyKc = (this->S(Pstd, T) + this->Gstd(T)/T)*this->Y()/(RR*T);

        const scalar nm = this->Y()/this->W();
        if (equal(nm, small))
        {
            return dKcdTbyKc;
        }
        else
        {
            return dKcdTbyKc - nm/T;
        }
    }


    template<class Thermo, template<class> class Type>
    inline Foam::scalar
    Foam::species::thermo<Thermo, Type>::dcpdT(const scalar p, const scalar T) const    // Derivative of cp w.r.t. temperature
    {
        return this->dCpdT(p, T)*this->W();;
    }





hConst
^^^^^^^^^

这是一个基于焓的热力学包，它在恒压条件下使用恒定热容，满足：

.. math::
    \begin{align}
    h = c_{p}(T - T_{\text{ref}}) + H_{s_{\text{ref}}}
    \end{align}

设置为hConst时将会读取thermodynamics字典中的Cp和Hf关键词；如果存在Tref关键词也会读取，否则默认值使用Tstd；如果存在Hsref关键词也会读取，否则默认值使用0。

.. code-block:: C
    :caption: src/thermophysicalModels/specie/thermo/hConst/hConstThermo.C

    template<class EquationOfState>
    Foam::hConstThermo<EquationOfState>::hConstThermo(const dictionary& dict)
    :
        EquationOfState(dict),
        Cp_(dict.subDict("thermodynamics").lookup<scalar>("Cp")),    // 定压比热容
        Hf_(dict.subDict("thermodynamics").lookup<scalar>("Hf")),    // 生成热（生成焓）
        Tref_(dict.subDict("thermodynamics").lookupOrDefault<scalar>("Tref", Tstd)),    // 线性化的参考温度
        Hsref_(dict.subDict("thermodynamics").lookupOrDefault<scalar>("Hsref", 0))    // 参考显焓，围绕它进行线性化
    {}

    template<class EquationOfState>
    void Foam::hConstThermo<EquationOfState>::write(Ostream& os) const
    {
        EquationOfState::write(os);

        dictionary dict("thermodynamics");
        dict.add("Cp", Cp_);
        dict.add("Hf", Hf_);
        if (Tref_ != Tstd)
        {
            dict.add("Tref", Tref_);
        }
        if (Hsref_ != 0)
        {
            dict.add("Hsref", Hsref_);
        }
        os  << indent << dict.dictName() << dict;
    }

在将thermo设置为hConst之后，可以通过thermo调用的函数所执行的内容如下所示：

+----------------------------+--------------------+-------------------------------------------------------------+
| 函数作用                   | 函数形式           | 返回内容                                                    |
+============================+====================+=============================================================+
| 限制温度                   | :code:`limit(T)`   | :code:`T`                                                   |
+----------------------------+--------------------+-------------------------------------------------------------+
| 计算定压比热容             | :code:`Cp(p,T)`    | :code:`Cp_ + EquationOfState::Cp(p, T)`                     |
+----------------------------+--------------------+-------------------------------------------------------------+
| 计算显焓                   | :code:`Hs(p,T)`    | :code:`Cp_*(T - Tref_) + Hsref_ + EquationOfState::H(p, T)` |
+----------------------------+--------------------+-------------------------------------------------------------+
| 计算绝对焓                 | :code:`Ha(p,T)`    | :code:`Hs(p, T) + Hf()`                                     |
+----------------------------+--------------------+-------------------------------------------------------------+
| 计算生成焓                 | :code:`Hf()`       | :code:`Hf_`                                                 |
+----------------------------+--------------------+-------------------------------------------------------------+
| 计算熵                     | :code:`S(p,T)`     | :code:`Cp_*log(T/Tstd) + EquationOfState::Sp(p, T)`         |
+----------------------------+--------------------+-------------------------------------------------------------+
| 计算标准吉布斯自由能       | :code:`Gstd(T)`    | :code:`Cp_*(T - Tref_) + Hsref_ + Hf() - Cp_*T*log(T/Tstd)` |
+----------------------------+--------------------+-------------------------------------------------------------+
| 计算定压比热容对温度的导数 | :code:`dCpdT(p,T)` | :code:`0`                                                   |
+----------------------------+--------------------+-------------------------------------------------------------+



.. code-block:: C
    :caption: src/thermophysicalModels/specie/thermo/hConst/hConstThermoI.H

    template<class EquationOfState>
    inline Foam::scalar Foam::hConstThermo<EquationOfState>::limit    // 将温度限制在从Tlow到Thigh的范围内
    (
        const scalar T
    ) const
    {
        return T;
    }

    template<class EquationOfState>
    inline Foam::scalar Foam::hConstThermo<EquationOfState>::Cp    // 定压比热容
    (
        const scalar p,
        const scalar T
    ) const
    {
        return Cp_ + EquationOfState::Cp(p, T);    // 其中EquationOfState::Cp表示由于状态方程而产生的定压比热容的贡献
    }

    template<class EquationOfState>
    inline Foam::scalar Foam::hConstThermo<EquationOfState>::Hs    // 显焓
    (
        const scalar p,
        const scalar T
    ) const
    {
        return Cp_*(T - Tref_) + Hsref_ + EquationOfState::H(p, T);    // 其中EquationOfState::H表示由于状态方程而产生的焓的贡献
    }

    template<class EquationOfState>
    inline Foam::scalar Foam::hConstThermo<EquationOfState>::Ha    // 绝对焓
    (
        const scalar p,
        const scalar T
    ) const
    {
        return Hs(p, T) + Hf();
    }

    template<class EquationOfState>
    inline Foam::scalar Foam::hConstThermo<EquationOfState>::Hf() const    // 生成焓
    {
        return Hf_;
    }

    template<class EquationOfState>
    inline Foam::scalar Foam::hConstThermo<EquationOfState>::S    // 熵
    (
        const scalar p,
        const scalar T
    ) const
    {
        return Cp_*log(T/Tstd) + EquationOfState::Sp(p, T);    // 其中EquationOfState::Sp表示由于状态方程而产生的熵对Cp/T积分的贡献
    }

    template<class EquationOfState>
    inline Foam::scalar Foam::hConstThermo<EquationOfState>::Gstd    // 混合物在标准态下的吉布斯自由能
    (
        const scalar T
    ) const
    {
        return Cp_*(T - Tref_) + Hsref_ + Hf() - Cp_*T*log(T/Tstd);
    }

    template<class EquationOfState>
    inline Foam::scalar Foam::hConstThermo<EquationOfState>::dCpdT    // 定压比热容关于温度的导数
    (
        const scalar p,
        const scalar T
    ) const
    {
        return 0;
    }




equationOfState
-------------------

状态方程equationOfState可选的有：

+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| 状态方程                 | 含义                                                                                                                                                            |
+==========================+=================================================================================================================================================================+
| rhoConst                 | 密度为常量                                                                                                                                                      |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| perfectGas               | 理想气体，即 :math:`\rho=\frac{1}{RT}p`                                                                                                                         |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| incompressiblePerfectGas | 不可压缩理想气体，即 :math:`\rho=\frac{1}{RT}p_{\text{ref}}` ，其中 :math:`p_{\text{ref}}` 为参考压力                                                           |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| perfectFluid             | 理想液体，即 :math:`\rho=\frac{1}{RT}p+\rho_{0}` ，其中 :math:`p_{0}` 为 :math:`T=0` 下的密度                                                                   |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| linear                   | 线性状态方程，即 :math:`\rho=\varphi p+\rho_{0}` ，其中 :math:`\varphi` 为可压缩性                                                                              |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| adiabaticPerfectFluid    | 绝热理想气体，即 :math:`\rho=\rho_{0}\left ( \frac{p+B}{p_{0}B}\right ) ^{1/\gamma}` ，其中 :math:`\rho_{0},p_{0}` 为参考密度和参考压力， :math:`B` 为模型常数  |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Boussinesq               | 布辛涅司克近似，即 :math:`\rho=\rho_{0}\big(1-\beta(T-T_{0})\big)` ，其中 :math:`\beta` 表示体膨胀率， :math:`\rho_{0}` 表示参考温度 :math:`T_{0}` 下的参考密度 |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| PengRobinsonGas          | 彭-罗宾森状态方程，即 :math:`\rho=\frac{1}{zRT}p` ，其中 :math:`z=z(p,T)`                                                                                       |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| icoPolynomial            | 不可压缩多项式状态方程 :math:`\rho=\sum\limits_{i=0}^{N-1}a_{i}T^{i}` ，其中 :math:`\varphi` 为可压缩性                                                         |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| icoTabulated             | 提供不可压缩流体 :math:`(T,\rho)` 键值对的数据列表                                                                                                              |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| rhoTabulated             | 可压缩流体的统一表格数据，计算 :math:`\rho` 作为 :math:`T` 和 :math:`T` 的函数                                                                                  |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| rPolynomial              | 液体或固体的倒数多项式状态方程，即 :math:`\frac{1}{\rho}=C_{0}+C_{1}T+C_{2}T^{2}-C_{3}p-C_{4}pT` ，其中的 :math:`C_{i}` 为系数                                  |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+


perfectGas
^^^^^^^^^^^^

理想气体状态方程，所使用的气体常数 :math:`R` 直接从specie或者混合物的分子量得到，所以不需要额外设定：

.. math::
    \begin{align}
    \rho = \frac{p}{RT} 
    \end{align}

当equationOfState设置为perfectGas之后，通过它可以调用的函数如下所示：

+------------------------+---------------------+--------------------------------+
| 函数作用               | 函数形式            | 返回内容                       |
+========================+=====================+================================+
| 计算密度场             | :code:`rho(p,T)`    | :code:`p/(this->R()*T)`        |
+------------------------+---------------------+--------------------------------+
| 计算对焓的贡献         | :code:`H(p,T)`      | :code:`0`                      |
+------------------------+---------------------+--------------------------------+
| 计算对定压比热容的贡献 | :code:`Cp(p,T)`     | :code:`0`                      |
+------------------------+---------------------+--------------------------------+
| 计算对能量的贡献       | :code:`E(p,T)`      | :code:`0`                      |
+------------------------+---------------------+--------------------------------+
| 计算对定体比热容的贡献 | :code:`Cv(p,T)`     | :code:`0`                      |
+------------------------+---------------------+--------------------------------+
| 计算熵对Cp/T积分的贡献 | :code:`Sp(p,T)`     | :code:`-this->R()*log(p/Pstd)` |
+------------------------+---------------------+--------------------------------+
| 计算熵对Cv/T积分的贡献 | :code:`Sv(p,T)`     | :code:`0`                      |
+------------------------+---------------------+--------------------------------+
| 计算可压缩性场         | :code:`psi(p,T)`    | :code:`1.0/(this->R()*T)`      |
+------------------------+---------------------+--------------------------------+
| 计算压缩因子           | :code:`Z(p,T)`      | :code:`1`                      |
+------------------------+---------------------+--------------------------------+
| 计算Cp与Cv的差         | :code:`CpMCv(p,T)`  | :code:`this->R()`              |
+------------------------+---------------------+--------------------------------+
| 计算热膨胀的体积系数   | :code:`alphav(p,T)` | :code:`1/T`                    |
+------------------------+---------------------+--------------------------------+



.. code-block:: C
    :caption: src/thermophysicalModels/specie/equationOfState/perfectGas/perfectGasI.H

    template<class Specie>
    inline Foam::scalar Foam::perfectGas<Specie>::rho(scalar p, scalar T) const    // 密度场
    {
        return p/(this->R()*T);    // 通过理想气体方程求解密度
    }

    template<class Specie>
    inline Foam::scalar Foam::perfectGas<Specie>::H(scalar p, scalar T) const    // 焓的贡献
    {
        return 0;
    }

    template<class Specie>
    inline Foam::scalar Foam::perfectGas<Specie>::Cp(scalar p, scalar T) const    // 定压比热容的贡献
    {
        return 0;
    }

    template<class Specie>
    inline Foam::scalar Foam::perfectGas<Specie>::E(scalar p, scalar T) const    // 能量贡献
    {
        return 0;
    }

    template<class Specie>
    inline Foam::scalar Foam::perfectGas<Specie>::Cv(scalar p, scalar T) const    // 定体比热容贡献
    {
        return 0;
    }

    template<class Specie>
    inline Foam::scalar Foam::perfectGas<Specie>::Sp(scalar p, scalar T) const    // 熵对Cp/T积分的贡献
    {
        return -this->R()*log(p/Pstd);
    }

    template<class Specie>
    inline Foam::scalar Foam::perfectGas<Specie>::Sv(scalar p, scalar T) const    // 熵对Cv/T积分的贡献
    {
        NotImplemented;
        return 0;
    }

    template<class Specie>
    inline Foam::scalar Foam::perfectGas<Specie>::psi(scalar p, scalar T) const    // 可压缩性场
    {
        return 1.0/(this->R()*T);
    }

    template<class Specie>
    inline Foam::scalar Foam::perfectGas<Specie>::Z(scalar p, scalar T) const    // 压缩因子
    {
        return 1;
    }

    template<class Specie>
    inline Foam::scalar Foam::perfectGas<Specie>::CpMCv(scalar p, scalar T) const    // Cp与Cv的差
    {
        return this->R();
    }

    template<class Specie>
    inline Foam::scalar Foam::perfectGas<Specie>::alphav(scalar p, scalar T) const    // 热膨胀的体积系数
    {
        return 1/T;
    }




specie
---------

这是热物理性质类型的基类。组分的量只有一种选择specie，后续需要进一步输入下面的信息：

+----------------+---------------------------------------------------------------------------+
| specie组分信息 | 含义                                                                      |
+================+===========================================================================+
| nMoles         | 摩尔数。仅仅在使用反应组分均一混合回归变量燃烧模型的时候起作用，否则其为1 |
+----------------+---------------------------------------------------------------------------+
| molWeight      | 摩尔质量g/mol                                                             |
+----------------+---------------------------------------------------------------------------+


.. code-block:: C
    :caption: src/thermophysicalModels/specie/specie/specie.C

    Foam::specie::specie(const dictionary& dict)
    :
        name_(dict.dictName()),
        Y_(dict.subDict("specie").lookupOrDefault("massFraction", 1.0)),    // 质量分数
        molWeight_(dict.subDict("specie").lookup<scalar>("molWeight"))      // 摩尔质量
    {}

    void Foam::specie::write(Ostream& os) const
    {
        dictionary dict("specie");    // 查找specie字典
        if (Y_ != 1)    // 如果质量分数不等于1
        {
            dict.add("massFraction", Y_);    // 则需要进一步读取massFraction关键词获取所设置的质量分数
        }
        dict.add("molWeight", molWeight_);    // 读取molWeight关键词获取摩尔质量
        os  << indent << dict.dictName() << dict;
    }


.. code-block:: C
    :caption: src/thermophysicalModels/specie/specie/specieI.H

    inline const word& specie::name() const    // 组分名称
    {
        return name_;
    }

    inline scalar specie::W() const    // 摩尔质量
    {
        return molWeight_;
    }

    inline scalar specie::Y() const    // 组分的质量分数
    {
        return Y_;
    }

    inline scalar specie::R() const    // 个别气体常数
    {
        return RR/molWeight_;    // 通过气体常数除以该组分的摩尔质量得到
    }




energy
---------

可以对能量方程求解的变量进行指定，其可为内能 :math:`e` 也可以为焓 :math:`h` ，并可以选择是否包含热源 :math:`\Delta h_{f}` 。其可以通过指定energy关键字来实现：

+------------------------+------------------------------+
| 能量方程变量           | 含义                         |
+========================+==============================+
| sensibleEnthalpy       | 利用焓值求解温度             |
+------------------------+------------------------------+
| sensibleInternalEnergy | 利用内能求解温度             |
+------------------------+------------------------------+
| absoluteEnthalpy       | 使用绝对焓表示包含热源的情况 |
+------------------------+------------------------------+
| absoluteInternalEnergy | 使用绝对内能求解温度         |
+------------------------+------------------------------+



sensibleEnthalpy
^^^^^^^^^^^^^^^^^^

这是一个热力学映射类，以使用关于显式焓的函数。

.. code-block:: C
    :caption: src/thermophysicalModels/specie/thermo/sensibleEnthalpy/sensibleEnthalpy.H
 
    static bool enthalpy()
    {
        return true;    // 使用焓
    }

    static word energyName()
    {
        return "h";    // 将energyName设置为焓h
    }

    // Heat capacity at constant pressure [J/kg/K]
    scalar Cpv    // 定压比热容
    (
        const Thermo& thermo,
        const scalar p,
        const scalar T
    ) const
    {
        return thermo.Cp(p, T);
    }

    // Sensible enthalpy [J/kg]
    scalar HE    // 显内能
    (
        const Thermo& thermo,
        const scalar p,
        const scalar T
    ) const
    {
        return thermo.Hs(p, T);
    }

    //- Temperature from sensible enthalpy given an initial temperature T0
    scalar THE    // 在给定初始温度T0的条件下，由显内能得到的温度
    (
        const Thermo& thermo,
        const scalar h,
        const scalar p,
        const scalar T0
    ) const
    {
        return thermo.THs(h, p, T0);
    }



sensibleInternalEnergy
^^^^^^^^^^^^^^^^^^^^^^^^^

这是一个热力学映射类，以使用关于显式内能的函数。

.. code-block:: C
    :caption: src/thermophysicalModels/specie/thermo/sensibleInternalEnergy/sensibleInternalEnergy.H

    static bool enthalpy()
    {
        return false;    // 不使用焓
    }

    static word energyName()
    {
        return "e";    // 将energyName设置为内能e
    }

    //- Heat capacity at constant volume [J/kg/K]
    scalar Cpv    // 定体比热容
    (
        const Thermo& thermo,
        const scalar p,
        const scalar T
    ) const
    {
        return thermo.Cv(p, T);    // 调用thermo设置模式的函数或者使用HtoEthermo.H文件中定义的函数
    }

    //- Sensible internal energy [J/kg]
    scalar HE    // 显内能
    (
        const Thermo& thermo,
        const scalar p,
        const scalar T
    ) const
    {
        return thermo.Es(p, T);    // 调用thermo设置模式的函数或者使用HtoEthermo.H文件中定义的函数
    }

    //- Temperature from sensible internal energy given an initial temperature T0
    scalar THE    // 在给定初始温度T0的条件下，由显内能得到的温度
    (
        const Thermo& thermo,
        const scalar e,
        const scalar p,
        const scalar T0
    ) const
    {
        return thermo.TEs(e, p, T0);    // 调用thermo模块模板函数
    }        


absoluteEnthalpy
^^^^^^^^^^^^^^^^^^^

这是一个热力学映射类，以使用关于绝对焓的函数。

.. code-block:: C
    :caption: src/thermophysicalModels/specie/thermo/absoluteEnthalpy/absoluteEnthalpy.H

    static bool enthalpy()
    {
        return true;    // 使用焓
    }

    static word energyName()
    {
        return "ha";    // 将energyName设置为绝对焓he
    }

    // Heat capacity at constant pressure [J/kg/K]
    scalar Cpv    // 定压比热容
    (
        const Thermo& thermo,
        const scalar p,
        const scalar T
    ) const
    {
        return thermo.Cp(p, T);
    }

    // Absolute enthalpy [J/kg]
    scalar HE    // 绝对焓
    (
        const Thermo& thermo,
        const scalar p,
        const scalar T
    ) const
    {
        return thermo.Ha(p, T);
    }

    //- Temperature from absolute enthalpy given an initial temperature T0
    scalar THE    // 给定初始温度T0，由绝对焓得到的温度
    (
        const Thermo& thermo,
        const scalar h,
        const scalar p,
        const scalar T0
    ) const
    {
        return thermo.THa(h, p, T0);
    }



absoluteInternalEnergy
^^^^^^^^^^^^^^^^^^^^^^^^

这是一个热力学映射类，以使用关于绝对内能的函数。

.. code-block:: C
    :caption: src/thermophysicalModels/specie/thermo/absoluteInternalEnergy/absoluteInternalEnergy.H

    static bool enthalpy()
    {
        return false;    // 不使用焓
    }

    static word energyName()
    {
        return "ea";    // 设置energyName为绝对内能ea
    }

    // Heat capacity at constant volume [J/kg/K]
    scalar Cpv    // 定体比热容
    (
        const Thermo& thermo,
        const scalar p,
        const scalar T
    ) const
    {
        return thermo.Cv(p, T);
    }

    // Absolute internal energy [J/kg]
    scalar HE    // 绝对内能
    (
        const Thermo& thermo,
        const scalar p,
        const scalar T
    ) const
    {
        return thermo.Ea(p, T);
    }

    //- Temperature from absolute internal energy given an initial temperature T0
    scalar THE    // 给定初始温度T0，由绝对内能得到的温度
    (
        const Thermo& thermo,
        const scalar e,
        const scalar p,
        const scalar T0
    ) const
    {
        return thermo.TEa(e, p, T0);
    }



ThermophysicalTransport
==========================

ThermophysicalTransport模块中包含湍流影响的热物理量，例如热通量、有效热扩散系数等，在求解器中将会通过thermophysicalTransport->的形式来调用对应的函数。在构建其函数的过程中继承了heThermo.C文件中的函数，并利用thermo()来调用其中的函数来计算对应物理量。

eddyDiffusivity是用于单相RAS或LES湍流流动的基于温度梯度热通量的涡流扩散模型。需要通过RAS/LES子字典中model关键词进行设置。热通量源通过一种隐式能量对温度梯度的修正来构建，在收敛的时候能量修正为零。

.. code-block:: C
    :caption: src/ThermophysicalTransportModels/turbulence/eddyDiffusivity/eddyDiffusivity.H

    //- Turbulent thermal diffusivity for enthalpy [kg/m/s]
    virtual tmp<volScalarField> alphat() const
    {
        return alphat_;
    }

    //- Turbulent thermal diffusivity for enthalpy for a patch [kg/m/s]
    virtual tmp<scalarField> alphat(const label patchi) const
    {
        return alphat()().boundaryField()[patchi];
    }

    //- Effective thermal turbulent diffusivity for temperature of mixture [W/m/K]
    virtual tmp<volScalarField> kappaEff() const
    {
        return this->thermo().kappaEff(alphat());
    }

    //- Effective thermal turbulent diffusivity for temperature of mixture for patch [W/m/K]
    virtual tmp<scalarField> kappaEff(const label patchi) const
    {
        return this->thermo().kappaEff
        (
            alphat(patchi),
            patchi
        );
    }

    //- Effective thermal turbulent diffusivity of mixture [kg/m/s]
    virtual tmp<volScalarField> alphaEff() const
    {
        return this->thermo().alphaEff(alphat());
    }

    //- Effective thermal turbulent diffusivity of mixture for patch [kg/m/s]
    virtual tmp<scalarField> alphaEff(const label patchi) const
    {
        return this->thermo().alphaEff
        (
            alphat(patchi),
            patchi
        );
    }


.. code-block:: C
    :caption: src/ThermophysicalTransportModels/turbulence/eddyDiffusivity/eddyDiffusivity.C

    template<class TurbulenceThermophysicalTransportModel>
    tmp<surfaceScalarField>
    eddyDiffusivity<TurbulenceThermophysicalTransportModel>::q() const    // 热通量
    {
        return surfaceScalarField::New
        (
            IOobject::groupName
            (
                "q",
                this->momentumTransport().alphaRhoPhi().group()
            ),
           -fvc::interpolate(this->alpha()*this->kappaEff())
           *fvc::snGrad(this->thermo().T())
        );
    }

    template<class TurbulenceThermophysicalTransportModel>
    tmp<fvScalarMatrix>
    eddyDiffusivity<TurbulenceThermophysicalTransportModel>::divq    // 热通量的散度
    (
        volScalarField& he
    ) const
    {
        // Return heat flux source as an implicit energy correction to the temperature gradient flux
        return
            -correction(fvm::laplacian(this->alpha()*this->alphaEff(), he))
            -fvc::laplacian(this->alpha()*this->kappaEff(), this->thermo().T());
    }

其中函数correction()的定义为

.. code-block:: C
    :caption: src/finiteVolume/fvMatrices/fvMatrix/fvMatrix.C

    template<class Type>
    Foam::tmp<Foam::fvMatrix<Type>> Foam::correction
    (
        const fvMatrix<Type>& A
    )
    {
        tmp<Foam::fvMatrix<Type>> tAcorr = A - (A & A.psi());

        // Delete the faceFluxCorrection from the correction matrix as it does not have a clear meaning or purpose
        deleteDemandDrivenData(tAcorr.ref().faceFluxCorrectionPtr());

        return tAcorr;
    }

.. note:: 关于correction()函数的讨论见 `Foam::correction() function <https://www.cfd-online.com/Forums/openfoam-programming-development/152356-foam-correction-function.html>`_ 。一个帮助理解该函数作用的例子是：correction(fvm::ddt(p)) 表示 d(p)/d(t) - d(pold)/d(t) 。


unityLewisEddyDiffusivity是用于RAS或LES模型的基于能量梯度热通量模型的涡流扩散模型，物质的通量在计算时假定具有统一的Lewis数。它是RAS/LES默认采用的模型，或者也可以子字典中的model关键词进行设置。

.. code-block:: C
    :caption: src/ThermophysicalTransportModels/turbulence/unityLewisEddyDiffusivity/unityLewisEddyDiffusivity.H

    virtual tmp<volScalarField> alphat() const
    {
        return alphat_;
    }

    //- Turbulent thermal diffusivity for enthalpy for a patch [kg/m/s]
    virtual tmp<scalarField> alphat(const label patchi) const
    {
        return alphat()().boundaryField()[patchi];
    }

    //- Effective thermal turbulent diffusivity for temperature of mixture [W/m/K]
    virtual tmp<volScalarField> kappaEff() const
    {
        return this->thermo().kappaEff(alphat());
    }

    //- Effective thermal turbulent diffusivity for temperature of mixture for patch [W/m/K]
    virtual tmp<scalarField> kappaEff(const label patchi) const
    {
        return this->thermo().kappaEff
        (
            alphat(patchi),
            patchi
        );
    }

    //- Effective thermal turbulent diffusivity of mixture [kg/m/s]
    virtual tmp<volScalarField> alphaEff() const
    {
        return this->thermo().alphaEff(alphat());
    }

    //- Effective thermal turbulent diffusivity of mixture for patch [kg/m/s]
    virtual tmp<scalarField> alphaEff(const label patchi) const
    {
        return this->thermo().alphaEff
        (
            alphat(patchi),
            patchi
        );
    }

    //- Effective mass diffusion coefficient for a given specie mass-fraction [kg/m/s]
    virtual tmp<volScalarField> DEff(const volScalarField& Yi) const
    {
        return volScalarField::New
        (
            "DEff",
            this->thermo().kappa()/this->thermo().Cp() + alphat()
        );
    }

    //- Effective mass diffusion coefficient for a given specie mass-fraction for patch [kg/m/s]
    virtual tmp<scalarField> DEff
    (
        const volScalarField& Yi,
        const label patchi
    ) const
    {
        return
            this->thermo().kappa().boundaryField()[patchi]
           /this->thermo().Cp().boundaryField()[patchi]
          + alphat(patchi);
    }



.. code-block:: C
    :caption: src/ThermophysicalTransportModels/turbulence/unityLewisEddyDiffusivity/unityLewisEddyDiffusivity.C

    template<class TurbulenceThermophysicalTransportModel>
    tmp<surfaceScalarField>
    unityLewisEddyDiffusivity<TurbulenceThermophysicalTransportModel>::q() const
    {
        return surfaceScalarField::New
        (
            IOobject::groupName
            (
                "q",
                this->momentumTransport().alphaRhoPhi().group()
            ),
           -fvc::interpolate(this->alphaEff()*this->alpha())
           *fvc::snGrad(this->thermo().he())
        );
    }


    template<class TurbulenceThermophysicalTransportModel>
    tmp<fvScalarMatrix>
    unityLewisEddyDiffusivity<TurbulenceThermophysicalTransportModel>::divq
    (
        volScalarField& he
    ) const
    {
        return -fvm::laplacian(this->alpha()*this->alphaEff(), he);
    }


    template<class TurbulenceThermophysicalTransportModel>
    tmp<surfaceScalarField>
    unityLewisEddyDiffusivity<TurbulenceThermophysicalTransportModel>::j
    (
        const volScalarField& Yi
    ) const
    {
        return surfaceScalarField::New
        (
            IOobject::groupName
            (
                "j(" + Yi.name() + ')',
                this->momentumTransport().alphaRhoPhi().group()
            ),
           -fvc::interpolate(this->DEff(Yi)*this->alpha())*fvc::snGrad(Yi)
        );
    }


    template<class TurbulenceThermophysicalTransportModel>
    tmp<fvScalarMatrix>
    unityLewisEddyDiffusivity<TurbulenceThermophysicalTransportModel>::divj
    (
        volScalarField& Yi
    ) const
    {
        return -fvm::laplacian(this->alpha()*this->DEff(Yi), Yi);
    }



Non-unity-Lewis-Eddy-diffusivity based temperature gradient heat flux model for RAS or LES of turbulent flow. Allows independent specification of turbulent Prandtl and Schmidt numbers.  Unity laminar Lewis number is assumed. The heat flux source is implemented as an implicit energy correction to the temperature gradient based flux source.  At convergence the energy correction is 0.

.. code-block:: C
    :caption: src/ThermophysicalTransportModels/turbulence/nonUnityLewisEddyDiffusivity/nonUnityLewisEddyDiffusivity.H

    //- Effective mass diffusion coefficient for a given specie mass-fraction [kg/m/s]
    virtual tmp<volScalarField> DEff(const volScalarField& Yi) const
    {
        return volScalarField::New
        (
            "DEff",
            this->thermo().alphaEff((this->Prt_/Sct_)*this->alphat())
        );
    }

    //- Effective mass diffusion coefficient for a given specie mass-fraction for patch [kg/m/s]
    virtual tmp<scalarField> DEff
    (
        const volScalarField& Yi,
        const label patchi
    ) const
    {
        return this->thermo().alphaEff
        (
            this->Prt_.value()/Sct_.value()*this->alphat(patchi),
            patchi
        );
    }


.. code-block:: C
    :caption: src/ThermophysicalTransportModels/turbulence/nonUnityLewisEddyDiffusivity/nonUnityLewisEddyDiffusivity.C

    template<class TurbulenceThermophysicalTransportModel>
    tmp<surfaceScalarField>
    nonUnityLewisEddyDiffusivity<TurbulenceThermophysicalTransportModel>::q() const
    {
        tmp<surfaceScalarField> tmpq
        (
            surfaceScalarField::New
            (
                IOobject::groupName
                (
                    "q",
                    this->momentumTransport().alphaRhoPhi().group()
                ),
               -fvc::interpolate(this->alpha()*this->kappaEff())
               *fvc::snGrad(this->thermo().T())
            )
        );

        const basicSpecieMixture& composition = this->thermo().composition();
        const PtrList<volScalarField>& Y = composition.Y();

        if (Y.size())
        {
            surfaceScalarField hGradY
            (
                surfaceScalarField::New
                (
                    "hGradY",
                    Y[0].mesh(),
                    dimensionedScalar(dimEnergy/dimMass/dimLength, 0)
                )
            );

            forAll(Y, i)
            {
                const volScalarField hi
                (
                    composition.Hs(i, this->thermo().p(), this->thermo().T())
                );

                hGradY += fvc::interpolate(hi)*fvc::snGrad(Y[i]);
            }

            tmpq.ref() -=
                fvc::interpolate
                (
                    this->alpha()
                   *this->thermo().alphaEff((this->Prt_/Sct_)*this->alphat())
                )*hGradY;
        }

        return tmpq;
    }


    template<class TurbulenceThermophysicalTransportModel>
    tmp<fvScalarMatrix>
    nonUnityLewisEddyDiffusivity<TurbulenceThermophysicalTransportModel>::divq
    (
        volScalarField& he
    ) const
    {
        tmp<fvScalarMatrix> tmpDivq
        (
            fvm::Su
            (
                -fvc::laplacian(this->alpha()*this->kappaEff(), this->thermo().T()),
                he
            )
        );

        const basicSpecieMixture& composition = this->thermo().composition();
        const PtrList<volScalarField>& Y = composition.Y();

        tmpDivq.ref() -=
            correction(fvm::laplacian(this->alpha()*this->alphaEff(), he));

        surfaceScalarField hGradY
        (
            surfaceScalarField::New
            (
                "hGradY",
                he.mesh(),
                dimensionedScalar(he.dimensions()/dimLength, 0)
            )
        );

        forAll(Y, i)
        {
            const volScalarField hi
            (
                composition.Hs(i, this->thermo().p(), this->thermo().T())
            );

            hGradY += fvc::interpolate(hi)*fvc::snGrad(Y[i]);
        }

        tmpDivq.ref() -=
            fvc::div
            (
                fvc::interpolate
                (
                    this->alpha()
                   *this->thermo().alphaEff((this->Prt_/Sct_)*this->alphat())
                )*hGradY*he.mesh().magSf()
            );

        return tmpDivq;
    }



Multi-component Fickian and eddy-diffusivity turbulent based temperature gradient heat flux model for RAS or LES of turbulent flow with optional Soret thermal diffusion of species. The mixture diffusion coefficients are specified as Function2<scalar>s of pressure and temperature but independent of composition. The heat flux source is implemented as an implicit energy correction to the temperature gradient based flux source.  At convergence the energy correction is 0.

.. code-block:: C
    :caption: src/ThermophysicalTransportModels/turbulence/FickianEddyDiffusivity/FickianEddyDiffusivity.C

    template<class TurbulenceThermophysicalTransportModel>
    tmp<volScalarField>
    FickianEddyDiffusivity<TurbulenceThermophysicalTransportModel>::DEff
    (
        const volScalarField& Yi
    ) const
    {
        return volScalarField::New
        (
            "DEff",
            Fickian
            <
                unityLewisEddyDiffusivity<TurbulenceThermophysicalTransportModel>
            >::DEff(Yi)
          + (this->Prt_/Sct_)*this->alphat()
        );
    }

    template<class TurbulenceThermophysicalTransportModel>
    tmp<scalarField>
    FickianEddyDiffusivity<TurbulenceThermophysicalTransportModel>::DEff
    (
        const volScalarField& Yi,
        const label patchi
    ) const
    {
        return
            Fickian
            <
                unityLewisEddyDiffusivity<TurbulenceThermophysicalTransportModel>
            >::DEff(Yi, patchi)
          + this->Prt_.value()/Sct_.value()*this->alphat(patchi);
    }





场设置
=========


常用的场文件名称及其意义如下所示：

+---------+---------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| 文件名  | 含义                                                                                  | 量纲                                                                                                 |
+=========+=======================================================================================+======================================================================================================+
| U       | 速度                                                                                  | :math:`\mathrm{m\cdot s^{-1}}`                                                                       |
+---------+---------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| U_0     | 前一个时间步长的速度(需要重新启动更高阶时间步长的格式时建立)                          | :math:`\mathrm{m\cdot s^{-1}}`                                                                       |
+---------+---------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| phi     | 流量                                                                                  | 对于不可压缩流为 :math:`\mathrm{m^{3}\cdot s^{-1}}` ；对于可压缩流为 :math:`\mathrm{kg\cdot s^{-1}}` |
+---------+---------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| p       | 压力。对于不可压缩求解器，这个场实际上是由恒定流体密度归一化的压力，                  | 对于不可压缩流为 :math:`\mathrm{m^{3}\cdot s^{-1}}` ；                                               |
+         +                                                                                       +                                                                                                      +
|         | 如果要得到真实的压力则需要在后期处理中乘以流体的密度。对于可压缩解算器，p是真实压力。 | 对于可压缩流为 :math:`\mathrm{kg\cdot s^{-1}}`                                                       |
+---------+---------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| epsilon | 湍流耗散率                                                                            | :math:`\mathrm{m^{2}\cdot s^{-3}}`                                                                   |
+---------+---------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| k       | 湍流动能                                                                              | :math:`\mathrm{m^{2}\cdot s^{-2}}`                                                                   |
+---------+---------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| rho     | 密度                                                                                  | :math:`\mathrm{kg\cdot m^{-3}}`                                                                      |
+---------+---------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| alpha   | 分散相体积分数                                                                        |                                                                                                      |
+---------+---------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| Theta   | 颗粒温度                                                                              | :math:`\mathrm{m^{2}\cdot s^{-2}}`                                                                   |
+---------+---------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| rDeltaT | 时间步长的倒数。对于改变局部时间步长的求解器，这表示局部时间步长。                    | :math:`\mathrm{s^{-1}}`                                                                              |
+         +                                                                                       +                                                                                                      +
|         | 这对于调试尤其有用。rDeltaT的高值可能表明需要在一个区域内进一步细化网格。             |                                                                                                      |
+---------+---------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+





边界条件
==================

边界上的某个场值，或者梯度值，其计算方法可以用如下通式表示：

.. math::
    \begin{align}
    & \phi_{f} = A_{1} \phi_{c} + B_{1} \\
    & \nabla \phi_{f} = A_{2} \phi_{c} + B_{2}
    \end{align}

其中 :math:`\phi_{c}` 表示 :math:`\phi` 在邻近边界的网格中心的值，四个系数 :math:`A_{1},B_{1},A_{2},B_{2}` 分别通过 :code:`valueInternalCoeffs` 、 :code:`valueBoundaryCoeffs` 、 :code:`gradientInternalCoeffs` 、 :code:`gradientBoundaryCoeffs` 来表示。

:code:`updateCoeffs()` 主要用来显式地计算并更新变量在边界上的值，当边界上的值是通过某个依赖于外部参数的公式来计算，并且值会随着迭代的进行而不断改变时，则需要用 :code:`updateCoeffs()` 。有些边界条件，比如最基本的 :code:`zeroGradient()` ，不需要外部的参数，只需要每一次将临近网格的值赋给边界就可以了，这时就可以用 :code:`evaluate()` 。

而有些边界条件继承于transform边界，里面额外定义了通过snGrad()和snGradTransformDiag()确定系数的方式，查看src/finiteVolume/fields/fvPatchFields/basic/transform中的transformFvPatchField.C可以看到它们之间的关系：


.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::transformFvPatchField<Type>::valueInternalCoeffs
    (
        const tmp<scalarField>&
    ) const
    {
        return pTraits<Type>::one - snGradTransformDiag();
    }

:code:`pTraits<Type>::one` 表示的是全一向量。上面的代码说明transform边界设定的系数 :math:`A_{1}` 表达式为

.. math::
    \begin{align}
    A_{1} = (1, 1,1) - \text{snGradTransformDiag} = 
    \begin{bmatrix}
    1 - \text{snGradTransformDiag}_{x} \\
    1 - \text{snGradTransformDiag}_{y} \\
    1 - \text{snGradTransformDiag}_{z}
    \end{bmatrix}
    \end{align}


.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::transformFvPatchField<Type>::valueBoundaryCoeffs
    (
        const tmp<scalarField>&
    ) const
    {
        return
            *this
          - cmptMultiply
            (
                valueInternalCoeffs(this->patch().weights()),
                this->patchInternalField()
            );
    }

:code:`cmptMultiply` 表示的是按位相乘。上面的代码说明transform边界设定的系数 :math:`B_{1}` 表达式为

.. math::
    \begin{align}
    B_{1} = \vec{\phi}_{p} - [(1, 1, 1) - \text{snGradTransformDiag}] * \vec{\phi}_{c} = 
    \begin{bmatrix}
    \phi_{px} - (1 - \text{snGradTransformDiag}_{x})\cdot \phi_{cx} \\
    \phi_{py} - (1 - \text{snGradTransformDiag}_{y})\cdot \phi_{cy} \\
    \phi_{pz} - (1 - \text{snGradTransformDiag}_{z})\cdot \phi_{cz}
    \end{bmatrix}
    \end{align}


.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::transformFvPatchField<Type>::gradientInternalCoeffs() const
    {
        return -this->patch().deltaCoeffs()*snGradTransformDiag();
    }

其中 :code:`this->patch().deltaCoeffs()` 可以认为返回的是 :math:`1/d` 。上面的代码说明transform边界条件设定的系数 :math:`A_{2}` 表达式为

.. math::
    \begin{align}
    A_{2} = - \frac{1}{d} \times \text{snGradTransformDiag} =
    \begin{bmatrix}
    - \frac{1}{d} \times \text{snGradTransformDiag}_{x} \\
    - \frac{1}{d} \times \text{snGradTransformDiag}_{y} \\
    - \frac{1}{d} \times \text{snGradTransformDiag}_{z}
    \end{bmatrix}
    \end{align}


.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::transformFvPatchField<Type>::gradientBoundaryCoeffs() const
    {
        return
            snGrad()
          - cmptMultiply(gradientInternalCoeffs(), this->patchInternalField());
    }

上面的代码说明transform边界条件设定的系数 :math:`B_{2}` 表达式为

.. math::
    \begin{align}
    B_{2} = \text{snGrad} - \big( -(\frac{1}{d}) \times \text{snGradTransformDiag} \big) \cdot \vec{\phi}_{c} =
    \begin{bmatrix}
    \text{snGrad}_{x} + \frac{1}{d} \times \text{snGradTransformDiag}_{x} \times \phi_{cx} \\
    \text{snGrad}_{y} + \frac{1}{d} \times \text{snGradTransformDiag}_{y} \times \phi_{cy} \\
    \text{snGrad}_{z} + \frac{1}{d} \times \text{snGradTransformDiag}_{z} \times \phi_{cz} 
    \end{bmatrix}
    \end{align}


部分派生类在定义自己的snGrad()和snGradTransformDiag()会涉及到 :code:`transform` 函数和 :code:`transformFieldMask` 。参考 `OpenFOAM 中的边界条件（三） <http://xiaopingqiu.github.io/2016/04/02/Boundary-conditions-in-OpenFOAM3/>`_ transform 函数的作用为：

.. code-block:: C

    inline scalar transform(constsymmTensor&, const scalar s)
    {
        return s;
    }

    template<class Cmpt>
    inline Vector<Cmpt> transform(const symmTensor& stt, const Vector<Cmpt>& v)
    {
        return stt & v;
    }

而与transformFieldMask有关的下述代码经过测试返回的是 :code:`diag` 本身：

.. code-block:: C

    transformFieldMask<Type>(pow<vector, pTraits<Type>::rank>(diag))



通用边界条件
---------------


fixedValue
^^^^^^^^^^^^

fixedValue边界条件对边界值和梯度值的计算方式如下：

.. math::
    \begin{align}
    x_{p} & = a \\
    \nabla x_{p} & = \frac{a - x_{c}}{d} 
    \end{align}

其中 :math:`a` 是自己通过value关键词设定的值， :math:`d` 是面心与面所属网格中心的距离。于是四个参数的设置应当如下：

.. math::
    \begin{align}
    & A_{1} = 0, && B_{1}=a \\
    & A_{2} = -\frac{1}{d} , && B_{2} = \frac{a}{d} 
    \end{align}

可以通过位于src/finiteVolume/fields/fvPatchFields/basic/fixedValue的fixedValueFvPatchField.C文件查看其内容：

.. code-block:: C

    template<class Type>
    void Foam::fixedValueFvPatchField<Type>::write(Ostream& os) const
    {
        fvPatchField<Type>::write(os);
        writeEntry(os, "value", *this);
    }

上面代码说明fixedValue边界条件需要读取value关键词的值，来赋值给 :code:`*this`


.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::fixedValueFvPatchField<Type>::valueInternalCoeffs
    (
        const tmp<scalarField>&
    ) const
    {
        return tmp<Field<Type>>
        (
            new Field<Type>(this->size(), Zero)
        );
    }

上面的代码是将valueInternalCoeffs也就是 :math:`A_{1}` 直接设置成了零，其中 :code:`Zero` 是OpenFOAM自行定义的可变维度零。


.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::fixedValueFvPatchField<Type>::valueBoundaryCoeffs
    (
        const tmp<scalarField>&
    ) const
    {
        return *this;
    }

上面的代码是将valueBoundaryCoeffs也就是 :math:`B_{1}` 设置为value关键词的值，:code:`*this` 表示类本身也即当前边界上的值。


.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::fixedValueFvPatchField<Type>::gradientInternalCoeffs() const
    {
        return -pTraits<Type>::one*this->patch().deltaCoeffs();
    }

上面的代码是将gradientInternalCoeffs也就是 :math:`A_{2}` 设置为 :math:`-1/d` 。其中 :code:`pTraits<Type>::one` 返回的是可变维度的一；可以近似认为 :code:`this->patch().deltaCoeffs()` 返回的是 :math:`1/d` ，严格来说应该是两个网格中心的距离往接触面法向的投影的倒数。


.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::fixedValueFvPatchField<Type>::gradientBoundaryCoeffs() const
    {
        return this->patch().deltaCoeffs()*(*this);
    }

上面的代码是将gradientBoundaryCoeffs也就是 :math:`B_{2}` 设置为 :math:`1/d \times \text{value}` 。



zeroGradient
^^^^^^^^^^^^^^^

zeroGradient对边界的值和梯度值的计算方式如下：

.. math::
    \begin{align}
    x_{p} &= x_{c} \\
    \nabla x_{p} &= 0
    \end{align}

于是可知四个参数的设置应当如下：

.. math::
    \begin{align}
    & A_{1}=1, && B_{1}=0 \\
    & A_{2}=0, && B_{2}=0
    \end{align}


位于src/finiteVolume/fields/fvPatchFields/basic/zeroGradient的zeroGradientFvPatchField.C如下所示：

.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::zeroGradientFvPatchField<Type>::valueInternalCoeffs
    (
        const tmp<scalarField>&
    ) const
    {
        return tmp<Field<Type>>
        (
            new Field<Type>(this->size(), pTraits<Type>::one)
        );
    }

上面的代码说明zeroGradient边界条件将valueInternalCoeffs也就是 :math:`A_{1}` 设置为 :math:`1` 。 

.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::zeroGradientFvPatchField<Type>::valueBoundaryCoeffs
    (
        const tmp<scalarField>&
    ) const
    {
        return tmp<Field<Type>>
        (
            new Field<Type>(this->size(), Zero)
        );
    }

上面的代码说明zeroGradient边界条件将valueBoundaryCoeffs也就是 :math:`B_{1}` 设置为 :math:`0` 。 

.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::zeroGradientFvPatchField<Type>::gradientInternalCoeffs() const
    {
        return tmp<Field<Type>>
        (
            new Field<Type>(this->size(), Zero)
        );
    }

上面的代码说明zeroGradient边界条件将gradientInternalCoeffs也就是 :math:`A_{2}` 设置为 :math:`0` 。 

.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::zeroGradientFvPatchField<Type>::gradientBoundaryCoeffs() const
    {
        return tmp<Field<Type>>
        (
            new Field<Type>(this->size(), Zero)
        );
    }

上面的代码说明zeroGradient边界条件将gradientBoundaryCoeffs也就是 :math:`B_{2}` 设置为 :math:`0` 。 



fixedGradient
^^^^^^^^^^^^^^^

fixedGradient对边界的值和梯度值的计算方式如下：

.. math::
    \begin{align}
    x_{p} &= x_{c} + a\cdot d \\
    \nabla x_{p} &= a
    \end{align}

其中 :math:`a` 是自行通过gradient关键词设定的固定梯度值， :math:`d` 是面心与面所属网格中心的距离。于是可知四个参数的设置应当如下：

.. math::
    \begin{align}
    & A_{1}=1, && B_{1}=a \cdot d \\
    & A_{2}=0, && B_{2}=a
    \end{align}

位于src/finiteVolume/fields/fvPatchFields/basic/fixedGradient的fixedGradientFvPatchField.C如下所示：

.. code-block:: C

    template<class Type>
    void Foam::fixedGradientFvPatchField<Type>::write(Ostream& os) const
    {
        fvPatchField<Type>::write(os);
        writeEntry(os, "gradient", gradient_);
    }

上面的代码说明fixedGradient边界条件需要读取字典中gradient关键词赋值给 :code:`gradient_` 变量。

.. code-block:: C

    template<class Type>
    void Foam::fixedGradientFvPatchField<Type>::evaluate(const Pstream::commsTypes)
    {
        if (!this->updated())
        {
            this->updateCoeffs();
        }

        Field<Type>::operator=
        (
            this->patchInternalField() + gradient_/this->patch().deltaCoeffs()
        );

        fvPatchField<Type>::evaluate();
    }

上面的代码定义了evaluate操作的内容为 :math:`x_{c} + \frac{a}{(1/d)}` ，其中 :code:`this->patchInternalField()` 返回 :math:`x_{c}` ， :code:`this->patch().deltaCoeffs()` 返回 :math:`1/d` 。

.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::fixedGradientFvPatchField<Type>::valueInternalCoeffs
    (
        const tmp<scalarField>&
    ) const
    {
        return tmp<Field<Type>>(new Field<Type>(this->size(), pTraits<Type>::one));
    }

上面的代码说明fixedGradient边界条件设定了valueInternalCoeffs也就是 :math:`A_{1}` 的值为 :math:`1` 。其中 :code:`pTraits<Type>::one` 返回的是 :math:`1` 。

.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::fixedGradientFvPatchField<Type>::valueBoundaryCoeffs
    (
        const tmp<scalarField>&
    ) const
    {
        return gradient()/this->patch().deltaCoeffs();
    }

上面的代码说明fixedGradient边界条件设定了valueBoundaryCoeffs也就是 :math:`B_{1}` 的值为 :math:`\frac{a}{(1/d)}` 。其中 :code:`gradient()` 返回的是已经映射到场上的 :code:`gradient_` 变量，即 :math:`a` ； :code:`this->patch().deltaCoeffs()` 返回的是 :math:`1/d` 。

.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::fixedGradientFvPatchField<Type>::gradientInternalCoeffs() const
    {
        return tmp<Field<Type>>
        (
            new Field<Type>(this->size(), Zero)    // 设定A2的值为 0
        );
    }

上面的代码说明fixedGradient边界条件设定了gradientInternalCoeffs也就是 :math:`A_{2}` 的值为 :math:`0` 。

.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::fixedGradientFvPatchField<Type>::gradientBoundaryCoeffs() const
    {
        return gradient();    // 设定B2的值为已经映射到场上的gradient_变量，即a
    }

上面的代码说明fixedGradient边界条件设定了gradientBoundaryCoeffs也就是 :math:`B_{2}` 的值为已经映射到场上的 :code:`gradient_` 变量，即 :math:`a` 。



mixed
^^^^^^^^^^^^

mixed边界条件对边界的值和梯度值的计算方式如下：

.. math::
    \begin{align}
    x_{p} &= [(1-\text{valueFraction})x_{c} + \text{valueFraction}\cdot \text{refValue}] + (1-\text{valueFraction}) \cdot \text{refGradient} \cdot d \\
    \nabla x_{p} &= \text{valueFraction}\cdot\frac{\text{refValue} - x_{c}}{d} + (1-\text{valueFraction}) \cdot \text{refGradient} 
    \end{align}

其中refValue是自行通过refValue关键词设定的参考值，refGradient是自行通过refGradient关键词设定的参考梯度，valueFraction是自行通过valueFraction关键词设定的权重值， :math:`d` 是面心与面所属网格中心的距离。于是可知四个参数的设置应当如下：

.. math::
    \begin{align}
    & A_{1}=1-\text{valueFraction}, && B_{1}=\text{valueFraction}\cdot \text{refValue} + (1-\text{valueFraction})\cdot \text{refGradient}\cdot d \\
    & A_{2}=\frac{-\text{valueFraction}}{d}, && B_{2}=\frac{\text{valueFraction}\cdot \text{refValue}}{d} +(1-\text{valueFraction}) \cdot \text{refGradient}
    \end{align}

位于src/finiteVolume/fields/fvPatchFields/basic/mixed的mixedFvPatchField.C如下所示：


.. code-block:: C

    template<class Type>
    void Foam::mixedFvPatchField<Type>::write(Ostream& os) const
    {
        fvPatchField<Type>::write(os);
        writeEntry(os, "refValue", refValue_);
        writeEntry(os, "refGradient", refGrad_);
        writeEntry(os, "valueFraction", valueFraction_);
        writeEntry(os, "value", *this);
    }

上面的代码说明mixed边界条件需要分别读取字典中的refValue、refGradient、valueFraction和value关键词的值，来赋给 :code:`refValue_` 、 :code:`refGrad_` 、 :code:`valueFraction_` 和 :code:`*this` 变量。其中value关键词是由于C++特性导致的，其实并不是必须的。


.. code-block:: C

    template<class Type>
    void Foam::mixedFvPatchField<Type>::evaluate(const Pstream::commsTypes)
    {
        if (!this->updated())
        {
            this->updateCoeffs();
        }

        Field<Type>::operator=    // 定义evaluate操作内容为 w*a + (1-w)*(x_c + b/(1/d) )
        (
            valueFraction_*refValue_
          +
            (1.0 - valueFraction_)*
            (
                this->patchInternalField()
              + refGrad_/this->patch().deltaCoeffs()
            )
        );

        fvPatchField<Type>::evaluate();
    }

上面的代码定义了mixed边界条件的evaluate操作内容为

.. math::
    \begin{align}
    \text{valueFraction} \times \text{refValue}
    + (1.0 - \text{valueFraction}) \times 
    (x_{c} + \frac{\text{refGrad}}{(1/d)})  
    \end{align}


.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::mixedFvPatchField<Type>::valueInternalCoeffs
    (
        const tmp<scalarField>&
    ) const
    {
        return Type(pTraits<Type>::one)*(1.0 - valueFraction_);
    }

上面的代码表明mixed边界条件设定valueInternalCoeffs也就是 :math:`A_{1}` 的值为 :math:`(1 - \text{valueFraction})` 。其中 :code:`pTraits<Type>::one` 作用是调整维度。


.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::mixedFvPatchField<Type>::valueBoundaryCoeffs
    (
        const tmp<scalarField>&
    ) const
    {
        return
             valueFraction_*refValue_                                        // 设定B1的值为 w*a + (1-w)*b/(1/d)
           + (1.0 - valueFraction_)*refGrad_/this->patch().deltaCoeffs();    // this->patch().deltaCoeffs()返回的是 1/d
    }

上面的代码表明mixed边界条件设定valueBoundaryCoeffs也就是 :math:`B_{1}` 的值为 :math:`\text{valueFraction} \times \text{refValue} + (1.0 - \text{valueFraction}) \times \frac{\text{refGrad}}{(1/d)}` 。

.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::mixedFvPatchField<Type>::gradientInternalCoeffs() const
    {
        return -Type(pTraits<Type>::one)*valueFraction_*this->patch().deltaCoeffs();
    }

上面的代码表明mixed边界条件设定gradientInternalCoeffs也就是 :math:`A_{2}` 的值为 :math:`- \text{valueFraction} \times (1/d)` 。


.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::mixedFvPatchField<Type>::gradientBoundaryCoeffs() const
    {
        return
            valueFraction_*this->patch().deltaCoeffs()*refValue_    // 设定B2的值为 w*(1/d)*a + (1-w)*b
          + (1.0 - valueFraction_)*refGrad_;                        // this->patch().deltaCoeffs()返回的是 1/d
    }

上面的代码表明mixed边界条件设定gradientBoundaryCoeffs也就是 :math:`B_{2}` 的值为 :math:`\text{valueFraction} \times (1/d) \times \text{refValue} + (1.0 - \text{valueFraction}) \times \text{refGrad}` 。


directionMixed
^^^^^^^^^^^^^^^^

该类是所有方向混合类型边界条件的基类。该类继承于transform边界条件，通过定义其自身的snGrad()和snGradTransformDiag()函数返回内容来实现。

.. code-block:: C

    template<class Type>
    void Foam::directionMixedFvPatchField<Type>::write(Ostream& os) const
    {
        transformFvPatchField<Type>::write(os);
        writeEntry(os, "refValue", refValue_);               // 读取字典中的关键词refValue赋值给refValue_变量
        writeEntry(os, "refGradient", refGrad_);             // 读取字典中的关键词refGradient赋值给refGrad_变量
        writeEntry(os, "valueFraction", valueFraction_);     // 读取字典中的关键词valueFraction赋值给valueFraction_变量
        writeEntry(os, "value", *this);
    }

上面的代码表明，directionMixed需要读取关键词refValue、refGradient、valueFraction的赋值。


.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::directionMixedFvPatchField<Type>::snGrad() const    // 定义snGrad函数操作内容
    {
        const Field<Type> pif(this->patchInternalField());    // pif用来代表内部场x_c

        tmp<Field<Type>> normalValue = transform(valueFraction_, refValue_);    // 定义normalValue的值，通过transform函数来计算

        tmp<Field<Type>> gradValue = pif + refGrad_/this->patch().deltaCoeffs();    // 定义gradValue的值为 x_c + refGrad / (1/d)

        tmp<Field<Type>> transformGradValue =    // 定义transformGradValue的值，通过transform函数来计算。其中I是单位矩阵
            transform(I - valueFraction_, gradValue);

        return
            (normalValue + transformGradValue - pif)*    // 定义snGrad函数返回结果为 (normalValue + transformGradValue - x_c) * (1/d)
            this->patch().deltaCoeffs();
    }

上面的代码表明，在directionMixed边界条件中，snGrad的具体定义内容为

.. math::
    \begin{align}
    \text{snGrad} &= 
    \frac{1}{d}\Big( \text{valueFraction} \cdot \text{refValue} + (\mathbf{I} - \text{valueFraction}) \cdot (\vec{\phi}_{c} + \text{refGrad}\cdot d) - \vec{\phi}_{c}\Big) \\
    & = \frac{1}{d}
    \begin{bmatrix}
    \text{valueFraction} \times (\text{refValue} -  \phi_{cx}) + (1 - \text{valueFraction}) \times \text{refGrad}\times d) \\
    \text{valueFraction} \times (\text{refValue} -  \phi_{cy}) + (1 - \text{valueFraction}) \times \text{refGrad}\times d) \\
    \text{valueFraction} \times (\text{refValue} -  \phi_{cz}) + (1 - \text{valueFraction}) \times \text{refGrad}\times d)
    \end{bmatrix} 
    \end{align}


.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::directionMixedFvPatchField<Type>::snGradTransformDiag() const    // 定义snGradTransformDiag函数的操作内容
    {
        vectorField diag(valueFraction_.size());    // 定义向量场diag

        diag.replace
        (
            vector::X,
            sqrt(mag(valueFraction_.component(symmTensor::XX)))    // 将diag向量的x分量替换为 \sqrt{ |valueFraction_xx| }
        );
        diag.replace
        (
            vector::Y,
            sqrt(mag(valueFraction_.component(symmTensor::YY)))    // 将diag向量的y分量替换为 \sqrt{ |valueFraction_yy| }
        );
        diag.replace
        (
            vector::Z,
            sqrt(mag(valueFraction_.component(symmTensor::ZZ)))    // 将diag向量的z分量替换为 \sqrt{ |valueFraction_zz| }
        );

        return transformFieldMask<Type>(pow<vector, pTraits<Type>::rank>(diag));
    }

上面的代码表明，在directionMixed边界条件中，snGradTransformDiag的具体定义内容为

.. math::
    \begin{align}
    \text{snGradTransformDiag} = 
    \begin{bmatrix}
    \sqrt{|\text{valueFraction}|} \\
    \sqrt{|\text{valueFraction}|} \\
    \sqrt{|\text{valueFraction}|} 
    \end{bmatrix} 
    \end{align}

因此在directionMixed边界条件中，四个系数的具体定义分别为

.. math::
    \begin{align}
    A_{1} = 
    \begin{bmatrix}
    1 - \sqrt{|\text{valueFraction}|} \\
    1 - \sqrt{|\text{valueFraction}|} \\
    1 - \sqrt{|\text{valueFraction}|}
    \end{bmatrix}
    \end{align}

.. math::
    \begin{align}
    B_{1} = 
    \begin{bmatrix}
    \phi_{px} - (1 - \sqrt{|\text{valueFraction}|}) \times \phi_{cx} \\
    \phi_{py} - (1 - \sqrt{|\text{valueFraction}|}) \times \phi_{cy} \\
    \phi_{pz} - (1 - \sqrt{|\text{valueFraction}|}) \times \phi_{cz}
    \end{bmatrix}
    \end{align}

.. math::
    \begin{align}
    A_{2} = -\frac{1}{d} 
    \begin{bmatrix}
    \sqrt{|\text{valueFraction}|} \\
    \sqrt{|\text{valueFraction}|} \\
    \sqrt{|\text{valueFraction}|}
    \end{bmatrix}
    \end{align}

.. math::
    \begin{align}
    B_{2} = 
    \begin{bmatrix}
    \frac{1}{d}\times  \text{valueFraction} \times \text{refValue} + \frac{1}{d}\times (\sqrt{|\text{valueFraction}|} - \text{valueFraction} ) \times \phi_{cx} + (1 - \text{valueFraction}) \times \text{refGrad} \\
    \frac{1}{d}\times  \text{valueFraction} \times \text{refValue} + \frac{1}{d}\times (\sqrt{|\text{valueFraction}|} - \text{valueFraction} ) \times \phi_{cy} + (1 - \text{valueFraction}) \times \text{refGrad} \\
    \frac{1}{d}\times  \text{valueFraction} \times \text{refValue} + \frac{1}{d}\times (\sqrt{|\text{valueFraction}|} - \text{valueFraction} ) \times \phi_{cz} + (1 - \text{valueFraction}) \times \text{refGrad} 
    \end{bmatrix}
    \end{align}


basicSymmetry
^^^^^^^^^^^^^^^^^

对于标量，该边界条件等价于zeroGradient。对于矢量的情况，边界上的值等于其临近网格中心的值的切向分量，满足：

.. math::
    \begin{align}
    \vec{\phi}_{p} = \vec{\phi}_{c} - (\vec{\phi}_{c} \cdot \vec{n}) \cdot \vec{n} = [\vec{\phi}_{c} + (I - 2\vec{n} \otimes \vec{n}) \cdot \vec{\phi}_{c}] \times \frac{1}{2} 
    \end{align}

各系数在OpenFOAM中的矩阵表示如下：

.. math::
    \begin{align}
    A_{1} =  \begin{bmatrix} 1-|n_{x}| \\ 1-|n_{y}| \\ 1-|n_{z}| \end{bmatrix}
    \end{align}

.. math::
    \begin{align}
    B_{1} =  \begin{bmatrix} \phi_{px} \\ \phi_{py} \\ \phi_{pz} \end{bmatrix}
           - \begin{bmatrix} (1-|n_{x}|)\phi_{cx} \\ (1-|n_{y}|)\phi_{cy} \\ (1-|n_{z}|)\phi_{cz} \end{bmatrix}
    \end{align}

.. math::
    \begin{align}
    A_{2} = -\frac{1}{d}\begin{bmatrix} |n_{x}| \\ |n_{y}| \\ |n_{z}| \end{bmatrix} 
    \end{align}

.. math::
    \begin{align}
    B_{2} = -\frac{1}{d}
            \begin{bmatrix} 
            n_{x}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z}) \\ 
            n_{y}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z}) \\
            n_{z}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z})
            \end{bmatrix} 
            + \frac{1}{d}
            \begin{bmatrix}
            |n_{x}|\phi_{cx} \\
            |n_{y}|\phi_{cy} \\
            |n_{z}|\phi_{cz}
            \end{bmatrix} 
    \end{align}


位于src/finiteVolume/fields/fvPatchFields/basic/basicSymmetry的basicSymmetryFvPatchField.C中定义系数的相关内容如下所示：

.. code-block:: C

    // * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::basicSymmetryFvPatchField<Type>::snGrad() const    // 定义snGrad的具体操作内容
    {
        tmp<vectorField> nHat = this->patch().nf();    // 用nHat表示面法向量

        const Field<Type> iF(this->patchInternalField());    // 用iF表示 \vec{\phi}_{c}

        return
        /*  snGrad的操作定义为 ((I - 2\vec{n} \otimes \vec{n}) \cdot \vec{\phi}_{c} - \vec{\phi}_{c} )\times \frac{1}{2d} 
            分量形式为
            \text{snGrad}_{x} = -\frac{1}{d}n_{x}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z}),
            \text{snGrad}_{y} = -\frac{1}{d}n_{y}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z}),
            \text{snGrad}_{z} = -\frac{1}{d}n_{z}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z})
        */
            (transform(I - 2.0*sqr(nHat), iF) - iF)
           *(this->patch().deltaCoeffs()/2.0);
    }


    template<class Type>
    void Foam::basicSymmetryFvPatchField<Type>::evaluate(const Pstream::commsTypes)
    {
        if (!this->updated())
        {
            this->updateCoeffs();
        }

        tmp<vectorField> nHat = this->patch().nf();    // 用nHat表示面法向量

        const Field<Type> iF(this->patchInternalField());    // 用iF表示 \vec{\phi}_{c}

        Field<Type>::operator=
        (
        /*  定义evaluate操作内容为 \frac{1}{2}(\vec{\phi}_{c} + (I - 2\vec{n} \otimes \vec{n}) \cdot \vec{\phi}_{c})
            分量形式为
            \phi_{cx} - n_{x}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z}),
            \phi_{cy} - n_{y}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z}),
            \phi_{cz} - n_{z}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z})
        */
            (iF + transform(I - 2.0*sqr(nHat), iF))/2.0
        );

        transformFvPatchField<Type>::evaluate();
    }


    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::basicSymmetryFvPatchField<Type>::snGradTransformDiag() const    // 定义snGradTransformDiag具体操作内容
    {
        const vectorField nHat(this->patch().nf());    // 用nHat表示面法向量

        vectorField diag(nHat.size());    // 定义向量 diag = (|n_{x}|, |n_{y}|, |n_{z}|)

        diag.replace(vector::X, mag(nHat.component(vector::X)));
        diag.replace(vector::Y, mag(nHat.component(vector::Y)));
        diag.replace(vector::Z, mag(nHat.component(vector::Z)));

        return transformFieldMask<Type>(pow<vector, pTraits<Type>::rank>(diag));    // snGradTransformDiag返回 diag = (|n_{x}|, |n_{y}|, |n_{z}|)
    }


inletOutlet
^^^^^^^^^^^^^^^^

inletOutlet边界条件是一个一般性的出流条件，同时给定了特定的入流条件。对于入流，该条件相当于fixedValue；对于出流，该条件相当于zeroGradient。该条件继承于mixed边界条件，通过设置不同的refValue、refGrad和valueFraction来实现。


位于src/finiteVolume/fields/fvPatchFields/derived/inletOutlet的inletOutletFvPatchField.C如下所示：

.. code-block:: C

    template<class Type>
    Foam::inletOutletFvPatchField<Type>::inletOutletFvPatchField
    (
        const fvPatch& p,
        const DimensionedField<Type, volMesh>& iF
    )
    :
        mixedFvPatchField<Type>(p, iF),    // 继承于mixed边界条件
        phiName_("phi")
    {
        this->refValue() = Zero;        // 初始化refValue的值为0
        this->refGrad() = Zero;         // 初始化refGrad的值为0
        this->valueFraction() = 0.0;    // 初始化valueFraction的值为0.0
    }

上面的代码表明inletOutlet边界条件继承于mixed边界条件，并且先将refValue、refGradient、valueFraction的值初始化为了 :math:`0` 。


.. code-block:: C

    template<class Type>
    Foam::inletOutletFvPatchField<Type>::inletOutletFvPatchField
    (
        const fvPatch& p,
        const DimensionedField<Type, volMesh>& iF,
        const dictionary& dict
    )
    :
        mixedFvPatchField<Type>(p, iF),    
        phiName_(dict.lookupOrDefault<word>("phi", "phi"))    // 读取子字典中phi关键词的值赋给phiName_变量，默认就是phi
    {
        this->refValue() = Field<Type>("inletValue", dict, p.size());

        if (dict.found("value"))    // 如果子字典中存在value关键词的赋值
        {
            fvPatchField<Type>::operator=
            (
                Field<Type>("value", dict, p.size())    // 将边界的值初始化为value的值
            );
        }
        else
        {
            fvPatchField<Type>::operator=(this->refValue());    // 如果不存在value关键词则将边界的值初始化为refValue的值
        }

        this->refGrad() = Zero;         // 设置refGradient的值为0
        this->valueFraction() = 0.0;    // 设置valueFraction的值为0
    }

上面的代码对边界上的情况进行了初始化。

.. code-block:: C

    template<class Type>
    void Foam::inletOutletFvPatchField<Type>::updateCoeffs()    // 通过updateCoeffs函数来修改mixed边界条件的参数来实现
    {
        if (this->updated())
        {
            return;
        }

        const Field<scalar>& phip =    // 定义phip为通量场的值
            this->patch().template lookupPatchField<surfaceScalarField, scalar>
            (
                phiName_
            );

        this->valueFraction() = neg(phip);    // 设置valueFraction的值为 neg(phip)

        mixedFvPatchField<Type>::updateCoeffs();    // 更新mixed边界条件的参数
    }

上面的代码表明intletOutlet边界条件根据通量场phi的大小来设置valueFraction的值，设置方式为

.. math::
    \begin{align}
    \text{valueFraction} = 
    \left\{\begin{array}{l}
    1, \quad \phi < 0, \\
    0, \quad \phi \ge 0
    \end{array}\right .
    \end{align}

其中 :code:`neg(phip)` 表示当phip小于零时取1，当phip大于等于零时取0，具体定义可以查看src/OpenFOAM/lnInclude/Scalar.H文件。


.. code-block:: C

    template<class Type>
    void Foam::inletOutletFvPatchField<Type>::write(Ostream& os) const
    {
        fvPatchField<Type>::write(os);
        if (phiName_ != "phi")
        {
            writeEntry(os, "phi", phiName_);    // 遇到不是默认的phi的情况时则读取phi关键词赋给的名字
        }
        writeEntry(os, "inletValue", this->refValue());    // 读取子字典的inletValue的值赋给refValue
        writeEntry(os, "value", *this);
    }

上面的代码表明inletOutlet边界条件将会读取字典里inletValue的值赋给refValue，同时会读取value关键词。

inletOutlet边界条件的一般设置方式如下所示：

.. code-block:: C

    patchName
    {
        type            inletOutlet;
        phi             phi;
        inletValue      uniform 0;
        value           uniform 0;
    }



freestream
^^^^^^^^^^^^

这个边界条件提供了一个自由流条件。它是由inletOutlet条件衍生而来的混合条件，其中操作模式根据通量的符号在固定(自由流)值和零梯度之间切换。该边界条件继承于inletOutlet边界条件。

.. code-block:: C

    const Field<Type>& freestreamValue() const
    {
        return this->refValue();
    }

    Field<Type>& freestreamValue()
    {
        return this->refValue();
    }

上面的代码表明freestreamValue和refValue是等价的。


.. code-block:: C

    template<class Type>
    Foam::freestreamFvPatchField<Type>::freestreamFvPatchField
    (
        const fvPatch& p,
        const DimensionedField<Type, volMesh>& iF,
        const dictionary& dict
    )
    :
        inletOutletFvPatchField<Type>(p, iF)
    {
        this->phiName_ = dict.lookupOrDefault<word>("phi","phi");    // 查找通量场phi

        freestreamValue() = Field<Type>("freestreamValue", dict, p.size());    // 读取freestreamValue的值赋给freestreamValue

        if (dict.found("value"))
        {
            fvPatchField<Type>::operator=
            (
                Field<Type>("value", dict, p.size())    // 如果有value关键词则初始化边界值为value的值
            );
        }
        else
        {
            fvPatchField<Type>::operator=(freestreamValue());    // 否则初始化边界值为freestreamValue的值
        }
    }

上面的代码表明freestream继承于inletOutlet边界条件，上面进行了边界情况的初始化，其余操作均与inletOutlet边界条件相同。可以认为freestreamValue和inletValue的作用是等价的。

.. code-block:: C

    template<class Type>
    void Foam::freestreamFvPatchField<Type>::write(Ostream& os) const
    {
        fvPatchField<Type>::write(os);
        if (this->phiName_ != "phi")
        {
            writeEntry(os, "phi", this->phiName_);
        }
        writeEntry(os, "freestreamValue", freestreamValue());
        writeEntry(os, "value", *this);
    }

freestream边界条件的一般设置方式如下所示：

.. code-block:: C

    patchName
    {
        type            freestream;
        freestreamValue uniform (300 0 0);
    }


速度边界条件
---------------

noSlip
^^^^^^^^^

这个边界条件使壁面处的速度固定为零。它继承于fixedValue边界条件。

.. code-block:: C

    Foam::noSlipFvPatchVectorField::noSlipFvPatchVectorField
    (
        const fvPatch& p,
        const DimensionedField<vector, volMesh>& iF,
        const dictionary& dict
    )
    :
        fixedValueFvPatchVectorField(p, iF, dict, false)
    {
        operator==(Zero);    // 继承fixedValue边界条件，设定为固定值 0
    }


partialSlip
^^^^^^^^^^^^^^

对于partialSlip边界，流体在边界法向上的速度为零，边界切向上的速度沿法向成梯度下降，满足：

.. math::
    \begin{align}
    \vec{\phi}_{p} = (1 - \text{valueFraction})[\vec{\phi}_{c} - (\vec{\phi}_{c} \cdot \vec{n}) \cdot \vec{n}] 
                   = (1 - \text{valueFraction})(I - \vec{n} \otimes \vec{n}) \cdot \vec{\phi}_{c}
    \end{align}

其中valueFraction为自行定义的衰减系数。各系数的表达式如下：

.. math::
    \begin{align}
    A_{1} = \begin{bmatrix} 
            (1 - \text{valueFraction})(1 - |n_{x}|) \\
            (1 - \text{valueFraction})(1 - |n_{y}|) \\
            (1 - \text{valueFraction})(1 - |n_{z}|) \\
            \end{bmatrix}
    \end{align}

.. math::
    \begin{align}
    B_{1} = \begin{bmatrix}
            \phi_{px} \\
            \phi_{py} \\
            \phi_{pz}
            \end{bmatrix}
          - \begin{bmatrix} 
            (1 - \text{valueFraction})(1 - |n_{x}|)\phi_{cx} \\
            (1 - \text{valueFraction})(1 - |n_{y}|)\phi_{cy} \\
            (1 - \text{valueFraction})(1 - |n_{z}|)\phi_{cz} \\
            \end{bmatrix}
    \end{align}

.. math::
    \begin{align}
    A_{2} = -\frac{1}{d}
            \begin{bmatrix}
            \text{valueFraction} + (1 - \text{valueFraction})|n_{x}| \\
            \text{valueFraction} + (1 - \text{valueFraction})|n_{y}| \\
            \text{valueFraction} + (1 - \text{valueFraction})|n_{z}|
            \end{bmatrix}
    \end{align}

.. math::
    \begin{align}
    B_{2} = \frac{1}{d} 
            \begin{bmatrix}
            (1 - \text{valueFraction})\big( n_{x} - n_{x}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z}) \big) - \phi_{cx} \\
            (1 - \text{valueFraction})\big( n_{y} - n_{y}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z}) \big) - \phi_{cy} \\
            (1 - \text{valueFraction})\big( n_{z} - n_{z}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z}) \big) - \phi_{cz}
            \end{bmatrix}
          + \frac{1}{d}
            \begin{bmatrix}
            \big( \text{valueFraction} + (1 - \text{valueFraction})|n_{x}| \big) \phi_{cx} \\
            \big( \text{valueFraction} + (1 - \text{valueFraction})|n_{y}| \big) \phi_{cy} \\
            \big( \text{valueFraction} + (1 - \text{valueFraction})|n_{z}| \big) \phi_{cz}
            \end{bmatrix}
    \end{align}

位于src/finiteVolume/fields/fvPatchFields/derived/partialSlip的partialSlipFvPatchField.C中定义系数的相关内容如下所示：

.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::partialSlipFvPatchField<Type>::snGrad() const    // 定义snGrad函数的操作内容
    {
        tmp<vectorField> nHat = this->patch().nf();    // 用nHat来表示面法向量
        const Field<Type> pif(this->patchInternalField());    // 用pif来表示内部场的值 \vec{\phi}_{c}

        return
        /*  snGrad函数的操作内容为 [ (1 - \text{valueFraction}) \times ( I-\vec{n} \otimes \vec{n} ) \cdot \vec{\phi}_{c} - \vec{\phi}_{c} ] * (1/d)
            分量形式为
            \text{snGrad}_{x} = [ (1 - \text{valueFraction}) \times (n_{x} - n_{x}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z})) - \phi_{cx} ] \times (1/d),
            \text{snGrad}_{y} = [ (1 - \text{valueFraction}) \times (n_{y} - n_{y}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z})) - \phi_{cy} ] \times (1/d),
            \text{snGrad}_{z} = [ (1 - \text{valueFraction}) \times (n_{z} - n_{z}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z})) - \phi_{cz} ] \times (1/d)
        */
        (
            (1.0 - valueFraction_)*transform(I - sqr(nHat), pif) - pif
        )*this->patch().deltaCoeffs();
    }


    template<class Type>
    void Foam::partialSlipFvPatchField<Type>::evaluate
    (
        const Pstream::commsTypes
    )
    {
        if (!this->updated())
        {
            this->updateCoeffs();
        }

        tmp<vectorField> nHat = this->patch().nf();

        Field<Type>::operator=    // 定义evaluate的具体操作内容
        (
        /*
            (1 - \text{valueFraction}) \times [( I-\vec{n} \otimes \vec{n} ) \cdot \vec{\phi}_{c}]
        */
            (1.0 - valueFraction_)
           *transform(I - sqr(nHat), this->patchInternalField())
        );

        transformFvPatchField<Type>::evaluate();
    }


    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::partialSlipFvPatchField<Type>::snGradTransformDiag() const    // 定义snGradTransformDiag函数的操作内容
    {
        const vectorField nHat(this->patch().nf());    // 用nHat来表示面法向量
        vectorField diag(nHat.size());    // 定义一个矢量场diag

        diag.replace(vector::X, mag(nHat.component(vector::X)));    // 替换对角矩阵x分量值为 |n_x| 
        diag.replace(vector::Y, mag(nHat.component(vector::Y)));    // 替换对角矩阵y分量值为 |n_y|
        diag.replace(vector::Z, mag(nHat.component(vector::Z)));    // 替换对角矩阵z分量值为 |n_z|
        /* 也即该向量场为 diag = ( |n_x| , |n_y| , |n_z|) */
        return
        /*  snGradTransformDiag函数的操作内容为 valueFraction * (1, 1, 1) + (1 - valueFraction) * diag
            分量形式为
            \text{snGradTransformDiag}_{x} = \text{valueFraction} + (1 - \text{valueFraction}) \times |n_{x}|,
            \text{snGradTransformDiag}_{y} = \text{valueFraction} + (1 - \text{valueFraction}) \times |n_{y}|,
            \text{snGradTransformDiag}_{z} = \text{valueFraction} + (1 - \text{valueFraction}) \times |n_{z}| 
        */
            valueFraction_*pTraits<Type>::one
          + (1.0 - valueFraction_)
           *transformFieldMask<Type>(pow<vector, pTraits<Type>::rank>(diag));
    }


    template<class Type>
    void Foam::partialSlipFvPatchField<Type>::write(Ostream& os) const
    {
        transformFvPatchField<Type>::write(os);
        writeEntry(os, "valueFraction", valueFraction_);    // 读取子字典中的valueFraction关键词赋值给valueFraction_变量
    }

slip
^^^^^^^

这个边界条件提供了一个滑移约束。一般用于无粘性流体的情况。该边界条件继承于basicSymmetry边界条件。

.. code-block:: C

    template<class Type>
    Foam::slipFvPatchField<Type>::slipFvPatchField
    (
        const fvPatch& p,
        const DimensionedField<Type, volMesh>& iF
    )
    :
       basicSymmetryFvPatchField<Type>(p, iF)    // noSlip边界等价于basicSymmetry边界的效果，即法向为零，切向保持
    {}


下面是使用该边界条件的一般设置方式：

.. code-block:: C

    patchName
    {
        type            slip;
    }



freestreamVelocity
^^^^^^^^^^^^^^^^^^^^^^

该边界条件为速度提供了自由流条件。这是一种使用速度方向在正常入口的固定值和正常出口流量的零梯度之间连续混合的进出口条件。该边界条件继承于mixed边界条件。

.. code-block:: C

    const vectorField& freestreamValue() const
    {
        return refValue();
    }

    vectorField& freestreamValue()
    {
        return refValue();
    }

上面的代码表明freestreamValue等价与refValue。

.. code-block:: C

    void Foam::freestreamVelocityFvPatchVectorField::write(Ostream& os) const
    {
        fvPatchVectorField::write(os);
        writeEntry(os, "freestreamValue", freestreamValue());
        writeEntry(os, "value", *this);
    }

上面的代码表明freestreamVelocity边界条件将会读取设置中freestreamValue和value关键词的赋值。

.. code-block:: C

    Foam::freestreamVelocityFvPatchVectorField::freestreamVelocityFvPatchVectorField
    (
        const fvPatch& p,
        const DimensionedField<vector, volMesh>& iF,
        const dictionary& dict
    )
    :
        mixedFvPatchVectorField(p, iF)
    {
        freestreamValue() = vectorField("freestreamValue", dict, p.size());    // 读取freestreamValue的值赋给freestreamValue变量

        if (dict.found("value"))
        {
            fvPatchVectorField::operator=
            (
                vectorField("value", dict, p.size())    // 如果有value关键词则初始化边界值为value的值
            );
        }
        else
        {
            fvPatchVectorField::operator=(freestreamValue());    // 否则初始化边界值为freestreamValue的值
        }

        refGrad() = Zero;       // 初始化refGradient的值为0
        valueFraction() = 1;    // 初始化valueFraction的值为1
    }

上面的代码表明freestreamVelocity继承于mixed边界条件，并进行了边界情况的初始化，并初始化refGradient的值为 :math:`0` ，初始化valueFraction的值为 :math:`1` 。

.. code-block:: C

    void Foam::freestreamVelocityFvPatchVectorField::updateCoeffs()
    {
        if (updated())
        {
            return;
        }

        const Field<vector> Up(0.5*(patchInternalField() + *this));    // 定义Up，通过内部速度场和value的设置进行计算
        const Field<scalar> magUp(mag(Up));    // 定义magUp为Up的模长大小

        const Field<vector> nf(patch().nf());    // 定义nf为网格面单位法向量

        Field<scalar>& vf = valueFraction();    // 定义vf为valueFraction的值

        forAll(vf, i)
        {
            if (magUp[i] > vSmall)
            {
                vf[i] = 0.5 - 0.5*(Up[i] & nf[i])/magUp[i];    // 当Up的模长大小不是小量时valueFraction的设置方法
            }
            else
            {
                vf[i] = 0.5;    // 当Up的模长为小量时设置valueFraction为0.5
            }
        }

        mixedFvPatchField<vector>::updateCoeffs();    // 更新mixed边界条件的参数
    }

上面的代码给出了valueFraction的设置方式：

.. math::
    \begin{align}
    \text{valueFraction} = 
    \left \{\begin{array}{l}
    0.5 - 0.5 \times \frac{0.5\times (\mathbf{U}_{c} + \text{value}) \cdot \mathbf{n}}{|0.5\times (\mathbf{U}_{c} + \text{value})|} , \quad |0.5\times (\mathbf{U}_{c} + \text{value})| > \text{vSmall} \\
    0.5, \qquad\qquad\qquad\qquad\qquad\quad  |0.5\times (\mathbf{U}_{c} + \text{value})| \le \text{vSmall}
    \end{array}\right . 
    \end{align}


pressureInletVelocity
^^^^^^^^^^^^^^^^^^^^^^^^

这个速度入口边界条件适用于指定压力的边界面。流入速度由与边界面法线方向的通量得到。该边界条件继承于fixedValue边界条件，并且一般需要压力场配合使用totalPressure边界条件。

进入src/finiteVolume/fields/fvPatchFields/derived/pressureInletVelocity/pressureInletVelocityFvPatchVectorField.C文件，可以看到如下代码：


.. code-block:: C

    void Foam::pressureInletVelocityFvPatchVectorField::updateCoeffs()
    {
        if (updated())
        {
            return;
        }

        const surfaceScalarField& phi =
            db().lookupObject<surfaceScalarField>(phiName_);

        const fvsPatchField<scalar>& phip =    // 边界面的通量场
            patch().patchField<surfaceScalarField, scalar>(phi);

        tmp<vectorField> n = patch().nf();    // 边界面的单位面法向量
        const Field<scalar>& magS = patch().magSf();    // 边界面的面积

        if (phi.dimensions() == dimFlux)    // 不可压缩流的情况，通量为体积通量
        {
            operator==(n*phip/magS);
        }
        else if (phi.dimensions() == dimMassFlux)    // 可压缩流的情况，通量为质量通量
        {
            const fvPatchField<scalar>& rhop =    // 边界面的密度场
                patch().lookupPatchField<volScalarField, scalar>(rhoName_);

            operator==(n*phip/(rhop*magS));
        }
        else
        {
            FatalErrorInFunction
                << "dimensions of phi are not correct"
                << "\n    on patch " << this->patch().name()
                << " of field " << this->internalField().name()
                << " in file " << this->internalField().objectPath()
                << exit(FatalError);
        }

        fixedValueFvPatchVectorField::updateCoeffs();
    }

上面的代码表明，pressureInletVelocity所设置的边界速度计算方式为：

.. math::
    \begin{align}
    \mathbf{U} =
    \left \{ \begin{array}{l}
    \frac{\phi\mathbf{n}}{|\mathbf{S}_{f}|} ,\quad   ~\text{if}~\phi~\text{is volume flux}  \\
    \frac{\phi\mathbf{n}}{\rho|\mathbf{S}_{f}|},\quad \text{if}~\phi~\text{is mass flux}  
    \end{array} \right .
    \end{align}


.. code-block:: C

    void Foam::pressureInletVelocityFvPatchVectorField::write(Ostream& os) const
    {
        fvPatchVectorField::write(os);
        writeEntryIfDifferent<word>(os, "phi", "phi", phiName_);
        writeEntryIfDifferent<word>(os, "rho", "rho", rhoName_);
        writeEntry(os, "value", *this);
    }

下面是pressureInletVelocity边界条件的一般设置方式：

.. code-block:: C

    patchName
    {
        type            pressureInletVelocity;
        phi             phi;
        rho             rho;    // 可压缩流
        value           uniform 0;
    }


.. note:: 如果预期可能会出现回流现象，则应该设置为pressureInletOutletVelocity边界条件。




pressureInletUniformVelocity
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

该速度入口边界条件适用于指定了压力的边界面。通过求边界面上通量的平均值来得到均一的入流速度，然后将其应用到边界面的法线方向。该边界条件继承于pressureInletUniformVelocity边界条件。

进入src/finiteVolume/fields/fvPatchFields/derived/pressureInletUniformVelocity/pressureInletUniformVelocityFvPatchVectorField.C文件，可以看到如下代码：

.. code-block:: C

    void Foam::pressureInletUniformVelocityFvPatchVectorField::updateCoeffs()
    {
        if (updated())
        {
            return;
        }

        pressureInletVelocityFvPatchVectorField::updateCoeffs();

        operator==(patch().nf()*gSum(patch().Sf() & *this)/gSum(patch().magSf()));
    }

由上面的代码可知，pressureInletUniformVelocity设置的边界速度计算方式为

.. math::
    \begin{align}
    \mathbf{U} = \frac{\mathbf{n} \sum\limits_{\text{global}}(\mathbf{S}_{f}\cdot \mathbf{U}_{p})}{\sum\limits_{\text{global}}|\mathbf{S}_{f}|}
    \end{align}

.. code-block:: C

    void Foam::pressureInletVelocityFvPatchVectorField::write(Ostream& os) const
    {
        fvPatchVectorField::write(os);
        writeEntryIfDifferent<word>(os, "phi", "phi", phiName_);    // 读取通量场的名字
        writeEntryIfDifferent<word>(os, "rho", "rho", rhoName_);    // 读取密度场的名字
        writeEntry(os, "value", *this);
    }

下面是pressureInletVelocity边界条件的一般设置方式：

.. code-block:: C

    patchName
    {
        type            pressureInletVelocity;
        phi             phi;
        rho             rho;    // 可压缩流
        value           uniform 0;
    }


pressureDirectedInletVelocity
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

这个速度入口边界条件适用于指定压力的补丁。流入速度由指定进口方向“方向”的通量得到。该边界条件继承于fixedValue边界条件。


.. code-block:: C

    void Foam::pressureDirectedInletVelocityFvPatchVectorField::updateCoeffs()
    {
        if (updated())
        {
            return;
        }

        const surfaceScalarField& phi =
            db().lookupObject<surfaceScalarField>(phiName_);

        const fvsPatchField<scalar>& phip =    // 获取通量场
            patch().patchField<surfaceScalarField, scalar>(phi);

        tmp<vectorField> n = patch().nf();    // 边界面的法向量
        tmp<scalarField> ndmagS = (n & inletDir_)*patch().magSf();

        if (phi.dimensions() == dimFlux)    // 不可压缩流的情况，通量为体积通量
        {
            operator==(inletDir_*phip/ndmagS);    // 计算边界值
        }
        else if (phi.dimensions() == dimMassFlux)    // 可压缩流的情况，通量为质量通量
        {
            const fvPatchField<scalar>& rhop =    // 获取密度场
                patch().lookupPatchField<volScalarField, scalar>(rhoName_);

            operator==(inletDir_*phip/(rhop*ndmagS));    // 计算边界值
        }
        else
        {
            FatalErrorInFunction
                << "dimensions of phi are not correct"
                << "\n    on patch " << this->patch().name()
                << " of field " << this->internalField().name()
                << " in file " << this->internalField().objectPath()
                << exit(FatalError);
        }

        fixedValueFvPatchVectorField::updateCoeffs();
    }

上面的代码表明，pressureDirectedInletVelocity所设置的边界处的速度计算方式为

.. math::
    \begin{align}
    \mathbf{U} = 
    \left \{ \begin{array}{l}
    \mathbf{V}_{\text{dir}}\frac{\phi}{(\mathbf{n} \cdot \mathbf{V}_{\text{dir}})|\mathbf{S}_{f}|} , \quad \text{if}~\phi~\text{is volume flux}   \\
    \mathbf{V}_{\text{dir}}\frac{\phi}{\rho (\mathbf{n} \cdot \mathbf{V}_{\text{dir}})|\mathbf{S}_{f}| } ,\quad \text{if}~\phi~\text{is mass flux}
    \end{array} \right .
    \end{align}

.. code-block:: C

    void Foam::pressureDirectedInletVelocityFvPatchVectorField::write
    (
        Ostream& os
    ) const
    {
        fvPatchVectorField::write(os);
        writeEntryIfDifferent<word>(os, "phi", "phi", phiName_);
        writeEntryIfDifferent<word>(os, "rho", "rho", rhoName_);
        writeEntry(os, "inletDirection", inletDir_);
        writeEntry(os, "value", *this);
    }

下面是pressureDirectedInletVelocity边界条件的一般设置方式：

.. code-block:: C

    patchName
    {
        type            pressureDirectedInletVelocity;
        phi             phi;
        rho             rho;    // 可压缩流
        inletDirection  uniform (1 0 0);
        value           uniform 0;
    }

pressureInletOutletVelocity
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

这是一个速度入口/出口边界条件，其中需要压力场配合使用fixedValue、totalPressure、entrainmentPressure等边界条件。该边界条件继承于directioniMixed边界，对于出流等价于zeroGradient边界条件；对于入流将会为法向分量设置为zeroGradient而为切向分量设置为fixedValue。外部切向速度可以被任意指定，如果没有设置则视为零。

进入src/finiteVolume/fields/fvPatchFields/derived/pressureInletOutletVelocityFvPatchVectorField.C文件，可以看到如下代码：

.. code-block:: C

    Foam::pressureInletOutletVelocityFvPatchVectorField::
    pressureInletOutletVelocityFvPatchVectorField
    (
        const fvPatch& p,
        const DimensionedField<vector, volMesh>& iF,
        const dictionary& dict
    )
    :
        directionMixedFvPatchVectorField(p, iF),    // 继承于directionMixed边界条件
        phiName_(dict.lookupOrDefault<word>("phi", "phi"))    // 读取phi关键词设置，默认为通量场名称为phi
    {
        fvPatchVectorField::operator=(vectorField("value", dict, p.size()));    // 读取value关键词赋值进行初始化

        if (dict.found("tangentialVelocity"))    // 如果设置了tangentialVelocity关键词则读取赋值
        {
            tangentialVelocity_ =
                Function1<vector>::New("tangentialVelocity", dict);
        }

        refValue() = Zero;         // 初始化refValue为零
        refGrad() = Zero;          // 初始化refGrad为零
        valueFraction() = Zero;    // 初始化valueFraction为零
    }


.. code-block:: C

    void Foam::pressureInletOutletVelocityFvPatchVectorField::updateCoeffs()
    {
        if (updated())
        {
            return;
        }

        if (tangentialVelocity_.valid())    // 如果设置了tangentialVelocity的值
        {
            const scalar t = this->db().time().userTimeValue();    // 获取时间t
            const vector tangentialVelocity = tangentialVelocity_->value(t);    // 获取在时间t时候tangentialVelocity的值
            const vectorField n(patch().nf());    // 边界面的单位面法向量
            refValue() = tangentialVelocity - n*(n & tangentialVelocity);    // 计算refValue
        }

        const fvsPatchField<scalar>& phip =    // 边界面的通量场
            patch().lookupPatchField<surfaceScalarField, scalar>(phiName_);

        valueFraction() = neg(phip)*(I - sqr(patch().nf()));    // 计算valueFraction

        directionMixedFvPatchVectorField::updateCoeffs();
        directionMixedFvPatchVectorField::evaluate();
    }

上面的代码表明，在pressureInletOutletVelocity边界条件中，在没有设置tangentialVelocity关键词的时候，refValue和refGrad的值被默认设置为了零，而valueFraction的计算方式为

.. math::
    \begin{align}
    \text{valueFraction} = 
    \left \{ \begin{array}{l}
    \mathbf{0}, \quad \phi \ge 0 \\
    \mathbf{I} - \mathbf{n}^{2} =
    \begin{bmatrix}
    1 - n_{x}^{2} \\
    1 - n_{y}^{2} \\
    1 - n_{z}^{2}
    \end{bmatrix}
    , \quad \phi < 0
    \end{array} \right . 
    \end{align}

如果设置了tangentialVelocity关键词，那么refValue将不再是零，其计算方式为

.. math::
    \begin{align}
    \text{refValue} = \mathbf{U_{\text{tan}}}(t) - \big(\mathbf{n} \cdot \mathbf{U_{\text{tan}}}(t)\big)\mathbf{n} 
    \end{align}


下面是pressureInletOutletVelocity边界条件的一般设置方式：

.. code-block:: C

    patchName
    {
        type            pressureInletOutletVelocity;
        phi             phi;
        tangentialVelocity (0 0 0);
        value           uniform 0;
    }


pressureDirectedInletOutletVelocity
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

该速度入口/出口边界条件应用于指定了压力的边界。对于出流，该边界条件等价于zeroGradient(由通量定义)；对于入流，速度由指定进口方向的通量得到。该边界条件继承于mixed边界条件。


.. code-block:: C

    Foam::pressureDirectedInletOutletVelocityFvPatchVectorField::
    pressureDirectedInletOutletVelocityFvPatchVectorField
    (
        const fvPatch& p,
        const DimensionedField<vector, volMesh>& iF,
        const dictionary& dict
    )
    :
        mixedFvPatchVectorField(p, iF),    // 继承于mixed边界条件
        phiName_(dict.lookupOrDefault<word>("phi", "phi")),    // 读取通量场名称，默认为phi
        rhoName_(dict.lookupOrDefault<word>("rho", "rho")),    // 读取密度场名称，默认为rho
        inletDir_("inletDirection", dict, p.size())    // 读取指定的进口速度
    {
        fvPatchVectorField::operator=(vectorField("value", dict, p.size()));    // 读取value关键词进行初始化
        refValue() = *this;    // 初始化refValue为当前值
        refGrad() = Zero;    // 初始化refGrad为零
        valueFraction() = 0.0;    // 初始化valueFraction为零
    }



.. code-block:: C

    void Foam::pressureDirectedInletOutletVelocityFvPatchVectorField::updateCoeffs()
    {
        if (updated())
        {
            return;
        }

        const surfaceScalarField& phi =
            db().lookupObject<surfaceScalarField>(phiName_);

        const fvsPatchField<scalar>& phip =    // 获取通量场
            patch().patchField<surfaceScalarField, scalar>(phi);

        tmp<vectorField> n = patch().nf();    // 获取边界面单位面法向量
        tmp<scalarField> ndmagS = (n & inletDir_)*patch().magSf();

        if (phi.dimensions() == dimFlux)    // 不可压缩流体，通量为体积通量
        {
            refValue() = inletDir_*phip/ndmagS;    // 计算refValue
        }
        else if (phi.dimensions() == dimMassFlux)    // 可压缩流体，通量为质量通量
        {
            const fvPatchField<scalar>& rhop =    // 获取密度场
                patch().lookupPatchField<volScalarField, scalar>(rhoName_);

            refValue() = inletDir_*phip/(rhop*ndmagS);    // 计算refValue
        }
        else
        {
            FatalErrorInFunction
                << "dimensions of phi are not correct"
                << "\n    on patch " << this->patch().name()
                << " of field " << this->internalField().name()
                << " in file " << this->internalField().objectPath()
                << exit(FatalError);
        }

        valueFraction() = neg(phip);    // 根据通量正负号设置valueFraction

        mixedFvPatchVectorField::updateCoeffs();
    }

上面的代码表明，refGrad默认被设置为零；valueFraction在入流的时候为设置为 :math:`1` ，在出流的时候设置为 :math:`0` ；refValue的计算方式为

.. math::
    \begin{align}
    \text{refValue} = 
    \left \{ \begin{array}{l}
    \mathbf{V}_{\text{dir}}\frac{\phi}{(\mathbf{n}_{f} \cdot \mathbf{V}_{\text{dir}})|\mathbf{S}_{f}|} , \quad \text{if}~\phi~\text{is volume flux} \\
    \mathbf{V}_{\text{dir}}\frac{\phi}{\rho (\mathbf{n}_{f} \cdot \mathbf{V}_{\text{dir}})|\mathbf{S}_{f}|} , \quad \text{if}~\phi~\text{is mass flux}
    \end{array} \right . 
    \end{align}


.. code-block:: C

    void Foam::pressureDirectedInletOutletVelocityFvPatchVectorField::write
    (
        Ostream& os
    ) const
    {
        fvPatchVectorField::write(os);
        writeEntryIfDifferent<word>(os, "phi", "phi", phiName_);
        writeEntryIfDifferent<word>(os, "rho", "rho", rhoName_);
        writeEntry(os, "inletDirection", inletDir_);
        writeEntry(os, "value", *this);
    }

下面是pressureDirectedInletOutletVelocity边界条件的一般设置方式：

.. code-block:: C

    patchName
    {
        type            pressureDirectedInletOutletVelocity;
        phi             phi;
        rho             rho;    // 可压缩流
        inletDirection  uniform (1 0 0);    // 入流方向
        value           uniform 0;
    }



压强边界条件
--------------

pressure
^^^^^^^^^^^^

静压边界条件。用作静态压力边界条件的基类，强迫替代压力变量，例如p_rgh。该边界条件继承于fixedValue边界条件。

.. code-block:: C

    Foam::pressureFvPatchScalarField::pressureFvPatchScalarField
    (
        const fvPatch& p,
        const DimensionedField<scalar, volMesh>& iF,
        const dictionary& dict
    )
    :
        fixedValueFvPatchScalarField(p, iF, dict, false),
        p_("p", dict, p.size())
    {
        if (dict.found("value"))
        {
            fvPatchScalarField::operator=
            (
                scalarField("value", dict, p.size())
            );
        }
        else
        {
            fvPatchField<scalar>::operator=(p_);
        }
    }


.. code-block:: C

    void Foam::pressureFvPatchScalarField::updateCoeffs()
    {
        if (updated())
        {
            return;
        }

        operator==(p_);

        fixedValueFvPatchScalarField::updateCoeffs();
    }


.. code-block:: C

    void Foam::pressureFvPatchScalarField::write(Ostream& os) const
    {
        fvPatchScalarField::write(os);
        writeEntry(os, "p", p_);
        writeEntry(os, "value", *this);
    }




freestreamPressure
^^^^^^^^^^^^^^^^^^^^^

该边界条件为压力提供了自由流动条件。这是一种出口-进口条件，使用速度方向在正常入口的零梯度和正常出口流量的固定值之间连续混合。该边界条件继承于mixed边界条件，通过利用速度设置valueFraction的值来实现。

进入src/finiteVolume/fields/fvPatchFields/derived/freestreamPressure/freestreamPressureFvPatchScalarField.H文件中，可以看到下面定义了一个成员函数：

.. code-block:: C

    const scalarField& freestreamValue() const
    {
        return refValue();
    }

    scalarField& freestreamValue()
    {
        return refValue();
    }

上面的代码表明freestreamValue等价于mixed边界条件里面的refValue。

进入src/finiteVolume/fields/fvPatchFields/derived/freestreamPressure/freestreamPressureFvPatchScalarField.C文件中，可以看到相关参数设置方式：

.. code-block:: C

    Foam::freestreamPressureFvPatchScalarField::
    freestreamPressureFvPatchScalarField
    (
        const fvPatch& p,
        const DimensionedField<scalar, volMesh>& iF,
        const dictionary& dict
    )
    :
        mixedFvPatchScalarField(p, iF),
        UName_(dict.lookupOrDefault<word>("U", "U")),
        supersonic_
        (
            dict.lookupOrDefault<Switch>("supersonic", false)    // 读取字典关键词supersonic的赋值，默认是false
        )
    {
        freestreamValue() = scalarField("freestreamValue", dict, p.size());

        if (dict.found("value"))
        {
            fvPatchScalarField::operator=
            (
                scalarField("value", dict, p.size())    // 如果字典中有value关键词就先将边界的值初始化为value的值
            );
        }
        else
        {
            fvPatchScalarField::operator=(freestreamValue());    // 如果没有value关键词就将边界初始化为freestreamValue的值
        }

        refGrad() = Zero;       // 初始化refGradient的值为0
        valueFraction() = 0;    // 初始化valueFraction的值为0
    }

上面的代码表明freestreamPreassure边界条件继承于mixed边界条件，并且refGradient的值被设置为了 :math:`0` ，而refValue则设置为了freestreamValue的值。

.. code-block:: C

    void Foam::freestreamPressureFvPatchScalarField::updateCoeffs()
    {
        if (updated())
        {
            return;
        }

        const Field<vector>& Up =    // 定义Up为当前的速度场
            patch().template lookupPatchField<volVectorField, vector>
            (
                UName_
            );

        const Field<scalar> magUp(mag(Up));    // 定义magUp为当前速度场的模长大小

        const Field<vector> nf(patch().nf());    // 定义nf为网格面单位法向量

        Field<scalar>& vf = valueFraction();    // 定义vf为valueFraction的值

        if (supersonic_)    // 如果设置supersonic为true
        {
            forAll(vf, i)
            {
                if (magUp[i] > vSmall)    // 如果速度场大小不是一个小量
                {
                    vf[i] = 0.5 - 0.5*(Up[i] & nf[i])/magUp[i];    // 设置valueFraction的值
                }
                else
                {
                    vf[i] = 0.5;    // 如果速度场大小是一个小量则取valueFraction = 0.5
                }
            }
        }
        else    // 如果设置supersonic为false
        {
            forAll(vf, i)
            {
                if (magUp[i] > vSmall)    // 如果速度场大小不是一个小量
                {
                    vf[i] = 0.5 + 0.5*(Up[i] & nf[i])/magUp[i];    // 设置valueFraction的值
                }
                else
                {
                    vf[i] = 0.5;    // 如果速度场大小是一个小量则取valueFraction = 0.5
                }
            }
        }

        mixedFvPatchField<scalar>::updateCoeffs();    // 更新mixed边界条件参数设置
    }

上面的代码表明，当设置supersonic为true时，valueFraction的计算方式为

.. math::
    \begin{align}
    \text{valueFraction} = 
    \left\{\begin{array}{l}
    0.5 - 0.5\times \frac{\mathbf{U} \cdot \mathbf{n}}{|\mathbf{U}|}, \quad |\mathbf{U}| > \text{vSmall} \\
    0.5 , \qquad\qquad\qquad ~~ |\mathbf{U}| \le \text{vSmall}
    \end{array}\right .
    \end{align}

当设置supersonic为false时，valueFraction的计算方式为

.. math::
    \begin{align}
    \text{valueFraction} = 
    \left\{\begin{array}{l}
    0.5 + 0.5\times \frac{\mathbf{U} \cdot \mathbf{n}}{|\mathbf{U}|}, \quad |\mathbf{U}| > \text{vSmall} \\
    0.5 , \qquad\qquad\qquad ~~ |\mathbf{U}| \le \text{vSmall}
    \end{array}\right .
    \end{align}

于是，freestreamPressure边界条件的四个参数的具体计算方式为

.. math::
    \begin{align}
    & A_{1} = 1 - \text{valueFraction}, && B_{1} = \text{valueFraction} \times \text{freestreamValue} \\
    & A_{2} = \frac{-\text{valueFraction}}{d}, && B_{2} = \frac{\text{valueFraction} \times \text{freestreamValue}}{d}   
    \end{align}


.. code-block:: C

    void Foam::freestreamPressureFvPatchScalarField::write(Ostream& os) const
    {
        fvPatchScalarField::write(os);
        writeEntryIfDifferent<word>(os, "U", "U", UName_);
        writeEntry(os, "freestreamValue", freestreamValue());
        writeEntry(os, "supersonic", supersonic_);
        writeEntry(os, "value", *this);
    }

上面的代码说明freestreamPressure将会读取速度场的名称，并且查找边界设置的freestreamValue、supersonic和value三个关键词。下面是使用freestreamPressure边界条件的一般设置方式：

.. code-block:: C

    patchName
    {
        type               freestreamPressure;
        U                  U;
        freestreamValue    uniform 1e5;
        supersonic         false;
    }



dynamicPressure
^^^^^^^^^^^^^^^^^^^


这个边界条件提供了一个动态压力条件。它从参考压力中减去动能项得到边界上固定的值。它构成了总压力和夹带压力条件的基类。

.. code-block:: C

    void Foam::dynamicPressureFvPatchScalarField::updateCoeffs
    (
        const scalarField& p0p,    // 静压
        const scalarField& K0mKp   // 单位动能
    )
    {
        if (updated())
        {
            return;
        }

        if (internalField().dimensions() == dimPressure)    // 如果内部场单位是Pa，即可压缩流情况
        {
            if (psiName_ == "none")    // 变密度和低速可压缩流的情况
            {
                // Variable density and low-speed compressible flow

                const fvPatchField<scalar>& rho =    // 定义密度场
                    patch().lookupPatchField<volScalarField, scalar>(rhoName_);

                operator==(p0p + rho*K0mKp);    // 计算值设置为fixedValue
            }
            else    // 高速可压缩流的情况
            {
                // High-speed compressible flow

                const fvPatchField<scalar>& psip =    // 定义可压缩性场
                    patch().lookupPatchField<volScalarField, scalar>(psiName_);

                if (gamma_ > 1)    // 比热容比大于1的情况
                {
                    const scalar gM1ByG = (gamma_ - 1)/gamma_;

                    operator==
                    (
                        p0p/pow(scalar(1) - psip*gM1ByG*K0mKp, 1/gM1ByG)
                    );
                }
                else    // 比热容小于等于1的情况
                {
                    operator==(p0p/(scalar(1) - psip*K0mKp));
                }
            }
        }
        else if (internalField().dimensions() == dimPressure/dimDensity)    // 不可压缩流情况
        {
            // Incompressible flow

            operator==(p0p + K0mKp);
        }
        else
        {
            FatalErrorInFunction
                << " Incorrect pressure dimensions " << internalField().dimensions()
                << nl
                << "    Should be " << dimPressure
                << " for compressible/variable density flow" << nl
                << "    or " << dimPressure/dimDensity
                << " for incompressible flow," << nl
                << "    on patch " << this->patch().name()
                << " of field " << this->internalField().name()
                << " in file " << this->internalField().objectPath()
                << exit(FatalError);
        }

        fixedValueFvPatchScalarField::updateCoeffs();    // 调用fixedValue边界条件的updateCoeffs
    }

从上面的代码可以看到，dynamicPressure边界条件实际上是通过某些方式计算得到压强值以fixedValue的方式进行边界设置的。对于变密度和低速可压缩流的情况，需要设置psi场的名为none，且计算方式为

.. math::
    \begin{align}
    p = p_{0} + \rho \cdot K
    \end{align}

对于高速可压缩流的情况，需要给定psi场的名，且计算方式为

.. math::
    \begin{align}
    p = 
    \left \{ \begin{array}{l}
    \frac{p_{0}}{\Big(1 - \psi \cdot \frac{\gamma - 1}{\gamma} \cdot K \Big)^{\frac{\gamma}{\gamma -1}}} , \quad \gamma > 1 \\
    \frac{p_{0}}{1 - \psi \cdot K} , \qquad\qquad\quad  \gamma \le 1
    \end{array} \right.
    \end{align}

对于不可压缩流的情况，计算方式为

.. math::
    \begin{align}
    p = p_{0} + K
    \end{align}


.. code-block:: C

    Foam::dynamicPressureFvPatchScalarField::dynamicPressureFvPatchScalarField
    (
        const fvPatch& p,
        const DimensionedField<scalar, volMesh>& iF,
        const dictionary& dict
    )
    :
        fixedValueFvPatchScalarField(p, iF, dict, false),
        rhoName_(dict.lookupOrDefault<word>("rho", "rho")),
        psiName_(dict.lookupOrDefault<word>("psi", "none")),
        gamma_(dict.lookupOrDefault<scalar>("gamma", 1)),
        p0_("p0", dict, p.size())
    {
        if (dict.found("value"))
        {
            fvPatchField<scalar>::operator=
            (
                scalarField("value", dict, p.size())
            );
        }
        else
        {
            fvPatchField<scalar>::operator=(p0_);
        }
    }

从上面的代码可知，初始化时会将psi的名设置为none，gamma的值初始化为 :math:`1` 。

.. code-block:: C

    void Foam::dynamicPressureFvPatchScalarField::write(Ostream& os) const
    {
        fvPatchScalarField::write(os);
        writeEntry(os, "rho", rhoName_);
        writeEntry(os, "psi", psiName_);
        writeEntry(os, "gamma", gamma_);
        writeEntry(os, "p0", p0_);
        writeEntry(os, "value", *this);
    }


totalPressure
^^^^^^^^^^^^^^^^^

基于恒定总压假设的流入、流出和夹带压力边界条件。对于流出，贴片压力设置为外部静压。对于流入，贴片压力是根据贴片速度和外部静压p0和外部速度U0来评估的，外部速度U0是根据贴片速度边界条件(如果使用该边界条件)中的可选tangentialVelocity入口查找的，否则U0被假设为零，外部总压力等于外部静压。

.. code-block:: C

    void Foam::totalPressureFvPatchScalarField::updateCoeffs()
    {
        // 获取通量场，用来表明方向，后续根据其正负号来运算
        const fvsPatchField<scalar>& phip = patch().lookupPatchField<surfaceScalarField, scalar>(phiName_);

        // 获取速度场
        const fvPatchField<vector>& Up = patch().lookupPatchField<volVectorField, vector>(UName_);

        if (isA<pressureInletOutletVelocityFvPatchVectorField>(Up))    // 如果速度场的边界条件设为了pressureInletOutletVelocity
        {
            const pressureInletOutletVelocityFvPatchVectorField& Upiov =
                refCast<const pressureInletOutletVelocityFvPatchVectorField>(Up);

            if (Upiov.tangentialVelocity().valid())
            {
                const scalar t = this->db().time().userTimeValue();

                dynamicPressureFvPatchScalarField::updateCoeffs
                (
                    p0_,
                    0.5*neg(phip)*magSqr(Upiov.tangentialVelocity()->value(t))
                  - 0.5*neg(phip)*magSqr(Up)
                );

                return;
            }
        }

        dynamicPressureFvPatchScalarField::updateCoeffs
        (
            p0_,
            -0.5*neg(phip)*magSqr(Up)
        );
    }

可以看到totalPressure边界条件继承于dynamicPressure边界条件，就是通过字典关键词p0来设置dynamicPressure中p0p的值，并且确定了单位动能的计算方式为

.. math::
    \begin{align}
    K = 
    \left \{ \begin{array}{l}
    0, \quad \phi \ge 0 \\
    -\frac{1}{2}|\mathbf{U}|^{2} ,\quad \phi < 0 
    \end{array} \right .
    \end{align}

而当速度边界条件设置为pressureInletOutletVelocity时，单位动能的计算方式则有所不同：

.. math::
    \begin{align}
    K = 
    \left \{ \begin{array}{l}
    0, \quad \phi \ge 0 \\
    \frac{1}{2}|\mathbf{U}_{\text{tan}}(t)|^{2} - \frac{1}{2}|\mathbf{U}|^{2}, \quad \phi < 0
    \end{array} \right .
    \end{align}


.. code-block:: C

    void Foam::totalPressureFvPatchScalarField::write(Ostream& os) const
    {
        dynamicPressureFvPatchScalarField::write(os);
        writeEntryIfDifferent<word>(os, "U", "U", UName_);
        writeEntryIfDifferent<word>(os, "phi", "phi", phiName_);
    }

下面是totalPressure的一般设置方式：

.. code-block:: C

    patchName
    {
        type            totalPressure;
        rho             rho;              // 可压缩流
        psi             none;             // 低速可压缩流
        gamma           1.4               // 可压缩流
        U               U;
        phi             phi;
        p0              uniform 1e5;
    }


温度边界条件
---------------

totalTemperature
^^^^^^^^^^^^^^^^^^^

这个边界条件提供了一个总温度条件。该边界条件继承于fixedValue边界条件。

进入src/finiteVolume/fields/fvPatchFields/derived/totalTemperature/totalTemperatureFvPatchScalarField.C文件，可以看到如下代码：

.. code-block:: C

    Foam::totalTemperatureFvPatchScalarField::totalTemperatureFvPatchScalarField
    (
        const fvPatch& p,
        const DimensionedField<scalar, volMesh>& iF,
        const dictionary& dict
    )
    :
        fixedValueFvPatchScalarField(p, iF, dict, false),
        UName_(dict.lookupOrDefault<word>("U", "U")),                 // 读取速度场名称，默认为U
        phiName_(dict.lookupOrDefault<word>("phi", "phi")),           // 读取通量场名称，默认为phi
        psiName_(dict.lookupOrDefault<word>("psi", "thermo:psi")),    // 读取可压缩性场名称，默认为thermo:psi
        gamma_(dict.lookup<scalar>("gamma")),                         // 读取比热容比的赋值
        T0_("T0", dict, p.size())                                     // 读取参考温度的赋值
    {
        if (dict.found("value"))    // 如果有value关键词则用value关键词的赋值进行初始化
        {
            fvPatchField<scalar>::operator=
            (
                scalarField("value", dict, p.size())
            );
        }
        else
        {
            fvPatchField<scalar>::operator=(T0_);    // 否则使用T0的值进行初始化
        }
    }

.. code-block:: C

    void Foam::totalTemperatureFvPatchScalarField::updateCoeffs()
    {
        if (updated())
        {
            return;
        }

        const fvPatchVectorField& Up = patch().lookupPatchField<volVectorField, vector>(UName_);    // 获取速度场
        const fvsPatchField<scalar>& phip = patch().lookupPatchField<surfaceScalarField, scalar>(phiName_);    // 获取通量场
        const fvPatchField<scalar>& psip = patch().lookupPatchField<volScalarField, scalar>(psiName_);    // 获取可压缩性场
        scalar gM1ByG = (gamma_ - 1.0)/gamma_;

        operator==
        (
            T0_/(1.0 + 0.5*psip*gM1ByG*neg(phip)*magSqr(Up))    // 计算边界处的赋值
        );

        fixedValueFvPatchScalarField::updateCoeffs();
    }

上面的代码表明，totalTemperature边界条件的边界温度计算方式为

.. math::
    \begin{align}
    T = 
    \left \{ \begin{array}{l}
    T_{0}, \quad \phi \ge 0 \\
    \frac{T_{0}}{1 + \frac{1}{2}\psi \frac{\gamma - 1}{\gamma}|\mathbf{U}|^{2}}, \quad \phi <0
    \end{array} \right .
    \end{align}

.. code-block:: C

    void Foam::totalTemperatureFvPatchScalarField::write(Ostream& os) const
    {
        fvPatchScalarField::write(os);
        writeEntryIfDifferent<word>(os, "U", "U", UName_);
        writeEntryIfDifferent<word>(os, "phi", "phi", phiName_);
        writeEntryIfDifferent<word>(os, "psi", "thermo:psi", psiName_);
        writeEntry(os, "gamma", gamma_);
        writeEntry(os, "T0", T0_);
        writeEntry(os, "value", *this);
    }



无反射边界条件
-----------------

advective
^^^^^^^^^^^^

可以参考 `OpenFOAM无反射边界条件源码学习 <https://blog.csdn.net/weixin_39124457/article/details/120152679>`_ 

该边界条件提供了一个平流流出条件，基于求解边界处的DDt(W, field) = 0，其中W为波速，field为应用该边界条件的场。该边界条件支持标准时间格式(Euler, backward, CrankNicolson, localEuler)。此外，还提供了一种可选机制，通过指定松弛长度尺度lInf和远场值fieldInf，将边界处的值放松到指定的远场值。出口的流/波速度(w)由虚函数advectionSpeed()提供，该函数的默认实现需要通量场的名称(phi)，如果给出的是质量通量而不是体积通量则还需要密度(rho)。

.. note:: 出口的流/波速度可以通过从这个类中派生一个专门的BC并覆盖advectionSpeed()来改变，例如在waveTransmissiveFvPatchField中，advectionSpeed()计算并返回流速度加上声波速度，从而创建一个声波传输边界条件。

边界处无反射在物理意义上可以认为是该物理量在边界处的物质导数为零，即由当地时间变化所引起的变化率与由流体通过边界流出引起的变化率的和恒为零：

.. math::
    \begin{align}
    \frac{D\phi}{Dt} = \frac{\partial \phi}{\partial t} + \mathbf{U} \cdot \nabla \phi 
    \approx \frac{\partial \phi}{\partial t} + U_{n}\cdot \frac{\partial \phi}{\partial \mathbf{n}} = 0
    \end{align}

其中 :math:`\phi` 就是需要无反射处理的流场变量。在后续， :math:`\frac{\partial \phi}{\partial t}` 项需要根据时间离散格式进行不同的处理， :math:`U_{n}` 则通过advectionSpeed()函数计算。

.. code-block:: C

    template<class Type>
    Foam::advectiveFvPatchField<Type>::advectiveFvPatchField
    (
        const fvPatch& p,
        const DimensionedField<Type, volMesh>& iF,
        const dictionary& dict
    )
    :
        mixedFvPatchField<Type>(p, iF),    // 继承于mixed边界条件
        phiName_(dict.lookupOrDefault<word>("phi", "phi")),    // 获取通量场的名称
        rhoName_(dict.lookupOrDefault<word>("rho", "rho")),    // 获取密度场的名称
        fieldInf_(Zero),    // 远场值初始化为零
        lInf_(-great)       // 松弛长度尺度初始化为-great
    {
        if (dict.found("value"))    // 如果设置了value
        {
            fvPatchField<Type>::operator=
            (
                Field<Type>("value", dict, p.size())    // 则用value初始化边界值
            );
        }
        else
        {
            fvPatchField<Type>::operator=(this->patchInternalField());   // 否则使用内部场的值初始化
        }

        this->refValue() = *this;       // refValue初始化为边界的当前值
        this->refGrad() = Zero;         // refGrad初始化为零
        this->valueFraction() = 0.0;    // valueFraction初始化为零

        if (dict.readIfPresent("lInf", lInf_))    // 如果设置了松弛长度尺度则读取
        {
            dict.lookup("fieldInf") >> fieldInf_;    // 并进一步读取远场值

            if (lInf_ < 0.0)    // 如果松弛长度尺度为负数则报错
            {
                FatalIOErrorInFunction
                (
                    dict
                )   << "unphysical lInf specified (lInf < 0)" << nl
                    << "    on patch " << this->patch().name()
                    << " of field " << this->internalField().name()
                    << " in file " << this->internalField().objectPath()
                    << exit(FatalIOError);
            }
        }
    }

上面的代码表明，refGrad被初始化为零，并且后续也没有修改。如果在字典中设置了松弛长度尺度lInf，那么它必须大于等于0，否则将会报错；而且只有设置了lInf之后才会进一步读取远场值fieldInf。

.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::scalarField>
    Foam::advectiveFvPatchField<Type>::advectionSpeed() const
    {
        const surfaceScalarField& phi = this->db().objectRegistry::template lookupObject<surfaceScalarField>(phiName_);
        // 获取通量场
        const fvsPatchField<scalar>& phip = this->patch().template lookupPatchField<surfaceScalarField, scalar>(phiName_);

        if (phi.dimensions() == dimMassFlux)    // 可压缩流的情况，通量为质量通量
        {
            // 获取密度场
            const fvPatchScalarField& rhop = this->patch().template lookupPatchField<volScalarField, scalar>(rhoName_);

            return phip/(rhop*this->patch().magSf());
        }
        else
        {
            return phip/this->patch().magSf();
        }
    }

上面的代码定义了advectionSpeed()函数返回的内容，返回值为

.. math::
    \begin{align}
    w = 
    \left\{\begin{array}{l}
    \frac{\phi}{|\mathbf{S}_{f}|} ,\quad \text{if}~\phi~\text{is volume flux}  \\
    \frac{\phi}{\rho |\mathbf{S}_{f}|} ,\quad \text{if}~\phi~\text{is mass flux}  
    \end{array}\right .
    \end{align}

.. code-block:: C

    template<class Type>
    void Foam::advectiveFvPatchField<Type>::updateCoeffs()
    {
        if (this->updated())
        {
            return;
        }

        const fvMesh& mesh = this->internalField().mesh();

        word ddtScheme
        (
            mesh.schemes().ddt(this->internalField().name())
        );
        scalar deltaT = this->db().time().deltaTValue();    // 获取时间步长

        const GeometricField<Type, fvPatchField, volMesh>& field =    // 获取内部场
            this->db().objectRegistry::template
            lookupObject<GeometricField<Type, fvPatchField, volMesh>>
            (
                this->internalField().name()
            );

        // Calculate the advection speed of the field wave
        // If the wave is incoming set the speed to 0.
        const scalarField w(Foam::max(advectionSpeed(), scalar(0)));    // 计算advectionSpeed，如果是入流则取0

        // Calculate the field wave coefficient alpha (See notes)
        const scalarField alpha(w*deltaT*this->patch().deltaCoeffs());    // 计算场波系数alpha

        label patchi = this->patch().index();

        // Non-reflecting outflow boundary
        // If lInf_ defined setup relaxation to the value fieldInf_.
        if (lInf_ > 0)    // 如果松弛长度尺度大于0
        {
            // Calculate the field relaxation coefficient k (See notes)
            const scalarField k(w*deltaT/lInf_);    // 计算场松弛系数k

            if    // 如果时间离散格式设置的是Euler或CrankNicolson格式
            (
                ddtScheme == fv::EulerDdtScheme<scalar>::typeName
             || ddtScheme == fv::CrankNicolsonDdtScheme<scalar>::typeName
            )
            {
                this->refValue() = (field.oldTime().boundaryField()[patchi] + k*fieldInf_)/(1.0 + k);    // 计算refValue

                this->valueFraction() = (1.0 + k)/(1.0 + alpha + k);    // 计算valueFraction
            }
            else if (ddtScheme == fv::backwardDdtScheme<scalar>::typeName)    // 如果时间离散格式设置的是backward格式
            {
                this->refValue() =    // 计算refValue
                (
                    2.0*field.oldTime().boundaryField()[patchi]
                  - 0.5*field.oldTime().oldTime().boundaryField()[patchi]
                  + k*fieldInf_
                )/(1.5 + k);

                this->valueFraction() = (1.5 + k)/(1.5 + alpha + k);    // 计算valueFraction
            }
            else if    // 如果时间离散格式设置的是localEuler格式
            (
                ddtScheme == fv::localEulerDdtScheme<scalar>::typeName
            )
            {
                const volScalarField& rDeltaT = fv::localEulerDdt::localRDeltaT(mesh);

                // Calculate the field wave coefficient alpha (See notes)
                const scalarField alpha    // 更新场波系数alpha
                (
                    w*this->patch().deltaCoeffs()/rDeltaT.boundaryField()[patchi]
                );

                // Calculate the field relaxation coefficient k (See notes)
                const scalarField k(w/(rDeltaT.boundaryField()[patchi]*lInf_));    // 更新场松弛系数k

                this->refValue() = (field.oldTime().boundaryField()[patchi] + k*fieldInf_)/(1.0 + k);    // 计算refValue

                this->valueFraction() = (1.0 + k)/(1.0 + alpha + k);    // 计算valueFraction
            }
            else    // 当设置的时间离散格式不是Euler,CrankNicolson,backward,localEuler中的其中一种时将报错
            {
                FatalErrorInFunction
                    << ddtScheme << nl
                    << "    on patch " << this->patch().name()
                    << " of field " << this->internalField().name()
                    << " in file " << this->internalField().objectPath()
                    << exit(FatalError);
            }
        }
        else    // 如果松弛长度尺度等于0
        {
            if    // 如果时间离散格式设置的是Euler或CrankNicolson格式
            (
                ddtScheme == fv::EulerDdtScheme<scalar>::typeName
             || ddtScheme == fv::CrankNicolsonDdtScheme<scalar>::typeName
            )
            {
                this->refValue() = field.oldTime().boundaryField()[patchi];    // 计算refValue

                this->valueFraction() = 1.0/(1.0 + alpha);    // 计算valueFraction
            }
            else if (ddtScheme == fv::backwardDdtScheme<scalar>::typeName)    // 如果时间离散格式设置的是backward格式
            {
                this->refValue() =    // 计算refValue
                (
                    2.0*field.oldTime().boundaryField()[patchi]
                  - 0.5*field.oldTime().oldTime().boundaryField()[patchi]
                )/1.5;

                this->valueFraction() = 1.5/(1.5 + alpha);    // 计算valueFraction
            }
            else if    // 如果时间离散格式设置的是localEuler格式
            (
                ddtScheme == fv::localEulerDdtScheme<scalar>::typeName
            )
            {
                const volScalarField& rDeltaT = fv::localEulerDdt::localRDeltaT(mesh);

                // Calculate the field wave coefficient alpha (See notes)
                const scalarField alpha    // 更新场波系数alpha
                (
                    w*this->patch().deltaCoeffs()/rDeltaT.boundaryField()[patchi]
                );

                this->refValue() = field.oldTime().boundaryField()[patchi];    // 计算refValue

                this->valueFraction() = 1.0/(1.0 + alpha);    // 计算valueFraction
            }
            else    // 当设置的时间离散格式不是Euler,CrankNicolson,backward,localEuler中的其中一种时将报错
            {
                FatalErrorInFunction
                    << ddtScheme
                    << "\n    on patch " << this->patch().name()
                    << " of field " << this->internalField().name()
                    << " in file " << this->internalField().objectPath()
                    << exit(FatalError);
            }
        }

        mixedFvPatchField<Type>::updateCoeffs();
    }

上面的代码表明，advective边界条件设置的边界值与松弛长度尺度的设置以及时间离散格式的设置有关。当松弛长度尺度lInf设置为0时，refValue设置方式如下：

1. 如果时间离散格式为Euler或CrankNicolson或localEuler，则
   
.. math::
    \begin{align}
    \text{refValue} = \phi_{p_{\text{old}}}
    \end{align}

2. 如果时间离散格式为backward，则

.. math::
    \begin{align}
    \text{refValue} = \frac{2}{3}\times (2\phi_{p_{\text{old}}} - \frac{1}{2}\phi_{p_{\text{oldold}}})
    \end{align}

当松弛长度尺度lInf设置为0时，valueFraction的设置方式如下：

1. 如果时间离散格式为Euler或CrankNicolson，则

.. math::
    \begin{align}
    \text{valueFraction} = \frac{1}{1 + \alpha} = \frac{1}{1 + w\Delta t \times \frac{1}{d}}
    \end{align}

2. 如果时间离散格式为backward，则

.. math::
    \begin{align}
    \text{valueFraction} = \frac{1.5}{1.5 + \alpha} = \frac{1.5}{1.5 + w\Delta t \times \frac{1}{d}}
    \end{align}

3. 如果时间离散格式为localEuler，则

.. math::
    \begin{align}
    \text{valueFraction} = \frac{1}{1 + \alpha'} = \frac{1}{1 + (w\times\frac{1}{d})/ \text{rDeltaT}}
    \end{align}

当松弛长度尺度lInf设置为大于零的时候，refValue的设置方式如下：

1. 如果时间离散格式为Euler或CrankNicolson，则
   
.. math::
    \begin{align}
    \text{refValue} = \frac{\phi_{p_{\text{old}}} + k \times \text{fieldInf}}{1 + k} 
    = \frac{\phi_{p_{\text{old}}} + \frac{w\Delta t}{\text{lInf}}\times \text{fieldInf}}{1 + \frac{w\Delta t}{\text{lInf}}} 
    \end{align}

2. 如果时间离散格式为backward，则
   
.. math::
    \begin{align}
    \text{refValue} = \frac{2\phi_{p_{\text{old}}} - 0.5\phi_{p_{\text{oldold}}} + k\times \text{fieldInf}}{1.5 + k}
    = \frac{2\phi_{p_{\text{old}}} - 0.5\phi_{p_{\text{oldold}}} + \frac{w\Delta t}{\text{lInf}}\times \text{fieldInf}}{1.5 + \frac{w\Delta t}{\text{lInf}}}
    \end{align}

3. 如果时间离散格式为localEuler，则

.. math::
    \begin{align}
    \text{refValue} = \frac{\phi_{p_{\text{old}}} + k' \times \text{fieldInf}}{1 + k'}
    = \frac{\phi_{p_{\text{old}} + \frac{w}{\text{rDeltaT} \times \text{lInf}}\times \text{fieldInf}}}{1 + \frac{w}{\text{rDeltaT} \times \text{lInf}}}
    \end{align}

当松弛长度尺度lInf设置为大于零的时候，valueFraction的设置方式如下：

1. 如果时间离散格式为Euler或CrankNicolson，则
   
.. math::
    \begin{align}
    \text{valueFraction} = \frac{1 + k}{1 + \alpha + k}
    = \frac{1 + \frac{w\Delta t}{\text{lInf}}}{1 + \frac{w\Delta t}{d} + \frac{w\Delta t}{\text{lInf}}}
    \end{align}

2. 如果时间离散格式为backward，则

.. math::
    \begin{align}
    \text{valueFraction} = \frac{1.5 + k}{1.5 + \alpha + k}
    = \frac{1.5 + \frac{w\Delta t}{\text{lInf}}}{1.5 + \frac{w\Delta t}{d} + \frac{w\Delta t}{\text{lInf}}}
    \end{align}

3. 如果时间离散格式为localEuler，则
   
.. math::
    \begin{align}
    \text{valueFraction} = \frac{1 + k'}{1 + \alpha' + k'}
    = \frac{1 + \frac{w}{\text{rDeltaT} \times \text{lInf}}}{1 + \frac{w}{d\times \text{rDeltaT}} + \frac{w}{\text{rDeltaT}\times \text{lInf}}}
    \end{align}

.. note:: 

    下面以Euler格式以及lInf设置为0的情况为例，说明各个系数为何设置成如上形式：

    .. math::
        \begin{align}
        \frac{\partial \phi}{\partial t} + U_{n}\cdot \frac{\partial \phi}{\partial \mathbf{n}}
        = \frac{\phi_{p} - \phi_{\text{old}}}{\Delta t} + w \times \frac{\phi_{p} - \phi_{c}}{d}  
        \end{align}

    于是可以得到

    .. math::
        \begin{align}
        \phi_{p} = \frac{\frac{1}{\Delta t}\phi_{\text{old}}}{\frac{1}{\Delta t} + w\times \frac{1}{d}} 
        + \frac{w\times \frac{1}{d} \phi_{c}}{\frac{1}{\Delta t} + w \times \frac{1}{d}}
        = \Big( 1 - \frac{1}{1 + w\Delta t\times \frac{1}{d}} \Big)\phi_{c}
        + \frac{1}{1 + w\Delta t \times \frac{1}{d}}\phi_{\text{old}} 
        \end{align}

    据此可以得到refValue、refGrad和valueFraction的表达式。


.. note:: 

    对于lInf设置大于零的情况，以Euler格式为例，用上述方法进行整理可以得到其求解的方程为

    .. math::
        \begin{align}
        \frac{\partial \phi}{\partial t} 
        + U_{n}\cdot \frac{\partial \phi}{\partial \mathbf{n}}
        = \frac{\phi_{p} - \phi_{p_{\text{old}}}}{\Delta t} 
        + w\times \Big( \frac{\phi_{p} - \phi_{c}}{d} + \frac{\phi_{p} - \text{fieldInf}}{\text{lInf}}  \Big) 
        = 0
        \end{align} 

    由此可知，lInf可以理解为当前边界面与设想远场位置的距离。




.. code-block:: C

    template<class Type>
    void Foam::advectiveFvPatchField<Type>::write(Ostream& os) const
    {
        fvPatchField<Type>::write(os);

        writeEntryIfDifferent<word>(os, "phi", "phi", phiName_);
        writeEntryIfDifferent<word>(os, "rho", "rho", rhoName_);

        if (lInf_ > 0)
        {
            writeEntry(os, "fieldInf", fieldInf_);
            writeEntry(os, "lInf", lInf_);
        }

        writeEntry(os, "value", *this);
    }


下面是advective边界条件一般的设置方式：

.. code-block:: C

    patchName
    {
        type            advective;
        phi             phi;
        rho             rho;     // 可压缩流的情况
        lInf            1;       // 松弛长度尺度
        fieldInf        2902;    // 远场值
    }



waveTransmissive
^^^^^^^^^^^^^^^^^^

该边界条件通过求解边界处DDt(W, field) = 0提供了一个波透射流出条件，W为波速，field为应用该边界条件的场。该边界条件继承于advective边界条件，不过求解的方程改为了

.. math::
    \begin{align}
    \frac{D\phi}{Dt} \approx \frac{\partial \phi}{\partial t} + (U_{n} + c) \cdot \frac{\partial \phi}{\partial \mathbf{n}} = 0 
    \end{align}

所以waveTransmissive边界条件就是设置了自己的advectionSpeed()函数，其中添加了音速。

进入src/finiteVolume/fields/fvPatchFields/derived/waveTransmissive/waveTransmissiveFvPatchField.C文件，可以看到如下代码：

.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::scalarField>
    Foam::waveTransmissiveFvPatchField<Type>::advectionSpeed() const
    {
        // Lookup the velocity and compressibility of the patch
        const fvPatchField<scalar>& psip =    // 获取可压缩性场
            this->patch().template
                lookupPatchField<volScalarField, scalar>(psiName_);

        const surfaceScalarField& phi =
            this->db().template lookupObject<surfaceScalarField>(this->phiName_);

        scalarField phip    // 获取通量场
        (
            this->patch().template
                lookupPatchField<surfaceScalarField, scalar>(this->phiName_)
        );

        if (phi.dimensions() == dimMassFlux)    // 可压缩流的情况，通量为质量通量
        {
            const fvPatchScalarField& rhop =    // 获取密度场
                this->patch().template
                    lookupPatchField<volScalarField, scalar>(this->rhoName_);

            phip /= rhop;    // 提前将通量除以密度，统一为体积通量
        }

        // Calculate the speed of the field wave w
        // by summing the component of the velocity normal to the boundary
        // and the speed of sound (sqrt(gamma_/psi)).
        return phip/this->patch().magSf() + sqrt(gamma_/psip);    // 求解波速度w
    }

上面的代码表明，在waveTransmissive边界条件中，advectionSpeed()返回的波速度被修改为了

.. math::
    \begin{align}
    w = 
    \left \{ \begin{array}{l}
    \frac{\phi}{|\mathbf{S}_{f}|} + \sqrt{\frac{\gamma}{\psi}}
    ,\quad \text{if}~\phi~\text{is volume flux} \\
    \frac{\phi}{\rho |\mathbf{S}_{f}|} + \sqrt{\frac{\gamma}{\psi}}
    ,\quad \text{if}~\phi~\text{is mass flux}
    \end{array} \right .
    \end{align}

.. code-block:: C

    template<class Type>
    void Foam::waveTransmissiveFvPatchField<Type>::write(Ostream& os) const
    {
        fvPatchField<Type>::write(os);

        writeEntryIfDifferent<word>(os, "phi", "phi", this->phiName_);
        writeEntryIfDifferent<word>(os, "rho", "rho", this->rhoName_);
        writeEntryIfDifferent<word>(os, "psi", "thermo:psi", psiName_);

        writeEntry(os, "gamma", gamma_);

        if (this->lInf_ > small)
        {
            writeEntry(os, "fieldInf", this->fieldInf_);
            writeEntry(os, "lInf", this->lInf_);
        }

        writeEntry(os, "value", *this);
    }

下面是waveTransmissive边界条件的一般设置方式：

.. code-block:: C

    patchName
    {
        type            waveTransmissive;
        phi             phi;
        psi             psi;
        gamma           1.4;
        lInf            1;
        fieldInf        2900;
    }


自定义边界条件
----------------


codedFixedValue
^^^^^^^^^^^^^^^^^^

下面是在射流外设置一个线性分布的速度场的例子：

.. code-block:: C

    AirInlet
        {
            type        codedFixedValue;
            value       uniform (0 0 6.10);

            name    linearVelocity;
            code
            #{
                const vectorField& Cf = patch().Cf();   //center of the patch
                vectorField& field = *this;             //the target velocity field

                const scalar Umax = 6.1;
                const scalar r1 = 0.02;                 //radius of the hot coflow
                const scalar r2 = 0.06;                 //radius of the domain

                forAll(Cf, faceI)
                {
                    const scalar x = Cf[faceI][0];
                    const scalar y = Cf[faceI][1];
                    const scalar R = sqrt(x*x+y*y);

                    if(R>r1){
                        field[faceI] = vector(0,0,Umax*(r2-R)/(r2-r1));
                    }
                }
            #};
        }

另外一个应用案例：

.. code-block:: C

    code
    #{
        const fvPatch& boundaryPatch = patch();   
        const vectorField& Cf = boundaryPatch.Cf();
        vectorField& field = *this;

        const scalar pi = constant::mathematical::pi;
        scalar x0=0.654157, z0=0.115013, d=0.004554;
        scalar umax=26.6,   fjet=138.5;
        scalar theta = 18.31163/pi;
           
        forAll(Cf, faceI)
        {
            scalar x  = Cf[faceI].x();
            scalar z  = Cf[faceI].z();
            scalar t  = this->db().time().value();

            scalar kesi  = pow( (x-x0)*(x-x0)+(z-z0)*(z-z0),0.5);
            scalar ujmag = 6*umax*( (kesi/d)-pow(kesi/d,2) )*sin(2*pi*fjet*t);
            scalar ujet  = ujmag*sin(theta);
            scalar vjet  = ujmag*cos(theta);
                
            field[faceI] = vector(ujet,0,vjet);
        }
    #};     


更多的案例：

.. code-block:: C

    inlet
    {
        type            codedFixedValue;
        value           uniform 0;
        name            codeinlet_air;
                    
        code            
        #{
            const vectorField& Cf = patch().Cf(); 

            scalarField& field = *this;

            scalar D = 0.0252;
            scalar ymax = 5.82*D; 

            forAll(Cf,faceI)
            {
                if ( Cf[faceI].y() > ymax ) 
                   {
                     field[faceI] = 1;
                   }
            }

        #};
    
    }


.. code-block:: C

    inlet
    {
        type            codedFixedValue;
        value           uniform (0 0 0);  //default value
        name            powvelocity;      //name of new BC type

        code
        #{
            const fvPatch &boundaryPatch = patch();
            const fvBoundaryMesh &boundaryMesh = boundaryPatch.boundaryMesh();
            const fvMesh &mesh = boundaryMesh.mesh();
            const fvPatchField<vector> &U = boundaryPatch.lookupPatchField<volVectorField, vector>("U");

            const vectorField FC = mesh.Cf();
            const scalarField y = FC&vector(0,1,0);
            
            vectorField U1 (U.size(), Zero);
            // const scalar pi = M_PI;
            const scalar U_0 = 0.5;
            const scalar D = 0.03;

            forAll(boundaryPatch, i)
            {
                U1[i] = vector(U_0*(pow(y[i]/D,1/7)), 0., 0.);
            }

            operator==(U1);
        #};
    }


如需要设置随时间变化的边界条件，可采用如下方法得到OF运行时间：

.. code-block:: C

    scalar t  = this->db().time().value();


添加下面的语句来解决 :code:`error: ‘mesh’ was not declared in this scope` 的问题：

.. code-block:: C

    codeOptions
    #{
    -I$(LIB_SRC)/meshTools/lnInclude
    #};







壁面函数
===========

壁面函数的推导
----------------

首先要了解近壁区域的性质才能了解什么时候能够使用壁面函数。引入两个无量纲数：

.. math::
    \begin{align}
    y^{+} = \frac{yu_{\tau}}{\nu}, \quad  u_{\tau} = \sqrt{\frac{\tau_{w}}{\rho}} , \quad u^{+} = \frac{u}{u_{\tau}}
    \end{align}

其中 :math:`u_{\tau}` 为摩擦速度，它可以后续用来定义无量纲速度； :math:`\tau_{w}` 为壁面切应力， :math:`y` 为距离壁面的距离， :math:`y^{+}` 是一个无量纲数， :math:`u^{+}` 为无量纲速度。第一层网格的 :math:`y^{+}` 值非常重要，因为它将决定其所在的近壁区域类型。

近壁区域可以分为三个类型，它们可以通过 :math:`y^{+}` 和 :math:`u^{+}` 的关系来进行区分：

1. **粘性底层** （ :math:`y^{+} < 5` ）：在粘性底层中，流体主要受粘性的影响，所以在这个区域可以假设剪切力等于壁面剪切应力 :math:`\tau_{w}` 。在粘性底层中粘性力决定了流动方式并且速度分布式线性的，满足
   
.. math::
    \begin{align}
    u ^{+} = y^{+}
    \end{align}

2. **对数分布区** （ :math:`30 < y^{+} < 200` ）：在对数分布区湍流应力起主导作用，速度分布变化按照关于壁面距离 :math:`y` 的对数方式进行分布，满足
   
.. math::
    \begin{align}
    u^{+} = \frac{1}{\kappa}\ln(E y^{+})
    \end{align}

其中 :math:`\kappa` 为卡门常数，取 :math:`\kappa=0.41` ，对于光滑壁面取 :math:`E = 9.8` 。

3. **缓冲区** ：粘性和湍流应力的作用尺度相似，因此在这部分区域速度分布非常复杂而无法良好定义，因此原始壁面函数需要壁面第一层网格中心位于这个区域。但是，一些改良的壁面函数能够允许第一层网格中心位于缓冲区。在OpenFOAM中，缓冲层被分为两部分，一部分认为是粘性底层满足线性关系，另一部分认为满足对数分布规律。

壁面函数的推导过程将会涉及到 :math:`\varepsilon, f, k, \nu, \overline{v^{2}}` 和 :math:`\omega` ，不过具体应用时都会取它们的无量纲形式，即

.. math::
    \begin{align}
    u^{+} = \frac{u}{u_{\tau}} ,\quad 
    k^{+}=\frac{k}{u_{\tau}^{2}} ,\quad
    \varepsilon^{+} = \frac{\varepsilon \nu}{u_{\tau}^{4}} ,\quad 
    \overline{v^{2}}^{+} = \frac{\overline{v^{2}}}{u_{\tau}^{2}} ,\quad
    f^{+} = \frac{f \nu}{u_{\tau}^{2}} ,\quad 
    \omega^{+} = \frac{\nu \omega}{u_{\tau}^{2}}  
    \end{align}

下面将讨论两类湍流模型，第一个是 :math:`v^{2}-f` 湍流模型，需要 :math:`k, \varepsilon, v^{2}, f` 壁面函数；第二个是 :math:`k-\omega` 湍流模型，需要 :math:`\omega` 壁面函数。

在粘性底层， :math:`v^{2}-f` 湍流模型方程组可以简化为

.. math::
    \begin{align}
    - \varepsilon^{+} 
    + \frac{\mathrm{d}^{2}k^{+}}{\mathrm{d}(y^{+})^{2}}
    = 0 
    \end{align}

.. math::
    \begin{align}
    - \frac{C_{\varepsilon 2}}{6}(\varepsilon^{+})^{1.5} 
    + \frac{\mathrm{d}^{2}\varepsilon^{+}}{\mathrm{d}(y^{+})^{2}} 
    = 0 
    \end{align}

.. math::
    \begin{align}
    - N \frac{\varepsilon^{+} (\overline{v^{2}})^{+}}{k^{+}} 
    + k^{+}f^{+} 
    + \frac{\mathrm{d}^{2}(\overline{v^{2}})^{+}}{\mathrm{d}(y^{+})^{2}} 
    = 0  
    \end{align}

.. math::
    \begin{align}
    \frac{2}{3}(C_{f1} - 1) 
    - (N - C_{f1})\frac{(\overline{v^{2}})^{+}}{k^{+}}
    - \frac{6}{(\varepsilon^{+})^{0.5}}f^{+}
    + \frac{C_{\eta}^{2} C_{L}^{2} 6}{\varepsilon^{+}}\frac{\mathrm{d}^{2}f^{+}}{\mathrm{d}(y^{+})^{2}} 
    = 0 
    \end{align}

根据上面的方程组可以得到 :math:`\varepsilon^{+}` 的表达式为

.. math::
    \begin{align}
    \varepsilon^{+} = \frac{14400}{C_{\varepsilon2}^{2}}\frac{1}{(y^{+} + C)^{4}}  
    \end{align}

根据边界条件 :math:`k^{+}(0)=0` ， :math:`\frac{\mathrm{d}k^{+}}{\mathrm{d}y^{+}}(0) = 0` ，可以使用 :math:`\varepsilon^{+}` 的结果进行积分得到 :math:`k^{+}` 的表达式为

.. math::
    \begin{align}
    k^{+} = \frac{2400}{C_{\varepsilon2}^{2}} \times \Big( \frac{1}{(y^{+} + C)^{4}} + \frac{2y^{+}}{C^{3}} - \frac{1}{C^{2}} \Big)
    \end{align}

假定 :math:`k^{+}` 满足一个二次函数关系 :math:`k^{+} = C_{k}(y^{+})^{2}` ，将其代入到湍流方程组中可以得到一个关于 :math:`\varepsilon^{+}` 的特别条件：

.. math::
    \begin{align}
    \varepsilon^{+} = 2 \frac{k^{+}}{(y^{+})^{2}} 
    \end{align}

:math:`f^{+}` 的边界条件的推导可以通过假设 :math:`(\overline{v^{2}})^{+} = C_{V^{2}}(y^{+})^{4}` ，将其代入到 :math:`v^{2}-f` 模型方程组就可以得到

.. math::
    \begin{align}
    f^{+} = \frac{-4(6-N)(\overline{v^{2}})^{+}}{\varepsilon^{+}(y^{+})^{4}} 
    \end{align}

在对数分布区，可以假设扩散项非常小，得到

.. math::
    \begin{align}
    \kappa y^{+} \frac{\mathrm{d}k^{+}}{\mathrm{d}y^{+}} = C_{k}
    \end{align}

用相同的方式可以推导出 :math:`\overline{v^{2}}^{+}` ， :math:`\varepsilon^{+}` 和 :math:`f^{+}` ：

.. math::
    \begin{align}
    \overline{v^{2}}^{+} = \frac{C_{V^{2}}}{\kappa}\log (y^{+}) + B_{V^{2}} 
    \end{align}

.. math::
    \begin{align}
    \varepsilon^{+} = \frac{1}{\kappa y^{+}} 
    \end{align}

.. math::
    \begin{align}
    f^{+} = N \frac{\overline{v^{2}}^{+}}{(k^{+})^{2}}\varepsilon^{+} 
    \end{align}

在上述推导过程中涉及到一些常数，这些常数的赋值在OpenFOAM中一般为

.. math::
    \begin{align}
    C_{k} = -0.416 ,\quad 
    B_{k} = 8.366 ,\quad 
    C_{V^{2}} = 0.193 ,\quad 
    B_{V^{2}} = -0.940
    \end{align}

与 :math:`v^{2}-f` 模型类似， :math:`k-\omega` 模型方程组也可以简化来得到 :math:`\omega` 在粘性底层和对数分布区的行为。在粘性底层，标准 :math:`k-\omega` 方程组可以简化为

.. math::
    \begin{align}
    C_{\mu} \omega^{+}k^{+} + \frac{\mathrm{d}^{2}k^{+}}{\mathrm{d}(y^{+})^{2}} = 0 
    \end{align}

.. math::
    \begin{align}
    - \beta_{1} (\omega^{+})^{2} + \frac{\mathrm{d}^{2}\omega^{+}}{\mathrm{d}(y^{+})^{2}} = 0 
    \end{align}

根据上面两个方程， :math:`\omega^{+}` 的奇异解为

.. math::
    \begin{align}
    \omega ^{+} = \frac{6}{\beta_{1}(y^{+})^{2}} 
    \end{align}

在对数分布区， :math:`\omega^{+}` 的表达式则为

.. math::
    \begin{align}
    \omega ^{+} = \frac{1}{\kappa\sqrt{C_{\mu}} y^{+}} 
    \end{align}

在过渡区 :math:`\omega^{+}` 通常根据粘性底层和对数分布律的组合来得到，即

.. math::
    \begin{align}
    \omega^{+} = \sqrt{[\omega^{+}_{\text{vis}}]^{2} + [\omega^{+}_{\text{log}}]^{2}} 
    \end{align}


壁面函数代码解读
------------------

壁面函数作为一种边界条件继承于FvPatchField类，它们提供Dirichlet和Neumann边界条件，继承于fixedValue和zeroGradient边界条件。它们的实现将会涉及到upateCoeffs()和evaluate()功能。另外，OpenFOAM还使用了yPlusLam这个量来表示粘性底层与对数分布区的交界位置，对于一些提供了两种计算模式的壁面函数，则会在类的最开始计算yPlusLam。同时，壁面函数的计算过程也可以分为两类，一类是计算第一层网格面上的值，另一类则是计算临近壁面的网格中心的值。

OpenFOAM的壁面函数定义在src/MomentumTransportModels/momentumTransportModels/derivedFvPatchFields/wallFunctions当中，总共有6大类壁面函数，而各类细分后总共有12种壁面函数：

+--------------------------+------------------------------------------------------+
| 壁面函数                 | 用途                                                 |
+==========================+======================================================+
| kqRWallFunction          | 用于高雷诺数，属于zeroGradient条件                   |
+--------------------------+------------------------------------------------------+
| kLowReWallFunction       | 用于高和低雷诺数，条件根据 :math:`y^{+}` 的情况      |
+--------------------------+------------------------------------------------------+
| epsilonWallFunction      | 用于高雷诺数                                         |
+--------------------------+------------------------------------------------------+
| epsilonLowReWallFunction | 用于高和低雷诺数，条件根据 :math:`y^{+}` 的情况      |
+--------------------------+------------------------------------------------------+
| V2WallFunction           | 用于高和低雷诺数，条件根据 :math:`y^{+}` 的情况      |
+--------------------------+------------------------------------------------------+
| fWallFunction            | 用于高和低雷诺数，条件根据 :math:`y^{+}` 的情况      |
+--------------------------+------------------------------------------------------+
| omegaWallFunction        | 用于高和低雷诺数，条件基于粘性底层和对数分布律的混合 |
+--------------------------+------------------------------------------------------+
| nutWallFunction          | 抽象类，不提供特定的 :math:`\nu_{t}`                 |
+--------------------------+------------------------------------------------------+
| nutLowReWallFunction     | 用于低雷诺数，条件是zero                             |
+--------------------------+------------------------------------------------------+
| nutUWallFunction         | 条件基于速度                                         |
+--------------------------+------------------------------------------------------+
| nutkWallFunction         | 条件基于kinematic                                    |
+--------------------------+------------------------------------------------------+
| nutUSpaldingWallFunction | 用于整个区域                                         |
+--------------------------+------------------------------------------------------+

在壁面函数的构建过程中，会使用到src/MomentumTransportModels/momentumTransportModels/momentumTransportModel.H中定义的调用函数来获取所需物理量。



nutWallFunction
^^^^^^^^^^^^^^^^^^

该边界条件是一个抽象类，提供了基于湍流动能湍流运动粘度条件。不少其他壁面函数会继承这里面定义的一些调用函数。

在nutWallFunctionFvPatchScalarField.H文件中可以看到声明的变量的含义及相关的调用函数：

.. code-block:: C

    protected:

        // Protected data

            //- Cmu coefficient
            scalar Cmu_;    // 系数Cmu

            //- Von Karman constant
            scalar kappa_;    // 卡门常数kappa

            //- E coefficient
            scalar E_;    // 粗糙系数E

            //- Y+ at the edge of the laminar sublayer
            scalar yPlusLam_;    // 粘性底层极限位置的y+值


        // Protected Member Functions

            //- Check the type of the patch
            virtual void checkType();

            //- Calculate the turbulence viscosity
            virtual tmp<scalarField> nut() const = 0;    // 计算湍流粘度

            //- Write local wall function variables
            virtual void writeLocalEntries(Ostream&) const;


.. code-block:: C

    //- Return the nut patchField for the given wall patch
    static const nutWallFunctionFvPatchScalarField& nutw    // 返回所选壁面的nut
    (
        const momentumTransportModel& turbModel,
        const label patchi
    );

    //- Calculate the Y+ at the edge of the laminar sublayer
    static scalar yPlusLam(const scalar kappa, const scalar E);    // 计算粘性底层极限位置的y+值yPlusLam

    //- Return the Y+ at the edge of the laminar sublayer
    scalar yPlusLam() const;    // 返回yPlusLam的值

    //- Calculate and return the yPlus at the boundary
    virtual tmp<scalarField> yPlus() const = 0;    // 计算壁面的y+


在直接使用该壁面函数时，将会读取设置中的Cmu、kappa和E关键词的赋值。

.. code-block:: C

    void Foam::nutWallFunctionFvPatchScalarField::writeLocalEntries
    (
        Ostream& os
    ) const
    {
        writeEntry(os, "Cmu", Cmu_);
        writeEntry(os, "kappa", kappa_);
        writeEntry(os, "E", E_);
    }

nutWallFunction继承于fixedValue边界条件，默认情况下会初始化 :math:`C_{\mu}=0.09` ， :math:`\kappa = 0.41` ， :math:`E=9.8` 。

.. code-block:: C

    Foam::nutWallFunctionFvPatchScalarField::nutWallFunctionFvPatchScalarField
    (
        const fvPatch& p,
        const DimensionedField<scalar, volMesh>& iF,
        const dictionary& dict
    )
    :
        fixedValueFvPatchScalarField(p, iF, dict),
        Cmu_(dict.lookupOrDefault<scalar>("Cmu", 0.09)),
        kappa_(dict.lookupOrDefault<scalar>("kappa", 0.41)),
        E_(dict.lookupOrDefault<scalar>("E", 9.8)),
        yPlusLam_(yPlusLam(kappa_, E_))
    {
        checkType();
    }


下面的代码定义了yPlusLam是如何通过kappa和E的值进行计算的：

.. code-block:: C

    Foam::scalar Foam::nutWallFunctionFvPatchScalarField::yPlusLam
    (
        const scalar kappa,
        const scalar E
    )
    {
        scalar ypl = 11.0;

        for (int i=0; i<10; i++)
        {
            ypl = log(max(E*ypl, 1))/kappa;
        }

        return ypl;
    }

可以看到，计算过程为

.. math::
    \begin{align}
    \text{ypl} = \frac{\log (\max(E\times \text{ypl}^{*} , 1))}{\kappa}  
    \end{align}



kqRWallFunction
^^^^^^^^^^^^^^^^^^

该边界条件为高雷诺数流动情况下的湍流k、q和R场提供了合适的条件。它本质上是对zeroGradient条件的简单包装。

.. code-block:: C

    template<class Type>
    void Foam::kqRWallFunctionFvPatchField<Type>::evaluate
    (
        const Pstream::commsTypes commsType
    )
    {
        zeroGradientFvPatchField<Type>::evaluate(commsType);
    }


    template<class Type>
    void Foam::kqRWallFunctionFvPatchField<Type>::write(Ostream& os) const
    {
        zeroGradientFvPatchField<Type>::write(os);
        writeEntry(os, "value", *this);
    }



kLowReWallFunction
^^^^^^^^^^^^^^^^^^^^^

该边界条件为低雷诺数和高雷诺数湍流流动情况提供了湍流动能壁函数条件。该模型在两种模式下运行，基于计算得到的层流-湍流转换y+值，该值由对应的nutWallFunction中指定的kappa和E导出。

.. code-block:: C

    void kLowReWallFunctionFvPatchScalarField::write(Ostream& os) const
    {
        writeEntry(os, "Ceps2", Ceps2_);
        fixedValueFvPatchField<scalar>::write(os);
    }

上面的代码表明kLowReWallFunction需要读取设置中Ceps2关键词的赋值。

.. code-block:: C

    kLowReWallFunctionFvPatchScalarField::kLowReWallFunctionFvPatchScalarField
    (
        const fvPatch& p,
        const DimensionedField<scalar, volMesh>& iF,
        const dictionary& dict
    )
    :
        fixedValueFvPatchField<scalar>(p, iF, dict),
        Ceps2_(dict.lookupOrDefault<scalar>("Ceps2", 1.9))
    {}

上面的代码表明kLowReWallFunction边界条件其实继承于fixedValue边界条件，并初始化Ceps2的值为1.9。


.. code-block:: C

    void kLowReWallFunctionFvPatchScalarField::updateCoeffs()
    {
        if (updated())
        {
            return;
        }

        const label patchi = patch().index();

        const momentumTransportModel& turbModel =
            db().lookupObject<momentumTransportModel>
            (
                IOobject::groupName
                (
                    momentumTransportModel::typeName,
                    internalField().group()
                )
            );

        const nutWallFunctionFvPatchScalarField& nutw =
            nutWallFunctionFvPatchScalarField::nutw(turbModel, patchi);

        const scalarField& y = turbModel.y()[patchi];    // 定义第一层网格中心到壁面的距离y

        const tmp<volScalarField> tk = turbModel.k();    // 定义第一层网格中心的湍动能k
        const volScalarField& k = tk();

        const tmp<scalarField> tnuw = turbModel.nu(patchi);    // 定义层流粘性nuw
        const scalarField& nuw = tnuw();

        const scalar Cmu25 = pow025(nutw.Cmu());    // 计算了Cmu系数的0.25次幂，记作Cmu25

        scalarField& kw = *this;

        // Set k wall values
        forAll(kw, facei)
        {
            label celli = patch().faceCells()[facei];

            scalar uTau = Cmu25*sqrt(k[celli]);    // 计算摩擦速度

            scalar yPlus = uTau*y[facei]/nuw[facei];    // 计算y+

            if (yPlus > nutw.yPlusLam())
            {
                scalar Ck = -0.416;
                scalar Bk = 8.366;
                kw[facei] = Ck/nutw.kappa()*log(yPlus) + Bk;
            }
            else
            {
                scalar C = 11.0;
                scalar Cf = (1.0/sqr(yPlus + C) + 2.0*yPlus/pow3(C) - 1.0/sqr(C));
                kw[facei] = 2400.0/sqr(Ceps2_)*Cf;
            }

            kw[facei] *= sqr(uTau);    // 更新壁面的湍流动能
        }

        // Limit kw to avoid failure of the turbulence model due to division by kw
        kw = max(kw, small);    // 避免后续除以kw的时候出现数值错误，即防止除以零

        fixedValueFvPatchField<scalar>::updateCoeffs();

        // TODO: perform averaging for cells sharing more than one boundary face
    }


从上面的代码可以看到摩擦速度 :math:`u_{\tau}` 和 :math:`y^{+}` 的计算方式为

.. math::
    \begin{align}
    u_{\tau} = C_{\mu}^{0.25}\sqrt{k} ,\quad
    y^{+} = \frac{u_{\tau}y}{\nu}
    \end{align}

壁面处的 :math:`k^{+}` 计算方式为

.. math::
    \begin{align}
    k^{+} = 
    \left \{\begin{array}{l}
    \frac{C_{k}}{\kappa}\log(y^{+}) + B_{k} ,\qquad\qquad\qquad\quad y^{+} > \text{yPlusLam} \\
    \frac{2400}{C_{eps}^{2}}\times \Big(\frac{1}{(y^{+} + C)^{2}} + \frac{2y^{+}}{C^{3}} - \frac{1}{C^{2}} \Big) ,\quad y^{+} \le \text{yPlusLam}
    \end{array}\right .
    \end{align}

其中 :math:`C_{k}=-0.416` ， :math:`B_{k} = 8.366` ; :math:`C = 11` ， :math:`C_{eps2}` 通过读取设置赋值得到。

最后将无量纲数 :math:`k^{+}` 计算为壁面边界处的 :math:`k` 的方式为：

.. math::
    \begin{align}
    k = k^{+} u_{\tau}^{2}
    \end{align}


v2WallFunction
^^^^^^^^^^^^^^^^

该边界条件为低雷诺数和高雷诺数湍流流动情况提供了一个垂直于流线壁函数的湍流应力条件。该模型在两种模式下运行，基于计算得到的层流-湍流转换y+值，该值由对应的nutWallFunction中指定的kappa和E导出。

.. code-block:: C

    void v2WallFunctionFvPatchScalarField::updateCoeffs()
    {
        if (updated())
        {
            return;
        }

        const label patchi = patch().index();

        const momentumTransportModel& turbModel =
            db().lookupObject<momentumTransportModel>
            (
                IOobject::groupName
                (
                    momentumTransportModel::typeName,
                    internalField().group()
                )
            );

        const nutWallFunctionFvPatchScalarField& nutw =
            nutWallFunctionFvPatchScalarField::nutw(turbModel, patchi);

        const scalarField& y = turbModel.y()[patchi];    // 定义到壁面的距离y

        const tmp<volScalarField> tk = turbModel.k();    // 定义湍流动能k
        const volScalarField& k = tk();

        const tmp<scalarField> tnuw = turbModel.nu(patchi);    // 定义层流粘性nuw
        const scalarField& nuw = tnuw();

        const scalar Cmu25 = pow025(nutw.Cmu());    // 计算了Cmu系数的0.25次幂，记作Cmu25

        scalarField& v2 = *this;

        // Set v2 wall values
        forAll(v2, facei)
        {
            label celli = patch().faceCells()[facei];

            scalar uTau = Cmu25*sqrt(k[celli]);    // 计算摩擦速度

            scalar yPlus = uTau*y[facei]/nuw[facei];    // 计算y+

            if (yPlus > nutw.yPlusLam())
            {
                scalar Cv2 = 0.193;
                scalar Bv2 = -0.94;
                v2[facei] = Cv2/nutw.kappa()*log(yPlus) + Bv2;
            }
            else
            {
                scalar Cv2 = 0.193;
                v2[facei] = Cv2*pow4(yPlus);
            }

            v2[facei] *= sqr(uTau);    // 更新壁面的v2
        }

        fixedValueFvPatchField<scalar>::updateCoeffs();

        // TODO: perform averaging for cells sharing more than one boundary face
    }

从上面的代码可以看到 :math:`(v^{2})^{+}` 的计算方式为

.. math::
    \begin{align}
    (v^{2})^{+} = 
    \left \{\begin{array}{l}
    \frac{C_{V^{2}}}{\kappa}\log(y^{+}) + B_{V^{2}} ,\quad y^{+} > \text{yPlusLam} \\
    C_{V^{2}}(y^{+})^{4} ,\qquad\qquad\quad y^{+} \le \text{yPlusLam}
    \end{array}\right .
    \end{align}

其中 :math:`C_{V^{2}} = 0.193` ， :math:`B_{V^{2}} = -0.94` 。

最后将无量纲数 :math:`(v^{2})^{+}` 计算为壁面处的 :math:`v^{2}` 的方式为

.. math::
    \begin{align}
    v^{2} = (v^{2})^{+}u_{\tau}^{2}
    \end{align}




fWallFunction
^^^^^^^^^^^^^^^

该边界条件提供了湍流阻尼函数f，低雷诺数和高雷诺数的壁面函数条件，湍流流动情况下的模型在两种模式下运行，基于计算得到的层流到湍流的转换y+值，由对应的nutWallFunction中指定的kappa和E导出。

.. code-block:: C

    void fWallFunctionFvPatchScalarField::updateCoeffs()
    {
        if (updated())
        {
            return;
        }

        const label patchi = patch().index();

        const momentumTransportModel& turbModel =
            db().lookupObject<momentumTransportModel>
            (
                IOobject::groupName
                (
                    momentumTransportModel::typeName,
                    internalField().group()
                )
            );
        const v2fBase& v2fModel = refCast<const v2fBase>(turbModel);

        const nutWallFunctionFvPatchScalarField& nutw =
            nutWallFunctionFvPatchScalarField::nutw(turbModel, patchi);

        const scalarField& y = turbModel.y()[patchi];    // 定义到壁面的距离y

        const tmp<volScalarField> tk = turbModel.k();    // 定义湍流动能k
        const volScalarField& k = tk();

        const tmp<volScalarField> tepsilon = turbModel.epsilon();    // 定义湍流动能耗散率epsilon
        const volScalarField& epsilon = tepsilon();

        const tmp<volScalarField> tv2 = v2fModel.v2();    // 定义垂直于流线的湍流应力v2
        const volScalarField& v2 = tv2();

        const tmp<scalarField> tnuw = turbModel.nu(patchi);    // 定义层流粘度nuw
        const scalarField& nuw = tnuw();

        const scalar Cmu25 = pow025(nutw.Cmu());    // 计算了Cmu系数的0.25次幂，记作Cmu25

        scalarField& f = *this;

        // Set f wall values
        forAll(f, facei)
        {
            label celli = patch().faceCells()[facei];

            scalar uTau = Cmu25*sqrt(k[celli]);    // 计算摩擦速度

            scalar yPlus = uTau*y[facei]/nuw[facei];    // 计算y+

            if (yPlus > nutw.yPlusLam())
            {
                scalar N = 6.0;
                scalar v2c = v2[celli];
                scalar epsc = epsilon[celli];
                scalar kc = k[celli];

                f[facei] = N*v2c*epsc/(sqr(kc) + rootVSmall);
                f[facei] /= sqr(uTau) + rootVSmall;
            }
            else
            {
                f[facei] = 0.0;
            }
        }

        fixedValueFvPatchField<scalar>::updateCoeffs();

        // TODO: perform averaging for cells sharing more than one boundary face
    }


:math:`f` 的计算方式为

.. math::
    \begin{align}
    f = 
    \left \{\begin{array}{l}
    \frac{Nv^{2}\varepsilon}{k^{2}u_{\tau}^{2}}  ,\quad y^{+} > \text{yPlusLam} \\
    0 ,\qquad y^{+} \le \text{yPlusLam}
    \end{array}\right .
    \end{align}

其中系数 :math:`N = 6` 。

.. attention:: 该壁面函数的实现方式与理论存在较大差异，在使用该壁面函数时需要注意是否满足自身需求。



epsilonWallFunction
^^^^^^^^^^^^^^^^^^^^^

该边界条件为低雷诺数和高雷诺数湍流模型提供了湍流耗散壁约束。该条件可应用于壁面边界，计算出湍流耗散场和湍流产生场，并指定近壁面 :math:`\epsilon` 值。



湍流模型
=============

所有包含湍流的求解器都需要读取momentumTransport文件内设置的湍流模型信息。在该文件内，由 :code:`simulationType` 关键词决定所使用的湍流模型，其可能的赋值有：

- :code:`laminar` ，表示不使用湍流模型；
- :code:`RAS` ，表示使用雷诺平均模型；
- :code:`LES` ，表示使用大涡模拟。
  




laminar模型
------------


.. code-block:: C
    :caption: src/MomentumTranportModels/momentumTransportModels/laminar/laminarModel/laminarModel.C

    template<class BasicMomentumTransportModel>
    Foam::laminarModel<BasicMomentumTransportModel>::laminarModel
    (
        const word& type,
        const alphaField& alpha,
        const rhoField& rho,
        const volVectorField& U,
        const surfaceScalarField& alphaRhoPhi,
        const surfaceScalarField& phi,
        const viscosity& viscosity
    )
    :
        BasicMomentumTransportModel
        (
            type,
            alpha,
            rho,
            U,
            alphaRhoPhi,
            phi,
            viscosity
        ),

        laminarDict_(this->subOrEmptyDict("laminar")),
        printCoeffs_(laminarDict_.lookupOrDefault<Switch>("printCoeffs", false)),
        coeffDict_(laminarDict_.optionalSubDict(type + "Coeffs"))
    {
        // Force the construction of the mesh deltaCoeffs which may be needed for the construction of the derived models and BCs
        this->mesh_.deltaCoeffs();
    }

    // * * * * * * * * * * * * * * * * Selectors * * * * * * * * * * * * * * * * //

    template<class BasicMomentumTransportModel>
    Foam::autoPtr<Foam::laminarModel<BasicMomentumTransportModel>>
    Foam::laminarModel<BasicMomentumTransportModel>::New
    (
        const alphaField& alpha,
        const rhoField& rho,
        const volVectorField& U,
        const surfaceScalarField& alphaRhoPhi,
        const surfaceScalarField& phi,
        const viscosity& viscosity
    )
    {
        const IOdictionary modelDict
        (
            momentumTransportModel::readModelDict
            (
                U.db(),
                alphaRhoPhi.group()
            )
        );

        if (modelDict.found("laminar"))
        {
            const word modelType = modelDict.subDict("laminar").lookupBackwardsCompatible<word> ( {"model", "laminarModel"} );

            Info<< "Selecting laminar stress model " << modelType << endl;

            typename dictionaryConstructorTable::iterator cstrIter = dictionaryConstructorTablePtr_->find(modelType);

            if (cstrIter == dictionaryConstructorTablePtr_->end())
            {
                FatalErrorInFunction
                    << "Unknown laminarModel type "
                    << modelType << nl << nl
                    << "Valid laminarModel types:" << endl
                    << dictionaryConstructorTablePtr_->sortedToc()
                    << exit(FatalError);
            }

            return autoPtr<laminarModel>
            (
                cstrIter()
                (
                    alpha,
                    rho,
                    U,
                    alphaRhoPhi,
                    phi,
                    viscosity
                )
            );
        }
        else    // 如果没有进一步设置laminar模型的类型，则默认为Stokes层流模型
        {
            Info<< "Selecting laminar stress model "
                << laminarModels::Stokes<BasicMomentumTransportModel>::typeName
                << endl;

            return autoPtr<laminarModel>
            (
                new laminarModels::Stokes<BasicMomentumTransportModel>
                (
                    alpha,
                    rho,
                    U,
                    alphaRhoPhi,
                    phi,
                    viscosity
                )
            );
        }
    }



.. code-block:: C
    :caption: src/MomentumTranportModels/momentumTransportModels/laminar/Stokes/Stokes.C

    template<class BasicMomentumTransportModel>
    Stokes<BasicMomentumTransportModel>::Stokes
    (
        const alphaField& alpha,
        const rhoField& rho,
        const volVectorField& U,
        const surfaceScalarField& alphaRhoPhi,
        const surfaceScalarField& phi,
        const viscosity& viscosity
    )
    :
        linearViscousStress<laminarModel<BasicMomentumTransportModel>>
        (
            typeName,
            alpha,
            rho,
            U,
            alphaRhoPhi,
            phi,
            viscosity
        )
    {}


    // * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //

    template<class BasicMomentumTransportModel>
    const dictionary& Stokes<BasicMomentumTransportModel>::coeffDict() const
    {
        return dictionary::null;
    }


    template<class BasicMomentumTransportModel>
    bool Stokes<BasicMomentumTransportModel>::read()
    {
        return true;
    }


    template<class BasicMomentumTransportModel>
    tmp<volScalarField> Stokes<BasicMomentumTransportModel>::nuEff() const
    {
        return volScalarField::New
        (
            IOobject::groupName("nuEff", this->alphaRhoPhi_.group()),
            this->nu()
        );
    }


    template<class BasicMomentumTransportModel>
    tmp<scalarField> Stokes<BasicMomentumTransportModel>::nuEff
    (
        const label patchi
    ) const
    {
        return this->nu(patchi);
    }


    template<class BasicMomentumTransportModel>
    void Stokes<BasicMomentumTransportModel>::correct()
    {
        laminarModel<BasicMomentumTransportModel>::correct();
    }



.. code-block:: C
    :caption: src/MomentumTranportModels/momentumTransportModels/linearViscousStress/linearViscousStress.C

    template<class BasicMomentumTransportModel>
    Foam::tmp<Foam::volSymmTensorField>
    Foam::linearViscousStress<BasicMomentumTransportModel>::devTau() const
    {
        return volSymmTensorField::New
        (
            IOobject::groupName("devTau", this->alphaRhoPhi_.group()),
            (-(this->alpha_*this->rho_*this->nuEff()))
           *dev(twoSymm(fvc::grad(this->U_)))
        );
    }

    template<class BasicMomentumTransportModel>
    Foam::tmp<Foam::fvVectorMatrix>
    Foam::linearViscousStress<BasicMomentumTransportModel>::divDevTau
    (
        volVectorField& U
    ) const
    {
        return
        (
          - fvc::div((this->alpha_*this->rho_*this->nuEff())*dev2(T(fvc::grad(U))))
          - fvm::laplacian(this->alpha_*this->rho_*this->nuEff(), U)
        );
    }

    template<class BasicMomentumTransportModel>
    Foam::tmp<Foam::fvVectorMatrix>
    Foam::linearViscousStress<BasicMomentumTransportModel>::divDevTau
    (
        const volScalarField& rho,
        volVectorField& U
    ) const
    {
        return
        (
          - fvc::div((this->alpha_*rho*this->nuEff())*dev2(T(fvc::grad(U))))
          - fvm::laplacian(this->alpha_*rho*this->nuEff(), U)
        );
    }




RAS模型
---------

速度的雷诺分解为其平均贡献和波动贡献的形式为

.. math::
    \begin{align}
    \mathbf{U}(\mathbf{x},t) = \overline{\mathbf{U}}(\mathbf{x},t) + \mathbf{U}'(\mathbf{x},t)
    \end{align}

其中，波动分量的均值定义为零，即

.. math::
    \begin{align}
    \overline{\mathbf{U}'} = 0 
    \end{align}

应用于Navier Stokes方程，可以得到平均速度和平均压力的方程：

.. math::
    \begin{align}
    \frac{\partial \rho}{\partial t} + \nabla \cdot (\rho\overline{\mathbf{U}}) = 0 
    \end{align}

.. math::
    \begin{align}
    \frac{\partial (\rho\overline{\mathbf{U}})}{\partial t} + \nabla \cdot (\rho \overline{\mathbf{U}} \otimes \overline{\mathbf{U}}) = \mathbf{g} + \nabla \cdot \overline{\tau} - \nabla \cdot (\rho \mathbf{R})
    \end{align}

其中时均切应力 :math:`\overline{\tau}` ，对于牛顿流体则表示为

.. math::
    \begin{align}
    \overline{\tau} = 
    - \Big( p + \frac{2}{3}\mu \nabla \cdot \overline{\mathbf{U}} \Big) \mathbf{I}
    + \mu \Big( \nabla \overline{\mathbf{U}} + (\nabla \overline{\mathbf{U}})^{T} \Big)
    \end{align}

根据数学关系：

.. math::
    \begin{align}
    \nabla \cdot \overline{\mathbf{U}}
    = \operatorname{tr}(\nabla \overline{\mathbf{U}})
    = \operatorname{tr}\Big( (\nabla \overline{\mathbf{U}})^{T} \Big) 
    \end{align}

时均切应力可以改写为

.. math::
    \begin{align}
    \overline{\tau} = - p\mathbf{I} + \mu \Big[ \nabla\overline{\mathbf{U}} + (\nabla\overline{\mathbf{U}})^{T} - \frac{2}{3}\operatorname{tr}\Big( (\nabla\overline{\mathbf{U}})^{T} \Big)\mathbf{I} \Big]
    \end{align}

:math:`\mathbf{R}` 为雷诺应力张量，可以进一步分解为各向同性贡献和偏向各向异性贡献：

.. math::
    \begin{align}
    \mathbf{R} = \overline{\mathbf{U}' \otimes \mathbf{U}'} 
    = \frac{2}{3}k\mathbf{I} + \overline{\mathbf{U}' \otimes \mathbf{U}'} - \frac{2}{3}k\mathbf{I}
    \end{align}

其中 :math:`k` 是湍流动能，定义为

.. math::
    \begin{align}
    k = \frac{1}{2} \overline{\mathbf{U}' \cdot \mathbf{U}'} = \frac{1}{2}\operatorname{tr}(\mathbf{R})
    \end{align}

只有雷诺应力张量的各向异性贡献才能传递动量，因此各向同性贡献可以加到平均压力上，从而得到完整的形式：

.. math::
    \begin{align}
    \frac{\partial (\rho\overline{\mathbf{U}})}{\partial t}
    + \nabla \cdot (\rho \overline{\mathbf{U}}\otimes \overline{\mathbf{U}})
    = \mathbf{g}
    - \nabla \overline{p}'
    + \nabla\cdot (\mu \nabla \overline{\mathbf{U}})
    + \nabla \cdot \Big[ \mu \Big( (\nabla\overline{\mathbf{U}})^{T} - \frac{2}{3}\operatorname{tr}\big( (\nabla\overline{\mathbf{U}})^{T} \big)\mathbf{I} \Big) \Big]
    - \nabla \cdot (\rho \mathbf{R}_{dev})
    \end{align}

其中

.. math::
    \begin{align}
    & \mathbf{R}_{dev} = \overline{\mathbf{U}' \otimes \mathbf{U}'} - \frac{2}{3}k\mathbf{I} \\
    & \overline{p}' = \overline{p} + \frac{2}{3}\rho k 
    \end{align}

湍流模型RAS家族提供了近似由 :math:`\mathbf{R}_{dev}` 引起的偏差各向异性应力贡献的方法。



如果选用了RAS模型，就需要在momentumTransport文件内进一步创建RAS子字典，该子字典需要包含下列内容：

- :code:`model` ：具体采用的RAS湍流模型的名称；
- :code:`turbulence` ：开启或关闭湍流模型，可能的赋值有 :code:`on` 或 :code:`off` ；
- :code:`printCoeffs` ：输出或不输出湍流模型系数，可能的赋值有 :code:`on` 或 :code:`off` ；
- :code:`<model>Coeffs` ：可选参数，指定后可以覆盖默认的湍流模型参数。
  

可用的RAS湍流模型包括：

+---------------------+------------------------------------------------------+-------------------+-------------------------------------------------------------+
| 不可压缩RAS湍流模型 | 含义                                                 | 可压缩RAS湍流模型 | 含义                                                        |
+=====================+======================================================+===================+=============================================================+
| LRR                 | Launder Reece and Rodi雷诺应力湍流模型               | LRR               | Launder Reece and Rodi雷诺应力湍流模型                      |
+---------------------+------------------------------------------------------+-------------------+-------------------------------------------------------------+
| LamBremhorstKE      | Lam and Bremhorst低雷诺数kEpsilon湍流模型            |                   |                                                             |
+---------------------+------------------------------------------------------+-------------------+-------------------------------------------------------------+
| LaunderSharmaKE     | 不可压缩Launder and Sharma低雷诺数湍流模型           | LaunderSharmaKE   | 基于RDT理论的Launder and Sharma低雷诺数kEpsilon燃烧湍流模型 |
+---------------------+------------------------------------------------------+-------------------+-------------------------------------------------------------+
| LienCubicKE         | 三次非线性低雷诺数kEpsilon湍流模型                   |                   |                                                             |
+---------------------+------------------------------------------------------+-------------------+-------------------------------------------------------------+
| LienLeschziner      | Lien and Leschziner低雷诺数kEpsilon湍流模型          |                   |                                                             |
+---------------------+------------------------------------------------------+-------------------+-------------------------------------------------------------+
| RNGkEpsilon         | 重整化群kEpsilon湍流模型                             | RNGkEpsilon       | 重整化群kEpsilon湍流模型                                    |
+---------------------+------------------------------------------------------+-------------------+-------------------------------------------------------------+
| SSG                 | Speziale Sarkar and Gatski雷诺应力湍流模型           | SSG               | Speziale Sarkar and Gatski雷诺应力湍流模型                  |
+---------------------+------------------------------------------------------+-------------------+-------------------------------------------------------------+
| ShihQuadraticKE     | Shih四次代数雷诺应力kEpsilon湍流模型                 |                   |                                                             |
+---------------------+------------------------------------------------------+-------------------+-------------------------------------------------------------+
| SpalartAllmaras     | Spalart Allmaras一方程混合长外流湍流模型             | SpalartAllmaras   | Spalart Allmaras一方程混合长外流湍流模型                    |
+---------------------+------------------------------------------------------+-------------------+-------------------------------------------------------------+
| kEpsilon            | 标准kEpsilon湍流模型                                 | kEpsilon          | 标准kEpsilon湍流模型                                        |
+---------------------+------------------------------------------------------+-------------------+-------------------------------------------------------------+
| kOmega              | 标准kOmega湍流模型                                   | kOmega            | 标准kOmega湍流模型                                          |
+---------------------+------------------------------------------------------+-------------------+-------------------------------------------------------------+
| kOmega2006          | 标准(2006)高雷诺数kOmega湍流模型                     | kOmega2006        | 标准(2006)高雷诺数kOmega湍流模型                            |
+---------------------+------------------------------------------------------+-------------------+-------------------------------------------------------------+
| kOmegaSST           | kOmegaSST湍流模型                                    | kOmegaSST         | kOmegaSST湍流模型                                           |
+---------------------+------------------------------------------------------+-------------------+-------------------------------------------------------------+
| kOmegaSSTLM         | 基于kOmegaSST的Langtry Menter四方程转变区SST湍流模型 | kOmegaSSTLM       | 基于kOmegaSST的Langtry Menter四方程转变区SST湍流模型        |
+---------------------+------------------------------------------------------+-------------------+-------------------------------------------------------------+
| kOmegaSSTSAS        | 基于kOmegaSST的自适应URANS湍流模型                   | kOmegaSSTSAS      | 基于kOmegaSST的自适应URANS湍流模型                          |
+---------------------+------------------------------------------------------+-------------------+-------------------------------------------------------------+
| kklOmega            | 低雷诺数k-kl-Omega湍流模型                           | buoyantKEpsilon   | 附带浮力项的标准kEpsilon湍流模型                            |
+---------------------+------------------------------------------------------+-------------------+-------------------------------------------------------------+
| qZeta               | Gibson and Dafa Alla低雷诺数湍流模型                 |                   |                                                             |
+---------------------+------------------------------------------------------+-------------------+-------------------------------------------------------------+
| realizableKE        | 可实现的kEpsilon湍流模型                             | realizableKE      | 可实现的kEpsilon湍流模型                                    |
+---------------------+------------------------------------------------------+-------------------+-------------------------------------------------------------+
| v2f                 | Lien and Kalitzin V2F湍流模型                        | v2f               | Lien and Kalitzin V2F湍流模型                               |
+---------------------+------------------------------------------------------+-------------------+-------------------------------------------------------------+



.. code-block:: C
    :caption: src/MomentumTranportModels/momentumTransportModels/eddyViscosity/eddyViscosity.C

    template<class BasicMomentumTransportModel>
    Foam::eddyViscosity<BasicMomentumTransportModel>::eddyViscosity
    (
        const word& type,
        const alphaField& alpha,
        const rhoField& rho,
        const volVectorField& U,
        const surfaceScalarField& alphaRhoPhi,
        const surfaceScalarField& phi,
        const viscosity& viscosity
    )
    :
        linearViscousStress<BasicMomentumTransportModel>    // 继承于linearViscousStress模型
        (
            type,
            alpha,
            rho,
            U,
            alphaRhoPhi,
            phi,
            viscosity
        ),

        nut_
        (
            IOobject
            (
                IOobject::groupName("nut", alphaRhoPhi.group()),
                this->runTime_.timeName(),
                this->mesh_,
                IOobject::MUST_READ,
                IOobject::AUTO_WRITE
            ),
            this->mesh_
        )
    {}

    // * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //

    template<class BasicMomentumTransportModel>
    bool Foam::eddyViscosity<BasicMomentumTransportModel>::read()
    {
        return BasicMomentumTransportModel::read();
    }


    template<class BasicMomentumTransportModel>
    Foam::tmp<Foam::volSymmTensorField>
    Foam::eddyViscosity<BasicMomentumTransportModel>::sigma() const
    {
        tmp<volScalarField> tk(k());

        // Get list of patchField type names from k
        wordList patchFieldTypes(tk().boundaryField().types());

        // For k patchField types which do not have an equivalent for symmTensor set to calculated
        forAll(patchFieldTypes, i)
        {
            if
            (
               !fvPatchField<symmTensor>::patchConstructorTablePtr_ ->found(patchFieldTypes[i])
            )
            {
                patchFieldTypes[i] = calculatedFvPatchField<symmTensor>::typeName;
            }
        }

        return volSymmTensorField::New
        (
            IOobject::groupName("R", this->alphaRhoPhi_.group()),
            ((2.0/3.0)*I)*tk() - (nut_)*dev(twoSymm(fvc::grad(this->U_))),
            patchFieldTypes
        );
    }


    template<class BasicMomentumTransportModel>
    void Foam::eddyViscosity<BasicMomentumTransportModel>::validate()
    {
        correctNut();
    }


    template<class BasicMomentumTransportModel>
    void Foam::eddyViscosity<BasicMomentumTransportModel>::correct()
    {
        BasicMomentumTransportModel::correct();
    }





kEpsilon
^^^^^^^^^^^

OpenFOAM中的kEpsilon模型为Launder和Spalding提出的标准kEpsilon湍流模型，所求解的 :math:`\varepsilon` 方程为

.. math::
    \begin{align}
    \frac{\partial (\alpha \rho\varepsilon_{n+1} )}{\partial t}
    + \nabla \cdot (\alpha \rho\mathbf{U}\varepsilon_{n+1} )
    - \nabla \cdot (\alpha \rho D_{\varepsilon }\nabla\varepsilon_{n+1} )
    = C_{1}\alpha \rho G \frac{\varepsilon}{k}
    - (\frac{2}{3}C_{1} - C_{3})\alpha \rho (\nabla \cdot \mathbf{U})\varepsilon_{n+1}
    - C_{2}\alpha \rho \frac{\varepsilon_{n}}{k}\varepsilon_{n+1}
    + S_{\varepsilon } 
    \end{align}

对应的代码为

.. code-block:: C

    tmp<fvScalarMatrix> epsEqn    // 湍流耗散率方程
    (
        fvm::ddt(alpha, rho, epsilon_)                                   // 非稳态项
      + fvm::div(alphaRhoPhi, epsilon_)                                  // 对流项
      - fvm::laplacian(alpha*rho*DepsilonEff(), epsilon_)                // 扩散项
     ==
        C1_*alpha()*rho()*G*epsilon_()/k_()                              // 生成项
      - fvm::SuSp(((2.0/3.0)*C1_ - C3_)*alpha()*rho()*divU, epsilon_)    // 连续性误差修正项
      - fvm::Sp(C2_*alpha()*rho()*epsilon_()/k_(), epsilon_)             // 耗散项
      + epsilonSource()                                                  // 自定义源项
      + fvModels.source(alpha, rho, epsilon_)                            // fvOption添加的源项
    );

所求解的 :math:`k` 方程为

.. math::
    \begin{align}
    \frac{\partial (\alpha \rho k_{n+1})}{\partial t}
    + \nabla \cdot (\alpha \rho\mathbf{U}k_{n+1})
    - \nabla\cdot (\alpha \rho D_{k}\nabla k_{n+1})
    = \alpha \rho G
    - \frac{2}{3}\alpha \rho (\nabla \cdot \mathbf{U})k_{n+1}
    - \alpha \rho \frac{\varepsilon}{k_{n}}k_{n+1}
    + S_{k}
    \end{align}

对应的代码为

.. code-block:: C

    tmp<fvScalarMatrix> kEqn    // 湍流动能方程
    (
        fvm::ddt(alpha, rho, k_)                       // 湍流动能当地变化率，非稳态项
      + fvm::div(alphaRhoPhi, k_)                      // 湍流动能迁移变化率，对流项
      - fvm::laplacian(alpha*rho*DkEff(), k_)          // 湍流扩散项
     ==
        alpha()*rho()*G                                // 湍流生成项
      - fvm::SuSp((2.0/3.0)*alpha()*rho()*divU, k_)    // 连续性误差修正项
      - fvm::Sp(alpha()*rho()*epsilon_()/k_(), k_)     // 黏性耗散项
      + kSource()                                      // 自定义源项
      + fvModels.source(alpha, rho, k_)                // fvOption源项
    );

其中 :math:`\alpha` 为质量分数，用于多相流的情况。另外有

.. math::
    \begin{align}
    G = \nu_{t} \Big( \nabla\mathbf{U} + (\nabla\mathbf{U})^{T} - \frac{2}{3}(\nabla\cdot\mathbf{U})\mathbf{I} \Big) : \nabla\mathbf{U}
    \end{align}

对应的代码为

.. code-block:: C

    tmp<volTensorField> tgradU = fvc::grad(U);    // 显式计算速度梯度张量
    volScalarField::Internal G    // 湍流产生项G
    (
        this->GName(),
        nut()*(dev(twoSymm(tgradU().v())) && tgradU().v())
    );
    tgradU.clear();


.. math::
    \begin{align}
    \nu_{t} = C_{\mu}\frac{k^{2}}{\varepsilon}
    \end{align}

对应的代码为

.. code-block:: C

    template<class BasicMomentumTransportModel>
    void kEpsilon<BasicMomentumTransportModel>::correctNut()
    {
        this->nut_ = Cmu_*sqr(k_)/epsilon_;    // 通过nut的定义式计算nut更新值
        this->nut_.correctBoundaryConditions();
        fvConstraints::New(this->mesh_).constrain(this->nut_);
    }

.. math::
    \begin{align}
    D_{k} = \frac{\nu_{t}}{\sigma_{k}} + \nu
    \end{align}

对应的代码为

.. code-block:: C

    tmp<volScalarField> DkEff() const    // 湍流动能的有效扩散系数
    {
        return volScalarField::New
        (
            "DkEff",
            (this->nut_/sigmak_ + this->nu())
        );
    }

.. math::
    \begin{align}
    D_{\varepsilon } = \frac{\nu_{t}}{\sigma_{\varepsilon }} + \nu 
    \end{align}

对应的代码为

.. code-block:: C

    tmp<volScalarField> DepsilonEff() const    // 湍流耗散率的有效扩散系数
    {
        return volScalarField::New
        (
            "DepsilonEff",
            (this->nut_/sigmaEps_ + this->nu())
        );
    }


各系数的默认取值如下：

+-----------------+---------------+---------------+---------------+--------------------+------------------------------+
| :math:`C_{\mu}` | :math:`C_{1}` | :math:`C_{2}` | :math:`C_{3}` | :math:`\sigma_{k}` | :math:`\sigma_{\varepsilon}` |
+=================+===============+===============+===============+====================+==============================+
| 0.09            | 1.44          | 1.92          | 0             | 1                  | 1.3                          |
+-----------------+---------------+---------------+---------------+--------------------+------------------------------+


进入src/MomentumTransportModels/momentumTransportModels/RAS/kEpsilon/kEpsilon.C文件，可以看到完整的求解策略：

.. code-block:: C

    template<class BasicMomentumTransportModel>
    void kEpsilon<BasicMomentumTransportModel>::correct()
    {
        if (!this->turbulence_)
        {
            return;
        }

        // Local references
        const alphaField& alpha = this->alpha_;    // 质量分数
        const rhoField& rho = this->rho_;    // 密度
        const surfaceScalarField& alphaRhoPhi = this->alphaRhoPhi_;    // 质量分数乘以密度后插值到面上的面通量
        const volVectorField& U = this->U_;    // 速度
        volScalarField& nut = this->nut_;    // 湍流粘度
        const Foam::fvModels& fvModels(Foam::fvModels::New(this->mesh_));
        const Foam::fvConstraints& fvConstraints
        (
            Foam::fvConstraints::New(this->mesh_)
        );

        eddyViscosity<RASModel<BasicMomentumTransportModel>>::correct();

        volScalarField::Internal divU    // 速度场的散度
        (
            /* 通过显式离散计算出速度散度的具体值。
               这里的fvc::absolute只在动网格的情况发挥作用，
               其定义可以查看fvcMeshPhi.C中的Foam::fvc::absolute
            */
            fvc::div(fvc::absolute(this->phi(), U))()
        );

        tmp<volTensorField> tgradU = fvc::grad(U);    // 显式计算速度梯度张量
        volScalarField::Internal G    // 湍流产生项G
        (
            this->GName(),
            nut()*(dev(twoSymm(tgradU().v())) && tgradU().v())
        );
        tgradU.clear();

        // Update epsilon and G at the wall
        epsilon_.boundaryFieldRef().updateCoeffs();

        // Dissipation equation
        tmp<fvScalarMatrix> epsEqn    // 湍流耗散率方程
        (
            fvm::ddt(alpha, rho, epsilon_)                                   // 非稳态项
          + fvm::div(alphaRhoPhi, epsilon_)                                  // 对流项
          - fvm::laplacian(alpha*rho*DepsilonEff(), epsilon_)                // 扩散项
         ==
            C1_*alpha()*rho()*G*epsilon_()/k_()                              // 生成项
          - fvm::SuSp(((2.0/3.0)*C1_ - C3_)*alpha()*rho()*divU, epsilon_)    // 连续性误差修正项
          - fvm::Sp(C2_*alpha()*rho()*epsilon_()/k_(), epsilon_)             // 耗散项
          + epsilonSource()                                                  // 自定义源项
          + fvModels.source(alpha, rho, epsilon_)                            // fvOption添加的源项
        );

        epsEqn.ref().relax();
        fvConstraints.constrain(epsEqn.ref());
        epsEqn.ref().boundaryManipulate(epsilon_.boundaryFieldRef());
        solve(epsEqn);    // 求解湍流耗散率方程
        fvConstraints.constrain(epsilon_);
        bound(epsilon_, this->epsilonMin_);

        // Turbulent kinetic energy equation
        tmp<fvScalarMatrix> kEqn    // 湍流动能方程
        (
            fvm::ddt(alpha, rho, k_)                       // 湍流动能当地变化率，非稳态项
          + fvm::div(alphaRhoPhi, k_)                      // 湍流动能迁移变化率，对流项
          - fvm::laplacian(alpha*rho*DkEff(), k_)          // 湍流扩散项
         ==
            alpha()*rho()*G                                // 湍流生成项
          - fvm::SuSp((2.0/3.0)*alpha()*rho()*divU, k_)    // 连续性误差修正项
          - fvm::Sp(alpha()*rho()*epsilon_()/k_(), k_)     // 黏性耗散项
          + kSource()                                      // 自定义源项
          + fvModels.source(alpha, rho, k_)                // fvOption源项
        );

        kEqn.ref().relax();
        fvConstraints.constrain(kEqn.ref());
        solve(kEqn);    // 求解湍流动能方程
        fvConstraints.constrain(k_);
        bound(k_, this->kMin_);

        correctNut();    // 更新湍流粘度nut
    }


使用该模型时需要在system/momentumTransport文件中写入下面内容：

.. code-block:: C

    simulationType RAS;
    RAS
    {
        RASModel            kEpsilon;
        turbulence          on;
        printCoeffs         on;

        kEpsilonCoeffs
        {
            Cmu        0.09;
            C1         1.44;
            C2         1.92;
            C3         0;
            sigmak     1.0;
            sigmaEps   1.3;
        }
    }

场文件中需要额外添加nut、k、epsilon、alphat，并设置相应的初始条件和边界条件。

fvSchemes中需要额外添加：

.. code-block:: C

    ddtSchemes
    {
        turbulence          Euler;
        ddt(rho,epsilon)    $turbulence;
        ddt(epsilon)        $turbulence;
        ddt(rho,k)          $turbulence;
    }

    gradSchemes
    {
        turbulence       Gauss linear;
        grad(epsilon)    $turbulence;
        grad(k)          $turbulence;
    }

    divSchemes
    {
        turbulence          Gauss upwind;
        div(phi,epsilon)    $turbulence;
        div(phi,k)          $turbulence;
    }

    laplacianSchemes
    {
        turbulence              Gauss linear limited corrected 0.5;
        laplacian(alphaEff,e)                   $turbulence;
        laplacian((rho*DepsilonEff),epsilon)    $turbulence;
        laplacian((rho*DkEff),k)                $turbulence;
    }

    interpolationSchemes
    {
        turbulence                  linear;
        interpolate(rho)            $turbulence;
    }

fvSolution中需要额外添加：

.. code-block:: C

    solvers
    {
        "(epsilon|k)"
        {
            solver          smoothSolver;
            smoother        GaussSeidel;
            nSweeps         2;
            tolerance       1e-09;
        }
    }



kOmega
^^^^^^^^

OpenFOAM中的kOmega模型为Wilcox-1988版，不过使用的系数存在部分区别。所求解的湍流比耗散率方程为

.. math::
    \begin{align}
    \frac{\partial (\alpha \rho\omega)}{\partial t}
    + \nabla \cdot (\alpha \rho\mathbf{U}\omega)
    - \nabla \cdot (\alpha \rho D_{\omega}\nabla\omega)
    = \alpha \rho G \frac{\gamma \omega}{k}
    - \frac{2}{3}\gamma \alpha \rho (\nabla \cdot \mathbf{U}) \omega
    - \beta \alpha \rho \omega^{2}
    + S_{\omega}
    \end{align}

对应的代码为

.. code-block:: C

    tmp<fvScalarMatrix> omegaEqn
    (
        fvm::ddt(alpha, rho, omega_)
      + fvm::div(alphaRhoPhi, omega_)
      - fvm::laplacian(alpha*rho*DomegaEff(), omega_)
     ==
        gamma_*alpha()*rho()*G*omega_()/k_()
      - fvm::SuSp(((2.0/3.0)*gamma_)*alpha()*rho()*divU, omega_)
      - fvm::Sp(beta_*alpha()*rho()*omega_(), omega_)
      + omegaSource()
      + fvModels.source(alpha, rho, omega_)
    );

所求解的湍流动能方程为

.. math::
    \begin{align}
    \frac{\partial (\alpha \rho k)}{\partial t}
    + \nabla \cdot (\alpha \rho\mathbf{U}k)
    - \nabla \cdot (\alpha \rho D_{k}\nabla k)
    = \alpha \rho G
    - \frac{2}{3}\alpha \rho (\nabla \cdot \mathbf{U})k
    - C_{\mu}\alpha \rho \omega k
    + S_{k} 
    \end{align}

对应的代码为

.. code-block:: C

    tmp<fvScalarMatrix> kEqn
    (
        fvm::ddt(alpha, rho, k_)
      + fvm::div(alphaRhoPhi, k_)
      - fvm::laplacian(alpha*rho*DkEff(), k_)
     ==
        alpha()*rho()*G
      - fvm::SuSp((2.0/3.0)*alpha()*rho()*divU, k_)
      - fvm::Sp(betaStar_*alpha()*rho()*omega_(), k_)
      + kSource()
      + fvModels.source(alpha, rho, k_)
    );

其中 :math:`\alpha` 为质量分数，用于多相流的情况。另外有

.. math::
    \begin{align}
    G = \nu_{t} \Big( \nabla\mathbf{U} + (\nabla\mathbf{U})^{T} - \frac{2}{3}(\nabla\cdot\mathbf{U})\mathbf{I} \Big) : \nabla\mathbf{U} 
    \end{align}

对应的代码为

.. code-block:: C

    tmp<volTensorField> tgradU = fvc::grad(U);
    volScalarField::Internal G
    (
        this->GName(),
        nut.v()*(dev(twoSymm(tgradU().v())) && tgradU().v())
    );
    tgradU.clear();

.. math::
    \begin{align}
    \nu_{t} = \frac{k}{\omega} 
    \end{align}

对应的代码为

.. code-block:: C

    template<class BasicMomentumTransportModel>
    void kOmega<BasicMomentumTransportModel>::correctNut()
    {
        this->nut_ = k_/omega_;
        this->nut_.correctBoundaryConditions();
        fvConstraints::New(this->mesh_).constrain(this->nut_);
    }


.. math::
    \begin{align}
    D_{k} = \alpha _{k}\nu_{t} + \nu
    \end{align}

对应的代码为

.. code-block:: C

    tmp<volScalarField> DkEff() const    // 湍流动能的有效扩散系数
    {
        return volScalarField::New
        (
            "DkEff",
            alphaK_*this->nut_ + this->nu()
        );
    }


.. math::
    \begin{align}
    D_{\omega} = \alpha_{\omega}\nu_{t} + \nu 
    \end{align}

对应的代码为

.. code-block:: C

    tmp<volScalarField> DomegaEff() const    // 湍流比耗散率的有效扩散系数
    {
        return volScalarField::New
        (
            "DomegaEff",
            alphaOmega_*this->nut_ + this->nu()
        );
    }

各系数的默认取值如下：

+-----------------+---------------+--------------------+-------------------------+----------------+
| :math:`C_{\mu}` | :math:`\beta` | :math:`\alpha_{k}` | :math:`\alpha_{\omega}` | :math:`\gamma` |
+=================+===============+====================+=========================+================+
| 0.09            | 0.072         | 0.5                | 0.5                     | 0.52           |
+-----------------+---------------+--------------------+-------------------------+----------------+

进入src/MomentumTransportModels/momentumTransportModels/RAS/kOmega/kOmega.C文件，可以看到完整的方程求解策略：

.. code-block:: C

    template<class BasicMomentumTransportModel>
    void kOmega<BasicMomentumTransportModel>::correct()
    {
        if (!this->turbulence_)
        {
            return;
        }

        // Local references
        const alphaField& alpha = this->alpha_;    // 质量分数
        const rhoField& rho = this->rho_;          // 密度
        const surfaceScalarField& alphaRhoPhi = this->alphaRhoPhi_;    // 质量分数乘以密度插值到面上的通量
        const volVectorField& U = this->U_;    // 速度场
        volScalarField& nut = this->nut_;      // 湍流粘度
        const Foam::fvModels& fvModels(Foam::fvModels::New(this->mesh_));
        const Foam::fvConstraints& fvConstraints
        (
            Foam::fvConstraints::New(this->mesh_)
        );

        eddyViscosity<RASModel<BasicMomentumTransportModel>>::correct();

        volScalarField::Internal divU    // 速度场的散度
        (
            fvc::div(fvc::absolute(this->phi(), U))().v()    // 显式计算散度
        );

        tmp<volTensorField> tgradU = fvc::grad(U);    // 速度梯度张量
        volScalarField::Internal G    // 湍流产生项
        (
            this->GName(),
            nut.v()*(dev(twoSymm(tgradU().v())) && tgradU().v())
        );
        tgradU.clear();

        // Update omega and G at the wall
        omega_.boundaryFieldRef().updateCoeffs();

        // Turbulence specific dissipation rate equation
        tmp<fvScalarMatrix> omegaEqn    // 湍流比耗散率方程
        (
            fvm::ddt(alpha, rho, omega_)
          + fvm::div(alphaRhoPhi, omega_)
          - fvm::laplacian(alpha*rho*DomegaEff(), omega_)
         ==
            gamma_*alpha()*rho()*G*omega_()/k_()
          - fvm::SuSp(((2.0/3.0)*gamma_)*alpha()*rho()*divU, omega_)
          - fvm::Sp(beta_*alpha()*rho()*omega_(), omega_)
          + omegaSource()
          + fvModels.source(alpha, rho, omega_)
        );

        omegaEqn.ref().relax();
        fvConstraints.constrain(omegaEqn.ref());
        omegaEqn.ref().boundaryManipulate(omega_.boundaryFieldRef());
        solve(omegaEqn);    // 求解湍流比耗散率方程
        fvConstraints.constrain(omega_);
        bound(omega_, this->omegaMin_);


        // Turbulent kinetic energy equation
        tmp<fvScalarMatrix> kEqn    // 湍流动能方程
        (
            fvm::ddt(alpha, rho, k_)
          + fvm::div(alphaRhoPhi, k_)
          - fvm::laplacian(alpha*rho*DkEff(), k_)
         ==
            alpha()*rho()*G
          - fvm::SuSp((2.0/3.0)*alpha()*rho()*divU, k_)
          - fvm::Sp(betaStar_*alpha()*rho()*omega_(), k_)
          + kSource()
          + fvModels.source(alpha, rho, k_)
        );

        kEqn.ref().relax();
        fvConstraints.constrain(kEqn.ref());
        solve(kEqn);    // 求解湍流动能方程
        fvConstraints.constrain(k_);
        bound(k_, this->kMin_);

        correctNut();    // 更新湍流粘度
    }



使用该模型时需要在system/momentumTransport文件中写入下面内容：

.. code-block:: C

    simulationType RAS;
    RAS
    {
        RASModel            kOmega;
        turbulence          on;
        printCoeffs         on;

        kOmegaCoeffs
        {
            betaStar      0.09;
            beta          0.072;
            gamma         0.52;
            alphaK        0.5;
            alphaOmega    0.5;
        }
    }

kOmegaSST
^^^^^^^^^^^

所求解的湍流动能方程为

.. math::
    \begin{align}
    \frac{\partial (\alpha \rho k)}{\partial t}
    + \nabla \cdot (\alpha \rho \mathbf{U}k)
    - \nabla \cdot (\alpha \rho D_{k}\nabla k)
    = \alpha \rho P_{k}
    - \frac{2}{3}\alpha \rho k(\nabla \cdot \mathbf{U})
    - \alpha \rho \beta^{*} \omega k
    + S_{k}
    \end{align}

对应的代码为

.. code-block:: C

    tmp<fvScalarMatrix> kEqn
    (
        fvm::ddt(alpha, rho, k_)
      + fvm::div(alphaRhoPhi, k_)
      - fvm::laplacian(alpha*rho*DkEff(F1), k_)
     ==
        alpha()*rho()*Pk(G)
      - fvm::SuSp((2.0/3.0)*alpha()*rho()*divU, k_)
      - fvm::Sp(alpha()*rho()*epsilonByk(F1, F23), k_)
      + kSource()
      + fvModels.source(alpha, rho, k_)
    );

所求解的湍流比耗散率方程为

.. math::
    \begin{align}
    & \quad \frac{\partial (\alpha \rho \omega)}{\partial t}
    + \nabla \cdot (\alpha \rho \mathbf{U}\omega)
    - \nabla \cdot (\alpha \rho D_{\omega}\nabla\omega) \\
    &= \alpha \rho \gamma \min \Big\{ \frac{G}{\nu_{t}}, \frac{c_{1}}{a_{1}}\beta^{*}\omega \max(a_{1}\omega,b_{1}F_{2}\sqrt{S_{2}} ) \Big\}
    - \frac{2}{3}\alpha \rho\gamma (\nabla \cdot \mathbf{U})\omega
    - \alpha \rho \beta \omega^{2}
    - \alpha \rho (F_{1} - 1)\frac{CD_{k\omega}}{\omega}\omega 
    + S_{\omega } 
    \end{align}

对应的代码为

.. code-block:: C

    tmp<fvScalarMatrix> omegaEqn
    (
        fvm::ddt(alpha, rho, omega_)
      + fvm::div(alphaRhoPhi, omega_)
      - fvm::laplacian(alpha*rho*DomegaEff(F1), omega_)
     ==
        alpha()*rho()*gamma
       *min
        (
            GbyNu,
            (c1_/a1_)*betaStar_*omega_()
           *max(a1_*omega_(), b1_*F23()*sqrt(S2()))
        )
      - fvm::SuSp((2.0/3.0)*alpha()*rho()*gamma*divU, omega_)
      - fvm::Sp(alpha()*rho()*beta*omega_(), omega_)
      - fvm::SuSp
        (
            alpha()*rho()*(F1() - scalar(1))*CDkOmega()/omega_(),
            omega_
        )
      + Qsas(S2(), gamma, beta)
      + omegaSource()
      + fvModels.source(alpha, rho, omega_)
    );

其中 :math:`\alpha` 为质量分数，用于多相流的情况。另外有

.. math::
    \begin{align}
    P_{k} = \min(G , c_{1}\beta^{*}k\omega)
    \end{align}

对应的代码为

.. code-block:: C

    template<class MomentumTransportModel, class BasicMomentumTransportModel>
    tmp<volScalarField::Internal>
    kOmegaSST<MomentumTransportModel, BasicMomentumTransportModel>::Pk
    (
        const volScalarField::Internal& G
    ) const
    {
        return min(G, (c1_*betaStar_)*this->k_()*this->omega_());
    }

.. math::
    \begin{align}
    CD_{k\omega} = \frac{2\alpha_{\omega2}(\nabla k \cdot \nabla\omega)}{\omega}
    \end{align}

对应的代码为

.. code-block:: C

    volScalarField CDkOmega
    (
        (2*alphaOmega2_)*(fvc::grad(k_) & fvc::grad(omega_))/omega_
    );

.. math::
    \begin{align}
    G = \nu_{t} \Big( \nabla\mathbf{U} + (\nabla\mathbf{U})^{T} - \frac{2}{3}(\nabla\cdot \mathbf{U})\mathbf{I} \Big) : \nabla \mathbf{U}
    \end{align}

对应的代码为

.. code-block:: C

    tmp<volTensorField> tgradU = fvc::grad(U);

    volScalarField::Internal GbyNu(dev(twoSymm(tgradU()())) && tgradU()());
    volScalarField::Internal G(this->GName(), nut()*GbyNu);


.. math::
    \begin{align}
    S_{2} = 2 \Big| \frac{\nabla\mathbf{U} + (\nabla\mathbf{U})^{T}}{2}  \Big|^{2}
    \end{align}

对应的代码为

.. code-block:: C

    volScalarField S2(2*magSqr(symm(tgradU())));


.. math::
    \begin{align}
    F_{1} = \tanh\left \{  \min\bigg[\min\Big[ \max\Big(\frac{\sqrt{k}}{\beta^{*}\omega y},  \frac{500\nu}{\omega y^{2}}\Big), \frac{4\alpha_{\omega2}k}{CD_{k\omega}y^{2}} \Big] , 10\bigg]\right \} ^{4}
    \end{align}

对应的代码为

.. code-block:: C

    template<class MomentumTransportModel, class BasicMomentumTransportModel>
    tmp<volScalarField>
    kOmegaSST<MomentumTransportModel, BasicMomentumTransportModel>::kOmegaSST::F1
    (
        const volScalarField& CDkOmega
    ) const
    {
        tmp<volScalarField> CDkOmegaPlus = max
        (
            CDkOmega,
            dimensionedScalar(dimless/sqr(dimTime), 1.0e-10)
        );

        tmp<volScalarField> arg1 = min
        (
            min
            (
                max
                (
                    (scalar(1)/betaStar_)*sqrt(k_)/(omega_*y_),
                    scalar(500)*this->nu()/(sqr(y_)*omega_)
                ),
                (4*alphaOmega2_)*k_/(CDkOmegaPlus*sqr(y_))
            ),
            scalar(10)
        );

        return tanh(pow4(arg1));
    }


.. math::
    \begin{align}
    F_{2} = \tanh \left \{ \min\Big[ \max\Big( \frac{2\sqrt{k}}{\beta^{*}\omega y}, \frac{500 \nu}{\omega y^{2}} \Big), 100\Big] \right \}^{2}
    \end{align}

对应的代码为

.. code-block:: C

    template<class MomentumTransportModel, class BasicMomentumTransportModel>
    tmp<volScalarField>
    kOmegaSST<MomentumTransportModel, BasicMomentumTransportModel>::kOmegaSST::
    F2() const
    {
        tmp<volScalarField> arg2 = min
        (
            max
            (
                (scalar(2)/betaStar_)*sqrt(k_)/(omega_*y_),
                scalar(500)*this->nu()/(sqr(y_)*omega_)
            ),
            scalar(100)
        );

        return tanh(sqr(arg2));
    }


.. math::
    \begin{align}
    D_{k} = B(F_{1}, \alpha_{k1}, \alpha_{k2})\nu_{t} + \nu
    \end{align}

对应的代码为

.. code-block:: C

    tmp<volScalarField> alphaK(const volScalarField& F1) const
    {
        return blend(F1, alphaK1_, alphaK2_);
    }

    tmp<volScalarField> DkEff(const volScalarField& F1) const
    {
        return volScalarField::New
        (
            "DkEff",
            alphaK(F1)*this->nut_ + this->nu()
        );
    }

.. math::
    \begin{align}
    D_{\omega} = B(F_{1}, \alpha_{\omega2}, \alpha_{\omega2})\nu_{t} + \nu
    \end{align}

对应的代码为

.. code-block:: C

    tmp<volScalarField> alphaOmega(const volScalarField& F1) const
    {
        return blend(F1, alphaOmega1_, alphaOmega2_);
    }

    tmp<volScalarField> DomegaEff(const volScalarField& F1) const
    {
        return volScalarField::New
        (
            "DomegaEff",
            alphaOmega(F1)*this->nut_ + this->nu()
        );
    }

.. math::
    \begin{align}
    \beta = B(F_{1}, \beta_{1}, \beta_{2})
    \end{align}

对应的代码为

.. code-block:: C

    tmp<volScalarField::Internal> beta
    (
        const volScalarField::Internal& F1
    ) const
    {
        return blend(F1, beta1_, beta2_);
    }

.. math::
    \begin{align}
    \gamma = B(F_{1}, \gamma_{1}, \gamma_{2})
    \end{align}

对应的代码为

.. code-block:: C

    tmp<volScalarField::Internal> gamma
    (
        const volScalarField::Internal& F1
    ) const
    {
        return blend(F1, gamma1_, gamma2_);
    }

.. math::
    \begin{align}
    B(a,b,c) = ab + (1-a)c
    \end{align}

对应的代码为

.. code-block:: C

    tmp<volScalarField> blend
    (
        const volScalarField& F1,
        const dimensionedScalar& psi1,
        const dimensionedScalar& psi2
    ) const
    {
        return F1*(psi1 - psi2) + psi2;
    }

.. math::
    \begin{align}
    \nu_{t} = \frac{a_{1}k}{\max(a_{1}\omega, b_{1}F_{2}\sqrt{S_{2}})}
    \end{align}

对应的代码为

.. code-block:: C

    template<class MomentumTransportModel, class BasicMomentumTransportModel>
    void kOmegaSST<MomentumTransportModel, BasicMomentumTransportModel>::correctNut
    (
        const volScalarField& S2,
        const volScalarField& F2
    )
    {
        this->nut_ = a1_*k_/max(a1_*omega_, b1_*F2*sqrt(S2));
        this->nut_.correctBoundaryConditions();
        fvConstraints::New(this->mesh_).constrain(this->nut_);
    }

.. math::
    \begin{align}
    \varepsilon = \beta^{*} k \omega
    \end{align}

对应的代码为

.. code-block:: C

    virtual tmp<volScalarField> epsilon() const
    {
        return volScalarField::New
        (
            "epsilon",
            betaStar_*k_*omega_,
            omega_.boundaryField().types()
        );
    }

各参数的默认取值如下：

+---------------------+---------------------+--------------------------+-------------------------+--------------------+--------------------+-------------------+-------------------+-------------------+---------------+---------------+---------------+
| :math:`\alpha_{k1}` | :math:`\alpha_{k2}` | :math:`\alpha_{\omega1}` | :math:`\alpha_{omega2}` | :math:`\gamma_{1}` | :math:`\gamma_{2}` | :math:`\beta_{1}` | :math:`\beta_{2}` | :math:`\beta^{*}` | :math:`a_{1}` | :math:`b_{1}` | :math:`c_{1}` |
+=====================+=====================+==========================+=========================+====================+====================+===================+===================+===================+===============+===============+===============+
| 0.85                | 1                   | 0.5                      | 0.856                   | 5/9                | 0.44               | 0.075             | 0.0828            | 0.09              | 0.31          | 1             | 10            |
+---------------------+---------------------+--------------------------+-------------------------+--------------------+--------------------+-------------------+-------------------+-------------------+---------------+---------------+---------------+

.. attention:: 

    另外还定义了F3函数，它默认关闭，需要通过字典设置为True来激活，如果激活了则可以处理粗糙壁面问题。它的定义为

    .. math::
        \begin{align}
        F_{3} = 1 - \tanh \Big[ \min\Big( \frac{150\nu}{\omega y^{2}} ,10 \Big) \Big]^{4}
        \end{align}

    F3通过作用于F2来发挥作用。涉及到的代码如下所示。

.. code-block:: C

    template<class MomentumTransportModel, class BasicMomentumTransportModel>
    tmp<volScalarField>
    kOmegaSST<MomentumTransportModel, BasicMomentumTransportModel>::kOmegaSST::
    F3() const
    {
        tmp<volScalarField> arg3 = min
        (
            150*this->nu()/(omega_*sqr(y_)),
            scalar(10)
        );

        return 1 - tanh(pow4(arg3));
    }

.. code-block:: C

    template<class MomentumTransportModel, class BasicMomentumTransportModel>
    tmp<volScalarField>
    kOmegaSST<MomentumTransportModel, BasicMomentumTransportModel>::kOmegaSST::
    F23() const
    {
        tmp<volScalarField> f23(F2());    // 默认是输出F2

        if (F3_)    // 如果激活F3
        {
            f23.ref() *= F3();    // 则在F2基础上乘以F3
        }

        return f23;
    }


进入src/MomentumTransportModels/momentumTransportModels/Base/kOmegaSST/kOmegaSSTBase.C文件，可以看到完整的求解策略：

.. code-block:: C

    template<class MomentumTransportModel, class BasicMomentumTransportModel>
    void kOmegaSST<MomentumTransportModel, BasicMomentumTransportModel>::correct()
    {
        if (!this->turbulence_)
        {
            return;
        }

        // Local references
        const alphaField& alpha = this->alpha_;
        const rhoField& rho = this->rho_;
        const surfaceScalarField& alphaRhoPhi = this->alphaRhoPhi_;
        const volVectorField& U = this->U_;
        volScalarField& nut = this->nut_;
        const Foam::fvModels& fvModels(Foam::fvModels::New(this->mesh_));
        const Foam::fvConstraints& fvConstraints
        (
            Foam::fvConstraints::New(this->mesh_)
        );

        MomentumTransportModel::correct();

        volScalarField::Internal divU
        (
            fvc::div(fvc::absolute(this->phi(), U))()()
        );

        tmp<volTensorField> tgradU = fvc::grad(U);
        volScalarField S2(2*magSqr(symm(tgradU())));
        volScalarField::Internal GbyNu(dev(twoSymm(tgradU()())) && tgradU()());
        volScalarField::Internal G(this->GName(), nut()*GbyNu);
        tgradU.clear();

        // Update omega and G at the wall
        omega_.boundaryFieldRef().updateCoeffs();

        volScalarField CDkOmega
        (
            (2*alphaOmega2_)*(fvc::grad(k_) & fvc::grad(omega_))/omega_
        );

        volScalarField F1(this->F1(CDkOmega));
        volScalarField F23(this->F23());

        {
            volScalarField::Internal gamma(this->gamma(F1));
            volScalarField::Internal beta(this->beta(F1));

            // Turbulent frequency equation
            tmp<fvScalarMatrix> omegaEqn
            (
                fvm::ddt(alpha, rho, omega_)
              + fvm::div(alphaRhoPhi, omega_)
              - fvm::laplacian(alpha*rho*DomegaEff(F1), omega_)
             ==
                alpha()*rho()*gamma
               *min
                (
                    GbyNu,
                    (c1_/a1_)*betaStar_*omega_()
                   *max(a1_*omega_(), b1_*F23()*sqrt(S2()))
                )
              - fvm::SuSp((2.0/3.0)*alpha()*rho()*gamma*divU, omega_)
              - fvm::Sp(alpha()*rho()*beta*omega_(), omega_)
              - fvm::SuSp
                (
                    alpha()*rho()*(F1() - scalar(1))*CDkOmega()/omega_(),
                    omega_
                )
              + Qsas(S2(), gamma, beta)
              + omegaSource()
              + fvModels.source(alpha, rho, omega_)
            );

            omegaEqn.ref().relax();
            fvConstraints.constrain(omegaEqn.ref());
            omegaEqn.ref().boundaryManipulate(omega_.boundaryFieldRef());
            solve(omegaEqn);
            fvConstraints.constrain(omega_);
            bound(omega_, this->omegaMin_);
        }

        // Turbulent kinetic energy equation
        tmp<fvScalarMatrix> kEqn
        (
            fvm::ddt(alpha, rho, k_)
          + fvm::div(alphaRhoPhi, k_)
          - fvm::laplacian(alpha*rho*DkEff(F1), k_)
         ==
            alpha()*rho()*Pk(G)
          - fvm::SuSp((2.0/3.0)*alpha()*rho()*divU, k_)
          - fvm::Sp(alpha()*rho()*epsilonByk(F1, F23), k_)
          + kSource()
          + fvModels.source(alpha, rho, k_)
        );

        kEqn.ref().relax();
        fvConstraints.constrain(kEqn.ref());
        solve(kEqn);
        fvConstraints.constrain(k_);
        bound(k_, this->kMin_);

        correctNut(S2, F23);
    }



使用该模型时需要在system/momentumTransport文件中写入下面内容：

.. code-block:: C

    simulationType RAS;
    RAS
    {
        RASModel            kOmegaSST;
        turbulence          on;
        printCoeffs         on;

        kOmegaSSTCoeffs
        {
            alphaK1        0.85;
            alphaK2        1.0;
            alphaOmega1    0.5;
            alphaOmega2    0.856;
            gamma1         5.0/9.0;
            gamma2         0.44;
            beta1          0.075;
            beta2          0.0828;
            betaStar       0.09;
            a1             0.31;
            b1             1.0;
            c1             10.0;
            F3             false;
        }
    }


场文件需要额外添加

fvSchemes文件需要额外添加：

.. code-block:: C

    ddtSchemes
    {
        turbulence        CrankNicolson 0.9;
        ddt(rho,omega)    $turbulence;
        ddt(omega)        $turbulence;
        ddt(rho,k)        $turbulence;
    }

    gradSchemes
    {
        turbulence     Gauss linear;
        grad(yPsi)     $turbulence;
        grad(omega)    $turbulence;
        grad(k)        $turbulence;
    }

    divSchemes
    {
        turbulence        Gauss upwind;
        div(phi,omega)    $turbulence;
        div(phi,k)        $turbulence;
    }

    laplacianSchemes
    {
        turbulence    Gauss linear limited corrected 0.5;
        laplacian(yPsi)                     $turbulence;
        laplacian(alphaEff,e)               $turbulence;
        laplacian((rho*DomegaEff),omega)    $turbulence;
        laplacian((rho*DkEff),k)            $turbulence;
    }

    interpolationSchemes
    {
        turbulence          linear;
        interpolate(rho)    $turbulence;
    }

    wallDist
    {
        method Poisson;
    }

fvSolution文件需要额外添加：

.. code-block:: C

    solvers
    {
        "(omega|k)"
        {
            solver          smoothSolver;
            smoother        GaussSeidel;
            nSweeps         2;
            tolerance       1e-09;
            relTol          0.01;
        }
        yPsi
        {
            solver         PCG;
            preconditioner DIC;
            tolerance      1e-9;
            relTol         0;
        }
    }











fvShemes离散格式设置
=======================

参考 `OpenFOAM中fvSchemes字典文件解析 <https://www.zybuluo.com/daidezhi/note/389113>`_ 

system/fvSchemes文件用来设置离散格式，凡是求解器里面出现的方程，都需要在这里进行离散格式设置。需要指定的信息主要以下子字典：

+----------------------+------------------+
| 子字典关键词         | 含义             |
+======================+==================+
| interpolationSchemes | 插值格式         |
+----------------------+------------------+
| snGradSchemes        | 面法向梯度格式   |
+----------------------+------------------+
| ddtSchemes           | 时间一阶导项格式 |
+----------------------+------------------+
| d2dt2Schemes         | 时间二阶导项格式 |
+----------------------+------------------+
| divSchemes           | 散度项格式       |
+----------------------+------------------+
| gradSchemes          | 梯度项格式       |
+----------------------+------------------+
| laplacianSchemes     | 拉普拉斯项格式   |
+----------------------+------------------+
| fluxRequired         | 需要计算通量的场 |
+----------------------+------------------+


插值格式interpolationSchemes
-------------------------------

插值格式在子字典interpolationSchemes下设置，通常用来指定从相邻两个体单元计算公共面单元处变量值的计算方法：

+----------+----------------------+------------------------------+------------------+
| 插值格式 | 具体方法             | 含义                         | 用途             |
+==========+======================+==============================+==================+
| 中心格式 | linear               | 线性插值(中心差分)格式       | 应用于普通场插值 |
+          +----------------------+------------------------------+                  +
|          | cubicCorrection      | 立方正交格式                 |                  |
+          +----------------------+------------------------------+                  +
|          | midPoint             | 对称加权线性插值格式         |                  |
+----------+----------------------+------------------------------+------------------+
| 迎风格式 | upwind               | 一阶迎风格式                 | 主要应用于对流项 |
+          +----------------------+------------------------------+                  +
|          | linearUpwind         | 线性迎风格式                 |                  |
+          +----------------------+------------------------------+                  +
|          | skewLinear           | 带畸变修正线性迎风格式       |                  |
+          +----------------------+------------------------------+                  +
|          | filteredLinear2      | 高频波过滤线性迎风格式       |                  |
+----------+----------------------+------------------------------+------------------+
| TVD家族  | limitedLinear        | 有界线性格式                 | 主要应用于对流项 |
+          +----------------------+------------------------------+                  +
|          | limitedLimitedLinear | 有界线性格式(带限制器)       |                  |
+          +----------------------+------------------------------+                  +
|          | limitedLinearV       | 有界线性格式(矢量场专用)     |                  |
+          +----------------------+------------------------------+                  +
|          | vanLeer              | van Leer有界格式             |                  |
+          +----------------------+------------------------------+                  +
|          | limitedVanLeer       | van Leer有界格式(带限制器)   |                  |
+          +----------------------+------------------------------+                  +
|          | vanLeerV             | van Leer有界格式(矢量场专用) |                  |
+          +----------------------+------------------------------+                  +
|          | MUSCL                | MUSCL有界格式                |                  |
+          +----------------------+------------------------------+                  +
|          | limitedMUSCL         | MUSCL有界格式(带限制器)      |                  |
+          +----------------------+------------------------------+                  +
|          | limitedCubic         | 立方正交有界格式             |                  |
+          +----------------------+------------------------------+                  +
|          | limitedLimitedCubic  | 立方正交有界格式(带限制器)   |                  |
+          +----------------------+------------------------------+                  +
|          | limitedCubicV        | 立方正交有界格式(矢量场专用) |                  |
+----------+----------------------+------------------------------+------------------+
| NVD家族  | SFCD                 | 自过滤中心格式               | 主要应用于对流项 |
+          +----------------------+------------------------------+                  +
|          | SFCDV                | 自过滤中心格式(矢量场专用)   |                  |
+          +----------------------+------------------------------+                  +
|          | Gamma                | Gamma差分格式                |                  |
+          +----------------------+------------------------------+                  +
|          | limitedGamma         | Gamma差分格式(带限制器)      |                  |
+          +----------------------+------------------------------+                  +
|          | GammaV               | Gamma差分格式(矢量场专用)    |                  |
+----------+----------------------+------------------------------+------------------+



针对对流项的插值格式需要在通量的基础上计算插值，因此这些格式的指定需要提供通量场的名称。在OpenFOAM标准求解器中，体积通量名称一般为phi，类型为surfaceScalarField（面心标量场），因此针对对流项的插值格式指定方式为：

.. code-block:: C

    default upwind phi;


一些基于TVD或者NVD的格式需要系数 :math:`\psi` ，该系数的值介于0和1之间。当 :math:`\psi=1` 时对应标准TVD格式，能够达到最快的收敛速度；当 :math:`\psi=0` 时对应最高精度，例如：

.. code-block:: C

    default limitedLinear phi 1.0;



某些标量场是严格有界的，例如VOF模型中的流体体积分数场 :math:`F` 的值严格介于0和1之间，因此才会出现一些带有限制器的增强版格式。如果想要指定有界场的上下限，需要在格式名称前加上limited前缀。例如将vanLeer格式的上下限设置为 :math:`[-2,3]` ：

.. code-block:: C

    default limitedVanLeer -2.0 3.0;

特别地，对于类似于流体体积分数场上下限严格为 :math:`[0,1]` 的情况，可以添加后缀01，例如：

.. code-block:: C

    default vanLeer01;


针对矢量场的有向性，一些带有限制器的格式具有矢量场的专用版本，使用方法为添加后缀V，如：

.. code-block:: C

    default limitedLinearV;


插值到网格表面的方式主要通过interpolate函数和dotInterpolate函数来实现：

.. code-block:: C
    :caption: src/finiteVolume/interpolation/surfaceInterpolation/surfaceInterpolationScheme/surfaceInterpolationScheme.C


    template<class Type>
    Foam::tmp<Foam::GeometricField<Type, Foam::fvsPatchField, Foam::surfaceMesh>>
    Foam::surfaceInterpolationScheme<Type>::interpolate
    (
        const GeometricField<Type, fvPatchField, volMesh>& vf,
        const tmp<surfaceScalarField>& tlambdas,
        const tmp<surfaceScalarField>& tys
    )
    {
        if (surfaceInterpolation::debug)
        {
            InfoInFunction
                << "Interpolating "
                << vf.type() << " "
                << vf.name()
                << " from cells to faces "
                   "without explicit correction"
                << endl;
        }

        const surfaceScalarField& lambdas = tlambdas();
        const surfaceScalarField& ys = tys();

        const Field<Type>& vfi = vf;
        const scalarField& lambda = lambdas;
        const scalarField& y = ys;

        const fvMesh& mesh = vf.mesh();
        const labelUList& P = mesh.owner();
        const labelUList& N = mesh.neighbour();

        tmp<GeometricField<Type, fvsPatchField, surfaceMesh>> tsf
        (
            GeometricField<Type, fvsPatchField, surfaceMesh>::New
            (
                "interpolate("+vf.name()+')',
                mesh,
                vf.dimensions()
            )
        );
        GeometricField<Type, fvsPatchField, surfaceMesh>& sf = tsf.ref();

        Field<Type>& sfi = sf.primitiveFieldRef();

        for (label fi=0; fi<P.size(); fi++)
        {
            sfi[fi] = lambda[fi]*vfi[P[fi]] + y[fi]*vfi[N[fi]];
        }


        // Interpolate across coupled patches using given lambdas and ys
        typename GeometricField<Type, fvsPatchField, surfaceMesh>::
            Boundary& sfbf = sf.boundaryFieldRef();

        forAll(lambdas.boundaryField(), pi)
        {
            const fvsPatchScalarField& pLambda = lambdas.boundaryField()[pi];
            const fvsPatchScalarField& pY = ys.boundaryField()[pi];

            if (vf.boundaryField()[pi].coupled())
            {
                sfbf[pi] =
                    pLambda*vf.boundaryField()[pi].patchInternalField()
                  + pY*vf.boundaryField()[pi].patchNeighbourField();
            }
            else
            {
                sfbf[pi] = vf.boundaryField()[pi];
            }
        }

        tlambdas.clear();
        tys.clear();

        return tsf;
    }



.. code-block:: C

    template<class Type>
    template<class SFType>
    Foam::tmp
    <
        Foam::GeometricField
        <
            typename Foam::innerProduct<typename SFType::value_type, Type>::type,
            Foam::fvsPatchField,
            Foam::surfaceMesh
        >
    >
    Foam::surfaceInterpolationScheme<Type>::dotInterpolate
    (
        const SFType& Sf,
        const GeometricField<Type, fvPatchField, volMesh>& vf,
        const tmp<surfaceScalarField>& tlambdas
    )
    {
        if (surfaceInterpolation::debug)
        {
            InfoInFunction
                << "Interpolating "
                << vf.type() << " "
                << vf.name()
                << " from cells to faces "
                   "without explicit correction"
                << endl;
        }

        typedef typename Foam::innerProduct<typename SFType::value_type, Type>::type
            RetType;

        const surfaceScalarField& lambdas = tlambdas();

        const Field<Type>& vfi = vf;
        const scalarField& lambda = lambdas;

        const fvMesh& mesh = vf.mesh();
        const labelUList& P = mesh.owner();
        const labelUList& N = mesh.neighbour();

        tmp<GeometricField<RetType, fvsPatchField, surfaceMesh>> tsf
        (
            GeometricField<RetType, fvsPatchField, surfaceMesh>::New
            (
                "interpolate("+vf.name()+')',
                mesh,
                Sf.dimensions()*vf.dimensions()
            )
        );
        GeometricField<RetType, fvsPatchField, surfaceMesh>& sf = tsf.ref();

        Field<RetType>& sfi = sf.primitiveFieldRef();

        const typename SFType::Internal& Sfi = Sf();

        for (label fi=0; fi<P.size(); fi++)
        {
            sfi[fi] = Sfi[fi] & (lambda[fi]*(vfi[P[fi]] - vfi[N[fi]]) + vfi[N[fi]]);
        }

        // Interpolate across coupled patches using given lambdas

        typename GeometricField<RetType, fvsPatchField, surfaceMesh>::
            Boundary& sfbf = sf.boundaryFieldRef();

        forAll(lambdas.boundaryField(), pi)
        {
            const fvsPatchScalarField& pLambda = lambdas.boundaryField()[pi];
            const typename SFType::Patch& pSf = Sf.boundaryField()[pi];
            fvsPatchField<RetType>& psf = sfbf[pi];

            if (vf.boundaryField()[pi].coupled())
            {
                psf =
                    pSf
                  & (
                        pLambda*vf.boundaryField()[pi].patchInternalField()
                      + (1.0 - pLambda)*vf.boundaryField()[pi].patchNeighbourField()
                    );
            }
            else
            {
                psf = pSf & vf.boundaryField()[pi];
            }
        }

        tlambdas.clear();

        return tsf;
    }


可以看到，核心的插值计算方式为

.. math::
    \begin{align}
    \phi_{f} = \lambda \phi_{O} + (1 - \lambda)\phi_{N} = \phi_{N} + \lambda(\phi_{O} - \phi_{N})
    \end{align}

lambda这个参数会通过weights函数来赋值，weights函数初始化时设置为了0，而具体的插值格式就是要确定各自不同的weights。


一些插值格式会使用到修正函数correction，该函数返回的值作为附加内容加到原本的权重计算结果，具体实现过程如下所示：

.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::GeometricField<Type, Foam::fvsPatchField, Foam::surfaceMesh>>
    Foam::surfaceInterpolationScheme<Type>::interpolate
    (
        const GeometricField<Type, fvPatchField, volMesh>& vf
    ) const
    {
        if (surfaceInterpolation::debug)
        {
            InfoInFunction
                << "Interpolating "
                << vf.type() << " "
                << vf.name()
                << " from cells to faces"
                << endl;
        }

        tmp<GeometricField<Type, fvsPatchField, surfaceMesh>> tsf = interpolate(vf, weights(vf));

        if (corrected())
        {
            tsf.ref() += correction(vf);
        }

        return tsf;
    }

.. code-block:: C

    template<class Type>
    Foam::tmp
    <
        Foam::GeometricField
        <
            typename Foam::innerProduct<Foam::vector, Type>::type,
            Foam::fvsPatchField,
            Foam::surfaceMesh
        >
    >
    Foam::surfaceInterpolationScheme<Type>::dotInterpolate
    (
        const surfaceVectorField& Sf,
        const GeometricField<Type, fvPatchField, volMesh>& vf
    ) const
    {
        if (surfaceInterpolation::debug)
        {
            InfoInFunction
                << "Interpolating "
                << vf.type() << " "
                << vf.name()
                << " from cells to faces"
                << endl;
        }

        tmp
        <
            GeometricField
            <
                typename Foam::innerProduct<Foam::vector, Type>::type,
                fvsPatchField,
                surfaceMesh
            >
        > tsf = dotInterpolate(Sf, vf, weights(vf));

        if (corrected())
        {
            tsf.ref() += Sf & correction(vf);
        }

        return tsf;
    }





linear
^^^^^^^^

进入src/finiteVolume/interpolation/surfaceInterpolation/schemes/linear/linear.H文件，可以看到权重函数与网格有关，因此定义了中心差分离散：

.. code-block:: C

    tmp<surfaceScalarField> weights
    (
        const GeometricField<Type, fvPatchField, volMesh>&
    ) const
    {
        return this->mesh().surfaceInterpolation::weights();
    }


cubic
^^^^^^

该格式继承于linear格式，同样返回线性权重，但是使用了修正函数。进入src/finiteVolume/interpolation/surfaceInterpolation/schemes/cubic/cubic.H文件可以看到定义的修正函数：

.. code-block:: C

    virtual tmp<GeometricField<Type, fvsPatchField, surfaceMesh>>
    correction
    (
        const GeometricField<Type, fvPatchField, volMesh>& vf
    ) const
    {
        const fvMesh& mesh = this->mesh();

        // calculate the appropriate interpolation factors
        const surfaceScalarField& lambda = mesh.weights();

        const surfaceScalarField kSc
        (
            lambda*(scalar(1) - lambda*(scalar(3) - scalar(2)*lambda))
        );

        const surfaceScalarField kVecP(sqr(scalar(1) - lambda)*lambda);
        const surfaceScalarField kVecN(sqr(lambda)*(lambda - scalar(1)));

        tmp<GeometricField<Type, fvsPatchField, surfaceMesh>> tsfCorr
        (
            GeometricField<Type, fvsPatchField, surfaceMesh>::New
            (
                "cubic::correction(" + vf.name() +')',
                surfaceInterpolationScheme<Type>::interpolate(vf, kSc, -kSc)
            )
        );
        GeometricField<Type, fvsPatchField, surfaceMesh>& sfCorr = tsfCorr.ref();

        for (direction cmpt=0; cmpt<pTraits<Type>::nComponents; cmpt++)
        {
            sfCorr.replace
            (
                cmpt,
                sfCorr.component(cmpt)
              + (
                    surfaceInterpolationScheme
                    <
                        typename outerProduct
                        <
                            vector,
                            typename pTraits<Type>::cmptType
                        >::type
                    >::interpolate
                    (
                        fv::gaussGrad
                        <typename pTraits<Type>::cmptType>(mesh)
                       .grad(vf.component(cmpt)),
                        kVecP,
                        kVecN
                    ) & mesh.Sf()
                )/mesh.magSf()/mesh.surfaceInterpolation::deltaCoeffs()
            );
        }

        typename GeometricField<Type, fvsPatchField, surfaceMesh>::Boundary& sfCorrbf = sfCorr.boundaryFieldRef();

        forAll(sfCorrbf, pi)
        {
            if (!sfCorrbf[pi].coupled())
            {
                sfCorrbf[pi] = Zero;
            }
        }

        return tsfCorr;
    }


downwind
^^^^^^^^^^^

进入src/finiteVolume/interpolation/surfaceInterpolation/schemes/downwind/downwind.H文件，可以看到该格式设置的权重函数为

.. code-block:: C

    virtual tmp<surfaceScalarField> weights
    (
        const GeometricField<Type, fvPatchField, volMesh>&
    ) const
    {
        return neg(faceFlux_);
    }

其中neg的定义可以在src/OpenFOAM/primitives/Scalar/Scalar.H文件中看到：

.. code-block:: C

    inline int neg(const Scalar s)
    {
        return (s < 0) ? 1: 0;
    }

因此downwind格式设置的权重表达式为

.. math::
    \begin{align}
    \lambda = \left \{\begin{array}{l}
    1, \quad \text{flux} < 0 \\
    0, \quad \text{flux} \ge 0  
    \end{array}\right .
    \end{align}



upwind
^^^^^^^^^^

进入src/finiteVolume/interpolation/surfaceInterpolation/limitedSchemes/upwind/upwind.H文件，可以看到该格式设置的权重函数为

.. code-block:: C

    tmp<surfaceScalarField> weights() const
    {
        return pos0(this->faceFlux_);
    }

其中pos0的定义可以在src/OpenFOAM/primitives/Scalar/Scalar.H文件中看到：

.. code-block:: C

    inline int pos0(const Scalar s)
    {
        return (s >= 0) ? 1: 0;
    }

因此upwind格式设置的权重表达式为

.. math::
    \begin{align}
    \lambda = \left \{\begin{array}{l}
    1, \quad \text{flux} \ge 0 \\
    0, \quad \text{flux < 0}  
    \end{array}\right .
    \end{align}


linearUpwind
^^^^^^^^^^^^^^^

该格式继承于upwind格式，使用的权重函数相同，但是该格式启用了correction函数，并定义了自己修正函数，其定义的修正函数如下：

.. code-block:: C
    :caption: src/finiteVolume/interpolation/surfaceInterpolation/schemes/linearUpwind/linearUpwind.C

    template<>
    Foam::tmp<Foam::surfaceVectorField>
    Foam::linearUpwind<Foam::vector>::correction
    (
        const volVectorField& vf
    ) const
    {
        const fvMesh& mesh = this->mesh();

        tmp<surfaceVectorField> tsfCorr    // 创建修正项，是一个定义在网格面上的矢量场
        (
            surfaceVectorField::New
            (
                "linearUpwind::correction(" + vf.name() + ')',
                mesh,
                dimensioned<vector>(vf.name(), vf.dimensions(), Zero)
            )
        );

        surfaceVectorField& sfCorr = tsfCorr.ref();    // 通过创建引用来后续修改修正项的值

        const surfaceScalarField& faceFlux = this->faceFlux_;    // 面通量

        const labelList& owner = mesh.owner();    // 当前网格的label
        const labelList& neighbour = mesh.neighbour();    // 相邻网格的label

        const volVectorField& C = mesh.C();    // 网格中心位置矢量
        const surfaceVectorField& Cf = mesh.Cf();    // 网格面心位置矢量

        tmp<fv::gradScheme<vector>> gradScheme_
        (
            fv::gradScheme<vector>::New
            (
                mesh,
                mesh.schemes().grad(gradSchemeName_)
            )
        );

        tmp<volTensorField> tgradVf = gradScheme_().grad(vf, gradSchemeName_);    // 通过gradScheme确定的方式获取体心的梯度值
        const volTensorField& gradVf = tgradVf();    // 存储通过tmp建立的梯度值

        forAll(faceFlux, facei)    // 计算内部场的修正项
        {
            const label celli = (faceFlux[facei] > 0) ? owner[facei] : neighbour[facei];
            sfCorr[facei] = (Cf[facei] - C[celli]) & gradVf[celli];
        }


        typename surfaceVectorField::Boundary& bSfCorr = sfCorr.boundaryFieldRef();    // 边界处的修正项的值

        forAll(bSfCorr, patchi)    // 当使用coupled类型边界时，计算边界处的修正项
        {
            fvsPatchVectorField& pSfCorr = bSfCorr[patchi];    // 每个边界处网格的值

            if (pSfCorr.coupled())
            {
                const labelUList& pOwner = mesh.boundary()[patchi].faceCells();     // 边界处网格的label
                const vectorField& pCf = Cf.boundaryField()[patchi];                // 边界处网格面心位置矢量
                const scalarField& pFaceFlux = faceFlux.boundaryField()[patchi];    // 边界网格面通量

                const tensorField pGradVfNei    // 相邻网格的梯度值
                (
                    gradVf.boundaryField()[patchi].patchNeighbourField()
                );

                // Build the d-vectors
                vectorField pd(Cf.boundaryField()[patchi].patch().delta());    // coupled边界面的距离矢量d

                forAll(pOwner, facei)
                {
                    label own = pOwner[facei];

                    if (pFaceFlux[facei] > 0)    // 如果边界面通量为正
                    {
                        pSfCorr[facei] = (pCf[facei] - C[own]) & gradVf[own];
                    }
                    else    // 如果边界面通量为负
                    {
                        pSfCorr[facei] = (pCf[facei] - pd[facei] - C[own]) & pGradVfNei[facei];
                    }
                }
            }
        }

        return tsfCorr;
    }


从上面的代码可以看到，修正项的表达式为

.. math::
    \begin{align}
    \text{correction} = \left \{\begin{array}{l}
    (\mathbf{r}_{Cf} - \mathbf{r}_{C}) \cdot \nabla \phi_{C} ,\quad \text{flux} > 0 \\
    (\mathbf{r}_{Cf} - \mathbf{r}_{N}) \cdot \nabla \phi_{N} ,\quad \text{flux} \le 0  
    \end{array}\right . 
    \end{align}

当使用了coupled边界条件时，边界处的修正项表达式为

.. math::
    \begin{align}
    \text{correction} = \left \{\begin{array}{l}
    (\mathbf{r}_{Cfp} - \mathbf{r}_{C}) \cdot \nabla\phi_{C} ,\quad \text{flux}_{p} > 0 \\
    (\mathbf{r}_{Cfp} - \mathbf{d} - \mathbf{r}_{C}) \cdot \nabla\phi_{N} ,\quad \text{flux}_{p} \le 0 
    \end{array}\right . 
    \end{align}

其中delta()函数的定义位于src/finiteVolume/fvMesh/fvPatches/basic/coupled/coupledFvPatch.C文件当中：

.. code-block:: C

    Foam::tmp<Foam::vectorField> Foam::coupledFvPatch::delta() const
    {
        return Cf() - Cn();
    }



NVD/TVD格式
^^^^^^^^^^^^^^
参考 `OpenFOAM类库介绍（六）对流项高分辨率格式理论 <https://blog.csdn.net/weixin_43325228/article/details/126356303>`_ 

OpenFOAM定义了limitedScheme类库来常见NVD/TVD有限权重因子，特定的插值格式则确定了各自的权重函数limiter。权重函数提供中心插值权重因子、面通量、单元和面梯度以及单元中心距离。limiter的使用方式如下所示：

.. code-block:: C
    :caption: src/finiteVolume/interpolation/surfaceInterpolation/limitedSchemes/LimitedScheme/LimitedScheme.C

    template<class Type, class Limiter, template<class> class LimitFunc>
    void Foam::LimitedScheme<Type, Limiter, LimitFunc>::calcLimiter
    (
        const GeometricField<Type, fvPatchField, volMesh>& phi,
        surfaceScalarField& limiterField
    ) const
    {
        const fvMesh& mesh = this->mesh();

        tmp<GeometricField<typename Limiter::phiType, fvPatchField, volMesh>> tlPhi = LimitFunc<Type>()(phi);

        const GeometricField<typename Limiter::phiType, fvPatchField, volMesh>& lPhi = tlPhi();

        tmp<GeometricField<typename Limiter::gradPhiType, fvPatchField, volMesh>> tgradc(fvc::grad(lPhi));
        const GeometricField<typename Limiter::gradPhiType, fvPatchField, volMesh>& gradc = tgradc();

        const surfaceScalarField& CDweights = mesh.surfaceInterpolation::weights();

        const labelUList& owner = mesh.owner();
        const labelUList& neighbour = mesh.neighbour();

        const vectorField& C = mesh.C();

        scalarField& pLim = limiterField.primitiveFieldRef();

        forAll(pLim, face)
        {
            label own = owner[face];
            label nei = neighbour[face];

            pLim[face] = Limiter::limiter
            (
                CDweights[face],
                this->faceFlux_[face],
                lPhi[own],
                lPhi[nei],
                gradc[own],
                gradc[nei],
                C[nei] - C[own]
            );
        }

        const typename GeometricField<Type, fvPatchField, volMesh>::Boundary& bPhi = phi.boundaryField();

        surfaceScalarField::Boundary& bLim = limiterField.boundaryFieldRef();

        forAll(bLim, patchi)
        {
            scalarField& pLim = bLim[patchi];

            if (bPhi[patchi].coupled())
            {
                const scalarField& pCDweights = CDweights.boundaryField()[patchi];
                const scalarField& pFaceFlux = this->faceFlux_.boundaryField()[patchi];

                const Field<typename Limiter::phiType> plPhiP
                (
                    lPhi.boundaryField()[patchi].patchInternalField()
                );
                const Field<typename Limiter::phiType> plPhiN
                (
                    lPhi.boundaryField()[patchi].patchNeighbourField()
                );
                const Field<typename Limiter::gradPhiType> pGradcP
                (
                    gradc.boundaryField()[patchi].patchInternalField()
                );
                const Field<typename Limiter::gradPhiType> pGradcN
                (
                    gradc.boundaryField()[patchi].patchNeighbourField()
                );

                // Build the d-vectors
                vectorField pd(CDweights.boundaryField()[patchi].patch().delta());

                forAll(pLim, face)
                {
                    pLim[face] = Limiter::limiter
                    (
                        pCDweights[face],
                        pFaceFlux[face],
                        plPhiP[face],
                        plPhiN[face],
                        pGradcP[face],
                        pGradcN[face],
                        pd[face]
                    );
                }
            }
            else
            {
                pLim = 1.0;
            }
        }
    }


权重函数通过如下方式来使用limiter进行计算：


.. code-block:: C
    :caption: src/finiteVolume/interpolation/surfaceInterpolation/limitedSchemes/limitedSurfaceInterpolationScheme/limitedSurfaceInterpolationScheme.C

    template<class Type>
    Foam::tmp<Foam::surfaceScalarField>
    Foam::limitedSurfaceInterpolationScheme<Type>::weights
    (
        const GeometricField<Type, fvPatchField, volMesh>& phi,
        const surfaceScalarField& CDweights,
        tmp<surfaceScalarField> tLimiter
    ) const
    {
        // Note that here the weights field is initialised as the limiter
        // from which the weight is calculated using the limiter value
        surfaceScalarField& Weights = tLimiter.ref();

        scalarField& pWeights = Weights.primitiveFieldRef();    // 初始化weight为limiter的值

        forAll(pWeights, face)
        {
            pWeights[face] = pWeights[face]*CDweights[face] + (1.0 - pWeights[face])*pos0(faceFlux_[face]);
        }

        surfaceScalarField::Boundary& bWeights = Weights.boundaryFieldRef();

        forAll(bWeights, patchi)
        {
            scalarField& pWeights = bWeights[patchi];

            const scalarField& pCDweights = CDweights.boundaryField()[patchi];
            const scalarField& pFaceFlux = faceFlux_.boundaryField()[patchi];

            forAll(pWeights, face)
            {
                pWeights[face] = pWeights[face]*pCDweights[face] + (1.0 - pWeights[face])*pos0(pFaceFlux[face]);
            }
        }

        return tLimiter;
    }

其中CDweights是使用中性差分得到的权重，用 :math:`\lambda_{CD}` 来表示，于是权重的表达式为

.. math::
    \begin{align}
    \lambda = \left \{\begin{array}{l}
    \lambda_{CD} \psi + (1 - \psi) ,\quad \text{flux} \ge 0 \\
    \lambda_{CD} \psi ,\quad \text{flux} < 0 
    \end{array}\right .
    \end{align}

将权重表达式代入到interpolate表达式中，即可得到NVD/TVD插值的通用表达式为

.. math::
    \begin{align}
    \phi_{f} = \left \{ \begin{array}{l}
    \phi_{C} + \frac{\psi}{2}(\phi_{N} - \phi_{C}) ,\quad \text{flux} \ge 0 \\
    \phi_{N} + \frac{\psi}{2}(\phi_{C} - \phi_{N}) ,\quad \text{flux} < 0  
    \end{array} \right .
    \end{align}

其物理意义是非常明确的，第一项表示一阶迎风，即上游的体心物理量，由于一阶迎风有较大的数值粘性，第二项做出修正，该修正可以使数值粘性减小，最终达到二阶精度。通量限制器 :math:`\psi` 的要求是：当物理量变化剧烈时返回一阶迎风格式，当物理量变化平缓时返回高阶格式。于是就需要引入一个无量纲数 :math:`r` 来定量描述物理量变化是否剧烈。不同的高阶格式就是设计不同的 :math:`\psi(r)` 函数。

.. note:: upwind格式也有定义 :math:`\psi` ，只不过是均匀的0场。

上面参数 :math:`r` 的一般定义为

.. math::
    \begin{align}
    r = \frac{\phi_{C} - \phi_{\text{up}}}{\phi_{\text{down}} - \phi_{C}}
    \end{align}

其中下标C表示所考察面的上游网格单元，up表示C的上游单元，down表示C的下游单元。对于非结构网格，我们可以很容易知道C和down单元，但是很难知道up单元是哪个，所以需要用线性近似的方式得到 :math:`\phi_{\text{up}}` 的值：

.. math::
    \begin{align}
    \phi_{\text{up} } = \phi_{\text{down} } - 2d_{C-\text{down}}\cdot (\nabla \phi)_{C}
    \end{align}

其中 :math:`d` 是一个距离矢量，从C的体心指向down的体心。将上式代入 :math:`r` 的表达式则得到

.. math::
    \begin{align}
    r = \frac{2d_{C-\text{down}}\cdot (\nabla\phi)_{C}}{\phi_{\text{down} } - \phi_{C}} - 1
    \end{align}

因此，在使用OpenFOAM的网格格式来表示则为

.. math::
    \begin{align}
    r = \left \{\begin{array}{l}
    \frac{2d_{CN} \cdot (\nabla\phi)_{O}}{\phi_{C} - \phi_{N}} - 1 ,\quad \text{flux}\ge 0 \\
    \frac{2d_{CN} \cdot (\nabla\phi)_{N}}{\phi_{N} - \phi_{C}} - 1 ,\quad \text{flux} < 0 
    \end{array}\right .
    \end{align}


该函数r()的定义位于src/finiteVolume/interpolation/surfaceInterpolation/limitedSchemes/LimitedScheme/NVDTVD.H文件中：

.. code-block:: C

    scalar r
    (
        const scalar faceFlux,
        const scalar phiP,
        const scalar phiN,
        const vector& gradcP,
        const vector& gradcN,
        const vector& d
    ) const
    {
        scalar gradf = phiN - phiP;

        scalar gradcf;

        if (faceFlux > 0)
        {
            gradcf = d & gradcP;
        }
        else
        {
            gradcf = d & gradcN;
        }

        if (mag(gradcf) >= 1000*mag(gradf))
        {
            return 2*1000*sign(gradcf)*sign(gradf) - 1;
        }
        else
        {
            return 2*(gradcf/gradf) - 1;
        }
    }


Minmod
^^^^^^^^

进入src/finiteVolume/interpolation/surfaceInterpolation/limitedSchemes/Minmod/Minmod.H文件可以看到Minmod格式的限制器的定义：

.. code-block:: C

    scalar limiter
    (
        const scalar cdWeight,
        const scalar faceFlux,
        const typename LimiterFunc::phiType& phiP,
        const typename LimiterFunc::phiType& phiN,
        const typename LimiterFunc::gradPhiType& gradcP,
        const typename LimiterFunc::gradPhiType& gradcN,
        const vector& d
    ) const
    {
        scalar r = LimiterFunc::r
        (
            faceFlux, phiP, phiN, gradcP, gradcN, d
        );

        return max(min(r, 1), 0);
    }


vanLeer
^^^^^^^^^^

进入src/finiteVolume/interpolation/surfaceInterpolation/limitedSchemes/vanLeer/vanLeer.H文件可以看到vanLeer格式的限制器的定义：

.. code-block:: C

    scalar limiter
    (
        const scalar,
        const scalar faceFlux,
        const typename LimiterFunc::phiType& phiP,
        const typename LimiterFunc::phiType& phiN,
        const typename LimiterFunc::gradPhiType& gradcP,
        const typename LimiterFunc::gradPhiType& gradcN,
        const vector& d
    ) const
    {
        scalar r = LimiterFunc::r
        (
            faceFlux, phiP, phiN, gradcP, gradcN, d
        );

        return (r + mag(r))/(1 + mag(r));
    }


MUSCL
^^^^^^^^

进入src/finiteVolume/interpolation/surfaceInterpolation/limitedSchemes/MUSCL/MUSCL.H文件可以看到MUSCL格式的限制器的定义：

.. code-block:: C

    scalar limiter
    (
        const scalar cdWeight,
        const scalar faceFlux,
        const typename LimiterFunc::phiType& phiP,
        const typename LimiterFunc::phiType& phiN,
        const typename LimiterFunc::gradPhiType& gradcP,
        const typename LimiterFunc::gradPhiType& gradcN,
        const vector& d
    ) const
    {
        scalar r = LimiterFunc::r
        (
            faceFlux, phiP, phiN, gradcP, gradcN, d
        );

        return max(min(min(2*r, 0.5*r + 0.5), 2), 0);
    }



OSPRE
^^^^^^^

进入src/finiteVolume/interpolation/surfaceInterpolation/limitedSchemes/OSPRE/OSPRE.H文件可以看到OSPRE格式的限制器的定义：

.. code-block:: C

    scalar limiter
    (
        const scalar cdWeight,
        const scalar faceFlux,
        const typename LimiterFunc::phiType& phiP,
        const typename LimiterFunc::phiType& phiN,
        const typename LimiterFunc::gradPhiType& gradcP,
        const typename LimiterFunc::gradPhiType& gradcN,
        const vector& d
    ) const
    {
        const scalar r = max
        (
            LimiterFunc::r(faceFlux, phiP, phiN, gradcP, gradcN, d), 0
        );

        const scalar rrp1 = r*(r + 1);

        return 1.5*rrp1/(rrp1 + 1);
    }


QUICK
^^^^^^^

进入src/finiteVolume/interpolation/surfaceInterpolation/limitedSchemes/QUICK/QUICK.H文件可以看到MUSCL格式的限制器的定义，值得注意的是QUICK格式没有使用r来定义自己的limiter，而是从头开始定义：

.. code-block:: C

    scalar limiter
    (
        const scalar cdWeight,
        const scalar faceFlux,
        const typename LimiterFunc::phiType& phiP,
        const typename LimiterFunc::phiType& phiN,
        const typename LimiterFunc::gradPhiType& gradcP,
        const typename LimiterFunc::gradPhiType& gradcN,
        const vector& d
    ) const
    {
        scalar phiCD = cdWeight*phiP + (1 - cdWeight)*phiN;

        scalar phiU, phif;

        if (faceFlux > 0)
        {
            phiU = phiP;
            phif = 0.5*(phiCD + phiP + (1 - cdWeight)*(d & gradcP));
        }
        else
        {
            phiU = phiN;
            phif = 0.5*(phiCD + phiN - cdWeight*(d & gradcN));
        }

        // Calculate the effective limiter for the QUICK interpolation
        scalar QLimiter = (phif - phiU)/stabilise(phiCD - phiU, small);

        // Limit the limiter between upwind and downwind
        return max(min(QLimiter, 2), 0);
    }



UMIST
^^^^^^^

进入src/finiteVolume/interpolation/surfaceInterpolation/limitedSchemes/UMIST/UMIST.H文件可以看到OSPRE格式的限制器的定义：

.. code-block:: C

    scalar limiter
    (
        const scalar cdWeight,
        const scalar faceFlux,
        const typename LimiterFunc::phiType& phiP,
        const typename LimiterFunc::phiType& phiN,
        const typename LimiterFunc::gradPhiType& gradcP,
        const typename LimiterFunc::gradPhiType& gradcN,
        const vector& d
    ) const
    {
        scalar r = LimiterFunc::r
        (
            faceFlux, phiP, phiN, gradcP, gradcN, d
        );

        return max(min(min(min(2*r, 0.75*r + 0.25), 0.25*r + 0.75), 2), 0);
    }



面法向梯度格式snGradSchemes
-------------------------------

面法向梯度指的是变量场梯度在面 :math:`f` 处的法向分量，一般需要在单独计算面法向梯度 :math:`\nabla_{f}\cdot \mathbf{A}_{f}` 或者指定拉普拉斯项 :math:`\nabla^{2}\cdot` 离散格式时指定面法向梯度格式。支持的标准格式有：

+----------------+--------------------------+
| 面法向梯度格式 | 含义                     |
+================+==========================+
| corrected      | 显示非正交修正格式       |
+----------------+--------------------------+
| uncorrected    | 无非正交修正格式         |
+----------------+--------------------------+
| limited        | 非完全正交修正格式       |
+----------------+--------------------------+
| bounded        | 对正值标量的有界修正格式 |
+----------------+--------------------------+
| fourth         | 四阶格式                 |
+----------------+--------------------------+


特别地，非完全正交修正格式limited需要指定系数 :math:`\psi` ，其值介于0和1之间：

- 取值为0时，无非正交修正；
- 取值为0.333时，限制非正交修正部分不超过正交部分的一半；
- 取值为0.5时，限制非正交修正部分不超过正交部分；
- 取值为1时，不限制非正交修正部分，等同于corrected格式。


下面是一些具体的设置案例：

.. code-block:: C

    default         corrected;








时间一阶导项格式ddtSchemes
----------------------------

时间一阶导项 :math:`\frac{\partial}{\partial t}` 格式支持的标准格式有：



+------------------+----------------------------------+
| 时间一阶导项格式 | 含义                             |
+==================+==================================+
| backward         | 二阶向后差分格式(BDS2)，隐式     |
+------------------+----------------------------------+
| bounded          |                                  |
+------------------+----------------------------------+
| CoEuler          | 一阶，可控制局部库朗数           |
+------------------+----------------------------------+
| CrankNicolson    | 二阶精度，有界，隐式             |
+------------------+----------------------------------+
| Euler            | 一阶精度，有界，隐式             |
+------------------+----------------------------------+
| localEuler       | 局部时间步，一阶精度，有界，隐式 |
+------------------+----------------------------------+
| SLTS             | 稳定局部时间步一阶欧拉隐式/显式  |
+------------------+----------------------------------+
| steadyState      | 定常，忽略时间导数项             |
+------------------+----------------------------------+


backward
^^^^^^^^^^

该格式使用当前和前两个时间步长来得到二阶时间精度。进入src/finiteVolume/finiteVolume/ddtSchemes/backwardDdtScheme/backwardDdtScheme.C文件可以看到

.. code-block:: C

    template<class Type>
    tmp<GeometricField<Type, fvPatchField, volMesh>>
    backwardDdtScheme<Type>::fvcDdt    // fvc::ddt(phi)的类型
    (
        const GeometricField<Type, fvPatchField, volMesh>& vf
    )
    {
        const dimensionedScalar rDeltaT = 1.0/mesh().time().deltaT();

        const word ddtName("ddt("+vf.name()+')');

        const scalar deltaT = deltaT_();
        const scalar deltaT0 = deltaT0_(vf);

        const scalar coefft   = 1 + deltaT/(deltaT + deltaT0);
        const scalar coefft00 = deltaT*deltaT/(deltaT0*(deltaT + deltaT0));
        const scalar coefft0  = coefft + coefft00;

        if (mesh().moving())
        {
            return tmp<GeometricField<Type, fvPatchField, volMesh>>
            (
                GeometricField<Type, fvPatchField, volMesh>::New
                (
                    ddtName,
                    rDeltaT*
                    (
                        coefft*vf() -
                        (
                            coefft0*vf.oldTime()()*mesh().V0()
                          - coefft00*vf.oldTime().oldTime()()
                           *mesh().V00()
                        )/mesh().V()
                    ),
                    rDeltaT.value()*
                    (
                        coefft*vf.boundaryField() -
                        (
                            coefft0*vf.oldTime().boundaryField()
                          - coefft00*vf.oldTime().oldTime().boundaryField()
                        )
                    )
                )
            );
        }
        else
        {
            return tmp<GeometricField<Type, fvPatchField, volMesh>>
            (
                GeometricField<Type, fvPatchField, volMesh>::New
                (
                    ddtName,
                    rDeltaT*
                    (
                        coefft*vf
                      - coefft0*vf.oldTime()
                      + coefft00*vf.oldTime().oldTime()
                    )
                )
            );
        }
    }

从上面的代码可以看到，对于静网格的情况，计算方式为

.. math::
    \begin{align}
    \frac{\partial \phi}{\partial t} =
    \frac{1}{\Delta t}\Big( A\phi - B\phi_{\text{old}} + C\phi_{\text{oldold}} \Big)
    \end{align}

对于动网格的情况，计算方式为

.. math::
    \begin{align}
    \frac{\partial \phi}{\partial t} =
    \frac{1}{\Delta t}\Big( A\phi - \frac{1}{V} (B\phi_{\text{old}}V_{\text{old}} - C\phi_{\text{oldold}}V_{\text{oldold}}) \Big)
    \end{align}

其中各系数的计算方式为

.. math::
    \begin{align}
    & A = 1 + \frac{\Delta t}{\Delta t + \Delta t_{\text{old}}} \\
    & B = A + C = 1 + \frac{\Delta t}{\Delta t + \Delta t_{\text{old}}} + \frac{\Delta t^{2}}{\Delta t_{\text{old}} \cdot (\Delta t + \Delta t_{\text{old}})} \\
    & C = \frac{\Delta t^{2}}{\Delta t_{\text{old}} \cdot (\Delta t + \Delta t_{\text{old}})}
    \end{align}


.. note:: 

    对于恒定时间步长的情况就化简为了经典backward(SOU)格式：

    .. math::
        \begin{align}
        \frac{\partial \phi}{\partial t} = \frac{3\phi - 4\phi_{\text{old}} + \phi_{\text{oldold}}}{2\Delta t}  
        \end{align}




.. code-block:: C

    template<class Type>
    tmp<fvMatrix<Type>>
    backwardDdtScheme<Type>::fvmDdt
    (
        const GeometricField<Type, fvPatchField, volMesh>& vf
    )
    {
        tmp<fvMatrix<Type>> tfvm
        (
            new fvMatrix<Type>
            (
                vf,
                vf.dimensions()*dimVol/dimTime
            )
        );

        fvMatrix<Type>& fvm = tfvm.ref();

        const scalar rDeltaT = 1.0/deltaT_();

        const scalar deltaT = deltaT_();
        const scalar deltaT0 = deltaT0_(vf);

        const scalar coefft   = 1 + deltaT/(deltaT + deltaT0);
        const scalar coefft00 = deltaT*deltaT/(deltaT0*(deltaT + deltaT0));
        const scalar coefft0  = coefft + coefft00;

        fvm.diag() = (coefft*rDeltaT)*mesh().V();

        if (mesh().moving())
        {
            fvm.source() = rDeltaT*
            (
                coefft0*vf.oldTime().primitiveField()*mesh().V0()
              - coefft00*vf.oldTime().oldTime().primitiveField()
               *mesh().V00()
            );
        }
        else
        {
            fvm.source() = rDeltaT*mesh().V()*
            (
                coefft0*vf.oldTime().primitiveField()
              - coefft00*vf.oldTime().oldTime().primitiveField()
            );
        }

        return tfvm;
    }

当使用隐式backward离散格式时，得到的系数矩阵对角项为

.. math::
    \begin{align}
    \operatorname{diag}(\mathbf{A}) = A\frac{V}{\Delta t}
    \end{align}

对于静网格的情况，得到的源项为

.. math::
    \begin{align}
    b = \frac{V}{\Delta t}\Big(B\phi_{\text{old}} - C\phi_{\text{oldold}}\Big) 
    \end{align}

对于动网格的情况，得到的源项为

.. math::
    \begin{align}
    b = \frac{1}{\Delta t}\Big( B\phi_{\text{old}}V_{\text{old}} - C\phi_{\text{oldold}}V_{\text{oldold}} \Big) 
    \end{align}

其中各系数的计算方式为

.. math::
    \begin{align}
    & A = 1 + \frac{\Delta t}{\Delta t + \Delta t_{\text{old}}} \\
    & B = A + C = 1 + \frac{\Delta t}{\Delta t + \Delta t_{\text{old}}} + \frac{\Delta t^{2}}{\Delta t_{\text{old}} \cdot (\Delta t + \Delta t_{\text{old}})} \\
    & C = \frac{\Delta t^{2}}{\Delta t_{\text{old}} \cdot (\Delta t + \Delta t_{\text{old}})}
    \end{align}





CrankNicolson
^^^^^^^^^^^^^^^^

二阶CrankNicolson格式使用当前时间步长、前一次时间步长以及前一次时间步的ddt。对于复杂几何中的复杂流动，CrankNicolson格式通常是不稳定的，因此有必要在保持比一阶Euler隐式格式更大时间精度的同时，将该格式偏离中心(off-center)以使其稳定。偏离中心是通过额外设置的强制系数ocCoeff来实现的，它的取值范围为 :math:`[0,1]` ，或者也可以使用ramp函数，在初始阶段从Euler格式过渡到CrankNicolson格式，以避免启动问题。

当强制系数为1时，该格式是完全中心的二阶格式；当系数为0时，该格式等效于欧拉隐式格式。系数取0.9时适用于需要更高阶时间精度的一系列情况，并提供与backward格式相似的精度和稳定性。不过，backward更具有鲁棒性且在时间上提供了正式的二阶精度。

与backward格式相比，CrankNicolson格式的优点是只需要新的和旧的时间值，与通量和源有关的附加项在时间步长的中点进行计算，这提供了限制通量的机会，以确保有界性，同时与Euler隐式格式相比保持更高的时间精度。而backward格式不能保证有界性。

进入src/finiteVolume/finiteVolume/ddtSchemes/CrankNicolsonDdtScheme/CrankNicolsonDdtScheme.C文件可以看到

.. code-block:: C

    template<class Type>
    tmp<GeometricField<Type, fvPatchField, volMesh>>
    CrankNicolsonDdtScheme<Type>::fvcDdt
    (
        const GeometricField<Type, fvPatchField, volMesh>& vf
    )
    {
        DDt0Field<GeometricField<Type, fvPatchField, volMesh>>& ddt0 =
            ddt0_<GeometricField<Type, fvPatchField, volMesh>>
            (
                "ddt0(" + vf.name() + ')',
                vf.dimensions()
            );

        const word ddtName("ddt(" + vf.name() + ')');

        dimensionedScalar rDtCoef = rDtCoef_(ddt0);

        if (mesh().moving())
        {
            if (evaluate(ddt0))
            {
                const scalar rDtCoef0 = rDtCoef0_(ddt0).value();

                ddt0.primitiveFieldRef() =
                (
                    rDtCoef0*
                    (
                        mesh().V0()*vf.oldTime().primitiveField()
                      - mesh().V00()*vf.oldTime().oldTime().primitiveField()
                    ) - mesh().V00()*offCentre_(ddt0.primitiveField())
                )/mesh().V0();

                ddt0.boundaryFieldRef() =
                (
                    rDtCoef0*
                    (
                        vf.oldTime().boundaryField()
                      - vf.oldTime().oldTime().boundaryField()
                    ) - offCentre_(ff(ddt0.boundaryField()))
                );
            }

            return GeometricField<Type, fvPatchField, volMesh>::New
            (
                ddtName,
                (
                    rDtCoef*
                    (
                        mesh().V()*vf
                      - mesh().V0()*vf.oldTime()
                    ) - mesh().V0()*offCentre_(ddt0()())
                )/mesh().V(),
                rDtCoef.value()*
                (
                    vf.boundaryField() - vf.oldTime().boundaryField()
                ) - offCentre_(ff(ddt0.boundaryField()))
            );
        }
        else
        {
            if (evaluate(ddt0))
            {
                ddt0 = rDtCoef0_(ddt0)*(vf.oldTime() - vf.oldTime().oldTime())
                     - offCentre_(ddt0());
            }

            return GeometricField<Type, fvPatchField, volMesh>::New
            (
                ddtName,
                rDtCoef*(vf - vf.oldTime()) - offCentre_(ddt0())
            );
        }
    }

对于静网格的情况，计算方式为

.. math::
    \begin{align}
    \frac{\partial \phi}{\partial t} =
    (1 + \text{ocCoeff})\frac{\phi - \phi_{\text{old}}}{\Delta t}
    - \text{ocCoeff}\times \Big(\frac{\partial \phi}{\partial t} \Big)_{\text{old}}  
    \end{align}


.. attention:: 
    
    - 可以看到，在OpenFOAM中实现的方式与原始的CrankNicolson格式定义有所不同，详细讨论参考 `Crank Nicolson scheme implemented wrong? <https://www.cfd-online.com/Forums/openfoam-programming-development/226125-crank-nicolson-scheme-implemented-wrong.html>`_ 
    - 由于需要读取两个时间步之前的数据，所以在只有0时间步场数据的情况下使用该格式时将会报错。因此，在初次计算时不应该使用该格式，而应该在用Euler格式计算出一定数据后再使用该格式。



.. code-block:: C

    template<class Type>
    tmp<fvMatrix<Type>>
    CrankNicolsonDdtScheme<Type>::fvmDdt
    (
        const GeometricField<Type, fvPatchField, volMesh>& vf
    )
    {
        DDt0Field<GeometricField<Type, fvPatchField, volMesh>>& ddt0 =
            ddt0_<GeometricField<Type, fvPatchField, volMesh>>
            (
                "ddt0(" + vf.name() + ')',
                vf.dimensions()
            );

        tmp<fvMatrix<Type>> tfvm
        (
            new fvMatrix<Type>
            (
                vf,
                vf.dimensions()*dimVol/dimTime
            )
        );

        fvMatrix<Type>& fvm = tfvm.ref();

        const scalar rDtCoef = rDtCoef_(ddt0).value();
        fvm.diag() = rDtCoef*mesh().V();

        vf.oldTime().oldTime();

        if (mesh().moving())
        {
            if (evaluate(ddt0))
            {
                const scalar rDtCoef0 = rDtCoef0_(ddt0).value();

                ddt0.primitiveFieldRef() =
                (
                    rDtCoef0*
                    (
                        mesh().V0()*vf.oldTime().primitiveField()
                      - mesh().V00()*vf.oldTime().oldTime().primitiveField()
                    )
                  - mesh().V00()*offCentre_(ddt0.primitiveField())
                )/mesh().V0();

                ddt0.boundaryFieldRef() =
                (
                    rDtCoef0*
                    (
                        vf.oldTime().boundaryField()
                      - vf.oldTime().oldTime().boundaryField()
                    )
                  - offCentre_(ff(ddt0.boundaryField()))
                );
            }

            fvm.source() =
            (
                rDtCoef*vf.oldTime().primitiveField()
              + offCentre_(ddt0.primitiveField())
            )*mesh().V0();
        }
        else
        {
            if (evaluate(ddt0))
            {
                ddt0 = rDtCoef0_(ddt0)*(vf.oldTime() - vf.oldTime().oldTime())
                     - offCentre_(ddt0());
            }

            fvm.source() =
            (
                rDtCoef*vf.oldTime().primitiveField()
              + offCentre_(ddt0.primitiveField())
            )*mesh().V();
        }

        return tfvm;
    }




Euler
^^^^^^^

进入src/finiteVolume/finiteVolume/ddtSchemes/EulerDdtScheme/EulerDdtScheme.C文件可以看到如下代码：

.. code-block:: C

    template<class Type>
    tmp<GeometricField<Type, fvPatchField, volMesh>>
    EulerDdtScheme<Type>::fvcDdt    // 显式离散
    (
        const GeometricField<Type, fvPatchField, volMesh>& vf    // fvc::ddt(phi)的类型
    )
    {
        const dimensionedScalar rDeltaT = 1.0/mesh().time().deltaT();

        const word ddtName("ddt("+vf.name()+')');

        if (mesh().moving())    // 动网格的情形
        {
            return GeometricField<Type, fvPatchField, volMesh>::New
            (
                ddtName,
                rDeltaT*
                (
                    vf()
                  - vf.oldTime()()*mesh().Vsc0()/mesh().Vsc()
                ),
                rDeltaT.value()*
                (
                    vf.boundaryField() - vf.oldTime().boundaryField()
                )
            );
        }
        else    // 静网格的情形
        {
            return GeometricField<Type, fvPatchField, volMesh>::New
            (
                ddtName,
                rDeltaT*(vf - vf.oldTime())
            );
        }
    }

可以看到，对于Euler格式，当网格属于静网格时，计算方式为

.. math::
    \begin{align}
    \frac{\partial \phi}{\partial t} = \frac{\phi - \phi_{\text{old}}}{\Delta t}  
    \end{align}

当网格属于动网格时，计算方式为

.. math::
    \begin{align}
    \frac{\partial \phi}{\partial t} = \frac{1}{\Delta t}\Big( \phi - \phi_{\text{old}}\frac{V_{\text{sc}_{\text{old}}}}{V_{\text{sc}}} \Big)  
    \end{align}

.. code-block:: C

    template<class Type>
    tmp<fvMatrix<Type>>
    EulerDdtScheme<Type>::fvmDdt    // 隐式离散
    (
        const GeometricField<Type, fvPatchField, volMesh>& vf    // fvm::ddt(phi)的类型
    )
    {
        tmp<fvMatrix<Type>> tfvm
        (
            new fvMatrix<Type>
            (
                vf,
                vf.dimensions()*dimVol/dimTime
            )
        );

        fvMatrix<Type>& fvm = tfvm.ref();

        const scalar rDeltaT = 1.0/mesh().time().deltaTValue();

        fvm.diag() = rDeltaT*mesh().Vsc();

        if (mesh().moving())
        {
            fvm.source() = rDeltaT*vf.oldTime().primitiveField()*mesh().Vsc0();
        }
        else
        {
            fvm.source() = rDeltaT*vf.oldTime().primitiveField()*mesh().Vsc();
        }

        return tfvm;
    }

当使用隐式Euler离散格式的时候，其产生的系数矩阵对角项为

.. math::
    \begin{align}
    \operatorname{diag}(\mathbf{A}) = \frac{V_{\text{sc}}}{\Delta t}
    \end{align}

当网格为静网格时，产生的源项为

.. math::
    \begin{align}
    b = \frac{1}{\Delta t}\phi_{\text{old}}V_{\text{sc}}
    \end{align}

当网格为动网格时，产生的源项为

.. math::
    \begin{align}
    b = \frac{1}{\Delta t}\phi_{\text{old}}V_{\text{sc}_{\text{old}}}
    \end{align}




SLTS
^^^^^^^

全称为Stabilised local time-step first-order Euler scheme。能够局部调整时间步长，使对流方程保持对角占优。该格式只能用于使用瞬态代码计算稳态问题的情况，其中由于传输一致性的原因，局部时间步长最好设置为欠松弛状态。

进入src/finiteVolume/finiteVolume/ddtSchemes/SLTSDdtScheme/SLTSDdtScheme.C文件，可以看到


.. code-block:: C

    template<class Type>
    void SLTSDdtScheme<Type>::relaxedDiag
    (
        scalarField& rD,
        const surfaceScalarField& phi
    ) const
    {
        const labelUList& owner = mesh().owner();
        const labelUList& neighbour = mesh().neighbour();
        scalarField diag(rD.size(), 0.0);

        forAll(owner, facei)
        {
            if (phi[facei] > 0.0)
            {
                diag[owner[facei]] += phi[facei];
                rD[neighbour[facei]] += phi[facei];
            }
            else
            {
                diag[neighbour[facei]] -= phi[facei];
                rD[owner[facei]] -= phi[facei];
            }
        }

        forAll(phi.boundaryField(), patchi)
        {
            const fvsPatchScalarField& pphi = phi.boundaryField()[patchi];
            const labelUList& faceCells = pphi.patch().patch().faceCells();

            forAll(pphi, patchFacei)
            {
                if (pphi[patchFacei] > 0.0)
                {
                    diag[faceCells[patchFacei]] += pphi[patchFacei];
                }
                else
                {
                    rD[faceCells[patchFacei]] -= pphi[patchFacei];
                }
            }
        }

        rD += (1.0/alpha_ - 2.0)*diag;
    }



steadyState
^^^^^^^^^^^^^^

.. code-block:: C

    template<class Type>
    tmp<GeometricField<Type, fvPatchField, volMesh>>
    steadyStateDdtScheme<Type>::fvcDdt
    (
        const dimensionedScalar& rho,
        const GeometricField<Type, fvPatchField, volMesh>& vf
    )
    {
        return GeometricField<Type, fvPatchField, volMesh>::New
        (
            "ddt("+rho.name()+','+vf.name()+')',
            mesh(),
            dimensioned<Type>
            (
                "0",
                rho.dimensions()*vf.dimensions()/dimTime,
                Zero
            )
        );
    }


.. code-block:: C

    template<class Type>
    tmp<fvMatrix<Type>>
    steadyStateDdtScheme<Type>::fvmDdt
    (
        const GeometricField<Type, fvPatchField, volMesh>& vf
    )
    {
        return tmp<fvMatrix<Type>>
        (
            new fvMatrix<Type>
            (
                vf,
                vf.dimensions()*dimVol/dimTime
            )
        );
    }













时间二阶导项格式d2dt2Schemes
-------------------------------

时间二阶导项 :math:`\frac{\partial^{2}}{\partial t^{2}}` 格式只支持Euler格式或steadyState格式。对于Euler格式，进入src/finiteVolume/finiteVolume/d2dt2Schemes/EulerD2dt2Scheme/EulerD2dt2Scheme.C文件，可以看到

.. code-block:: C

    template<class Type>
    tmp<GeometricField<Type, fvPatchField, volMesh>>
    EulerD2dt2Scheme<Type>::fvcD2dt2
    (
        const GeometricField<Type, fvPatchField, volMesh>& vf
    )
    {
        const dimensionedScalar rDeltaT2
        (
            4.0/sqr(mesh().time().deltaT() + mesh().time().deltaT0())
        );

        const word d2dt2name("d2dt2("+vf.name()+')');

        const scalar deltaT = mesh().time().deltaTValue();
        const scalar deltaT0 = mesh().time().deltaT0Value();

        const scalar coefft   = (deltaT + deltaT0)/(2*deltaT);
        const scalar coefft00 = (deltaT + deltaT0)/(2*deltaT0);
        const scalar coefft0  = coefft + coefft00;

        if (mesh().moving())
        {
            const dimensionedScalar halfRdeltaT2(rDeltaT2/2.0);

            const volScalarField::Internal VV0(mesh().V() + mesh().V0());
            const volScalarField::Internal V0V00(mesh().V0() + mesh().V00());

            return GeometricField<Type, fvPatchField, volMesh>::New
            (
                d2dt2name,
                halfRdeltaT2*
                (
                    coefft*VV0*vf()

                  - (coefft*VV0 + coefft00*V0V00)
                   *vf.oldTime()()

                  + (coefft00*V0V00)*vf.oldTime().oldTime()()
                )/mesh().V(),
                rDeltaT2.value()*
                (
                    coefft*vf.boundaryField()
                  - coefft0*vf.oldTime().boundaryField()
                  + coefft00*vf.oldTime().oldTime().boundaryField()
                )
            );
        }
        else
        {
            return GeometricField<Type, fvPatchField, volMesh>::New
            (
                d2dt2name,
                rDeltaT2*
                (
                    coefft*vf
                  - coefft0*vf.oldTime()
                  + coefft00*vf.oldTime().oldTime()
                )
            );
        }
    }


.. code-block:: C

    template<class Type>
    tmp<fvMatrix<Type>>
    EulerD2dt2Scheme<Type>::fvmD2dt2
    (
        const GeometricField<Type, fvPatchField, volMesh>& vf
    )
    {
        tmp<fvMatrix<Type>> tfvm
        (
            new fvMatrix<Type>
            (
                vf,
                vf.dimensions()*dimVol/dimTime/dimTime
            )
        );

        fvMatrix<Type>& fvm = tfvm.ref();

        const scalar deltaT = mesh().time().deltaTValue();
        const scalar deltaT0 = mesh().time().deltaT0Value();

        const scalar coefft   = (deltaT + deltaT0)/(2*deltaT);
        const scalar coefft00 = (deltaT + deltaT0)/(2*deltaT0);
        const scalar coefft0  = coefft + coefft00;

        const scalar rDeltaT2 = 4.0/sqr(deltaT + deltaT0);

        if (mesh().moving())
        {
            const scalar halfRdeltaT2 = rDeltaT2/2.0;

            const scalarField VV0(mesh().V() + mesh().V0());
            const scalarField V0V00(mesh().V0() + mesh().V00());

            fvm.diag() = (coefft*halfRdeltaT2)*VV0;

            fvm.source() = halfRdeltaT2*
            (
                (coefft*VV0 + coefft00*V0V00)
               *vf.oldTime().primitiveField()

              - (coefft00*V0V00)*vf.oldTime().oldTime().primitiveField()
            );
        }
        else
        {
            fvm.diag() = (coefft*rDeltaT2)*mesh().V();

            fvm.source() = rDeltaT2*mesh().V()*
            (
                coefft0*vf.oldTime().primitiveField()
              - coefft00*vf.oldTime().oldTime().primitiveField()
            );
        }

        return tfvm;
    }






梯度项格式gradSchemes
------------------------

梯度项 :math:`\nabla` 格式支持的标准格式有：


+-----------------------------+-------------------------------------------------------+
| 梯度项格式                  | 含义                                                  |
+=============================+=======================================================+
| Gauss <interpolationScheme> | 高斯积分，<interpolationScheme>设置插值格式，二阶精度 |
+-----------------------------+-------------------------------------------------------+
| leastSquares                | 最小二乘法，二阶精度                                  |
+-----------------------------+-------------------------------------------------------+
| fourth                      | 最小二乘法，四阶精度                                  |
+-----------------------------+-------------------------------------------------------+
| cellLimited <gradScheme>    | 上述格式的体单元有界版本                              |
+-----------------------------+-------------------------------------------------------+
| faceLimited <gradScheme>    | 上述格式的面单元有界版本                              |
+-----------------------------+-------------------------------------------------------+


下面是一些具体的设置案例：

.. code-block:: C

    default         Gauss linear;





散度项格式divSchemes
-----------------------

参考 `Divergence schemes <https://www.openfoam.com/documentation/guides/latest/doc/guide-schemes-divergence.html>`_ 

此项一般只出现在涉及流体流动的数值模拟中，例如标量形式的 :math:`\nabla\cdot(\rho \mathbf{U}T)` 和矢量形式的 :math:`\nabla\cdot(\rho \mathbf{U}\mathbf{U})` 。以动量方程中的对流项 :math:`\nabla\cdot(\rho \mathbf{U}\mathbf{U})` 为例，基于有限体积积分有

.. math::
    \begin{align}
    \int_{V}\nabla\cdot(\rho\mathbf{U}\mathbf{U})~\mathrm{d}V=\int_{\mathbf{A}_{f}}\rho\mathbf{U}\mathbf{U}\cdot \mathrm{d}\mathbf{A}_{f}=\sum \rho_{f}\mathbf{U}_{f}\mathbf{U}_{f}\cdot \mathbf{A}_{f}=\sum \phi_{f}\mathbf{U}_{f} 
    \end{align}

其中 :math:`\phi_{f}` 表示面 :math:`f` 处的质量通量，即 :math:`\rho_{f}\mathbf{U}_{f}\cdot\mathbf{A}_{f}` ，也因此在OpenFOAM中表示为 :code:`div(phi, U)` 。

散度项格式一般为下面的格式：

.. code-block:: C

    Gauss <interpolationScheme>


为线性化此非线性项，在对对流项进行离散的过程中， :math:`\phi_{f}` 是作为已知量参与计算的，一般使用上一时间步的速度场 :math:`\mathbf{U}^{n}` 计算得到，即

.. math::
    \begin{align}
    \sum\rho_{f}\mathbf{U}_{f}\mathbf{U}_{f}\cdot\mathbf{A}_{f}=\sum\rho_{f}^{n}\mathbf{U}_{f}^{n+1}\mathbf{U}_{f}^{n}\cdot\mathbf{A}_{f}=\sum\phi_{f}^{n}\mathbf{U}_{f}^{n+1}
    \end{align}

其中 :math:`\phi_{f}^{n}` 的数值通过Rhie-Chow动量插值计算得到。因此，这里的插值格式<interpolationScheme>只针对上式中的 :math:`\mathbf{U}_{f}^{n+1}` 。

对于 :math:`\nabla \cdot \phi` 的情况，进入src/finiteVolume/finiteVolume/divSchemes/gaussDivScheme/GaussDivScheme.C文件可以看到基于Gauss积分理论的散度计算实现方式：

.. code-block:: C

    template<class Type>
    tmp
    <
        GeometricField
        <typename innerProduct<vector, Type>::type, fvPatchField, volMesh>
    >
    gaussDivScheme<Type>::fvcDiv    // 散度的显式离散
    (
        const GeometricField<Type, fvPatchField, volMesh>& vf
    )
    {
        tmp
        <
            GeometricField
            <typename innerProduct<vector, Type>::type, fvPatchField, volMesh>
        > tDiv
        (
            fvc::surfaceIntegrate
            (
                this->tinterpScheme_().dotInterpolate(this->mesh_.Sf(), vf)
            )
        );

        tDiv.ref().rename("div(" + vf.name() + ')');

        return tDiv;
    }


对于 :math:`\nabla \cdot (\phi\mathbf{U})` 的情况，进入src/finiteVolume/finiteVolume/convectionSchemes/gaussConvectionScheme/gaussConvectionScheme.C文件可以看到：


.. code-block:: C

    template<class Type>
    tmp<GeometricField<Type, fvPatchField, volMesh>>
    gaussConvectionScheme<Type>::fvcDiv    // 散度的显式离散
    (
        const surfaceScalarField& faceFlux,
        const GeometricField<Type, fvPatchField, volMesh>& vf
    ) const
    {
        tmp<GeometricField<Type, fvPatchField, volMesh>> tConvection
        (
            fvc::surfaceIntegrate(flux(faceFlux, vf))
        );

        tConvection.ref().rename
        (
            "convection(" + faceFlux.name() + ',' + vf.name() + ')'
        );

        return tConvection;
    }


.. code-block:: C

    template<class Type>
    tmp<fvMatrix<Type>>
    gaussConvectionScheme<Type>::fvmDiv    // 散度的隐式离散
    (
        const surfaceScalarField& faceFlux,
        const GeometricField<Type, fvPatchField, volMesh>& vf
    ) const
    {
        tmp<surfaceScalarField> tweights = tinterpScheme_().weights(vf);
        const surfaceScalarField& weights = tweights();

        tmp<fvMatrix<Type>> tfvm
        (
            new fvMatrix<Type>
            (
                vf,
                faceFlux.dimensions()*vf.dimensions()
            )
        );
        fvMatrix<Type>& fvm = tfvm.ref();

        fvm.lower() = -weights.primitiveField()*faceFlux.primitiveField();
        fvm.upper() = fvm.lower() + faceFlux.primitiveField();
        fvm.negSumDiag();

        forAll(vf.boundaryField(), patchi)
        {
            const fvPatchField<Type>& psf = vf.boundaryField()[patchi];
            const fvsPatchScalarField& patchFlux = faceFlux.boundaryField()[patchi];
            const fvsPatchScalarField& pw = weights.boundaryField()[patchi];

            fvm.internalCoeffs()[patchi] = patchFlux*psf.valueInternalCoeffs(pw);
            fvm.boundaryCoeffs()[patchi] = -patchFlux*psf.valueBoundaryCoeffs(pw);
        }

        if (tinterpScheme_().corrected())
        {
            fvm += fvc::surfaceIntegrate(faceFlux*tinterpScheme_().correction(vf));
        }

        return tfvm;
    }







+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| 散度项格式                                      | 数学特性                                                                                                                                                                                                                                                         |
+=================================================+==================================================================================================================================================================================================================================================================+
| Gauss limitedLinear <coeff>                     | 一阶或二阶，无界                                                                                                                                                                                                                                                 |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss linear                                    | 二阶，无界，低耗散(适合于LES)，用于各项同性网格                                                                                                                                                                                                                  |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss linearUpwind grad(U)                      | 二阶，无界，采用迎风插值权重并基于局部单元梯度进行显式修正                                                                                                                                                                                                       |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss midPoint                                  | 一阶或二阶，无界，应用于各向同性网格时等价于linear，使用表面通量计算                                                                                                                                                                                             |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss Minmod                                    | 一阶，无界，最小模量                                                                                                                                                                                                                                             |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss MUSCL                                     | 二阶，无界，守恒定律的单调上游中心格式                                                                                                                                                                                                                           |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss QUICK                                     | 二阶，无界，对流运动学的二次上游插值                                                                                                                                                                                                                             |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss UMIST                                     | 二阶，无界，标量传输的上游单调插值                                                                                                                                                                                                                               |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss upwind                                    | 一阶，有界，根据上游值设置面值，相当于假设单元值是各向同性的且其值代表平均值                                                                                                                                                                                     |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss vanLeer                                   | 二阶，无界                                                                                                                                                                                                                                                       |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss CoBlended <co1> <scheme1> <co2> <scheme2> | 基于表面库朗数混合两种格式：当Co小于<co1>时采用<scheme1>，当Co大于<co2>时采用<scheme2>，当<co1>小于Co小于<co2>时线性混合<scheme1>和<scheme2>                                                                                                                     |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss DEShybrid <many coeff>                    | 基于局部属性混合两种格式                                                                                                                                                                                                                                         |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss filteredLinear2 <k> <l>                   | 二阶，无界，试图限制linear格式的无界性。<k>是缩放校正应用的比率，取0时为线性，取1时为完全限制；<l>是相对于difference across the face的最大允许overshoot/undershoot，取0时为没有overshoot/undershoot，取1时为overshoot/undershoot与difference across the face相等 |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss LUST <grad-scheme>                        | 无界，线性迎风稳定输送，固定使用linearUpwind权重0.25，linear权重0.75                                                                                                                                                                                             |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+





对于某些流动情况，有几种对流方案可供选择：稳态，有界标量传输和有限方案。对于稳态情况，可以应用有界形式：

.. code-block:: C

    bounded Gauss <interpolation scheme>

这增加了一个线性化，隐式源贡献的传输方程的形式。也就是说，它去掉了一个与连续性误差成比例的分量。随着计算的进行，这作为收敛辅助，趋向于有界解。在收敛时，这一项变为零，对最终解没有贡献。







拉普拉斯项格式laplacianSchemes
----------------------------------

在流体流动的动量方程中，拉普拉斯项一般为 :math:`\nabla\cdot(\nu\nabla\mathbf{U})` ，在OpenFOAM中表示为 :code:`laplacian(nu, U)` ，基于有限体积积分有：

.. math::
    \begin{align}
    \int_{V}\nabla\cdot(\nu\nabla\mathbf{U})~\mathrm{d}V=\int_{\mathbf{A}_{f}}\nu_{f}\nabla\mathbf{U}_{f}\cdot\mathrm{d}\mathbf{A}_{f}=\sum\nu_{f}\nabla\mathbf{U}_{f}\cdot\mathbf{A}_{f}    
    \end{align}

因此，需要指定 :math:`\nu_{f}` 的插值格式，同时也要指定面法向梯度 :math:`\nabla\mathbf{U}_{f}` 的离散格式。拉普拉斯格式laplacianSchemes只支持下面的格式：

.. code-block:: C

    Gauss <interpolationScheme> <snGradScheme>

其中 :code:`<interpolationScheme>` 用于指定 :math:`\nu_{f}` 的插值格式； :code:`<snGradScheme>` 用于指定面法向梯度 :math:`\nabla\mathbf{U}_{f}\cdot\mathbf{A}_{f}` 的离散格式：

+----------------------+----------------------------------+
| 所选的<snGradScheme> | 数学特性                         |
+======================+==================================+
| corrected            | 无界，二阶，守恒                 |
+----------------------+----------------------------------+
| uncorrected          | 有界，一阶，非守恒               |
+----------------------+----------------------------------+
| limited              | corrected和uncorrected的混合格式 |
+----------------------+----------------------------------+
| bounded              | 有界，一阶                       |
+----------------------+----------------------------------+
| fourth               | 无界，四阶，守恒                 |
+----------------------+----------------------------------+


下面是一些具体的设置案例：

.. code-block:: C

    default         Gauss linear corrected;





需要计算通量的场fluxRequired
------------------------------

fluxRequired子字典列举了数值模拟过程中需要计算通量的场。例如流体流动模拟中，在求解压力p的方程后需要计算通量，这可以通过在fluxRequired子字典中简单地指定：

.. code-block:: C

    fluxRequired 
    { 
        p; 
    }





fvSolution代数方程组求解设置
==============================

该文件由solvers、所采用耦合算法(PISO、SIMPLE、PIMPLE)以及relaxationFactors等子字典组成。

solvers设置
---------------

+----------------+--------------------------------------------------------------------------------------------------------------------+
| solvers关键词  | 含义                                                                                                               |
+================+====================================================================================================================+
| solver         | 代数方程组求解器，可选的求解器包括：                                                                               |
+                +                                                                                                                    +
|                | - PCG：预处理共轭梯度(对称)求解器；                                                                                |
+                +                                                                                                                    +
|                | - PBiCG：预处理稳定双共轭梯度(非对称)求解器；                                                                      |
+                +                                                                                                                    +
|                | - smoothSolver：光滑求解器；                                                                                       |
+                +                                                                                                                    +
|                | - GAMG：几何-代数多重网格求解器；                                                                                  |
+                +                                                                                                                    +
|                | - diagonal：对角求解器(显式离散)；                                                                                 |
+----------------+--------------------------------------------------------------------------------------------------------------------+
| preconditioner | 当solver采用了PCG/PBiCG求解器时进行设置。本质上为一个改变原先系数矩阵条件数的左乘矩阵。可选的预处理器包括：        |
+                +                                                                                                                    +
|                | - DIC：不完全的对角Cholesky预处理器(对称矩阵)；                                                                    |
+                +                                                                                                                    +
|                | - FDIC：不完全的快速对角Cholesky预处理器(相当于带缓存的DIC)；                                                      |
+                +                                                                                                                    +
|                | - DILU：对角不完全LU预处理器(非对称)；                                                                             |
+                +                                                                                                                    +
|                | - diagonal：对角预处理器；                                                                                         |
+                +                                                                                                                    +
|                | - GAMG：几何-代数多重网格预处理器；                                                                                |
+                +                                                                                                                    +
|                | - none：不进行预处理；                                                                                             |
+----------------+--------------------------------------------------------------------------------------------------------------------+
| smoother       | 当solver采用了smoothSolver时进行设置，可以选择的光滑器包括：                                                       |
+                +                                                                                                                    +
|                | - GaussSeidel：高斯塞德尔光顺器。一般情况下最可靠；                                                                |
+                +                                                                                                                    +
|                | - DIC：不完全的对角Cholesky光顺器(对称矩阵)。对于有些条件数不好的矩阵收敛性更好；                                  |
+                +                                                                                                                    +
|                | - DICGaussSeidel：不完全的对角Cholesky-高斯塞德尔光顺器(对称矩阵)；                                                |
+----------------+--------------------------------------------------------------------------------------------------------------------+
| tolerance      | 绝对残差(前后两次迭代结果的差值)。决定了求解器退出的标准。对于稳态问题应该取得很小，而对于瞬态问题则不能取得太小。 |
+----------------+--------------------------------------------------------------------------------------------------------------------+
| relTol         | 相对残差(前后两次迭代残差的比值)。当设置为非零数时将忽略tolerance的设置。                                          |
+----------------+--------------------------------------------------------------------------------------------------------------------+
| maxIter        | 最大迭代次数。                                                                                                     |
+----------------+--------------------------------------------------------------------------------------------------------------------+




耦合算法设置
---------------

.. code-block:: C

    //PISO算法设置
    PISO
    {
        nCorrectors     2;                  //PISO修正次数
        nNonOrthogonalCorrectors 0;         //非正交修正次数
        pRefCell        0;                  //压力参考单元
        pRefValue       0;                  //压力参考值
    }


欠松弛处理设置
----------------

欠松弛处理主要有两种不同的使用方式：

- 在迭代之前提高系数矩阵主对角元素数值，并且降低源项来保证系数矩阵对角占优，比如速度场U；
- 限制变量在迭代后改变的大小，比如压力场p。
  
欠松弛因子 :math:`\alpha` 介于0和1之间，越接近0求解越稳定，但同时也会降低求解效率；提高 :math:`\alpha` 的数值会提高求解效率，但同时也会降低稳定性。

欠松弛因子在子字典relaxationFactors下指定，通过子字典名equations和fields来设置不同的欠松弛方式，例如：

.. code-block:: C

    relaxationFactors
    {
        fields
        {
            p 0.3;
        }
        equations
        {
            U 0.7;
        }
    }



controlDict设置
====================

位于system文件夹内的controlDict文件用于设置时间和输入输出控制，包括时间控制、计算结果输出控制、时间步长自适应控制、字典读取控制和运行时加载库或者函数五个部分。

常规设置
----------

时间控制部分startFrom关键词决定了开始计算的时间，可选的取值包括：

+------------+---------------------------------------------------------------+
| startFrom  | 含义                                                          |
+============+===============================================================+
| firstTime  | 所有时间目录中最早的时间步                                    |
+------------+---------------------------------------------------------------+
| latestTime | 所有时间目录中最近的时间步                                    |
+------------+---------------------------------------------------------------+
| startTime  | 从指定开始的时间步开始计算，需要在下面指定startTime关键词的值 |
+------------+---------------------------------------------------------------+


时间控制部分stopAt关键词决定了停止计算的时间，可选的取值包括：

+------------+-----------------------------------------------------------+
| stopAt     | 含义                                                      |
+============+===========================================================+
| endTime    | 在指定的结束时间停止计算，需要在下面指定endTime关键词的值 |
+------------+-----------------------------------------------------------+
| writeNow   | 当前时间步完成时结束计算并且输出计算结果                  |
+------------+-----------------------------------------------------------+
| noWriteNow | 当前时间步完成时结束计算但是不输出计算结果                |
+------------+-----------------------------------------------------------+
| nextWrite  | 下一个时间步完成时结束计算并且输出计算结果                |
+------------+-----------------------------------------------------------+


计算结果输出控制部分writeControl关键词决定计算结果输出间隔方式，可选的取值包括：

+-------------------+------------------------------------------------------------------------+
| writeControl      | 含义                                                                   |
+===================+========================================================================+
| timeStep          | 按照时间步输出，间隔由关键字writeInterval指定，单位为[步]              |
+-------------------+------------------------------------------------------------------------+
| runTime           | 按照计算时间输出，间隔由关键字writeInterval指定，单位为[s]             |
+-------------------+------------------------------------------------------------------------+
| adjustableRunTime | 时间自适应下按照计算时间输出，间隔由关键字writeInterval指定，单位为[s] |
+-------------------+------------------------------------------------------------------------+
| cpuTime           | 按照CPU时间输出，间隔由关键字writeInterval指定，单位为[s]              |
+-------------------+------------------------------------------------------------------------+
| clockTime         | 按照真实时间输出，间隔由关键字writeInterval指定，单位为[s]             |
+-------------------+------------------------------------------------------------------------+


计算结果输出控制部分writeFormat关键词决定了计算结果输出的格式，可选的取值包括：

+-------------+------------------------------------------------------------------------+
| writeFormat | 含义                                                                   |
+=============+========================================================================+
| ascii       | 文本格式，由writePrecision关键词控制有效数字位数                       |
+-------------+------------------------------------------------------------------------+
| binary      | 二进制格式，直接将内存内容写入文件，能够减少文件存储空间，提高读写效率 |
+-------------+------------------------------------------------------------------------+


计算结果输出控制部分writeCompression关键词决定了输出文件是否压缩，可选的取值包括：

+------------------+--------------+
| writeCompression | 含义         |
+==================+==============+
| uncompressed     | 不压缩       |
+------------------+--------------+
| compressed       | gzip压缩格式 |
+------------------+--------------+


计算结果输出控制部分timeFormat关键词决定了时间的格式，可选的取值包括：

+------------+----------------------------------------------------------------------------+
| timeFormat | 含义                                                                       |
+============+============================================================================+
| fixed      | :math:`\pm\text{m.dddddd}` ，其中d由timePrecision来控制                    |
+------------+----------------------------------------------------------------------------+
| scientific | :math:`\pm\text{m.dddddd}\pm\text{xx}` ，其中d由timePrecision来控制        |
+------------+----------------------------------------------------------------------------+
| general    | 使用scientific格式，默认小数点后有4位有效位数，也可通过timePrecision来调节 |
+------------+----------------------------------------------------------------------------+

自适应时间步长需要指定自适应开关adjustTimeStep，最大库朗数maxCo时间步长最大值maxDeltaT的数值，例如：

.. code-block:: C

    //时间步长自适应控制
    adjustTimeStep  yes;                //是否开启时间步长自适应
    maxCo           0.5;                //最大库郎数
    maxDeltaT       1.0;                //最大时间步长


在计算过程当中，一些字典文件可能会被修改，这时需要打开读取开关runTimeModifiable，以让求解器更新一些参数。


运行时加载库或者函数控制
----------------------------

设置运行时需要加载的库或函数如下所示：

.. code-block:: C

    libs        libUser1.so;    //库列表，库文件位于$LD_LIBRARY_PATH
    functions   probes;         //函数列表



后处理
========

postProcess
-------------

可以在终端通过下面的命令查看可用的后处理方法：

.. code-block:: shell

    postProcess -list


在使用postProcess功能前，需要在controlDict文件内的functions字典内添加相应的子字典设置。然后通过在终端输入下面的命令进行后处理：

.. code-block:: shell

    <solver> -postProcess


age
^^^^^^

Calculates and writes out the time taken for a particle to travel from an inlet to the location. Solves the following equation when incompressible: \f[ \div (\phi t) = 1 \f] where: t is Age [s], \phi is Volumetric flux [m^3/s]. Boundary conditions are generated automatically as zeroGradient on all walls and inletOutlet everywhere else.

.. code-block:: C

    age1
    {
        type            age;
        libs            ("libsolverFunctionObjects.so");

        executeControl  writeTime;
        writeControl    writeTime;

        schemesField    k;
    }

.. code-block:: C
    :caption: src/functionObjects/field/age/age.C

    bool Foam::functionObjects::age::read(const dictionary& dict)
    {
        phiName_ = dict.lookupOrDefault<word>("phi", "phi");
        rhoName_ = dict.lookupOrDefault<word>("rho", "rho");
        nCorr_ = dict.lookupOrDefault<int>("nCorr", 5);
        schemesField_ = dict.lookupOrDefault<word>("schemesField", typeName);
        diffusion_ = dict.lookupOrDefault<Switch>("diffusion", false);
        tolerance_ = dict.lookupOrDefault<scalar>("tolerance", 1e-5);

        return true;
    }

.. code-block:: C
    :caption: src/functionObjects/field/age/age.C

    bool Foam::functionObjects::age::execute()
    {
        tmp<volScalarField> tage
        (
            new volScalarField
            (
                IOobject
                (
                    typeName,
                    mesh_.time().timeName(),
                    mesh_,
                    IOobject::READ_IF_PRESENT,
                    IOobject::AUTO_WRITE,
                    false
                ),
                mesh_,
                dimensionedScalar(dimTime, 0),
                patchTypes()
            )
        );
        volScalarField& age = tage.ref();

        const word divScheme("div(phi," + schemesField_ + ")");

        // Set under-relaxation coeff
        scalar relaxCoeff = 0.0;
        if (mesh_.solution().relaxEquation(schemesField_))
        {
            relaxCoeff = mesh_.solution().equationRelaxationFactor(schemesField_);
        }

        const Foam::fvModels& fvModels(Foam::fvModels::New(mesh_));
        const Foam::fvConstraints& fvConstraints
        (
            Foam::fvConstraints::New(mesh_)
        );

        // This only works because the null constructed inletValue for an inletOutletFvPatchField is zero. 
        // If we needed any other value we would have to loop over the inletOutlet patches and explicitly set the inletValues. 
        // We would need to change the interface of inletOutlet in order to do this.

        const surfaceScalarField& phi = mesh_.lookupObject<surfaceScalarField>(phiName_);

        if (phi.dimensions() == dimMass/dimTime)
        {
            const volScalarField& rho = mesh_.lookupObject<volScalarField>(rhoName_);

            const word laplacianScheme("laplacian(muEff," + schemesField_ + ")");

            tmp<volScalarField> tnuEff;
            if (diffusion_)
            {
                tnuEff = mesh_.lookupObject<momentumTransportModel>(momentumTransportModel::typeName).nuEff();
            }

            for (int i=0; i<=nCorr_; i++)
            {
                fvScalarMatrix ageEqn
                (
                    fvm::div(phi, age, divScheme) == rho + fvModels.source(rho, age)
                );

                if (diffusion_)
                {
                    ageEqn -= fvm::laplacian(rho*tnuEff(), age, laplacianScheme);
                }

                ageEqn.relax(relaxCoeff);

                fvConstraints.constrain(ageEqn);

                if (converged(i, ageEqn.solve(schemesField_).initialResidual()))
                {
                    break;
                };

                fvConstraints.constrain(age);
            }
        }
        else
        {
            tmp<volScalarField> tnuEff;
            word laplacianScheme;

            if (diffusion_)
            {
                tnuEff = mesh_.lookupObject<momentumTransportModel>(momentumTransportModel::typeName).nuEff();

                laplacianScheme = "laplacian(" + tnuEff().name() + ',' + schemesField_ + ")";
            }

            for (int i=0; i<=nCorr_; i++)
            {
                fvScalarMatrix ageEqn
                (
                    fvm::div(phi, age, divScheme) == dimensionedScalar(1) + fvModels.source(age)
                );

                if (diffusion_)
                {
                    ageEqn -= fvm::laplacian(tnuEff(), age, laplacianScheme);
                }

                ageEqn.relax(relaxCoeff);

                fvConstraints.constrain(ageEqn);

                if (converged(i, ageEqn.solve(schemesField_).initialResidual()))
                {
                    break;
                }

                fvConstraints.constrain(age);
            }
        }

        Info<< "Min/max age:" << min(age).value() << ' ' << max(age).value() << endl;

        return store(tage);
    }

CourantNo
^^^^^^^^^^^

Calculates and outputs the Courant number as a volScalarField.  The field is stored on the mesh database so that it can be retrieved and used for other applications.


.. code-block:: C
    :caption: src/functionObjects/field/CourantNo/CourantNo.C

    Foam::tmp<Foam::volScalarField::Internal>
    Foam::functionObjects::CourantNo::byRho
    (
        const tmp<volScalarField::Internal>& Co
    ) const
    {
        if (Co().dimensions() == dimDensity)
        {
            return Co/obr_.lookupObject<volScalarField>(rhoName_);
        }
        else
        {
            return Co;
        }
    }


    bool Foam::functionObjects::CourantNo::calc()
    {
        if (foundObject<surfaceScalarField>(fieldName_))
        {
            const surfaceScalarField& phi = lookupObject<surfaceScalarField>(fieldName_);

            tmp<volScalarField> tCo
            (
                volScalarField::New
                (
                    resultName_,
                    mesh_,
                    dimensionedScalar(dimless, 0),
                    zeroGradientFvPatchScalarField::typeName
                )
            );

            tCo->ref() = byRho( (0.5*mesh_.time().deltaT()) * fvc::surfaceSum(mag(phi))()()/mesh_.V() );

            tCo->correctBoundaryConditions();

            return store(resultName_, tCo);
        }
        else
        {
            cannotFindObject<surfaceScalarField>(fieldName_);

            return false;
        }
    }


    // * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //

    Foam::functionObjects::CourantNo::CourantNo
    (
        const word& name,
        const Time& runTime,
        const dictionary& dict
    )
    :
        fieldExpression(name, runTime, dict, "Co", "phi")
    {
        read(dict);
    }

    // * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //

    bool Foam::functionObjects::CourantNo::read(const dictionary& dict)
    {
        fieldExpression::read(dict);

        rhoName_ = dict.lookupOrDefault<word>("rho", "rho");

        return true;
    }


MachNo
^^^^^^^^^

Calculates and writes the Mach number as a volScalarField.

.. code-block:: C
    :caption: src/functionObjects/field/MachNo/MachNo.C

    bool Foam::functionObjects::MachNo::calc()
    {
        if
        (
            foundObject<volVectorField>(fieldName_)
         && foundObject<fluidThermo>(physicalProperties::typeName)
        )
        {
            const fluidThermo& thermo = lookupObject<fluidThermo>(physicalProperties::typeName);

            const volVectorField& U = lookupObject<volVectorField>(fieldName_);

            return store
            (
                resultName_,
                mag(U)/sqrt(thermo.gamma()*thermo.p()/thermo.rho())
            );
        }
        else
        {
            return false;
        }
    }


    // * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //

    Foam::functionObjects::MachNo::MachNo
    (
        const word& name,
        const Time& runTime,
        const dictionary& dict
    )
    :
        fieldExpression(name, runTime, dict, "Ma", "U")
    {}


forces
^^^^^^^^^

使用forces功能需要在controlDict的functions字典中添加如下内容：

.. code-block:: C

    forces1
    {
        // Mandatory entries
        type            forces;
        libs            ("libforces.so");
        patches         (<list of patch names>);

        // Field names
        p               p;
        U               U;
        rho             rho;
        // 如果是不可压缩流则将rho修改为如下设置
        // rho         rhoInf;
        // rhoInf      100000;
        
        pRef            0;          // Reference pressure [Pa]
        porosity        no;         // Include porosity effects?
        writeFields     yes;        // Store and write volume field representations of forces and moments
        CofR            (0 0 0);    // Centre of rotation for moment calculations

        // Spatial data binning
        // - extents given by the bounds of the input geometry
        /* binData
        {
            nBin        20;
            direction   (1 0 0);
            cumulative  yes;
        } */
    }



forces功能读取controlDict中functions字典的逻辑如下：

.. code-block:: C
    :caption: src/functionObjects/forces/forces/forces.C

    bool Foam::functionObjects::forces::read(const dictionary& dict)
    {
        fvMeshFunctionObject::read(dict);

        initialised_ = false;

        Log << type() << " " << name() << ":" << nl;

        directForceDensity_ = dict.lookupOrDefault("directForceDensity", false);    // 是否直接提供force density，默认为false

        const polyBoundaryMesh& pbm = mesh_.boundaryMesh();
        patchSet_ = pbm.patchSet(wordReList(dict.lookup("patches")));    // 读取边界面名称

        if (directForceDensity_)    // 如果直接提供force density
        {
            // Optional entry for fDName
            fDName_ = dict.lookupOrDefault<word>("fD", "fD");    // 读取fD
        }
        else    // 如果没有直接提供force density(默认情况)
        {
            // Optional phase entry
            phaseName_ = dict.lookupOrDefault<word>("phase", word::null);    // 读取相名称，默认为空

            // Optional U, p and rho entries
            pName_ = dict.lookupOrDefault<word> ( "p", IOobject::groupName("p", phaseName_) );    // 读取压强场名称
            UName_ = dict.lookupOrDefault<word> ( "U", IOobject::groupName("U", phaseName_) );    // 读取速度场名称
            rhoName_ = dict.lookupOrDefault<word> ( "rho", IOobject::groupName("rho", phaseName_) );    // 读取密度场名称

            // Reference density needed for incompressible calculations
            if (rhoName_ == "rhoInf")    // 如果密度场名称设置为了rhoInf
            {
                dict.lookup("rhoInf") >> rhoRef_;    // 那么rhoRef的值即为rhoInf的值
            }

            // Reference pressure, 0 by default
            pRef_ = dict.lookupOrDefault<scalar>("pRef", 0.0);    // 读取参考压强，默认为零
        }

        // Centre of rotation for moment calculations specified directly, from coordinate system, or implicitly (0 0 0)
        if (dict.found("CofR"))
        {
            coordSys_ = coordinateSystem("coordSys", vector(dict.lookup("CofR")));
            localSystem_ = false;
        }
        else
        {
            coordSys_ = coordinateSystem("coordSys", dict);
            localSystem_ = true;
        }

        dict.readIfPresent("porosity", porosity_);    // 孔隙度
        if (porosity_)
        {
            Log << "    Including porosity effects" << endl;
        }
        else
        {
            Log << "    Not including porosity effects" << endl;
        }

        if (dict.found("binData"))
        {
            const dictionary& binDict(dict.subDict("binData"));
            binDict.lookup("nBin") >> nBin_;

            if (nBin_ < 0)
            {
                FatalIOErrorInFunction(dict) << "Number of bins (nBin) must be zero or greater" << exit(FatalIOError);
            }
            else if ((nBin_ == 0) || (nBin_ == 1))
            {
                nBin_ = 1;
                forAll(force_, i)
                {
                    force_[i].setSize(1);
                    moment_[i].setSize(1);
                }
            }

            if (nBin_ > 1)
            {
                binDict.lookup("direction") >> binDir_;
                binDir_ /= mag(binDir_);

                binMin_ = great;
                scalar binMax = -great;
                forAllConstIter(labelHashSet, patchSet_, iter)
                {
                    const label patchi = iter.key();
                    const polyPatch& pp = pbm[patchi];
                    const scalarField d(pp.faceCentres() & binDir_);
                    binMin_ = min(min(d), binMin_);
                    binMax = max(max(d), binMax);
                }
                reduce(binMin_, minOp<scalar>());
                reduce(binMax, maxOp<scalar>());

                // slightly boost binMax so that region of interest is fully within bounds
                binMax = 1.0001*(binMax - binMin_) + binMin_;

                binDx_ = (binMax - binMin_)/scalar(nBin_);

                // create the bin points used for writing
                binPoints_.setSize(nBin_);
                forAll(binPoints_, i)
                {
                    binPoints_[i] = (i + 0.5)*binDir_*binDx_;
                }

                binDict.lookup("cumulative") >> binCumulative_;

                // allocate storage for forces and moments
                forAll(force_, i)
                {
                    force_[i].setSize(nBin_);
                    moment_[i].setSize(nBin_);
                }
            }
        }

        if (nBin_ == 1)
        {
            // allocate storage for forces and moments
            force_[0].setSize(1);
            force_[1].setSize(1);
            force_[2].setSize(1);
            moment_[0].setSize(1);
            moment_[1].setSize(1);
            moment_[2].setSize(1);
        }

        resetNames(createFileNames(dict));

        return true;
    }

在forces功能中计算forces和moment的方式如下：

.. code-block:: C
    :caption: src/functionObjects/forces/forces/forces.C

    void Foam::functionObjects::forces::calcForcesMoment()
    {
        initialise();

        force_[0] = Zero;    // pressure force per bin
        force_[1] = Zero;    // viscous force per bin
        force_[2] = Zero;    // porous force per bin

        moment_[0] = Zero;    // pressure moment per bin
        moment_[1] = Zero;    // viscous moment per bin
        moment_[2] = Zero;    // porous moment per bin

        if (directForceDensity_)    // 如果直接提供了force density的数据
        {
            const volVectorField& fD = obr_.lookupObject<volVectorField>(fDName_);    // 读取force density

            const surfaceVectorField::Boundary& Sfb = mesh_.Sf().boundaryField();    // 边界面的面法向量

            forAllConstIter(labelHashSet, patchSet_, iter)
            {
                const label patchi = iter.key();

                const vectorField Md ( mesh_.C().boundaryField()[patchi] - coordSys_.origin() );

                const scalarField sA(mag(Sfb[patchi]));    // 边界面的网格面积

                // Normal force = surfaceUnitNormal*(surfaceNormal & forceDensity)
                const vectorField fN    // 法向力
                (
                    Sfb[patchi]/sA * ( Sfb[patchi] & fD.boundaryField()[patchi] )
                );

                // Tangential force (total force minus normal fN)
                const vectorField fT(sA*fD.boundaryField()[patchi] - fN);    // 切向力

                //- Porous force
                const vectorField fP(Md.size(), Zero);    // 孔隙力

                applyBins(Md, fN, fT, fP, mesh_.C().boundaryField()[patchi]);
            }
        }
        else    // 如果没有直接提供force density的数据(默认情况)
        {
            const volScalarField& p = obr_.lookupObject<volScalarField>(pName_);    // 读取压强

            const surfaceVectorField::Boundary& Sfb = mesh_.Sf().boundaryField();    // 边界面的面法向量

            tmp<volSymmTensorField> tdevTau = devTau();
            const volSymmTensorField::Boundary& devTaub = tdevTau().boundaryField();    // 在边界面处的切应力

            // Scale pRef by density for incompressible simulations
            const scalar pRef = pRef_/rho(p);    // 如果是可压缩流则不会做任何事；如果是不可压缩流则将pRef除以rhoRef(rhoInf)

            forAllConstIter(labelHashSet, patchSet_, iter)
            {
                const label patchi = iter.key();

                const vectorField Md
                (
                    mesh_.C().boundaryField()[patchi] - coordSys_.origin()
                );

                const vectorField fN    // 法向力
                (
                    alpha(patchi) * rho(p) * Sfb[patchi] * (p.boundaryField()[patchi] - pRef)
                );

                const vectorField fT(Sfb[patchi] & devTaub[patchi]);    // 切向力

                const vectorField fP(Md.size(), Zero);    // 孔隙力

                applyBins(Md, fN, fT, fP, mesh_.C().boundaryField()[patchi]);
            }
        }

        if (porosity_)    // 如果考虑孔隙作用
        {
            // ...
        }

        Pstream::listCombineGather(force_, plusEqOp<vectorField>());
        Pstream::listCombineGather(moment_, plusEqOp<vectorField>());
        Pstream::listCombineScatter(force_);
        Pstream::listCombineScatter(moment_);
    }

其中applyBins()函数的具体执行内容如下，实际上由该函数计算出最终的forces和moment：

.. code-block:: C
    :caption: src/functionObjects/forces/forces/forces.C

    void Foam::functionObjects::forces::applyBins
    (
        const vectorField& Md,
        const vectorField& fN,
        const vectorField& fT,
        const vectorField& fP,
        const vectorField& d
    )
    {
        if (nBin_ == 1)
        {
            force_[0][0] += sum(fN);
            force_[1][0] += sum(fT);
            force_[2][0] += sum(fP);
            moment_[0][0] += sum(Md^fN);
            moment_[1][0] += sum(Md^fT);
            moment_[2][0] += sum(Md^fP);
        }
        else
        {
            scalarField dd((d & binDir_) - binMin_);

            forAll(dd, i)
            {
                label bini = min(max(floor(dd[i]/binDx_), 0), force_[0].size() - 1);

                force_[0][bini] += fN[i];
                force_[1][bini] += fT[i];
                force_[2][bini] += fP[i];
                moment_[0][bini] += Md[i]^fN[i];
                moment_[1][bini] += Md[i]^fT[i];
                moment_[2][bini] += Md[i]^fP[i];
            }
        }
    }

forces计算结果输出为dat文件的逻辑如下：

.. code-block:: C
    :caption: src/functionObjects/forces/forces/forces.C

    void Foam::functionObjects::forces::writeForces()
    {
        Log << type() << " " << name() << " write:" << nl
            << "    sum of forces:" << nl
            << "        pressure : " << sum(force_[0]) << nl
            << "        viscous  : " << sum(force_[1]) << nl
            << "        porous   : " << sum(force_[2]) << nl
            << "    sum of moments:" << nl
            << "        pressure : " << sum(moment_[0]) << nl
            << "        viscous  : " << sum(moment_[1]) << nl
            << "        porous   : " << sum(moment_[2])
            << endl;

        writeTime(file(fileID::mainFile));

        if (porosity_)
        {
            file(fileID::mainFile) << tab << setw(1) << '('
                << sum(force_[0]) << setw(1) << ' '
                << sum(force_[1]) << setw(1) << ' '
                << sum(force_[2]) << setw(3) << ") ("
                << sum(moment_[0]) << setw(1) << ' '
                << sum(moment_[1]) << setw(1) << ' '
                << sum(moment_[2]) << setw(1) << ')';
        }
        else
        {
            file(fileID::mainFile) << tab << setw(1) << '('
                << sum(force_[0]) << setw(1) << ' '
                << sum(force_[1]) << setw(3) << ") ("
                << sum(moment_[0]) << setw(1) << ' '
                << sum(moment_[1]) << setw(1) << ')';
        }

        if (localSystem_)
        {
            if (porosity_)
            {
                file(fileID::mainFile) << tab << setw(1) << '('
                    << sum(coordSys_.localVector(force_[0])) << setw(1) << ' '
                    << sum(coordSys_.localVector(force_[1])) << setw(1) << ' '
                    << sum(coordSys_.localVector(force_[2])) << setw(3) << ") ("
                    << sum(coordSys_.localVector(moment_[0])) << setw(1) << ' '
                    << sum(coordSys_.localVector(moment_[1])) << setw(1) << ' '
                    << sum(coordSys_.localVector(moment_[2])) << setw(1) << ')';
            }
            else
            {
                file(fileID::mainFile) << tab << setw(1) << '('
                    << sum(coordSys_.localVector(force_[0])) << setw(1) << ' '
                    << sum(coordSys_.localVector(force_[1])) << setw(3) << ") ("
                    << sum(coordSys_.localVector(moment_[0])) << setw(1) << ' '
                    << sum(coordSys_.localVector(moment_[1])) << setw(1) << ')';
            }
        }

        file(fileID::mainFile) << endl;
    }






forceCoeffs
^^^^^^^^^^^^^^

使用forceCoeffs功能需要在controlDict的functions字典中添加如下内容：

.. code-block:: C

    forceCoeffs1
    {
        // Mandatory entries
        type            forceCoeffs;
        libs            ("libforces.so");
        patches         (<list of patch names>);

        // Field names
        p               p;
        U               U;
        rho             rho;    // 不可压缩流则设置为rhoInf

        rhoInf      100000;         // Freestream density
        magUInf         30;         // Freestream velocity magnitude [m/s]
        pRef            0;          // Reference pressure [Pa]

        porosity        no;         // Include porosity effects?
        writeFields     yes;        // Store and write volume field representations of forces and moments
        CofR            (0 0 0);    // Centre of rotation for moment calculations
        liftDir         (0 0 1);    // Lift direction
        dragDir         (1 0 0);    // Drag direction
        pitchAxis       (0 1 0);    // Pitch axis
        
        lRef            1;          // Reference length [m]
        Aref            1.75;       // Reference area [m2]

        // Spatial data binning
        // - extents given by the bounds of the input geometry
        /* binData
        {
            nBin        20;
            direction   (1 0 0);
            cumulative  yes;
        } */
    }

.. math::
    \begin{align}
    & C_{l} = \frac{\mathbf{F}_{total} \cdot \mathbf{n}_{lift}}{A_{ref}\times (\frac{1}{2}\rho_{Inf}|\mathbf{U}_{Inf}|^{2})} \\
    & C_{d} = \frac{\mathbf{F}_{total} \cdot \mathbf{n}_{drag}}{A_{ref}\times (\frac{1}{2}\rho_{Inf}|\mathbf{U}_{Inf}|^{2})} \\
    & C_{m} = \frac{totMoment \cdot pitchAxis}{A_{ref}\times l_{ref} \times (\frac{1}{2}\rho_{Inf}|\mathbf{U}_{Inf}|^{2})} 
    \end{align}


forceCoeffs功能读取controlDict中functions字典的逻辑如下：

.. code-block:: C
    :caption: src/functionObjects/forces/forceCoeffs/forceCoeffs.C

    bool Foam::functionObjects::forceCoeffs::read(const dictionary& dict)
    {
        forces::read(dict);    // 按照forces功能的方式先读取一遍字典

        // Directions for lift and drag forces, and pitch moment
        // Normalise to ensure that the directions are unit vectors

        dict.lookup("liftDir") >> liftDir_;    // 读取lift force方向
        liftDir_ /= mag(liftDir_);    // 修正为单位向量

        dict.lookup("dragDir") >> dragDir_;    // 读取drag force方向
        dragDir_ /= mag(dragDir_);    // 修正为单位向量

        dict.lookup("pitchAxis") >> pitchAxis_;    // 读取pitch坐标系方向
        pitchAxis_ /= mag(pitchAxis_);    // 修正为单位向量

        // Free stream velocity magnitude
        dict.lookup("magUInf") >> magUInf_;    // 读取自由流的速度大小

        // Reference (free stream) density
        dict.lookup("rhoInf") >> rhoRef_;    // 读取自由流的密度

        // Reference length and area scales
        dict.lookup("lRef") >> lRef_;    // 读取参考长度
        dict.lookup("Aref") >> Aref_;    //  读取参考面积

        return true;
    }

forceCoeffs功能计算各力系数的方式如下，它首先通过forces功能计算总力，再点乘对应方向的单位向量得到升力、曳力等：

.. code-block:: C
    :caption: src/functionObjects/forces/forceCoeffs/forceCoeffs.C

    bool Foam::functionObjects::forceCoeffs::write()
    {
        forces::calcForcesMoment();    // 计算 forces 和 moment

        if (Pstream::master())
        {
            logFiles::write();

            scalar pDyn = 0.5*rhoRef_*magUInf_*magUInf_;    // 动压

            Field<vector> totForce(force_[0] + force_[1] + force_[2]);
            Field<vector> totMoment(moment_[0] + moment_[1] + moment_[2]);

            List<Field<scalar>> coeffs(3);
            coeffs[0].setSize(nBin_);
            coeffs[1].setSize(nBin_);
            coeffs[2].setSize(nBin_);

            // lift, drag and moment
            coeffs[0] = (totForce & liftDir_)/(Aref_*pDyn);
            coeffs[1] = (totForce & dragDir_)/(Aref_*pDyn);
            coeffs[2] = (totMoment & pitchAxis_)/(Aref_*lRef_*pDyn);

            scalar Cl = sum(coeffs[0]);    // total lift coefficient
            scalar Cd = sum(coeffs[1]);    // total drag coefficient
            scalar Cm = sum(coeffs[2]);    // total moment coefficient

            scalar Clf = Cl/2.0 + Cm;    // total front lift coefficient
            scalar Clr = Cl/2.0 - Cm;    // total rear lift coefficient

            writeTime(file(fileID::mainFile));
            file(fileID::mainFile) << tab << Cm << tab  << Cd << tab << Cl << tab << Clf << tab << Clr << endl;

            Log << type() << " " << name() << " write:" << nl
                << "    Cm    = " << Cm << nl
                << "    Cd    = " << Cd << nl
                << "    Cl    = " << Cl << nl
                << "    Cl(f) = " << Clf << nl
                << "    Cl(r) = " << Clr << endl;

            if (nBin_ > 1)
            {
                if (binCumulative_)
                {
                    for (label i = 1; i < coeffs[0].size(); i++)
                    {
                        coeffs[0][i] += coeffs[0][i-1];
                        coeffs[1][i] += coeffs[1][i-1];
                        coeffs[2][i] += coeffs[2][i-1];
                    }
                }

                writeTime(file(fileID::binsFile));

                forAll(coeffs[0], i)
                {
                    file(fileID::binsFile) << tab << coeffs[2][i] << tab << coeffs[1][i] << tab << coeffs[0][i];
                }

                file(fileID::binsFile) << endl;
            }

            Log << endl;
        }

        return true;
    }


Lambda2
^^^^^^^^^^^^

Calculates and outputs the second largest eigenvalue of the sum of the square of the symmetrical and anti-symmetrical parts of the velocity gradient tensor.

.. code-block:: C
    :caption: src/functionObjects/field/Lambda2/Lambda2.C

    bool Foam::functionObjects::Lambda2::calc()
    {
        if (foundObject<volVectorField>(fieldName_))
        {
            const volVectorField& U = lookupObject<volVectorField>(fieldName_);
            const tmp<volTensorField> tgradU(fvc::grad(U));
            const volTensorField& gradU = tgradU();

            const volTensorField SSplusWW
            (
                (symm(gradU) & symm(gradU))
              + (skew(gradU) & skew(gradU))
            );

            return store
            (
                resultName_,
               -eigenValues(SSplusWW)().component(vector::Y)
            );
        }
        else
        {
            cannotFindObject<volVectorField>(fieldName_);

            return false;
        }
    }

Q
^^^^

Calculates and outputs the second invariant of the velocity gradient tensor [1/s^2]. \f[ Q = 0.5(sqr(tr(\nabla U)) - tr(((\nabla U) \cdot (\nabla U)))) \f].

.. code-block:: C
    :caption: src/functionObjects/field/Q/Q.C

    bool Foam::functionObjects::Q::calc()
    {
        if (foundObject<volVectorField>(fieldName_))
        {
            const volVectorField& U = lookupObject<volVectorField>(fieldName_);
            const tmp<volTensorField> tgradU(fvc::grad(U));
            const volTensorField& gradU = tgradU();

            return store
            (
                resultName_,
                0.5*(sqr(tr(gradU)) - tr(((gradU) & (gradU))))
            );
        }
        else
        {
            cannotFindObject<volVectorField>(fieldName_);

            return false;
        }
    }


yPlus
^^^^^^^

Evaluates and outputs turbulence y+ for models. Values written to time directories as field 'yPlus' or 'yPlus.<phase>'.


.. code-block:: C

    yPlus1
    {
        type        yPlus;
        libs        ("libfieldFunctionObjects.so");
        //...
    }



.. code-block:: C
    :caption: src/functionObjects/field/yPlus/yPlus.C

    // * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //

    Foam::functionObjects::yPlus::yPlus
    (
        const word& name,
        const Time& runTime,
        const dictionary& dict
    )
    :
        fvMeshFunctionObject(name, runTime, dict),
        logFiles(obr_, name),
        writeLocalObjects(obr_, log),
        phaseName_(dict.lookupOrDefault<word>("phase", word::null))
    {
        read(dict);
    }

    // * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //

    bool Foam::functionObjects::yPlus::read(const dictionary& dict)
    {
        fvMeshFunctionObject::read(dict);
        writeLocalObjects::read(dict);

        resetName(IOobject::groupName(typeName, phaseName_));
        resetLocalObjectName(IOobject::groupName(typeName, phaseName_));

        return true;
    }


.. code-block:: C
    :caption: src/functionObjects/field/yPlus/yPlus.C

    bool Foam::functionObjects::yPlus::execute()
    {
        if (mesh_.foundObject<momentumTransportModel>
        (
            IOobject::groupName(momentumTransportModel::typeName, phaseName_))
        )
        {
            const momentumTransportModel& model =
                mesh_.lookupObject<momentumTransportModel>
                (
                    IOobject::groupName
                    (
                        momentumTransportModel::typeName,
                        phaseName_
                    )
                );

            word name(IOobject::groupName(type(), phaseName_));

            return store(name, calcYPlus(model));
        }
        else
        {
            FatalErrorInFunction << "Unable to find turbulence model in the " << "database" << exit(FatalError);
        }

        return true;
    }


    Foam::tmp<Foam::volScalarField> Foam::functionObjects::yPlus::calcYPlus
    (
        const momentumTransportModel& turbModel
    )
    {
        tmp<volScalarField> tyPlus
        (
            volScalarField::New
            (
                IOobject::groupName(type(), phaseName_),
                mesh_,
                dimensionedScalar(dimless, 0)
            )
        );

        volScalarField::Boundary& yPlusBf = tyPlus.ref().boundaryFieldRef();

        const volScalarField::Boundary& d = nearWallDist::New(mesh_).y();

        const tmp<volScalarField> tnut = turbModel.nut();
        const volScalarField::Boundary& nutBf = tnut().boundaryField();

        const tmp<volScalarField> tnuEff = turbModel.nuEff();
        const volScalarField::Boundary& nuEffBf = tnuEff().boundaryField();

        const tmp<volScalarField> tnu = turbModel.nu();
        const volScalarField::Boundary& nuBf = tnu().boundaryField();

        const fvPatchList& patches = mesh_.boundary();

        forAll(patches, patchi)
        {
            const fvPatch& patch = patches[patchi];

            if (isA<nutWallFunctionFvPatchScalarField>(nutBf[patchi]))
            {
                const nutWallFunctionFvPatchScalarField& nutPf = dynamic_cast<const nutWallFunctionFvPatchScalarField&>(nutBf[patchi]);

                yPlusBf[patchi] = nutPf.yPlus();
            }
            else if (isA<wallFvPatch>(patch))
            {
                yPlusBf[patchi] = d[patchi] * sqrt( nuEffBf[patchi] * mag(turbModel.U().boundaryField()[patchi].snGrad()) )/nuBf[patchi];
            }
        }

        return tyPlus;
    }


.. code-block:: C
    :caption: src/functionObjects/field/yPlus/yPlus.C

    bool Foam::functionObjects::yPlus::write()
    {
        Log << type() << " " << name() << " write:" << nl;

        writeLocalObjects::write();
        logFiles::write();

        const volScalarField& yPlus = mesh_.lookupObject<volScalarField>(IOobject::groupName(type(), phaseName_));
        const volScalarField::Boundary& yPlusBf = yPlus.boundaryField();
        const fvPatchList& patches = mesh_.boundary();

        forAll(patches, patchi)
        {
            const fvPatch& patch = patches[patchi];

            if (isA<wallFvPatch>(patch))
            {
                const scalarField& yPlusp = yPlusBf[patchi];

                const scalar minYplus = gMin(yPlusp);
                const scalar maxYplus = gMax(yPlusp);
                const scalar avgYplus = gAverage(yPlusp);

                if (Pstream::master())
                {
                    Log << "    patch " << patch.name() << " y+ : min = " << minYplus << ", max = " << maxYplus << ", average = " << avgYplus << nl;

                    writeTime(file());
                    file() << tab << patch.name() << tab << minYplus << tab << maxYplus << tab << avgYplus << endl;
                }
            }
        }

        Log << endl;

        return true;
    }



场计算
^^^^^^^^^

+-----------------------+------------------------------------------------------------------+
| functionObject        | 作用                                                             |
+=======================+==================================================================+
| CourantNo             | 输出库郎数                                                       |
+-----------------------+------------------------------------------------------------------+
| Lambda2               | 输出Lambda2                                                      |
+-----------------------+------------------------------------------------------------------+
| MachNo                | 计算马赫数                                                       |
+-----------------------+------------------------------------------------------------------+
| Peclect               | 输出Peclet数                                                     |
+-----------------------+------------------------------------------------------------------+
| Q                     | 计算速度梯度第二不变量                                           |
+-----------------------+------------------------------------------------------------------+
| R                     | 计算雷诺应力张量场                                               |
+-----------------------+------------------------------------------------------------------+
| XiReactionRate        | 写入湍流火焰速度以及反应速率体标量场                             |
+-----------------------+------------------------------------------------------------------+
| add                   | 添加场                                                           |
+-----------------------+------------------------------------------------------------------+
| components            | 写入矢量场的分量                                                 |
+-----------------------+------------------------------------------------------------------+
| ddt                   | 计算场的时间导数                                                 |
+-----------------------+------------------------------------------------------------------+
| div                   | 计算场的散度                                                     |
+-----------------------+------------------------------------------------------------------+
| enstrophy             | 计算场的涡度拟能                                                 |
+-----------------------+------------------------------------------------------------------+
| flowType              | 输出速度场类型，-1 表示有旋流；0 表示剪切流；+1 表示其他类型流动 |
+-----------------------+------------------------------------------------------------------+
| grad                  | 计算场的梯度                                                     |
+-----------------------+------------------------------------------------------------------+
| mag                   | 计算场的模                                                       |
+-----------------------+------------------------------------------------------------------+
| magSqr                | 计算场的模的平方                                                 |
+-----------------------+------------------------------------------------------------------+
| randomize             | 对场添加随机分量，扰动量可以指定                                 |
+-----------------------+------------------------------------------------------------------+
| scale                 | 对场进行缩放                                                     |
+-----------------------+------------------------------------------------------------------+
| streamFunction        | 计算网格点的流函数；计算面通量                                   |
+-----------------------+------------------------------------------------------------------+
| substract             | 从某个场中减去某个场的值                                         |
+-----------------------+------------------------------------------------------------------+
| turbulenceFields      | 计算给定的湍流场                                                 |
+-----------------------+------------------------------------------------------------------+
| turbulenceIntensity   | 计算湍流强度场                                                   |
+-----------------------+------------------------------------------------------------------+
| vorticity             | 计算涡量场，例如速度的旋度                                       |
+-----------------------+------------------------------------------------------------------+
| wallShearStress       | 计算壁面剪切力，输出体矢量场                                     |
+-----------------------+------------------------------------------------------------------+
| wallHeatFlux          | 计算壁面热通量，输出体矢量场                                     |
+-----------------------+------------------------------------------------------------------+
| wallHeatTransferCoeff | 计算边界场的壁面换热系数                                         |
+-----------------------+------------------------------------------------------------------+
| writeCellCenters      | 通过体矢量场的方式输出网格体心矢量                               |
+-----------------------+------------------------------------------------------------------+
| writeCellVolumes      | 通过体标量场的方式输出网格单元体积                               |
+-----------------------+------------------------------------------------------------------+
| writeObjects          | 输出某些特定场                                                   |
+-----------------------+------------------------------------------------------------------+
| yPlus                 | 计算湍流的 y+                                                    |
+-----------------------+------------------------------------------------------------------+


流率计算
^^^^^^^^^

+--------------------+----------------------------------------------------------------------------------+
| functionObject     | 作用                                                                             |
+====================+==================================================================================+
| flowRateFaceZone   | 计算patch特定面区域的流量。有可能是体积通量，也有可能是质量通量                  |
+--------------------+----------------------------------------------------------------------------------+
| flowRatePatch      | 计算patch的流量。有可能是体积通量，也有可能是质量通量                            |
+--------------------+----------------------------------------------------------------------------------+
| volFlowRateSurface | 计算三角面的体积通量，速度的计算采用对面表面进行插值并积分。建议三角的面积足够小 |
+--------------------+----------------------------------------------------------------------------------+




提取制图
^^^^^^^^^^

+----------------+----------------------+
| functionObject | 作用                 |
+================+======================+
| singleGraph    | 提取某一条线上的数据 |
+----------------+----------------------+

拉格朗日数据
^^^^^^^^^^^^^^^^

+----------------+------------------------------------------------------------------+
| functionObject | 作用                                                             |
+================+==================================================================+
| dsmcFields     | 从DSMC计算结果中提取UMean、translationalT、internalT以及overallT |
+----------------+------------------------------------------------------------------+


监控极值
^^^^^^^^^

+------------------+----------------------------------------------+
| functionObject   | 作用                                         |
+==================+==============================================+
| cellMax          | 对于一个或多个场，输出最大的值               |
+------------------+----------------------------------------------+
| cellMin          | 对于一个或多个场，输出最小的值               |
+------------------+----------------------------------------------+
| faceMax          | 对于一个或多个场，输出面上最大的值           |
+------------------+----------------------------------------------+
| faceMin          | 对于一个或多个场，输出面上最小的值           |
+------------------+----------------------------------------------+
| minMaxComponents | 通过非标量的形式，输出最大最小值以及位置     |
+------------------+----------------------------------------------+
| MinMaxMagnitude  | 通过非标量的形式，输出最大最小值的模以及位置 |
+------------------+----------------------------------------------+


数据格式
^^^^^^^^^^^^

+----------------+----------------------------------------------------------------------+
| functionObject | 作用                                                                 |
+================+======================================================================+
| residuals      | 对于指定场，输出每个时间步迭代的初始残差。对于矢量场，输出最大的分量 |
+----------------+----------------------------------------------------------------------+
| Time           | 写入运行时间、CPU时间、钟表时间                                      |
+----------------+----------------------------------------------------------------------+


压力工具
^^^^^^^^^^

+-----------------------------+------------------------------------+
| functionObject              | 作用                               |
+=============================+====================================+
| pressureDifferencePatch     | 计算两个patch的平均压力差          |
+-----------------------------+------------------------------------+
| pressureDifferenceSurface   | 将压力插值在三角面并计算平均压力差 |
+-----------------------------+------------------------------------+
| staticPressure              | 通过指定的密度计算动压             |
+-----------------------------+------------------------------------+
| totalPressureCompressible   | 计算可压缩求解器的总压             |
+-----------------------------+------------------------------------+
| totalPressureIncompressible | 计算不可压缩求解器的动力总压       |
+-----------------------------+------------------------------------+

探针
^^^^^^

+-----------------+----------------------------------------------------------------------------+
| functionObject  | 作用                                                                       |
+=================+============================================================================+
| boundaryCloud   | 输出场在某 patch 上指定位置的值                                            |
+-----------------+----------------------------------------------------------------------------+
| interfaceHeight | 对于一系列的点，输出界面的高度。这个高度是在这个点上，界面和壁面的垂直距离 |
+-----------------+----------------------------------------------------------------------------+
| internalCloud   | 输出场在指定位置的值                                                       |
+-----------------+----------------------------------------------------------------------------+
| Probes          | 输出场在指定位置距离最近的网格单元的值                                     |
+-----------------+----------------------------------------------------------------------------+

外挂求解器
^^^^^^^^^^^^^^^

+----------------------------+--------------------+
| functionObject             | 作用               |
+============================+====================+
| scalarTransport            | 求解标量场传输方程 |
+----------------------------+--------------------+
| icoUncoupledKinematicCloud | 求解拉格朗日粒子云 |
+----------------------------+--------------------+

可视化工具
^^^^^^^^^^^^^^

+----------------+---------------------------------+
| functionObject | 作用                            |
+================+=================================+
| streamlines    | 通过VTK格式输出流线数据         |
+----------------+---------------------------------+
| surfaces       | 通过VTK格式输出切割面、等值面等 |
+----------------+---------------------------------+




ParaView
-------------

画截面上的流线
^^^^^^^^^^^^^^^^

paraview的Stream Tracer无法直接作一个截面上的流线。比如，对于OpenFOAM的算例，即使是二维算例，截取一个面后，用 Stream tracer 无法得到流线。解决办法是存在的，本篇介绍如果通过一系列filter的组合来得到截面上的流线。

1. 作出需要查看流线的截面Slice；
2. 对上述截面添加Filters/Alphabetical/Surface Vector，让速度矢量投影到平面上；
3. 对得到的Surface Vector使用Filters/Alphabetical/Mask Points，生成一系列参考点用于绘制流线。
   
在MaskPoints中需要调节On Ratio参数以及Maximum number of points参数。其中，On Ratio控制取点的疏密，表示每多少个点中取一个；Maximum number of points控制总点数的数目；一般会勾选Random Sampling以及Generate Vertices。

4. 开启Filters/Alphabetical/Stream Tracer with Custom Source，分别选择上述的SurfaceVector作为Input，选择上述的MaskPoints作为Seed Source。
   

.. note:: 流线的疏密可以通过MaskPoints的点数量来控制，但是点数的空间分布不容易控制。





运算函数定义
===============

张量运算符
-------------

进入src/OpenFOAM/dimensionedTypes/dimensionedTensor/dimensionedTensor.H文件可以看到声明的张量运算符：

.. code-block:: C

    dimensionedScalar tr(const dimensionedTensor&);    // 取张量的迹
    dimensionedTensor dev(const dimensionedTensor&);   
    dimensionedTensor dev2(const dimensionedTensor&);
    dimensionedScalar det(const dimensionedTensor&);    // 取张量的行列式
    dimensionedTensor cof(const dimensionedTensor&);
    dimensionedTensor inv(const dimensionedTensor&);
    dimensionedSymmTensor symm(const dimensionedTensor&);
    dimensionedSymmTensor twoSymm(const dimensionedTensor&);
    dimensionedTensor skew(const dimensionedTensor&);

    dimensionedVector eigenValues(const dimensionedTensor&);    // 求特征值
    dimensionedTensor eigenVectors(const dimensionedTensor&);    // 求特征向量

    dimensionedVector eigenValues(const dimensionedSymmTensor&);    // 对称张量情况下求特征值
    dimensionedTensor eigenVectors(const dimensionedSymmTensor&);    // 对称张量情况下求特征向量









求解器代码解读
==================

文件信息读取
--------------

位于system文件夹内的fvSchemes和fvSolution文件通过mesh对象进行获取，调用的是下面的两个函数：

.. code-block:: C
    :caption: src/finiteVolume/fvMesh/fvMesh.C

    const Foam::fvSchemes& Foam::fvMesh::schemes() const
    {
        if (!fvSchemes_.valid())
        {
            fvSchemes_ = new fvSchemes(*this);
        }

        return fvSchemes_;
    }


    const Foam::fvSolution& Foam::fvMesh::solution() const
    {
        if (!fvSolution_.valid())
        {
            fvSolution_ = new fvSolution(*this);
        }

        return fvSolution_;
    }

位于constant文件夹内的physicalProperties文件同样通过mesh对象进行获取，最底层的调用函数为：

.. code-block:: C
    :caption: src/physicalProperties/physicalProperties/physicalProperties.C

    Foam::IOobject Foam::physicalProperties::findModelDict
    (
        const objectRegistry& obr,
        const word& group,
        bool registerObject
    )
    {
        typeIOobject<IOdictionary> physicalPropertiesIO
        (
            IOobject::groupName(physicalProperties::typeName, group),
            obr.time().constant(),
            obr,
            IOobject::MUST_READ_IF_MODIFIED,
            IOobject::NO_WRITE,
            registerObject
        );

        if (physicalPropertiesIO.headerOk())
        {
            return physicalPropertiesIO;
        }
        else
        {
            typeIOobject<IOdictionary> thermophysicalPropertiesIO
            (
                IOobject::groupName("thermophysicalProperties", group),
                obr.time().constant(),
                obr,
                IOobject::MUST_READ_IF_MODIFIED,
                IOobject::NO_WRITE,
                registerObject
            );

            if (thermophysicalPropertiesIO.headerOk())
            {
                return thermophysicalPropertiesIO;
            }
            else
            {
                typeIOobject<IOdictionary> transportPropertiesIO
                (
                    IOobject::groupName("transportProperties", group),
                    obr.time().constant(),
                    obr,
                    IOobject::MUST_READ_IF_MODIFIED,
                    IOobject::NO_WRITE,
                    registerObject
                );

                if (transportPropertiesIO.headerOk())
                {
                    return transportPropertiesIO;
                }
                else
                {
                    return physicalPropertiesIO;
                }
            }
        }
    }


    // * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //

    Foam::physicalProperties::physicalProperties
    (
        const fvMesh& mesh,
        const word& group
    )
    :
        IOdictionary(findModelDict(mesh, group, true))
    {
        // Ensure name of IOdictionary is typeName
        rename(IOobject::groupName(physicalProperties::typeName, group));
    }

不过一般会通过basicThermo以及相应选择的热物理模型库来进行调用，例如在使用psiThermo模型库的求解器中，读取physicalProperties所调用的函数如下：

.. code-block:: C
    :caption: src/thermophysicalModels/basic/basicThermo/basicThermoTemplates.C

    template<class Thermo>
    Foam::autoPtr<Thermo> Foam::basicThermo::New
    (
        const fvMesh& mesh,
        const word& phaseName
    )
    {
        const IOdictionary thermoDict
        (
            physicalProperties::findModelDict(mesh, phaseName)
        );

        typename Thermo::fvMeshConstructorTable::iterator cstrIter =
            lookupCstrIter<Thermo, typename Thermo::fvMeshConstructorTable>
            (
                thermoDict,
                Thermo::fvMeshConstructorTablePtr_
            );

        return autoPtr<Thermo>(cstrIter()(mesh, phaseName));
    }

.. code-block:: C
    :caption: src/thermophysicalModels/basic/psiThermo/psiThermo.C

    Foam::autoPtr<Foam::psiThermo> Foam::psiThermo::New
    (
        const fvMesh& mesh,
        const word& phaseName
    )
    {
        return basicThermo::New<psiThermo>(mesh, phaseName);
    }

.. code-block:: C
    :caption: src/thermophysicalModels/basic/psiThermo/psiThermo.H

    static autoPtr<psiThermo> New
    (
        const fvMesh& mesh,
        const word& phaseName=word::null
    );


一个简单的应用案例如下：

.. code-block:: C

    autoPtr<psiThermo> pThermo
    (
        psiThermo::New(mesh)
    );
    psiThermo& thermo = pThermo();


位于constant文件夹内的momentumTransport文件同样通过mesh对象进行获取，最底层的调用函数为：

.. code-block:: C
    :caption: src/MomentumTransportModels/momentumTransportModels/momentumTransportModel.C

    Foam::typeIOobject<Foam::IOdictionary>
    Foam::momentumTransportModel::readModelDict
    (
        const objectRegistry& obr,
        const word& group,
        bool registerObject
    )
    {
        typeIOobject<IOdictionary> momentumTransport
        (
            IOobject::groupName(typeName, group),
            obr.time().constant(),
            obr,
            IOobject::MUST_READ_IF_MODIFIED,
            IOobject::NO_WRITE,
            registerObject
        );

        if (momentumTransport.headerOk())
        {
            return momentumTransport;
        }
        else
        {
            typeIOobject<IOdictionary> turbulenceProperties
            (
                IOobject::groupName("turbulenceProperties", group),
                obr.time().constant(),
                obr,
                IOobject::MUST_READ_IF_MODIFIED,
                IOobject::NO_WRITE,
                registerObject
            );

            if (turbulenceProperties.headerOk())
            {
                return turbulenceProperties;
            }
            else
            {
                return momentumTransport;
            }
        }
    }


    // * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //

    Foam::momentumTransportModel::momentumTransportModel
    (
        const volVectorField& U,
        const surfaceScalarField& alphaRhoPhi,
        const surfaceScalarField& phi,
        const viscosity& viscosity
    )
    :
        IOdictionary(readModelDict(U.db(), alphaRhoPhi.group(), true)),

        runTime_(U.time()),
        mesh_(U.mesh()),

        U_(U),
        alphaRhoPhi_(alphaRhoPhi),
        phi_(phi),
        viscosity_(viscosity)
    {
        // Ensure name of IOdictionary is typeName
        rename(IOobject::groupName(typeName, alphaRhoPhi.group()));
    }



.. code-block:: C
    :caption: src/ThermophysicalTransportModels/thermophysicalTransportModel/thermophysicalTransportModel.C

    Foam::thermophysicalTransportModel::thermophysicalTransportModel
    (
        const compressibleMomentumTransportModel& momentumTransport
    )
    :
        IOdictionary
        (
            IOobject
            (
                IOobject::groupName
                (
                    typeName, momentumTransport.alphaRhoPhi().group()
                ),
                momentumTransport.time().constant(),
                momentumTransport.mesh(),
                IOobject::READ_IF_PRESENT,
                IOobject::NO_WRITE
            )
        ),

        momentumTransportModel_(momentumTransport)
    {
        // Add run-time re-reading of thermophysicalTransport dictionary after construction to avoid problems if the dictionary is not present
        readOpt() = IOobject::MUST_READ_IF_MODIFIED;
        addWatch();
    }


一个经典的应用案例如下：

.. code-block:: C

    Info<< "Creating turbulence model\n" << endl;
    autoPtr<compressible::momentumTransportModel> turbulence
    (
        compressible::momentumTransportModel::New
        (
            rho,
            U,
            phi,
            thermo
        )
    );

    Info<< "Creating thermophysical transport model\n" << endl;
    autoPtr<fluidThermophysicalTransportModel> thermophysicalTransport
    (
        fluidThermophysicalTransportModel::New(turbulence(), thermo)
    );



在读取到文件内容之后，可以利用subDict()函数可以进一步读取文件中的子字典内容，调用的函数为

.. code-block:: C
    :caption: src/OpenFOAM/db/dictionary/dictionary.C

    const Foam::dictionary& Foam::dictionary::subDict(const word& keyword) const
    {
        const entry* entryPtr = lookupEntryPtr(keyword, false, true);

        if (entryPtr == nullptr)
        {
            FatalIOErrorInFunction(*this)
                << "keyword " << keyword << " is undefined in dictionary "
                << name()
                << exit(FatalIOError);
        }
        return entryPtr->dict();
    }


    Foam::dictionary& Foam::dictionary::subDict(const word& keyword)
    {
        entry* entryPtr = lookupEntryPtr(keyword, false, true);

        if (entryPtr == nullptr)
        {
            FatalIOErrorInFunction(*this)
                << "keyword " << keyword << " is undefined in dictionary "
                << name()
                << exit(FatalIOError);
        }
        return entryPtr->dict();
    }

下面是一个简单的应用案例：

.. code-block:: C

    p.mesh().schemes().subDict("divSchemes").subDict("dbns");


在读取到文件内子字典之后，需要使用lookup()函数来读取子字典内设置的关键词来得到其相应赋值，调用的函数为

.. code-block:: C
    :caption: src/OpenFOAM/db/IOobjectList/IOobjectList.C

    Foam::IOobject* Foam::IOobjectList::lookup(const word& name) const
    {
        HashPtrTable<IOobject>::const_iterator iter = find(name);

        if (iter != end())
        {
            if (IOobject::debug)
            {
                InfoInFunction << "Found " << name << endl;
            }

            return const_cast<IOobject*>(*iter);
        }
        else
        {
            if (IOobject::debug)
            {
                InfoInFunction << "Could not find " << name << endl;
            }

            return nullptr;
        }
    }


    Foam::IOobjectList Foam::IOobjectList::lookup(const wordRe& name) const
    {
        IOobjectList objectsOfName(size());

        forAllConstIter(HashPtrTable<IOobject>, *this, iter)
        {
            if (name.match(iter()->name()))
            {
                if (IOobject::debug)
                {
                    InfoInFunction << "Found " << iter.key() << endl;
                }

                objectsOfName.insert(iter.key(), new IOobject(*iter()));
            }
        }

        return objectsOfName;
    }


    Foam::IOobjectList Foam::IOobjectList::lookup(const wordReList& patterns) const
    {
        wordReListMatcher names(patterns);

        IOobjectList objectsOfName(size());

        forAllConstIter(HashPtrTable<IOobject>, *this, iter)
        {
            if (names.match(iter()->name()))
            {
                if (IOobject::debug)
                {
                    InfoInFunction << "Found " << iter.key() << endl;
                }

                objectsOfName.insert(iter.key(), new IOobject(*iter()));
            }
        }

        return objectsOfName;
    }


一个简单的应用案例如下：

.. code-block:: C

    const dictionary& subDict = p.mesh().schemes().subDict("divSchemes").subDict("dbns");
    word name = word(subDict.lookup("flux")) + "Flux" + word(subDict.lookup("limiter")) + "Limiter";


关于自定义文件的读取与输出可以参考 `OpenFOAM编程基础(2) -数据读取与保存 <https://blog.csdn.net/aha_miemie/article/details/122738115>`_ 。例如现在要读取一个位于constant文件夹内的一个名为customProperties的文件内容，则通过如下方式创建该文件对象：

.. code-block:: C

    IOdictionary custonProperties
    (
        IOobject
        (
            "customProperties",      // 目标文件名
            runtime().constant(),    // 目标文件路径
            mesh,
            IOobject::MUST_READ,
            IOobject::NO_WRITE
        )
    );

接下来就可以对该对象进行各种读取操作：

.. code-block:: C

    // 读取指定关键词所赋的文字内容
    word someWord;
    custonProperties.lookup("someWord") >> someWord;

    // 在读取时检查数据类型，并且设置默认初始值
    scalar someScalar;
    custonProperties.lookupOrDefault<scalar>("someScalar", 1.0) >> someScalar;

    // 读取指定关键词所赋的bool值
    bool someBool;
    custonProperties.lookupOrDefault<Switch>("someBool", true) >> someBool;

    // 读取指定关键词所赋的列表数据
    List<scalar> someList;
    custonProperties.lookup("someList") >> someList;

    // 读取指定关键词所赋的哈希表数据
    HashTable<vector, word> someHashTable;
    custonProperties.lookup("someHashTable") >> someHashTable;




源项处理策略
--------------

以下面关于 :math:`\phi` 的输运方程为例：

.. math::
    \begin{align}
    \frac{\partial \phi}{\partial t}
    + \nabla\cdot (\mathbf{U}\phi)
    - \nabla \cdot \gamma \nabla\phi
    = S_{\phi} 
    \end{align}

源项 :math:`S_{\phi}` 在实际情况下是比较复杂的，可能包含非线性项。为了求解稳定，通常对其线性化处理：

.. math::
    \begin{align}
    S_{\phi} = S_{u} + S_{p}\phi
    \end{align}

其中 :math:`S_{u}` 和 :math:`S_{p}` 可以与 :math:`\phi` 有关，也可以与 :math:`\phi` 无关。

将输运方程离散成 :math:`\mathbf{A}\mathbf{x} = \mathbf{b}` ，那么 :math:`S_{u}` 将进入 :math:`\mathbf{b}` ，而 :math:`S_{p}` 将变成 :math:`-S_{p}` 进入 :math:`\mathbf{A}` 的对角元素。如果 :math:`S_{p}` 为正，则将削弱 :math:`\mathbf{A}` 的对角占优，很可能造成线性方程组求解发散，因此在对源项进行线性化时必须保证 :math:`S_{p}` 为负或零。

进入src/finiteVolume/finiteVolume/fvm/fvmSup.C文件，对于从 :math:`\mathbf{b}` 中加上 :math:`S_{u}` 的操作在OpenFOAM中通过 :code:`fvm::Su()` 实现：

.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::fvMatrix<Type>>
    Foam::fvm::Su
    (
        const DimensionedField<Type, volMesh>& su,
        const GeometricField<Type, fvPatchField, volMesh>& vf
    )
    {
        const fvMesh& mesh = vf.mesh();

        tmp<fvMatrix<Type>> tfvm
        (
            new fvMatrix<Type>
            (
                vf,
                dimVol*su.dimensions()
            )
        );
        fvMatrix<Type>& fvm = tfvm.ref();

        fvm.source() -= mesh.V()*su.field();

        return tfvm;
    }

对于在系数矩阵 :math:`\mathbf{A}` 对角元素减去 :math:`S_{p}` 的操作在OpenFOAM中通过 :code:`fvm::Sp()` 实现：

.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::fvMatrix<Type>>
    Foam::fvm::Sp
    (
        const volScalarField::Internal& sp,
        const GeometricField<Type, fvPatchField, volMesh>& vf
    )
    {
        const fvMesh& mesh = vf.mesh();

        tmp<fvMatrix<Type>> tfvm
        (
            new fvMatrix<Type>
            (
                vf,
                dimVol*sp.dimensions()*vf.dimensions()
            )
        );
        fvMatrix<Type>& fvm = tfvm.ref();

        fvm.diag() += mesh.V()*sp.field();    // 在fvmB的系数矩阵对角处加上源sp，考虑==运算后即为在最终方程系数矩阵对角处减去源sp

        return tfvm;
    }

当源项为负数的时候，求解方程得到的值也可能为负值，但这对于一些不可能为负数的物理量（比如温度 :math:`T` 、湍动能 :math:`k` 、湍流比耗散率 :math:`\omega` ）来说是没有意义的。为了避免这种情况发生，可以将源项做如下处理：

.. math::
    \begin{align}
    S_{\phi} = S_{\text{const}} \approx S_{\text{const}}\frac{\phi_{n+1}}{\phi_{n}} 
    \end{align}

其中 :math:`S_{\text{const}}` 为负的源项。经过上述处理之后， :math:`-S_{\text{const}}/\phi_{n}` 将作为正数计入到系数矩阵的对角元素中，既增强了对角占优，又可以保证 :math:`\phi` 为非负。

对于复杂的源项，在不同位置的正负可能不同。为了使整个线性方程组的求解更加稳定，需要对正负源项分开处理，具体做法为：

- 如果 :math:`S_{\phi} < 0` ，则对其采用隐式离散，即 :math:`S_{u}=0` ， :math:`S_{p}=S_{\phi}/\phi_{0}` ，将其贡献计入 :math:`\mathbf{A}` 对角上。
- 如果 :math:`S_{\phi} > 0` ，则对其采用显式离散，即 :math:`S_{u}=S_{\phi}` ， :math:`S_{p}=0` ，将其贡献计入 :math:`\mathbf{b}` 中。

上面的操作通过 :code:`fvm::SuSp()` 来实现：

.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::fvMatrix<Type>>
    Foam::fvm::SuSp
    (
        const volScalarField::Internal& susp,
        const GeometricField<Type, fvPatchField, volMesh>& vf
    )
    {
        const fvMesh& mesh = vf.mesh();

        tmp<fvMatrix<Type>> tfvm
        (
            new fvMatrix<Type>
            (
                vf,
                dimVol*susp.dimensions()*vf.dimensions()
            )
        );
        fvMatrix<Type>& fvm = tfvm.ref();

        fvm.diag() += mesh.V()*max(susp.field(), scalar(0));    // 从fvmB系数矩阵对角加上正的susp，考虑==运算即为从最终系数矩阵对角上减去正的源susp

        fvm.source() -= mesh.V()*min(susp.field(), scalar(0))    // 从fvmB的b上减去负的susp，考虑==运算即为从最终方程b上加上负的源susp
            *vf.primitiveField();

        return tfvm;
    }



.. note:: 

    源项线性化的选择并不是唯一的，不同的选择有不同的精度和稳定性。例如，考虑如下形式的源项：

    .. math::
        \begin{align}
        S_{\phi} = 10 - 2\phi^{3}
        \end{align}

    上式包含非线性项 :math:`-2\phi^{3}` ，需要对其进行线性化处理。有多种方法可以选择：

    1. 令 :math:`S_{u} = 10 - 2\phi_{0}^{3}` ， :math:`S_{p}=0` ，即
    
    .. math::
        \begin{align}
        S_{\phi}^{n+1} = 10 - 2\phi_{n+1}^{3} \cong 10 - 2\phi_{n}^{3} + 0 \times \phi_{n+1}
        \end{align}

    2. 令 :math:`S_{u}=10` ， :math:`-2\phi_{0}^{2}` ，即
    
    .. math::
        \begin{align}
        S_{\phi}^{n+1} = 10 - 2\phi_{n+1}^{3} = 10 - 2\phi_{n+1}^{2}\cdot \phi_{n+1} \cong 10 - 2\phi_{n}^{2}\cdot \phi_{n+1}
        \end{align}

    3. 使用Picard's method，对 :math:`S_{\phi}` 在 :math:`\phi_{0}` 处进行泰勒展开，只保留一阶项：
    
    .. math::
        \begin{align}
        S_{\phi}^{n+1} \approx S_{\phi}^{n} + \frac{\partial S_{\phi}}{\partial \phi}\Big|_{\phi=\phi_{n}}(\phi_{n+1} - \phi_{n})
        = 10 - 2\phi_{n}^{3} + (-6\phi_{n}^{2})(\phi_{n+1} - \phi_{n})
        = 10 + 4\phi_{n}^{3} - 6\phi_{n}^{2}\cdot \phi_{n+1}
        \end{align}

    也即 :math:`S_{u}=10+4\phi_{n}^{3}` ， :math:`S_{p}=-6\phi_{n}^{2}` 。

    在上述三种不同的线性化方法中，第三种方法精度最高，第一种方法精度最低。


.. note:: 

    利用源项线性化处理可以实现指定某个网格单元的值。对于某一个单元P，如果需要指定该处的值为 :math:`\phi_{P,\text{desired}}` ，则可以对该单元施加如下线性化后的源项：

    .. math::
        \begin{align}
        S_{P} = A_{\text{large}}\phi_{P,\text{desired}} - A_{\text{large}}\phi_{P}
        \end{align}

    其中 :math:`A_{\text{large}}` 为一个很大的数，比如 :math:`10^{10}` 。对于单元P，将除源项之外的所有项离散后的方程表示为

    .. math::
        \begin{align}
        A_{P}\phi_{P} + \sum_{n\sim nb}^{N}A_{N}\phi_{N} = b_{P}
        \end{align}

    加上源项后，上式变为

    .. math::
        \begin{align}
        (A_{P} + A_{\text{large}})\phi_{P} + \sum_{n\sim nb}^{N}A_{N}\phi_{N} = b_{P} + A_{\text{large}}\phi_{P,\text{desired}}
        \end{align}

    如果满足 :math:`A_{\text{large}} \gg A_{P}` 、 :math:`A_{\text{large}} \gg A_{N}` 且 :math:`A_{\text{large}}\phi_{P,\text{desired}} \gg b_{P}` ，则求解得到的 :math:`\phi_{P}\approx \phi_{P,\text{desired}}` 。在需要修改某个网格单元的值时而不影响其他单元时（比如重叠网格的插值单元赋值），这种方法格外有用。


.. attention:: 

    在构建方程矩阵的时候会用到 :code:`==` 运算，该操作符已经被重载，实际进行的是两边的fvScalarMatrix对象进行相减操作。该运算的运算优先级低于+和-，因此==最后计算。方程矩阵代码执行时，先计算==左右两边的表达式，然后再将这两个对象进行==运算。也就是说，方程代码做的是类似fvmA-fvmB的操作，而源项放在fvmB中，由于fvmB是需要减去的，因此这可以解释上面的Su()、Sp()、SuSp()操作的正负号与正常理解的正负号相反的原因。

    下面是OpenFOAM重载==运算的代码。

.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::fvMatrix<Type>> Foam::operator==
    (
        const fvMatrix<Type>& A,
        const fvMatrix<Type>& B
    )
    {
        checkMethod(A, B, "==");
        return (A - B);
    }





laplacianFoam求解器
---------------------

laplacianFoam的createFields.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    Info<< "Reading field T\n" << endl;

    volScalarField T    // 定义在网格体中心的标量场T
    (
        IOobject
        (
            "T",                      // 场的名称(T),用于确定初始文件名称(T)以及变量名称(T)
            runTime.timeName(),       // 存储位置为运行时间(文件夹)
            mesh,                     // 注册于网格对象mesh中
            IOobject::MUST_READ,      // 该对象通过读取文件创建,必须进行读取
            IOobject::AUTO_WRITE      // 根据controlDict中的设置自动写入结果文件
        ),
        mesh    // 新建体心标量场(T)所用的网格对象,在createMesh.H创建
    );


    Info<< "Reading physicalProperties\n" << endl;

    // IOdictionary用于新建字典文件
    IOdictionary physicalProperties    // 参数控制文件声明通过文件physicalProperties读取
    (
        IOobject
        (
            "physicalProperties",                // 文件名
            runTime.constant(),                  // 文件位置，位于$case/constant
            mesh,                                // 网格对象，主要从事对象注册，以便由runTime.write()控制输出
            IOobject::MUST_READ_IF_MODIFIED,     // 在字典文件被更改的时候进行读取
            IOobject::NO_WRITE                   // 不输出，字典文件不需要输出
        )
    );


    Info<< "Reading diffusivity DT\n" << endl;

    // dimensionedScalar用于新建带单位标量，新建扩散率DT。因为各向同性，DT为常数
    dimensionedScalar DT
    (
        // 通过查询参数控制文件$case/constant/physicalProperties，初始化带单位标量
        // 查询关键字DT并读取
        physicalProperties.lookup("DT")
    );

    #include "createFvModels.H"
    #include "createFvConstraints.H"


laplacianFoam.C
^^^^^^^^^^^^^^^^^


laplacianFoam求解器用于求解热传递温度控制方程：

.. math::
    \begin{align}
    \frac{\partial T}{\partial t} - \nabla^{2}(D_{T}T) = 0 
    \end{align}

其中 :math:`T` 表示温度， :math:`t` 表示时间， :math:`D_{T}` 为热扩散系数，具体表达式为

.. math::
    \begin{align}
    D_{T} = \frac{k}{\rho C_{p}} 
    \end{align}

其中 :math:`k` 表示热传导系数， :math:`\rho` 为密度， :math:`C_{p}` 为比热容。

.. code-block:: C

    #include "fvCFD.H"            // 必备头文件。涉及到时间构建、矩阵组建、有限体积离散、网格组建、量纲设置等
    #include "fvModels.H"
    #include "fvConstraints.H"
    #include "simpleControl.H"    // 定义SIMPLE循环，使用SIMPLE循环必备头文件

    int main(int argc, char *argv[])
    {
        #include "setRootCaseLists.H"    // 必备头文件。根据输入参数argc和argv设置算例根目录rootcase

        #include "createTime.H"          // 创建时间对象，涉及到runTime控制。非定常求解器必备头文件
        #include "createMesh.H"          // 必备头文件。创建网格对象，根据$case/constant/polyMesh文件夹中的网格数据创建对象mesh

        simpleControl simple(mesh);      // 从网格mesh对象构造类simpleControl(基类:solutionControl)的对象simple

        #include "createFields.H"        // 创建场对象，位于求解器根目录

        Info<< "\nCalculating temperature distribution\n" << endl;

        while (simple.loop(runTime))    // 开始时间循环，采用SIMPLE算法必备语句
        {
            Info<< "Time = " << runTime.userTimeName() << nl << endl;

            fvModels.correct();
            
            // 是否进行非正交修正
            // 如果在fvSolution字典文件中设置为0就只求解控制方程一次，如果设置为n则求解控制方程n-1次
            while (simple.correctNonOrthogonal())
            {
                
                fvScalarMatrix TEqn    // 定义热传递温度控制方程
                (
                    fvm::ddt(T) - fvm::laplacian(DT, T)    // fvm表示隐式离散,返回有限体积稀疏矩阵类fvMatrix对象
                 ==                                        // fvMatrix的==操作符执行优先级最低。先将==左右的各项相加，最后执行==。而==操作符被重载了，实际上是-
                    fvModels.source(T)    // 源项
                );

                fvConstraints.constrain(TEqn);
                TEqn.solve();    // 求解方程。solve是FOAM名称空间的全局函数,参数为矩阵fvMatrix
                fvConstraints.constrain(T);
            }

            #include "write.H"    // 额外计算grad(T)并进行输出

            Info<< "ExecutionTime = " << runTime.elapsedCpuTime() << " s"
                << "  ClockTime = " << runTime.elapsedClockTime() << " s"
                << nl << endl;
        }

        Info<< "End\n" << endl;

        return 0;
    }


laplacianFoam的write.H
^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    if (runTime.writeTime())    // 当运行时间步到达输出时间的时候执行下面的内容
    {
        volVectorField gradT(fvc::grad(T));    // 计算T的梯度，结果是定义在网格体中心的向量场。fvc::grad显示离散计算能够直接得到结果

        volScalarField gradTx    // 定义在网格体中心的标量场gradTx
        (
            IOobject
            (
                "gradTx",
                runTime.timeName(),     // 位于时间文件夹
                mesh,
                IOobject::NO_READ,      // 不进行读取
                IOobject::AUTO_WRITE    // 到达输出时间步时自动进行输出
            ),
            gradT.component(vector::X)    // 取计算得到的gradT的x分量赋值给gradTx
        );

        volScalarField gradTy    // 定义在网格体中心的标量场gradTy
        (
            IOobject
            (
                "gradTy",
                runTime.timeName(),     // 位于时间文件夹
                mesh,
                IOobject::NO_READ,      // 不进行读取
                IOobject::AUTO_WRITE    // 到达输出时间步时自动进行输出
            ),
            gradT.component(vector::Y)    // 取计算得到的gradT的y分量赋值给gradTy
        );

        volScalarField gradTz    // 定义在网格体中心的标量场gradTz
        (
            IOobject
            (
                "gradTz",
                runTime.timeName(),     // 位于时间文件夹
                mesh,
                IOobject::NO_READ,      // 不进行读取
                IOobject::AUTO_WRITE    // 到达输出时间步时自动进行输出
            ),
            gradT.component(vector::Z)    // 取计算得到的gradT的z分量赋值给gradTz
        );


        runTime.write();    // 输出计算结果
    }



scalarTransportFoam求解器
---------------------------


scalarTransportFoam的createFields.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    Info<< "Reading field T\n" << endl;

    volScalarField T    // 定义在网格体中心的标量场T
    (
        IOobject
        (
            "T",
            runTime.timeName(),     // 位于时间文件夹
            mesh,
            IOobject::MUST_READ,    // 必须读取
            IOobject::AUTO_WRITE    // 根据controlDict设置自动输出
        ),
        mesh
    );


    Info<< "Reading field U\n" << endl;

    volVectorField U
    (
        IOobject
        (
            "U",
            runTime.timeName(),     // 位于时间文件夹
            mesh,
            IOobject::MUST_READ,    // 必须读取
            IOobject::AUTO_WRITE    // 根据controlDict设置自动输出
        ),
        mesh
    );


    Info<< "Reading physicalProperties\n" << endl;

    IOdictionary physicalProperties    // 创建physicalProperties
    (
        IOobject
        (
            "physicalProperties",               // 读取physicalProperties文件
            runTime.constant(),                 // 位于constant文件夹
            mesh,
            IOobject::MUST_READ_IF_MODIFIED,    // 修改后必须读取
            IOobject::NO_WRITE                  // 不进行输出
        )
    );


    Info<< "Reading diffusivity DT\n" << endl;

    dimensionedScalar DT    // 创建标量DT
    (
        physicalProperties.lookup("DT")    // 从physicalProperties文件中读取DT关键词的值
    );

    #include "createPhi.H"    // 创建通量场

    #include "createFvModels.H"
    #include "createFvConstraints.H"




scalarTransportFoam.C
^^^^^^^^^^^^^^^^^^^^^^^^^^

最基本的控制方程为

.. math::
    \begin{align}
        \frac{\partial (\rho T)}{\partial t} 
      + \nabla \cdot (\rho \mathbf{U}T) 
    =   \nabla \cdot (\Gamma \nabla T)
      + Q
    \end{align}

scalarTransportFoam处理的是 :math:`\rho` 和 :math:`\Gamma` 为常量的情况，因此上述方程可以简化为

.. math::
    \begin{align}
    \frac{\partial T}{\partial T} + \nabla \cdot (\mathbf{U}T) = \nabla \cdot (D_{T}\nabla T) + q
    \end{align}

其中 :math:`D_{T}=\frac{\Gamma}{\rho}` ， :math:`q = \frac{Q}{\rho}` 。


.. code-block:: C

    #include "fvCFD.H"
    #include "fvModels.H"
    #include "fvConstraints.H"
    #include "simpleControl.H"    // 使用SIMPLE算法必备头文件

    int main(int argc, char *argv[])
    {
        #include "setRootCaseLists.H"
        #include "createTime.H"
        #include "createMesh.H"

        simpleControl simple(mesh);

        #include "createFields.H"    // 创建场信息

        Info<< "\nCalculating scalar transport\n" << endl;

        #include "CourantNo.H"

        while (simple.loop(runTime))    // 开始SIMPLE算法循环
        {
            Info<< "Time = " << runTime.userTimeName() << nl << endl;

            fvModels.correct();

            while (simple.correctNonOrthogonal())
            {
                fvScalarMatrix TEqn    // 标量传输方程
                (
                    fvm::ddt(T)              // 非稳态项
                  + fvm::div(phi, T)         // 对流项
                  - fvm::laplacian(DT, T)    // 扩散项
                 ==
                    fvModels.source(T)       // 源项
                );

                TEqn.relax();
                fvConstraints.constrain(TEqn);
                TEqn.solve();    // 求解标量传输方程
                fvConstraints.constrain(T);
            }

            runTime.write();
        }

        Info<< "End\n" << endl;

        return 0;
    }




potentialFoam求解器
---------------------


potentialFoam的createFields.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    Info<< "Reading velocity field U\n" << endl;
    volVectorField U    // 定义在网格体中心的矢量场U
    (
        IOobject
        (
            "U",
            runTime.timeName(),     // 位于时间文件夹
            mesh,
            IOobject::MUST_READ,    // 必须读取
            IOobject::AUTO_WRITE    // 根据controlDict设置自动输出
        ),
        mesh
    );

    U = Zero;

    surfaceScalarField phi    // 定义在网格面中心的标量场phi
    (
        IOobject
        (
            "phi",
            runTime.timeName(),     // 位于时间文件夹
            mesh,
            IOobject::NO_READ,      // 不进行读取
            IOobject::AUTO_WRITE    // 根据controlDict设置自动输出
        ),
        fvc::flux(U)    // 速度场插值到网格面上后点乘面矢量得到通量
    );

    if (args.optionFound("initialiseUBCs"))
    {
        U.correctBoundaryConditions();
        phi = fvc::flux(U);
    }


    // Default name for the pressure field
    word pName("p");    // 使用pName关键字来表示p，只起到替换作用

    // Update name of the pressure field from the command-line option
    args.optionReadIfPresent("pName", pName);

    // Infer the pressure BCs from the velocity
    wordList pBCTypes
    (
        U.boundaryField().size(),
        fixedValueFvPatchScalarField::typeName
    );

    forAll(U.boundaryField(), patchi)
    {
        if (U.boundaryField()[patchi].fixesValue())
        {
            pBCTypes[patchi] = zeroGradientFvPatchScalarField::typeName;
        }
    }

    Info<< "Constructing pressure field " << pName << nl << endl;
    volScalarField p    // 定义在体中心的标量场p
    (
        IOobject
        (
            pName,
            runTime.timeName(),           // 处于时间文件夹
            mesh,
            IOobject::READ_IF_PRESENT,    // 如果存在则进行读取
            IOobject::NO_WRITE            // 不进行输出
        ),
        mesh,
        dimensionedScalar(pName, sqr(dimVelocity), 0),
        pBCTypes
    );

    // Infer the velocity potential BCs from the pressure
    wordList PhiBCTypes
    (
        p.boundaryField().size(),
        zeroGradientFvPatchScalarField::typeName
    );

    forAll(p.boundaryField(), patchi)
    {
        if (p.boundaryField()[patchi].fixesValue())
        {
            PhiBCTypes[patchi] = fixedValueFvPatchScalarField::typeName;
        }
    }

    Info<< "Constructing velocity potential field Phi\n" << endl;
    volScalarField Phi    // 定义在网格体中心的标量场，速度势场Phi
    (
        IOobject
        (
            "Phi",
            runTime.timeName(),           // 处于时间文件夹
            mesh,
            IOobject::READ_IF_PRESENT,    // 如果存在则读取
            IOobject::NO_WRITE            // 不进行读取
        ),
        mesh,
        dimensionedScalar(dimLength*dimVelocity, 0),
        PhiBCTypes
    );

    label PhiRefCell = 0;      // 初始化速度势流参考网格标签
    scalar PhiRefValue = 0;    // 初始化速度势流参考值
    setRefCell
    (
        Phi,
        potentialFlow.dict(),    // 读取potentialFlow子字典
        PhiRefCell,              // 设置速度势流参考网格标签
        PhiRefValue              // 设置速度势流参考值
    );
    mesh.schemes().setFluxRequired(Phi.name());

    #include "createMRF.H"




potentialFoam.C
^^^^^^^^^^^^^^^^^^^

首先有稳态不可压缩流体连续性方程：

.. math::
    \begin{align}
    \nabla \cdot \mathbf{U} = 0
    \end{align}

对于无粘无旋流，则必定存在一个势函数 :math:`\Phi` 使得(速度势与压力同向)

.. math::
    \begin{align}
    -\nabla \cdot \Phi = \mathbf{U}
    \end{align}

将上式代入连续性方程得到

.. math::
    \begin{align}
    -\nabla \cdot (\nabla \Phi) = \nabla \cdot \mathbf{U}
    \end{align}

该方程的离散形式为：

.. math::
    \begin{align}
    -\sum(\nabla \Phi)_{f}\cdot \mathbf{S}_{f} = \sum\mathbf{U}_{f}\cdot \mathbf{S}_{f} = \sum\phi_{f}
    \end{align}


.. attention:: 

    之所以没有直接考虑 :math:`-\nabla \cdot (\nabla \Phi)=0` 是因为这个方程离散后得到 :math:`-\sum(\nabla \Phi)_{f}\cdot \mathbf{S}_{f}=0` ，无法考虑速度边界条件的影响。而由于速度边界条件很可能不等于零，所以不能采用这个方程。

求解流程可以分为以下几步：

- 首先针对计算域，将初始化的 :math:`\mathbf{U}` 内部场设置为0，保证 :math:`\sum\phi_{f}` 在内部场为零。 :math:`\mathbf{U}` 的边界场需要自己给定，且不为零。
- 求解一次所离散的方程，获得 :math:`\Phi` 场。
- 对于内部场，由于 :math:`\sum\phi_{f}=0` ，因此在内部场有 :math:`\phi_{f} = -(\nabla \Phi)_{f}\cdot \mathbf{S}_{f}` 。
- 对于边界场，如果是固定值边界条件，那么 :math:`\sum\phi_{f}` 通过速度计算而来，为一个固定值；如果是零法向梯度边界，边界处有 :math:`\phi_{f} = -(\nabla \Phi)_{f}\cdot \mathbf{S}_{f}` 。
- 获得 :math:`\phi_{f}` 场后可以重组得到速度场 :math:`\mathbf{U}` 。
  
.. note:: 

    同时，在求解所离散的方程的时候，需要边界条件。速度的边界条件通常自行给定。 :math:`\Phi` 的边界条件在进口，因为已经给定速度，因此要给定零法向梯度边界条件。

.. code-block:: C

    #include "fvCFD.H"
    #include "nonOrthogonalSolutionControl.H"

    int main(int argc, char *argv[])
    {
        argList::addOption
        (
            "pName",
            "pName",
            "Name of the pressure field"
        );

        argList::addBoolOption
        (
            "initialiseUBCs",
            "Initialise U boundary conditions"
        );

        argList::addBoolOption
        (
            "writePhi",
            "Write the velocity potential field"
        );

        argList::addBoolOption
        (
            "writep",
            "Calculate and write the pressure field"
        );

        argList::addBoolOption
        (
            "withFunctionObjects",
            "execute functionObjects"
        );

        #include "setRootCaseLists.H"
        #include "createTime.H"
        #include "createMesh.H"

        nonOrthogonalSolutionControl potentialFlow(mesh, "potentialFlow");

        #include "createFields.H"    // 创建场信息

        Info<< nl << "Calculating potential flow" << endl;

        // Since solver contains no time loop it would never execute
        // function objects so do it ourselves
        runTime.functionObjects().start();    // 启动求解

        MRF.makeRelative(phi);
        adjustPhi(phi, U, p);

        // Non-orthogonal velocity potential corrector loop
        while (potentialFlow.correctNonOrthogonal())
        {
            fvScalarMatrix PhiEqn    // 势流方程
            (
                fvm::laplacian(dimensionedScalar(dimless, 1), Phi)    // 势流拉普拉斯项
             ==
                fvc::div(phi)    // 速度梯度项
            );

            PhiEqn.setReference(PhiRefCell, PhiRefValue);    // 设置势流参考网格和参考值
            PhiEqn.solve();    // 求解势流方程得到Phi

            if (potentialFlow.finalNonOrthogonalIter())
            {
                phi -= PhiEqn.flux();    // 通过速度势流得到通量
            }
        }

        Info<< "Continuity error = "
            << mag(fvc::div(phi))().weightedAverage(mesh.V()).value()
            << endl;

        U = fvc::reconstruct(MRF.absolute(phi));    // 通过通量重组出速度场
        U.correctBoundaryConditions();

        Info<< "Interpolated velocity error = "
            << (
                    sqrt(sum(sqr(fvc::flux(U) - MRF.absolute(phi))))
                   /sum(mesh.magSf())
               ).value()
            << endl;

        // Write U and phi
        U.write();      // 输出速度场
        phi.write();    // 输出通量场

        // Optionally write Phi
        if (args.optionFound("writePhi"))    // 如果设置了writePhi
        {
            Phi.write();    // 输出速度势流场
        }

        // Calculate the pressure field
        if (args.optionFound("writep"))    // 如果设置了writep则要计算压力场
        {
            Info<< nl << "Calculating approximate pressure field" << endl;

            label pRefCell = 0;        // 初始化压力参考网格标签
            scalar pRefValue = 0.0;    // 初始化压力参考值
            setRefCell
            (
                p,
                potentialFlow.dict(),    // 读取potentialFlow子字典
                pRefCell,                // 设置压力参考网格标签
                pRefValue                // 设置压力参考值
            );

            // Calculate the flow-direction filter tensor
            /* 计算速度场模长的平方值 |U|^{2} ，是定义在网格体中心的标量场 */
            volScalarField magSqrU(magSqr(U));

            /* 定义在网格体中心的对称张量场
               F为流向滤波张量，表示为 U^{2} / |U|^{2}
               small是一个极小数1.0e-6，用来避免除数为零 */
            volSymmTensorField F(sqr(U)/(magSqrU + small*average(magSqrU)));

            // Calculate the divergence of the flow-direction filtered div(U*U)
            // Filtering with the flow-direction generates a more reasonable
            // pressure distribution in regions of high velocity gradient in the
            // direction of the flow
            /*
               在流动方向的高速度梯度区域，按流动方向进行过滤，可使压力分布更加合理
            */
            volScalarField divDivUU    // 滤波后流向的散度，是定义在网格体中心的标量场
            (
                /*
                   \nabla \cdot (\frac{U^{2}}{|U|^{2}} \cdot \nabla \cdot (UU))
                */
                fvc::div
                (
                    F & fvc::div(phi, U),
                    "div(div(phi,U))"
                )
            );

            // Solve a Poisson equation for the approximate pressure
            while (potentialFlow.correctNonOrthogonal())
            {
                fvScalarMatrix pEqn    // 压力泊松方程，属于标量方程
                (
                    /*
                       \nabla^{2} p + \nabla \cdot (\frac{U^{2}}{|U|^{2}} \cdot \nabla \cdot (UU))
                    */
                    fvm::laplacian(p) + divDivUU
                );

                pEqn.setReference(pRefCell, pRefValue);    // 设置压力参考网格和参考值
                pEqn.solve();    // 求解压力泊松方程得到估计压力场
            }

            p.write();    // 输出压力场
        }

        runTime.functionObjects().end();    // 结束求解

        Info<< "ExecutionTime = " << runTime.elapsedCpuTime() << " s"
            << "  ClockTime = " << runTime.elapsedClockTime() << " s"
            << nl << endl;

        Info<< "End\n" << endl;

        return 0;
    }



potentialFoam的createControls.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

在求解器目录中还存在这个头文件，但是在potentialFoam.C中并没有调用。

.. code-block:: C

    const dictionary& potentialFlow
    (
        mesh.solution().dict().subDict("potentialFlow")
    );

    const int nNonOrthCorr
    (
        potentialFlow.lookupOrDefault<int>("nNonOrthogonalCorrectors", 0)
    );





icoFoam求解器
----------------


icoFoam的createFields.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    // 在此之前已经创建了runTime和mesh对象，可以直接使用runTime和mesh进行操作
    Info<< "Reading physicalProperties\n" << endl;      // 打印信息，提示要读取physicalProperties这个文件

    IOdictionary physicalProperties    // 创建physicalProperties对象
    (
        IOobject     // 通过IOobject读取physicalProperties文件内的信息
        (
            "physicalProperties",
            runTime.constant(),                   // 存在于constant文件夹下
            mesh,
            IOobject::MUST_READ_IF_MODIFIED,
            IOobject::NO_WRITE                    // 位于constant文件夹内的属性不进行输出
        )
    );

    dimensionedScalar nu    // 创建有量纲标量场-动力粘度场nu
    (
        "nu",                                           
        dimViscosity,
        physicalProperties.lookup("nu")    // 通过读取关键词nu的值进行创建
    );

    Info<< "Reading field p\n" << endl;
    volScalarField p    // 创建定义在网格体中心的标量场-压力场p
    (
        IOobject    // 通过IOobject读取p文件内的信息
        (
            "p",
            runTime.timeName(),     // 存在于时间文件夹下
            mesh,
            IOobject::MUST_READ,    // 必须进行读取
            IOobject::AUTO_WRITE    // 会自动进行输出
        ),
        mesh
    );


    Info<< "Reading field U\n" << endl;
    volVectorField U    // 创建定义在网格体中心的矢量场-速度场U
    (
        IOobject    // 通过IOobject读取U文件内的信息
        (
            "U",
            runTime.timeName(),     // 存在于时间文件夹下
            mesh,
            IOobject::MUST_READ,    // 必须进行读取
            IOobject::AUTO_WRITE    // 会自动进行输出
        ),
        mesh
    );


    #include "createPhi.H"    // 创建面通量场phi


    label pRefCell = 0;         // 标定网格参考的编号，首先初始化为了0
    scalar pRefValue = 0.0;     // 标定网格的参考值，首先初始化为了0。不可压缩流有意义的是参考压力值
    // 进入fvSolution文件查找PISP子字典，读取其中的pRefCell与pRefValue的值并进行更新
    setRefCell(p, mesh.solution().dict().subDict("PISO"), pRefCell, pRefValue);
    mesh.schemes().setFluxRequired(p.name());






icoFoam.C
^^^^^^^^^^^^^^^

icoFoam求解不可压缩流体，控制方程有两个：

.. math::
    \begin{align}
    \nabla \cdot \mathbf{U} = 0
    \end{align}

.. math::
    \begin{align}
    \frac{\partial \mathbf{U}}{\partial t}
    + \nabla\cdot(\mathbf{U}\mathbf{U}) 
    = 
    -\nabla \frac{p}{\rho} 
    + \nabla \cdot (\nu \nabla \mathbf{U}) 
    \end{align}

使用有限体积法处理动量方程得到

.. math::
    \begin{align}
    \frac{1}{\Delta t}\iint \bigg( 
    \frac{\partial \mathbf{U}}{\partial t}
    + \nabla\cdot(\mathbf{U}\mathbf{U}) 
    \bigg) \mathrm{d}V\mathrm{d}t
    = 
    \frac{1}{\Delta t}\iint \bigg(
    -\nabla \frac{p}{\rho} 
    + \nabla \cdot (\nu \nabla \mathbf{U}) 
    \bigg) \mathrm{d}V\mathrm{d}t
    \end{align}

接下来对各项进行离散处理。首先是时间项欧拉全隐式离散：

.. math::
    \begin{align}
    \frac{1}{\Delta t}\iint \frac{\partial \mathbf{U}}{\partial t} \mathrm{d}V\mathrm{d}t = \frac{(\mathbf{U}_{P}^{*} - \mathbf{U}_{P}^{t})}{\Delta t}V_{P}
    \end{align}

其中下标P表示当前网格，上标t表示当前时间步(已知)，上标*表示预测步。

对流项隐式离散利用了高斯定理：

.. math::
    \begin{align}
    \frac{1}{\Delta t}\iint \nabla \cdot (\mathbf{U}\mathbf{U}) \mathrm{d}V\mathrm{d}t 
    = \frac{1}{\Delta t}\iint (\mathbf{U}\mathbf{U}) \cdot \mathrm{d}\mathbf{S}\mathrm{d}t
    = \frac{1}{\Delta t}\sum (\mathbf{U}^{*}\mathbf{U}^{t})_{f} \cdot \mathbf{S}_{f} \Delta t
    = \sum \phi_{f}^{t} \mathbf{U}_{f}^{*}
    \end{align}

其中下标f表示插值到网格面上， :math:`\mathbf{S}_{f}` 为网格面矢量， :math:`\phi_{f}^{t}` 为网格面上当前时间步的通量。

扩散项隐式离散：

.. math::
    \begin{align}
    \frac{1}{\Delta t}\iint \nabla \cdot (\nu \nabla \mathbf{U}) \mathrm{d}V\mathrm{d}t
    = \frac{1}{\Delta t}\iint \nu \nabla \mathbf{U} \cdot \mathrm{d}\mathbf{S}\mathrm{d}t  
    = \sum (\nu \nabla \mathbf{U}^{*})_{f} \cdot \mathbf{S}_{f} 
    \end{align}

其中 :math:`\nabla \mathbf{U}^{*}` 定义在网格体中心， :math:`(\nabla \mathbf{U}^{*})_{f}` 定义在网格面中心。

为了方便，重新定义 :math:`p = \frac{p}{\rho}` 去掉密度，于是压力项显式离散为

.. math::
    \begin{align}
    \frac{1}{\Delta t} \iint - \nabla p~\mathrm{d}V\mathrm{d}t
    = \frac{1}{\Delta t}\iint - p ~\mathrm{d}\mathbf{S}\mathrm{d}t
    = -\sum (p_{f}^{t}\mathbf{S}_{f}) 
    \end{align}

将上面的离散结果全部应用到动量方程并将所有速度相关的项移到左边则得到

.. math::
    \begin{align}
    \frac{(\mathbf{U}_{P}^{*} - \mathbf{U}_{P}^{t})}{\Delta t}V_{P}
    + \sum \phi_{f}^{t} \mathbf{U}_{f}^{*}
    - \sum (\nu \nabla \mathbf{U}^{*})_{f} \cdot \mathbf{S}_{f}
    =
    - \sum (p_{f}^{t}\mathbf{S}_{f})
    \end{align}

左侧与速度相关的方程在icoFoam中通过如下方式组建：

.. code-block:: C

    fvVectorMatrix UEqn
    (
        fvm::ddt(U)
        + fvm::div(phi, U)
        - fvm::laplacian(nu, U)
    );  

右侧显式离散的压力梯度项则如下进行组建：

.. code-block:: C

    -fvc::grad(p)

上述方程中 :math:`\mathbf{U}_{P}^{*}` 作为未知数保留下来， :math:`\phi_{f}^{t}` 通过 :math:`\mathbf{U}_{P}^{t}` 插值计算得到。插值到面的过程需要自行选择格式，以均一网格上的中心线性格式为例则有

.. math::
    \begin{align}
    \mathbf{U}_{f}^{*} = \frac{\mathbf{U}_{P}^{*} + \mathbf{U}_{N}^{*}}{2}, \qquad p_{f}^{t} = \frac{p_{P}^{t} + p_{N}^{t}}{2}  
    \end{align}

其中下标P表示定义在当前网格的体中心，下标N表示定义在相邻网格的体中心。

为了使用紧致基架点防止数值振荡， :math:`(\nabla \mathbf{U}^{*})_{f} \cdot \mathbf{S}_{f}` 需要重新表示为面法向梯度乘以面矢量的模，即

.. math::
    \begin{array}{c}
    (\nabla \mathbf{U}^{*})_{f} \cdot \mathbf{S}_{f}
    = \bigg( (\nabla \mathbf{U}^{*})_{f} \cdot \frac{\mathbf{S}_{f}}{|\mathbf{S}_{f}|} \bigg) \cdot |\mathbf{S}_{f}|
    \end{array}

上面的面法向梯度可以离散为

.. math::
    \begin{align}
    (\nabla \mathbf{U}^{*})_{f} \cdot \frac{\mathbf{S}_{f}}{|\mathbf{S}_{f}|}
    = \frac{\mathbf{U}_{N}^{*} - \mathbf{U}_{P}^{*}}{|\mathbf{d}|} 
    \end{align}

其中 :math:`\mathbf{d}` 表示相邻网格体中心之间的距离矢量。

将这些进一步的离散形式应用于动量方程则得到

.. math::
    \begin{align}
    \frac{\mathbf{U}_{P}^{*} - \mathbf{U}_{P}^{t}}{\Delta t}V_{P}
    + \sum \phi_{f}^{t} \frac{\mathbf{U}_{P}^{*} + \mathbf{U}_{N}^{*}}{2}
    - \sum \nu \frac{\mathbf{U}_{N}^{*} - \mathbf{U}_{P}^{*}}{|\mathbf{d}|} |\mathbf{S}_{f}|
    =
    - \sum \frac{p_{P}^{t} + p_{N}^{t}}{2} \mathbf{S}_{f}    
    \end{align}

按各速度项提取系数进行整理得到

.. math::
    \begin{align}
    \bigg( \frac{V_{P}}{\Delta t} + \sum\frac{\phi_{f}^{t}}{2} + \sum \nu\frac{|\mathbf{S}_{f}|}{|\mathbf{d}|} \bigg) \mathbf{U}_{P}^{*}
    + \sum \bigg( \frac{\phi_{f}^{t}}{2} - \nu \frac{|\mathbf{S}_{f}|}{|\mathbf{d}|} \bigg) \mathbf{U}_{N}^{*}
    - \frac{V_{P}}{\Delta t} \mathbf{U}_{P}^{t}
    =
    - \sum \frac{p_{P}^{t} + p_{N}^{t}}{2}\mathbf{S}_{f}  
    \end{align}

各系数记为

.. math::
    \begin{align}
    A_{P} &= \frac{V_{P}}{\Delta t} + \sum\frac{\phi_{f}^{t}}{2} + \sum \nu\frac{|\mathbf{S}_{f}|}{|\mathbf{d}|}  \\
    A_{N} &= \frac{\phi_{f}^{t}}{2} - \nu \frac{|\mathbf{S}_{f}|}{|\mathbf{d}|}  \\
    \end{align}

其中 :math:`A_{P}` 通过 :code:`UEqn.A()` 来得到，实际操作则是提取了关于U的线性方程组的系数矩阵的对角元素， :code:`A()` 操作定义于src/finiteVolume/fvMatrices/fvMatrix/fvMatrix.C文件当中的809行。在后续常以 :math:`1/A_{P}` 的形式出现，因此icoFoam如下进行定义：

.. code-block:: C

    volScalarField rAU(1.0/UEqn.A());

于是上式简写为

.. math::
    \begin{align}
    A_{P}\mathbf{U}_{P}^{*} + \sum A_{N}\mathbf{U}_{N}^{*} - \frac{V_{P}}{\Delta t} \mathbf{U}_{P}^{t} = - \sum \frac{p_{P}^{t} + p_{N}^{t}}{2}\mathbf{S}_{f}
    \end{align}

该方程称为 **动量预测方程** ，求解它就能够获得预测速度 :math:`\mathbf{U}_{P}^{*}` ：

.. code-block:: C

    if (piso.momentumPredictor())
    {
        solve(UEqn == -fvc::grad(p));
    }

.. note:: 不过动量预测步骤并不是必须的，如果不调用动量预测，则 :math:`\mathbf{U}_{P}^{*}=\mathbf{U}_{P}^{t}` 。


对连续性方程进行离散得到

.. math::
    \begin{align}
    \sum (\mathbf{U}_{P,f}^{t+\Delta t} \cdot \mathbf{S}_{f}) = 0
    \end{align}

其中上标 :math:`t+\Delta t` 表示下一时间步达到收敛状态的情况。下面要尝试使用压力来表示 :math:`\mathbf{U}_{P,f}^{t+\Delta t}` 。

重新来看动量预测方程，考虑 **达到收敛情况的动量预测方程** 则有

.. math::
    \begin{align}
    A_{P}\mathbf{U}_{P}^{t+\Delta t} + \sum A_{N}\mathbf{U}_{N}^{t+\Delta t} - \frac{V_{P}}{\Delta t} \mathbf{U}_{P}^{t} = - \sum p_{f}^{t+\Delta t}\mathbf{S}_{f}
    \end{align}

收敛情况下的动量预测方程和原始动量预测方程做减法则得到

.. math::
    \begin{align}
    A_{P}(\mathbf{U}_{P}^{t+\Delta t} - \mathbf{U}_{P}^{*})
    + \sum A_{N}(\mathbf{U}_{N}^{t+\Delta t} - \mathbf{U}_{N}^{*})
    = - \sum (p_{f}^{t+\Delta t} - p_{f}^{t}) \mathbf{S}_{f} 
    \end{align}


对收敛情况下的动量预测方程做移项得到 :math:`\mathbf{U}_{P}^{t+\Delta t}` 的表达式：

.. math::
    \begin{align}
    \mathbf{U}_{P}^{t+\Delta t}
    = 
    \mathbf{HbyA}_{P}^{t+\Delta t}
    - \frac{1}{A_{P}} \sum p_{f}^{t+\Delta t}\mathbf{S}_{f} 
    \end{align}

其中

.. math::
    \begin{align}
    \mathbf{HbyA}_{P}^{t+\Delta t} = \frac{1}{A_{P}} \Big( -\sum A_{N}\mathbf{U}_{N}^{t+\Delta t} + \frac{V_{P}}{\Delta t} \mathbf{U}_{P}^{t} \Big)  
    \end{align}

类似的，面上的速度则可以表示为

.. math::
    \begin{align}
    \mathbf{U}_{P,f}^{t+\Delta t}
    =
    \mathbf{HbyA}_{f}^{t+\Delta t}
    -\Big(\frac{1}{A_{P}}\Big)_{f} \Big( \sum p_{f}^{t+\Delta t}\mathbf{S}_{f} \Big)_{f}
    \end{align}

上式就成功将 :math:`\mathbf{U}_{P,f}^{t+\Delta t}` 表示为与压力有关的式子，代入到离散的连续性方程则得到

.. math::
    \begin{align}
    \sum \bigg( \mathbf{HbyA}_{f}^{t+\Delta t} -\Big(\frac{1}{A_{P}}\Big)_{f} \Big( \sum p_{f}^{t+\Delta t}\mathbf{S}_{f} \Big)_{f} \bigg) \cdot \mathbf{S}_{f} = 0
    \end{align}

将面矢量点乘乘进去并移项就得到了压力泊松方程的离散形式：

.. math::
    \begin{align}
    \sum \mathbf{HbyA}_{f}^{t+\Delta t} \cdot \mathbf{S}_{f} = \sum \Big(\frac{1}{A_{P}}\Big)_{f}\Big( \sum p_{f}^{t+\Delta t}\mathbf{S}_{f} \Big)_{f} \cdot \mathbf{S}_{f}
    \end{align}

其所表达的原始压力泊松方程的形式为

.. math::
    \begin{align}
    \nabla \cdot \mathbf{HbyA}^{t+\Delta t} = \nabla \cdot \Big( \frac{1}{A_{P}}\nabla p^{t+\Delta t} \Big) 
    \end{align}


.. attention:: 

    上述压力泊松方程的离散形式对 :math:`\nabla \cdot \Big( \frac{1}{A}\nabla p^{t+\Delta t} \Big)` 的处理是先求梯度再求散度，但是这样会引起数值振荡。为了调用紧致格式防止数值振荡，应当从原始压力泊松方程形式考虑，通过拉普拉斯并进行高斯积分进行离散。

目前我们只有通过动量预测方程求解出来的 :math:`\mathbf{U}_{P}^{*}` ，而 :math:`\mathbf{HbyA}_{P}^{t+\Delta t}` 和 :math:`p^{t+\Delta t}` 均未知，因此压力泊松方程尚不能求解。为了解决这个问题，Issa提出了PISO算法。依据PISO算法，重新考虑收敛情况下的动量预测方程和原始动量预测方程作差后的方程，引入忽略相邻点影响的假定，则有

.. math::
    \begin{align}
    A_{P}(\mathbf{U}_{P}^{t+\Delta t} - \mathbf{U}_{P}^{*}) = -\sum (p_{f}^{t+\Delta t} - p_{f}^{t}) \mathbf{S}_{f}
    \end{align}

将上式与原始动量方程相加得到

.. math::
    \begin{align}
    A_{P}\mathbf{U}_{P}^{**} + \sum A_{N}\mathbf{U}_{N}^{*} - \frac{V_{P}}{\Delta t} \mathbf{U}_{P}^{t} = - \sum p_{f}^{*}\mathbf{S}_{f}
    \end{align}

.. note:: 因为忽略了相邻点的影响，方程求解的结果将不会是准确的，也即两个方程相加将不会产生 :math:`\mathbf{U}_{P}^{t+\Delta t}` 和 :math:`p_{f}^{t+\Delta t}` ，而是预测值 :math:`\mathbf{U}_{P}^{**}` 和 :math:`p_{f}^{*}` 。

对上式进行移项得到 :math:`\mathbf{U}_{P}^{**}` 的表达式：

.. math::
    \begin{align}
    \mathbf{U}_{P}^{**} = \mathbf{HbyA}_{P}^{*} - \frac{1}{A_{P}}\sum p_{f}^{*}\mathbf{S}_{f}   
    \end{align}

其中

.. math::
    \begin{align}
    \mathbf{HbyA}_{P}^{*} = \frac{1}{A_{P}} \Big( -\sum A_{N}\mathbf{U}_{N}^{*} + \frac{V_{P}}{\Delta t} \mathbf{U}_{P}^{t} \Big)  
    \end{align}

使用 :code:`UEqn.H()` 来得到 :math:`-\sum A_{N}\mathbf{U}_{N}^{*} + \frac{V_{P}}{\Delta t} \mathbf{U}_{P}^{t}` ，实际操作内容的讨论见 `what's the meaning of UEqn().A() <https://www.cfd-online.com/Forums/openfoam/75661-whats-meaning-ueqn.html>`_  ， :code:`H()` 操作定义于src/finiteVolume/fvMatrices/fvMatrix/fvMatrix.C文件当中的831行。在icoFoam通过如下方式进行定义：

.. code-block:: C

    volVectorField HbyA(constrainHbyA(rAU*UEqn.H(), U, p));

类似的可以得到插值在面上的形式：

.. math::
    \begin{align}
    \mathbf{U}_{P,f}^{**} = \mathbf{HbyA}_{f}^{*} - \Big(\frac{1}{A_{P}}\Big)_{f} \Big(\sum p_{f}^{*}\mathbf{S}_{f}\Big)_{f}
    \end{align}

上式代入到离散的连续性方程则得到

.. math::
    \begin{align}
    \sum \bigg( \mathbf{HbyA}_{f}^{*} - \Big(\frac{1}{A_{P}}\Big)_{f} \Big(\sum p_{f}^{*}\mathbf{S}_{f}\Big)_{f} \bigg) \cdot \mathbf{S}_{f} = 0
    \end{align}

将面矢量点乘乘进去并移项则得到

.. math::
    \begin{align}
    \sum \mathbf{HbyA}_{f}^{*} \cdot \mathbf{S}_{f} =  \sum \Big(\frac{1}{A_{P}}\Big)_{f} \Big( \sum p_{f}^{*}\mathbf{S}_{f} \Big)_{f} \cdot \mathbf{S}_{f}
    \end{align}

其中 :math:`\mathbf{HbyA}_{f}^{*} \cdot \mathbf{S}_{f}` 用了一个定义在网格面中心的标量场来表示：

.. code-block:: C

    surfaceScalarField phiHbyA
    (
        "phiHbyA",
        fvc::flux(HbyA)
        + fvc::interpolate(rAU)*fvc::ddtCorr(U, phi)    // 保证速度通量的全局守恒，以确保压力方程有解
    );


如此也就成功组建得到了压力泊松方程：

.. math::
    \begin{align}
    \nabla \cdot \Big( \frac{1}{A_{P}}\nabla p^{*} \Big) = \nabla \cdot \mathbf{HbyA}^{*} 
    \end{align}

该压力泊松方程在icoFoam当中通过如下方式进行组建：

.. code-block:: C

    fvScalarMatrix pEqn
    (
        fvm::laplacian(rAU, p) == fvc::div(phiHbyA)
    );

.. attention:: :code:`fvc::div` 操作实际上进行的是加和操作。因此在进行这个操作之前总是要自行先计算出所需的通量。


求解该压力泊松方程后可以得到 :math:`p^{*}` ，回代到 :math:`\mathbf{U}_{P}^{**}` 的表达式就可以得到满足连续性方程的 :math:`\mathbf{U}_{P}^{**}` ：

.. code-block:: C

    U = HbyA - rAU*fvc::grad(p);

但是，由于忽略了相邻点的影响，此时求解得到的 :math:`p^{*}` 和 :math:`\mathbf{U}_{P}^{**}` 并不严格满足动量方程，因此还需要继续使用这两个量进行时间步内的循环迭代，即 :code:`while (piso.correct())` 循环。PISO算法在时间步内的迭代一般只需要3步即可。

除此之外，在每次求解出预测压力与预测速度之后，还会使用最新压力校正速度通量，以保证速度通量场严格守恒：

.. code-block:: C

    if (piso.finalNonOrthogonalIter())
    {
        phi = phiHbyA - pEqn.flux();
    }

其中 :code:`pEqn.flux()` 返回的内容是

.. code-block:: C

    fvc::interpolate(rUA)*fvc::snGrad(p)*mag(mesh.Sf())


.. note:: 

    在OpenFOAM中的通量计算有一点不同，主要差别在于 :math:`\phi^{*}` 被定义为了 :math:`\left ( \frac{A_{H}}{A_{D}} \right )_{f} \cdot \mathbf{S}_{f} + \phi_{e}` ，其中添加的 :math:`\phi_{e}` 为

    .. math::
        \begin{align}
        \phi_{e} = \frac{\gamma \rho}{A_{D}\Delta t}(\phi_{0}-\mathbf{S}_{f}\cdot\mathbf{U}_{f,0})
        \end{align}

    而 :math:`\gamma` 参数具体含义为

    .. math::
        \begin{align}
        \gamma = 1- \min\left ( \frac{|\phi_{0}-\mathbf{U}_{f,0}|\cdot\mathbf{S}_{f}}{|\phi_{0}|+\varepsilon},1  \right ) 
        \end{align}

icoFoam使用PISO算法求解NS方程，基本的步骤如下：

1. 根据初始条件(压力场、速度场等)求解预测速度场；
2. 根据预测速度求无压力梯度项的速度场；
3. 根据无压力梯度项的速度场求解压力(泊松)方程，得到压力场；
4. 根据压力场修正预测速度场以满足连续性方程；
5. 返回第二步，循环直到满足收敛要求。




.. code-block:: C

    #include "fvCFD.H"    // 有限体积库头文件的集合
    #include "pisoControl.H"    //定义PISO循环,使用PISO循环必备头文件

    int main(int argc, char *argv[])
    {
        #include "setRootCaseLists.H"     // 用于检查算例文件的结构是否正确
        #include "createTime.H"           // 创建runTime时间对象
        #include "createMesh.H"           // 创建mesh网格对象

        pisoControl piso(mesh);    // 从网格mesh对象构造类pisoControl(基类:solutionControl)的对象piso

        #include "createFields.H"          // 对场量进行初始化
        #include "initContinuityErrs.H"    // 初始化连续误差


        Info<< "\nStarting time loop\n" << endl;

        while (runTime.loop())
        {
            Info<< "Time = " << runTime.userTimeName() << nl << endl;

            #include "CourantNo.H"    // 计算库朗数并输出至屏幕

            // Momentum predictor

            fvVectorMatrix UEqn    // 创建了一个关于U的式子(U方程)，即动量方程等号左边的部分
            (
                fvm::ddt(U)              // 隐式离散时间导数项
              + fvm::div(phi, U)         // 隐式离散对流项
              - fvm::laplacian(nu, U)    // 隐式离散扩散项
            );
            
            // 动量预测求解开关，对于多相流以及低雷诺数一般设置为off
            // 通过fvSolution中momentumPredictor进行赋值
            if (piso.momentumPredictor())
            {
                // 求解动量方程，使用上一步的压力场，得到预测速度场
                solve(UEqn == -fvc::grad(p));    // 显式离散压强梯度项
            }

            // --- PISO loop
            while (piso.correct())    // 通过system/fvSolution中PISO字典中的nCorrectors关键词来指定循环次数
            {
                volScalarField rAU(1.0/UEqn.A());    // 创建一个定义在体中心的标量场rAU

                volVectorField HbyA(constrainHbyA(rAU*UEqn.H(), U, p));    // 创建一个定义在体中心的向量场HbyA

                surfaceScalarField phiHbyA    // 创建一个定义在面中心的标量场
                (
                    "phiHbyA",
                    fvc::flux(HbyA)                               // 将HbyA差分到面上，并点乘面矢量
                  + fvc::interpolate(rAU)*fvc::ddtCorr(U, phi)    // 这一项是OpenFOAM自己添加的项，保证速度通量的全局守恒以确保压力方程有解
                );

                /* 确保整个区域的净通量为0，即流入等于流出，
                   函数先统计流入和流出的量，如果两者不相等，那么调整速度assignable边界，
                   通过改动边界上的值使得整个体系通量守恒。
                   也就是要修正压力边界（梯度为0）上的phi，使其满足连续性方程。 */
                adjustPhi(phiHbyA, U, p);

                // Update the pressure BCs to ensure flux consistency
                constrainPressure(p, U, phiHbyA, rAU);    // //更正压力边界条件，保证通量守恒，用于修正fixedFluxPressure类压力边界条件

                // Non-orthogonal pressure corrector loop
                while (piso.correctNonOrthogonal())    // 网格非正交压力修正循环，需要指定nNonOrthogonalCorrectors的值来确定循环次数
                {
                    // Pressure corrector
                    // 构造泊松压力方程进行求解
                    fvScalarMatrix pEqn
                    (
                        fvm::laplacian(rAU, p) == fvc::div(phiHbyA)
                    );
                    
                    // 在不可压缩流动中，只有相对压力才起作用。除非存在边界压力
                    // 一个网格的压力可以任意设定，以产生独特的压力解决方案
                    pEqn.setReference(pRefCell, pRefValue);    // 设置压力参考值

                    pEqn.solve();    // 求解上述p方程，可以得到p的值

                    if (piso.finalNonOrthogonalIter())    // 使用求解的压力场修正通量场，即在最后一次修正的时候使通量守恒
                    {
                        phi = phiHbyA - pEqn.flux();
                    }
                }

                #include "continuityErrs.H"    // 计算连续性方程误差

                // 校正速度，满足边界条件(主要针对第二类边界条件）
                U = HbyA - rAU*fvc::grad(p);

                /* 上述隐式求解过程中U的边界条件不会参与，调用该函数之后才得到边界值，
                   该函数的主要作用是将GeometricField中的变量及时更新，
                   通常会在每一时间步的结束时刻调用一次，多次调用也不会出错。 */
                U.correctBoundaryConditions();
            }

            runTime.write();    // 输出时间

            Info<< "ExecutionTime = " << runTime.elapsedCpuTime() << " s"
                << "  ClockTime = " << runTime.elapsedClockTime() << " s"
                << nl << endl;
        }

        Info<< "End\n" << endl;

        return 0;
    }


.. note:: 

    更新通量phi采用 :code:`phi = phiHbyA - pEqn.flux()` 的方法，而不是在求解出正确速度场之后通过 :code:`phi = fvc::flux(U)` 来更新，这样可以保证通量phi是严格守恒的。由于U不存在守恒的概念，即使是通过正确的U插值求解通量也不能保证一定守恒。






pisoFoam求解器
------------------

pisoFoam的createFields.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    Info<< "Reading field p\n" << endl;
    volScalarField p    // 创建定义在网格体中心的标量场-压力场p
    (
        IOobject    // 通过IOobject读取p文件内的信息
        (
            "p",
            runTime.timeName(),     // 存在于时间文件夹下
            mesh,
            IOobject::MUST_READ,    // 必须进行读取
            IOobject::AUTO_WRITE    // 会自动进行输出
        ),
        mesh
    );

    Info<< "Reading field U\n" << endl;
    volVectorField U    // 创建定义在网格体中心的矢量场-速度场U
    (
        IOobject    // 通过IOobject读取U文件内的信息
        (
            "U",
            runTime.timeName(),     // 存在于时间文件夹下
            mesh,
            IOobject::MUST_READ,    // 必须读取
            IOobject::AUTO_WRITE    // 会自动进行输出
        ),
        mesh
    );

    #include "createPhi.H"    // 创建面通量场phi


    pressureReference pressureReference(p, piso.dict());

    mesh.schemes().setFluxRequired(p.name());

    // autoPtr是一个智能指针，不需要用户考虑内存释放等问题
    autoPtr<viscosityModel> viscosity(viscosityModel::New(mesh));    // 创建一个viscosity指针

    autoPtr<incompressible::momentumTransportModel> turbulence    // 创建一个turbulence指针
    (
        incompressible::momentumTransportModel::New(U, phi, viscosity)
    );

    #include "createMRF.H"
    #include "createFvModels.H"
    #include "createFvConstraints.H"


pisoFoam.C
^^^^^^^^^^^^^^

.. code-block:: C

    #include "fvCFD.H"
    #include "viscosityModel.H"
    #include "incompressibleMomentumTransportModels.H"   // 引入湍流模型
    #include "pisoControl.H"
    #include "pressureReference.H"
    #include "fvModels.H"
    #include "fvConstraints.H"

    int main(int argc, char *argv[])
    {
        #include "postProcess.H"

        #include "setRootCaseLists.H"
        #include "createTime.H"
        #include "createMesh.H"
        #include "createControl.H"
        #include "createFields.H"          // 创建场信息与粘度湍流指针
        #include "initContinuityErrs.H"    //定义标量的连续性误差为0

        turbulence->validate();

        Info<< "\nStarting time loop\n" << endl;

        while (runTime.loop())
        {
            Info<< "Time = " << runTime.userTimeName() << nl << endl;

            #include "CourantNo.H"

            // Pressure-velocity PISO corrector
            {
                fvModels.correct();

                #include "UEqn.H"    // 求解速度场

                // --- PISO loop
                while (piso.correct())
                {
                    #include "pEqn.H"    // 求解压力场
                }
            }

            viscosity->correct();     // 更新与粘度有关的量，涉及非牛顿流体系数
            turbulence->correct();    // 更新与所选湍流模型有关的量

            runTime.write();    // 输出时间

            Info<< "ExecutionTime = " << runTime.elapsedCpuTime() << " s"
                << "  ClockTime = " << runTime.elapsedClockTime() << " s"
                << nl << endl;
        }

        Info<< "End\n" << endl;

        return 0;
    }


pisoFoam的UEqn.H
^^^^^^^^^^^^^^^^^^

.. code-block:: C

    MRF.correctBoundaryVelocity(U);

    fvVectorMatrix UEqn
    (
        fvm::ddt(U) + fvm::div(phi, U)    // 隐式离散时间导数项和隐式离散对流项
      + MRF.DDt(U)                        // MRF方法旋转坐标系的额外项，用于动网格系统，
                                          // 这里表示\mathbf{\Omega } \times \mathbf{U}_{I} 。
      + turbulence->divDevSigma(U)        // 考虑湍流扩散效应的拉普拉斯项，
                                          // 不仅有基于分子间的粘性mu还有基于湍流的粘性mu_t 。
     ==
        fvModels.source(U)    // 动量方程的源项
    );

    UEqn.relax();    // 松弛技术，
                     // 对方程进行隐形松弛，用来提高矩阵的对角占优有利解；
                     // 对场进行显性松弛。

    fvConstraints.constrain(UEqn);

    if (piso.momentumPredictor())
    {
        // 求解动量方程
        // p是上一个时间步的压强，求解将会更新U，下面所有的U都将是这一步求解出来的U
        solve(UEqn == -fvc::grad(p));    // 显式离散压强梯度项

        fvConstraints.constrain(U);
    }

    //到了这里就得到了预测速度


pisoFoam的pEqn.H
^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    /* 创建一个定义在体中心的标量场rAU，
       UEqn.A()进行了A运算，返回的是A_{D}，
       因此rAU实际上是1/A_{D}。 */
    volScalarField rAU(1.0/UEqn.A());
    
    /* 创建一个定义在体中心的向量场HbyA，UEqn.H()进行了H运算返回的是A_{H}，
       因此HbyA实际上是A_{H}/A_{D}，constrainHbyA函数将U固定值边界条件赋给HbyA。 */
    volVectorField HbyA(constrainHbyA(rAU*UEqn.H(), U, p));
    
    surfaceScalarField phiHbyA    // 创建一个定义在面中心的标量场，这是一个中间通量\phi^{*}
    (          
        "phiHbyA",
        fvc::flux(HbyA)    // 将HbyA差分到面上，并点乘面矢量
      + MRF.zeroFilter(fvc::interpolate(rAU)*fvc::ddtCorr(U, phi))
    );
    
    MRF.makeRelative(phiHbyA);

    adjustPhi(phiHbyA, U, p);

    // Update the pressure BCs to ensure flux consistency
    constrainPressure(p, U, phiHbyA, rAU, MRF);    // 用于修正fixedFluxPressure类压力边界条件
    
    // Non-orthogonal pressure corrector loop
    while (piso.correctNonOrthogonal())    // 默认非正交修正为0
    {
        // Pressure corrector

        fvScalarMatrix pEqn
        (
            // 方程等号左边使用隐式离散，方程等号右边使用显式离散
            fvm::laplacian(rAU, p) == fvc::div(phiHbyA)
        );

        pEqn.setReference    // 设置压力参考值
        (
            pressureReference.refCell(),
            pressureReference.refValue()
        );

        pEqn.solve();     // 求解上述p方程，可以得到p的值

        if (piso.finalNonOrthogonalIter())    // 非正交修正的总迭代残差
        {
            /* 即 \phi = \phi^{*} - \phi^{**}，其中pEqn.flux()返回的\phi^{**}
               最终得到统一的、能够满足连续性方程的通量 */
            phi = phiHbyA - pEqn.flux();
        }
    }
    
    #include "continuityErrs.H"
    
    /* 使用修正后的压力场求解出正确的速度场，即
       \mathbf{U} = \frac{A_{H}}{A_{D}} - \frac{\nabla p}{A_{D}}
    */
    U = HbyA - rAU*fvc::grad(p);
    U.correctBoundaryConditions();
    fvConstraints.constrain(U);



rhoPimpleFoam求解器
----------------------

rhoPimpleFoam的createFields.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    #include "createRDeltaT.H"
    /* 位于src/finiteVolume/cfdTools/general/include文件夹中，与local Euler格式相关，执行内容为
        bool LTS = fv::localEulerDdt::enabled(mesh);

        tmp<volScalarField> trDeltaT;

        if (LTS)
        {
            Info<< "Using LTS" << endl;

            trDeltaT = tmp<volScalarField>
            (
                new volScalarField
                (
                    IOobject
                    (
                        fv::localEulerDdt::rDeltaTName,
                        runTime.timeName(),
                        mesh,
                        IOobject::READ_IF_PRESENT,
                        IOobject::AUTO_WRITE
                    ),
                    mesh,
                    dimensionedScalar(dimless/dimTime, 1),
                    extrapolatedCalculatedFvPatchScalarField::typeName
                )
            );
        }
    */

    Info<< "Reading thermophysical properties\n" << endl;

    autoPtr<fluidThermo> pThermo
    (
        fluidThermo::New(mesh)
    );
    fluidThermo& thermo = pThermo();
    thermo.validate(args.executable(), "h", "e");

    volScalarField& p = thermo.p();    // 创建压力场

    volScalarField rho    // 创建密度场
    (
        IOobject
        (
            "rho",
            runTime.timeName(),
            mesh,
            IOobject::READ_IF_PRESENT,
            IOobject::AUTO_WRITE
        ),
        thermo.rho()
    );

    Info<< "Reading field U\n" << endl;
    volVectorField U    // 创建速度场
    (
        IOobject
        (
            "U",
            runTime.timeName(),
            mesh,
            IOobject::MUST_READ,
            IOobject::AUTO_WRITE
        ),
        mesh
    );

    #include "compressibleCreatePhi.H"
    /* 位于src/fininteVolume/cfdTools/compressible文件夹，所执行代码如下
        Info<< "Reading/calculating face flux field phi\n" << endl;

        surfaceScalarField phi    // 创建质量通量场phi
        (
            IOobject
            (
                "phi",
                runTime.timeName(),
                mesh,
                IOobject::READ_IF_PRESENT,
                IOobject::AUTO_WRITE
            ),
            linearInterpolate(rho*U) & mesh.Sf()
        );
    */

    pressureReference pressureReference    // PIMPLE算法程序结构要求pref，但是由于是可压缩流，实际会返回false而不执行任何内容
    (
        p,
        pimple.dict(),
        thermo.incompressible()    // 可压缩流返回false
    );

    mesh.schemes().setFluxRequired(p.name());    // 将压力场设置为需要计算通量

    Info<< "Creating turbulence model\n" << endl;
    autoPtr<compressible::momentumTransportModel> turbulence    // 创建湍流指针
    (
        compressible::momentumTransportModel::New
        (
            rho,
            U,
            phi,
            thermo
        )
    );

    Info<< "Creating thermophysical transport model\n" << endl;
    autoPtr<fluidThermophysicalTransportModel> thermophysicalTransport
    (
        fluidThermophysicalTransportModel::New(turbulence(), thermo)
    );

    Info<< "Creating field dpdt\n" << endl;
    volScalarField dpdt    // 创建dpdt场
    (
        IOobject
        (
            "dpdt",
            runTime.timeName(),
            mesh
        ),
        mesh,
        dimensionedScalar(p.dimensions()/dimTime, 0)
    );

    Info<< "Creating field kinetic energy K\n" << endl;
    volScalarField K("K", 0.5*magSqr(U));    // 创建动能场

    dimensionedScalar initialMass = fvc::domainIntegrate(rho);    // 通过密度计算算域内总质量

    #include "createMRF.H"
    #include "createFvModels.H"
    #include "createFvConstraints.H"


rhoPimpleFoam.C
^^^^^^^^^^^^^^^^^^

.. code-block:: C

    #include "fvCFD.H"
    #include "fluidThermo.H"                            // 引入热物理物料模型
    #include "compressibleMomentumTransportModels.H"    // 引入可压缩流体湍流模型
    #include "fluidThermophysicalTransportModel.H"      // 引入热物理能量模型
    #include "pimpleControl.H"                          // PIMPLE算法必要头文件
    #include "pressureReference.H"                      // 为封闭体积模拟中的压力参考提供控制，可压缩流情况实际不起作用，这里是由于程序结构缘故引用
    #include "CorrectPhi.H"
    /* 执行内容如下
        // Calculate absolute flux from the mapped surface velocity
        phi = mesh.Sf() & rhoUf();

        correctUphiBCs(rho, U, phi, true);

        CorrectPhi
        (
            phi,
            p,
            rho,
            psi,
            dimensionedScalar("rAUf", dimTime, 1),
            divrhoU(),
            pimple
        );

        // Make the fluxes relative to the mesh-motion
        fvc::makeRelative(phi, rho, U);
    */
    #include "fvModels.H"
    #include "fvConstraints.H"
    #include "localEulerDdtScheme.H"    // local Euler格式必备头文件
    #include "fvcSmooth.H"

    int main(int argc, char *argv[])
    {
        #include "postProcess.H"

        #include "setRootCaseLists.H"
        #include "createTime.H"
        #include "createMesh.H"
        #include "createDyMControls.H"
        #include "initContinuityErrs.H"   // 声明并初始化累积连续性错误，执行语句为 scalar cumulativeContErr = 0;
        #include "createFields.H"         // 创建场信息与热物理模型
        #include "createFieldRefs.H"      // 创建可压缩性场psi，执行语句为 const volScalarField& psi = thermo.psi();
        #include "createRhoUfIfPresent.H"

        turbulence->validate();    // 初始化湍流场，主要是计算nut

        if (!LTS)    // 如果没有使用local Euler格式
        {
            #include "compressibleCourantNo.H"
            #include "setInitialDeltaT.H"
        }

        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

        Info<< "\nStarting time loop\n" << endl;

        while (pimple.run(runTime))
        {
            #include "readDyMControls.H"

            // Store divrhoU from the previous mesh so that it can be mapped and used in correctPhi to ensure the corrected phi has the same divergence
            autoPtr<volScalarField> divrhoU;
            if (correctPhi)
            {
                divrhoU = new volScalarField
                (
                    "divrhoU",
                    fvc::div(fvc::absolute(phi, rho, U))
                );
            }

            if (LTS)
            {
                #include "setRDeltaT.H"
            }
            else
            {
                #include "compressibleCourantNo.H"
                #include "setDeltaT.H"
            }

            fvModels.preUpdateMesh();

            // Store momentum to set rhoUf for introduced faces.
            autoPtr<volVectorField> rhoU;
            if (rhoUf.valid())
            {
                rhoU = new volVectorField("rhoU", rho*U);
            }

            // Update the mesh for topology change, mesh to mesh mapping
            mesh.update();

            runTime++;

            Info<< "Time = " << runTime.userTimeName() << nl << endl;

            // --- Pressure-velocity PIMPLE corrector loop
            while (pimple.loop())
            {
                if (pimple.firstPimpleIter() || moveMeshOuterCorrectors)
                {
                    // Move the mesh
                    mesh.move();

                    if (mesh.changing())    // 动网格的情况
                    {
                        MRF.update();

                        if (correctPhi)
                        {
                            #include "correctPhi.H"
                            /* 执行内容如下
                                // Calculate absolute flux from the mapped surface velocity
                                phi = mesh.Sf() & rhoUf();
                                correctUphiBCs(rho, U, phi, true);

                                CorrectPhi
                                (
                                    phi,
                                    p,
                                    rho,
                                    psi,
                                    dimensionedScalar("rAUf", dimTime, 1),
                                    divrhoU(),
                                    pimple
                                );

                                // Make the fluxes relative to the mesh-motion
                                fvc::makeRelative(phi, rho, U);
                            */

                        }

                        if (checkMeshCourantNo)
                        {
                            #include "meshCourantNo.H"
                        }
                    }
                }

                if (!mesh.schemes().steady() && !pimple.simpleRho() && pimple.firstPimpleIter())
                {
                    #include "rhoEqn.H"
                    /* 位于src/finiteVolume/cfdTools/compressible文件夹，执行内容为
                        fvScalarMatrix rhoEqn
                        (
                            fvm::ddt(rho)
                          + fvc::div(phi)
                          ==
                            fvModels.source(rho)
                        );

                        fvConstraints.constrain(rhoEqn);
                        rhoEqn.solve();
                        fvConstraints.constrain(rho);
                    */
                }

                fvModels.correct();

                #include "UEqn.H"    // 求解动量方程
                #include "EEqn.H"    // 求解能量方程

                // --- Pressure corrector loop
                while (pimple.correct())
                {
                    #include "pEqn.H"    // 求解压力方程
                }

                if (pimple.turbCorr())
                {
                    turbulence->correct();                 // 更新湍流模型相关参数
                    thermophysicalTransport->correct();    // 更新热物理模型相关参数
                }
            }

            if (!mesh.schemes().steady())    // 如果不是稳态问题
            {
                rho = thermo.rho();    // 更新密度场
            }

            runTime.write();

            Info<< "ExecutionTime = " << runTime.elapsedCpuTime() << " s"
                << "  ClockTime = " << runTime.elapsedClockTime() << " s"
                << nl << endl;
        }

        Info<< "End\n" << endl;

        return 0;
    }


rhoPimpleFoam的UEqn.H
^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    // Solve the Momentum equation

    MRF.correctBoundaryVelocity(U);

    tmp<fvVectorMatrix> tUEqn
    (
        fvm::ddt(rho, U) + fvm::div(phi, U)
      + MRF.DDt(rho, U)
      + turbulence->divDevTau(U)
     ==
        fvModels.source(rho, U)
    );
    fvVectorMatrix& UEqn = tUEqn.ref();
    UEqn.relax();
    fvConstraints.constrain(UEqn);

    if (pimple.momentumPredictor())
    {
        solve(UEqn == -fvc::grad(p));

        fvConstraints.constrain(U);
        K = 0.5*magSqr(U);
    }


rhoPimpleFoam的EEqn.H
^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    volScalarField& he = thermo.he();

    fvScalarMatrix EEqn
    (
        fvm::ddt(rho, he) + fvm::div(phi, he)
      + fvc::ddt(rho, K) + fvc::div(phi, K)
      + (
            he.name() == "e"
          ? fvc::div(fvc::absolute(phi, rho, U), p/rho)
          : -dpdt
        )
      + thermophysicalTransport->divq(he)
     ==
        fvModels.source(rho, he)
    );

    EEqn.relax();
    fvConstraints.constrain(EEqn);
    EEqn.solve();
    fvConstraints.constrain(he);
    thermo.correct();




rhoPimpleFoam的pEqn.H
^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    rho = thermo.rho();
    rho.relax();

    // Thermodynamic density needs to be updated by psi*d(p) after the pressure solution
    const volScalarField psip0(psi*p);

    const volScalarField rAU("rAU", 1.0/UEqn.A());
    const surfaceScalarField rhorAUf("rhorAUf", fvc::interpolate(rho*rAU));

    tmp<volScalarField> rAtU
    (
        pimple.consistent()
      ? volScalarField::New("rAtU", 1.0/(1.0/rAU - UEqn.H1()))
      : tmp<volScalarField>(nullptr)
    );
    tmp<surfaceScalarField> rhorAtUf
    (
        pimple.consistent()
      ? surfaceScalarField::New("rhoRAtUf", fvc::interpolate(rho*rAtU()))
      : tmp<surfaceScalarField>(nullptr)
    );

    const volScalarField& rAAtU = pimple.consistent() ? rAtU() : rAU;
    const surfaceScalarField& rhorAAtUf = pimple.consistent() ? rhorAtUf() : rhorAUf;

    volVectorField HbyA(constrainHbyA(rAU*UEqn.H(), U, p));

    if (pimple.nCorrPiso() <= 1)
    {
        tUEqn.clear();
    }

    surfaceScalarField phiHbyA
    (
        "phiHbyA",
        fvc::interpolate(rho)*fvc::flux(HbyA)
      + MRF.zeroFilter(rhorAUf*fvc::ddtCorr(rho, U, phi, rhoUf))
    );

    MRF.makeRelative(fvc::interpolate(rho), phiHbyA);

    // Update the pressure BCs to ensure flux consistency
    constrainPressure(p, rho, U, phiHbyA, rhorAAtUf, MRF);

    fvc::makeRelative(phiHbyA, rho, U);

    bool adjustMass = false;

    if (pimple.transonic())
    {
        const surfaceScalarField phid
        (
            "phid",
            (fvc::interpolate(psi)/fvc::interpolate(rho))*phiHbyA
        );

        const fvScalarMatrix divPhidp(fvm::div(phid, p));
        phiHbyA -= divPhidp.flux();

        if (pimple.consistent())
        {
            phiHbyA += (rhorAAtUf - rhorAUf)*fvc::snGrad(p)*mesh.magSf();
            HbyA += (rAAtU - rAU)*fvc::grad(p);
        }

        fvScalarMatrix pDDtEqn
        (
            fvc::ddt(rho) + psi*correction(fvm::ddt(p))
          + fvc::div(phiHbyA) + divPhidp
         ==
            fvModels.source(psi, p, rho.name())
        );

        while (pimple.correctNonOrthogonal())
        {
            fvScalarMatrix pEqn(pDDtEqn - fvm::laplacian(rhorAAtUf, p));

            // Relax the pressure equation to ensure diagonal-dominance
            pEqn.relax();

            pEqn.setReference
            (
                pressureReference.refCell(),
                pressureReference.refValue()
            );

            pEqn.solve();

            if (pimple.finalNonOrthogonalIter())
            {
                phi = phiHbyA + pEqn.flux();
            }
        }
    }
    else
    {
        if (mesh.schemes().steady())
        {
            adjustMass = adjustPhi(phiHbyA, U, p);
        }

        if (pimple.consistent())
        {
            phiHbyA += (rhorAAtUf - rhorAUf)*fvc::snGrad(p)*mesh.magSf();
            HbyA += (rAAtU - rAU)*fvc::grad(p);
        }

        fvScalarMatrix pDDtEqn
        (
            fvc::ddt(rho) + psi*correction(fvm::ddt(p))
          + fvc::div(phiHbyA)
         ==
            fvModels.source(psi, p, rho.name())
        );

        while (pimple.correctNonOrthogonal())
        {
            fvScalarMatrix pEqn(pDDtEqn - fvm::laplacian(rhorAAtUf, p));

            pEqn.setReference
            (
                pressureReference.refCell(),
                pressureReference.refValue()
            );

            pEqn.solve();

            if (pimple.finalNonOrthogonalIter())
            {
                phi = phiHbyA + pEqn.flux();
            }
        }
    }

    if (mesh.schemes().steady())
    {
        #include "incompressible/continuityErrs.H"
    }
    else
    {
        const bool constrained = fvConstraints.constrain(p);

        // Thermodynamic density update
        thermo.correctRho(psi*p - psip0);

        if (constrained)
        {
            rho = thermo.rho();
        }

        #include "rhoEqn.H"
        #include "compressibleContinuityErrs.H"
    }

    // Explicitly relax pressure for momentum corrector
    p.relax();

    U = HbyA - rAAtU*fvc::grad(p);
    U.correctBoundaryConditions();
    fvConstraints.constrain(U);
    K = 0.5*magSqr(U);

    if (mesh.schemes().steady())
    {
        fvConstraints.constrain(p);
    }

    // For steady compressible closed-volume cases adjust the pressure level to obey overall mass continuity
    if (adjustMass && !thermo.incompressible())
    {
        p += (initialMass - fvc::domainIntegrate(thermo.rho())) / fvc::domainIntegrate(psi);
        p.correctBoundaryConditions();
    }

    if (mesh.schemes().steady() || pimple.simpleRho() || adjustMass)
    {
        rho = thermo.rho();
    }

    // Correct rhoUf if the mesh is moving
    fvc::correctRhoUf(rhoUf, rho, U, phi, MRF);

    if (mesh.schemes().steady() || pimple.simpleRho())
    {
        rho.relax();
    }

    if (thermo.dpdt())
    {
        dpdt = fvc::ddt(p);

        if (mesh.moving())
        {
            dpdt -= fvc::div(fvc::meshPhi(rho, U), p);
        }
    }





rhoSimpleFoam求解器
----------------------

rhoSimpleFoam的createFields.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    Info<< "Reading thermophysical properties\n" << endl;

    autoPtr<fluidThermo> pThermo
    (
        fluidThermo::New(mesh)
    );
    fluidThermo& thermo = pThermo();
    thermo.validate(args.executable(), "h", "e");

    volScalarField& p = thermo.p();    // 创建定义在网格体中心的压力场p

    volScalarField rho    // 定义在网格体中心的标量场，密度场rho
    (
        IOobject
        (
            "rho",
            runTime.timeName(),           // 位于时间文件夹
            mesh,
            IOobject::READ_IF_PRESENT,    // 如果存在则读取
            IOobject::AUTO_WRITE          // 自动输出
        ),
        thermo.rho()    // 依据thermo设置计算rho
    );

    Info<< "Reading field U\n" << endl;
    volVectorField U    // 定义在网格体中心的矢量场，速度场U
    (
        IOobject
        (
            "U",
            runTime.timeName(),     // 位于时间文件夹
            mesh,
            IOobject::MUST_READ,    // 必须读取
            IOobject::AUTO_WRITE    // 自动输出
        ),
        mesh
    );

    #include "compressibleCreatePhi.H"
    /* 位于src/fininteVolume/cfdTools/compressible文件夹，所执行代码如下
        Info<< "Reading/calculating face flux field phi\n" << endl;

        surfaceScalarField phi    // 创建质量通量场phi
        (
            IOobject
            (
                "phi",
                runTime.timeName(),
                mesh,
                IOobject::READ_IF_PRESENT,
                IOobject::AUTO_WRITE
            ),
            linearInterpolate(rho*U) & mesh.Sf()
        );
    */


    pressureReference pressureReference    // SIMPLE算法程序结构要求pref，但是由于是可压缩流，实际会返回false而不执行任何内容
    (
        p,
        simple.dict(),
        thermo.incompressible()    // 可压缩流返回false
    );

    mesh.schemes().setFluxRequired(p.name());    // 将压力场设置为需要计算通量

    Info<< "Creating turbulence model\n" << endl;
    autoPtr<compressible::momentumTransportModel> turbulence    // 创建湍流指针
    (
        compressible::momentumTransportModel::New
        (
            rho,
            U,
            phi,
            thermo
        )
    );

    Info<< "Creating thermophysical transport model\n" << endl;
    autoPtr<fluidThermophysicalTransportModel> thermophysicalTransport
    (
        fluidThermophysicalTransportModel::New(turbulence(), thermo)
    );

    dimensionedScalar initialMass = fvc::domainIntegrate(rho);    // 通过密度计算算域内总质量

    #include "createMRF.H"
    #include "createFvModels.H"
    #include "createFvConstraints.H"


rhoSimpleFoam.C
^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    #include "fvCFD.H"
    #include "fluidThermo.H"                            // 引入热物理物料模型
    #include "compressibleMomentumTransportModels.H"    // 引入可压缩流体湍流模型
    #include "fluidThermophysicalTransportModel.H"      // 引入热物理能量模型
    #include "simpleControl.H"                          // SIMPLE算法必要头文件
    #include "pressureReference.H"                      // 为封闭体积模拟中的压力参考提供控制，可压缩流情况实际不起作用，这里是由于程序结构缘故引用
    #include "fvModels.H"
    #include "fvConstraints.H"

    int main(int argc, char *argv[])
    {
        #include "postProcess.H"

        #include "setRootCaseLists.H"
        #include "createTime.H"
        #include "createMesh.H"
        #include "createControl.H"
        #include "createFields.H"         // 创建场信息与热物理模型
        #include "createFieldRefs.H"      // 创建可压缩性场psi，执行语句为 const volScalarField& psi = thermo.psi();
        #include "initContinuityErrs.H"   // 声明并初始化累积连续性错误，执行语句为 scalar cumulativeContErr = 0;

        turbulence->validate();    // 初始化湍流场，主要是计算nut

        Info<< "\nStarting time loop\n" << endl;

        while (simple.loop(runTime))    // 开始SIMPLE循环
        {
            Info<< "Time = " << runTime.userTimeName() << nl << endl;

            fvModels.correct();

            // Pressure-velocity SIMPLE corrector
            #include "UEqn.H"    // 求解U方程，得到速度场
            #include "EEqn.H"    // 求解能量方程
            #include "pEqn.H"    // 求解压力方程，得到压力场

            turbulence->correct();                 // 更新湍流模型相关参数
            thermophysicalTransport->correct();    // 更新热物理模型相关参数

            runTime.write();    // 输出场文件

            Info<< "ExecutionTime = " << runTime.elapsedCpuTime() << " s"
                << "  ClockTime = " << runTime.elapsedClockTime() << " s"
                << nl << endl;
        }

        Info<< "End\n" << endl;

        return 0;
    }


rhoSimpleFoam的UEqn.H
^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    // Solve the Momentum equation

    MRF.correctBoundaryVelocity(U);

    tmp<fvVectorMatrix> tUEqn
    (
        fvm::div(phi, U)            // 对流项
      + MRF.DDt(rho, U)             // 科里奥利加速度
      + turbulence->divDevTau(U)    // 雷诺应力项
     ==
        fvModels.source(rho, U)    // 源项
    );
    fvVectorMatrix& UEqn = tUEqn.ref();    // 通过tmp创建之后要先引用再使用

    UEqn.relax();

    fvConstraints.constrain(UEqn);

    solve(UEqn == -fvc::grad(p));    // 求解动量方程

    fvConstraints.constrain(U);

其中MRF.DDt(rho, U)执行的内容为如下，它返回科里奥利加速度：

.. code-block:: C

    // 位于src/finiteVolume/cfdTools/general/MRF/MRFZoneList.C
    Foam::tmp<Foam::volVectorField> Foam::MRFZoneList::DDt
    (
        const volScalarField& rho,
        const volVectorField& U
    ) const
    {
        return rho*DDt(U);
    }

.. code-block:: C

    // 位于src/finiteVolume/finiteVolume/fvc/fvcDDt.C
    template<class Type>
    tmp<GeometricField<Type, fvPatchField, volMesh>>
    DDt
    (
        const surfaceScalarField& phi,
        const GeometricField<Type, fvPatchField, volMesh>& psi
    )
    {
        tmp<GeometricField<Type, fvPatchField, volMesh>> ddtDivPhiPsi
            = fvc::ddt(psi) + fvc::div(phi, psi);

        if (phi.mesh().moving())
        {
            return ddtDivPhiPsi - fvc::div(phi + phi.mesh().phi())*psi;
        }
        else
        {
            return ddtDivPhiPsi - fvc::div(phi)*psi;
        }
    }

参考 `MRF.DDt(U)---MRF模型简介 <https://blog.csdn.net/hanbingchegu/article/details/107326376>`_  ，MRF涉及旋转机械等的动网格技术，如果不使用MRF，则MRF.DDt(rho, U)可以忽略，因此求解的动量方程为

.. math::
    \begin{align}
    \nabla\cdot(\rho\mathbf{UU})
    + \nabla \cdot (\rho\mathbf{R}_{\text{eff}})
    - \nabla \cdot (\nu_{\text{eff}}\rho\nabla \mathbf{U})
    = -\nabla p
    \end{align}


rhoSimpleFoam的EEqn.H
^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    volScalarField& he = thermo.he();    // 创建能量场，根据设置可能是e或h

    fvScalarMatrix EEqn    // 组建能量方程
    (
        fvm::div(phi, he)
      + (
            he.name() == "e"
          ? fvc::div(phi, volScalarField("Ekp", 0.5*magSqr(U) + p/rho))
          : fvc::div(phi, volScalarField("K", 0.5*magSqr(U)))
        )
      + thermophysicalTransport->divq(he)
     ==
        fvModels.source(rho, he)
    );

    EEqn.relax();

    fvConstraints.constrain(EEqn);

    EEqn.solve();    // 求解能量方程

    fvConstraints.constrain(he);

    thermo.correct();
    

可以看到，针对热物理模型设置的不同，能量方程的表现形式也不同。如果能量场设置为内能e，则求解的能量方程为

.. math::
    \begin{align}
    \nabla \cdot (\rho \mathbf{U}e)
    + \nabla \cdot \Big(\rho\mathbf{U} (\frac{1}{2}|\mathbf{U}|^{2} + \frac{p}{\rho})\Big)
    + \nabla \cdot \mathbf{q}
    = S_{e}
    \end{align}

如果能量场设置为焓h，则求解的能量方程为

.. math::
    \begin{align}
    \nabla \cdot (\rho\mathbf{U}h)
    + \nabla\cdot (\rho\mathbf{U}\frac{1}{2}|\mathbf{U}|^{2})
    + \nabla \cdot \mathbf{q}
    = S_{h}
    \end{align}




rhoSimpleFoam的pEqn.H
^^^^^^^^^^^^^^^^^^^^^^^^


压力方程在高速流(transonic)和低速流两种情况下会有所不同。

对于 **低速流** 的情况，可以认为密度的变化并不是特别的大，那么在收敛的情况下可以认为

.. math::
    \begin{align}
    \mathbf{U}^{n+1} = \Big(\frac{\mathbf{H}}{A}\Big)^{n+1} - \frac{\nabla p^{n+1}}{A^{n+1}}
    \end{align}

从而速度修正量可以写成

.. math::
    \begin{align}
    \mathbf{U}' = \Big(\frac{\mathbf{H}}{A}\Big)' - \frac{\nabla p^{n+1}}{A^{n+1}} + \frac{\nabla p^{n}}{A^{n}} 
    \end{align}

假定忽略相邻点影响，上式改写为

.. math::
    \begin{align}
    \mathbf{U}' = - \frac{\nabla p^{n+1}}{A^{n+1}} + \frac{\nabla p^{n}}{A^{n}} 
    \end{align}

继续假定 :math:`A` 的变化较小，即 :math:`A^{n+1} = A^{n}` ，则

.. math::
    \begin{align}
    \mathbf{U}' = - \frac{\nabla p'}{A^{n}}
    \end{align}

将上式与考虑了相邻点影响的已知速度表示方程相加，得到

.. math::
    \begin{align}
    \mathbf{U}^{n+1} = \mathbf{U}^{n} + \mathbf{U}'
    = \Big(\frac{\mathbf{H}}{A}\Big)^{n} - \frac{\nabla p^{n+1}}{A^{n}}
    ,\quad 
    \mathbf{U}^{n+1}_{f} = \mathbf{U}^{n}_{f} + \mathbf{U}'_{f}
    = \Big(\frac{\mathbf{H}}{A}\Big)^{n}_{f} - \frac{(\nabla p^{n+1})_{f}}{A_{f}^{n}}
    \end{align}

考虑连续性方程（认为密度变化足够小）：

.. math::
    \begin{align}
    \sum \rho_{f}^{n}\mathbf{U}_{f}^{n+1} \cdot \mathbf{S}_{f} = 0
    \end{align}

将速度的表达式代入连续性方程，即可得到所求解的压力方程：

.. math::
    \begin{align}
    \sum \rho_{f}^{n} \Big(\frac{\mathbf{H}}{A}\Big)_{f}^{n} \cdot \mathbf{S}_{f}
    = \sum \rho_{f}^{n}\frac{(\nabla p^{n+1})_{f}}{A_{f}^{n}} \cdot \mathbf{S}_{f} 
    \end{align}

其中 :math:`\rho_{f}^{n} \Big(\frac{\mathbf{H}}{A}\Big)_{f}^{n} \cdot \mathbf{S}_{f}` 通过phiHbyA来表示：

.. code-block:: C

    const volScalarField rAU("rAU", 1.0/UEqn.A());

    volVectorField HbyA(constrainHbyA(rAU*UEqn.H(), U, p));

    surfaceScalarField phiHbyA
    (
        "phiHbyA",
        fvc::interpolate(rho)*fvc::flux(HbyA)
    );

而方程等号右侧是一个laplacian项，表示为

.. code-block:: C

    const surfaceScalarField rhorAUf("rhorAUf", fvc::interpolate(rho*rAU));

    const surfaceScalarField& rhorAAtUf = simple.consistent() ? rhorAtUf() : rhorAUf;

    fvm::laplacian(rhorAAtUf, p)

因此，低速流情况组建的压力方程表示为

.. code-block:: C

    fvScalarMatrix pEqn
    (
        fvc::div(phiHbyA)
      - fvm::laplacian(rhorAAtUf, p)
      ==
        fvModels.source(psi, p, rho.name())
    );


对于 **高速流** 的情况，连续性方程满足

.. math::
    \begin{align}
    \sum(\rho_{f}^{n} + \rho_{f}')(\mathbf{U}_{f}^{n} + \mathbf{U}_{f}')\cdot\mathbf{S}_{f} = 0
    \end{align}

其中 :math:`p_{f}'` 和 :math:`\mathbf{U}_{f}'` 表示修正量。进一步展开可以得到

.. math::
    \begin{align}
    0 = \sum\Big[(\rho_{f}^{n} + \rho_{f}')\mathbf{U}_{f}^{n} + \rho_{f}^{n}\mathbf{U}_{f}' + \rho_{f}'\mathbf{U}_{f}' \Big]
    \approx \sum\Big[(\rho_{f}^{n} + \rho_{f}')\mathbf{U}_{f}^{n} + \rho_{f}^{n}\mathbf{U}_{f}' \Big]
    \end{align}

引入略去相邻点影响的假定：

.. math::
    \begin{align}
    A\mathbf{U}' = \mathbf{H}(\mathbf{U}') - \nabla p' \approx - \nabla p'
    \quad \Rightarrow \quad
    \mathbf{U}' = - \frac{\nabla p'}{A^{n}} 
    ,\quad \mathbf{U}'_{f} = - \frac{(\nabla p')_{f}}{A^{n}_{f}} 
    \end{align}

同时还有考虑相邻点影响的已知速度场关系：

.. math::
    \begin{align}
    \mathbf{U}_{f}^{n} = \Big(\frac{\mathbf{H}}{A}\Big)_{f}^{n} - \frac{(\nabla p^{n})_{f}}{A_{f}^{n}}
    \end{align}

将它们代入到连续性方程中，得到

.. math::
    \begin{align}
    \sum(\rho_{f}^{n} + \rho_{f}')\Big(\frac{\mathbf{H}}{A}\Big)^{n}_{f}\cdot \mathbf{S}_{f}
    - \sum(\rho_{f}^{n} + \rho_{f}')\frac{(\nabla p^{n})_{f}}{A_{f}^{n}} \cdot \mathbf{S}_{f}
    - \sum \rho_{f}^{n}\frac{(\nabla p')_{f}}{A_{f}^{n}} \cdot \mathbf{S}_{f}
    = 0  
    \end{align}

由于 :math:`\nabla p' = \nabla p^{n+1} - \nabla p^{n}` ，从而上式中含有该式的项满足

.. math::
    \begin{align}
    - \sum\rho_{f}^{n}\frac{(\nabla p')_{f}}{A_{f}^{n}} \cdot \mathbf{S}_{f}
    = - \sum\rho_{f}^{n}\frac{(\nabla p^{n+1})_{f}}{A_{f}^{n}} \cdot \mathbf{S}_{f}
    + \sum\rho_{f}^{n}\frac{(\nabla p^{n})_{f}}{A_{f}^{n}} \cdot \mathbf{S}_{f}
    \end{align}

进而将上式代入前式，并进行化简与移项合并，得到

.. math::
    \begin{align}
    \sum\rho_{f}^{n}\Big(\frac{\mathbf{H}}{A}\Big)^{n}_{f}\cdot \mathbf{S}_{f}
    + \sum\rho_{f}' \bigg[ \Big(\frac{\mathbf{H}}{A}\Big)^{n}_{f} - \frac{(\nabla p^{n})_{f}}{A_{f}^{n}} \bigg] \cdot \mathbf{S}_{f}
    = \sum \rho_{f}^{n} \frac{(\nabla p^{n+1})_{f}}{A_{f}^{n}} \cdot \mathbf{S}_{f} 
    \end{align}

再根据 :math:`\rho_{f}' = \psi p_{f}^{n+1} - \psi p_{f}^{n}` ，代入上式，进行化简与移项合并，得到

.. math::
    \begin{align}
    \sum (\rho_{f}^{n} - \psi p_{f}^{n})\Big(\frac{\mathbf{H}}{A}\Big)_{f}^{n} \cdot \mathbf{S}_{f}
    + \sum \psi p_{f}^{n+1}\Big(\frac{\mathbf{H}}{A}\Big)_{f}^{n} \cdot \mathbf{S}_{f}
    + \sum \psi (p_{f}^{n} - p_{f}^{n+1})\frac{(\nabla p^{n})_{f}}{A_{f}^{n}} \cdot \mathbf{S}_{f}
    = \sum \rho_{f}^{n}\frac{(\nabla p^{n+1})_{f}}{A_{f}^{n}} \cdot \mathbf{S}_{f} 
    \end{align}

上式中等号左侧第三项被省略，因此最终求解的压力方程为

.. math::
    \begin{align}
    \sum (\rho_{f}^{n} - \psi p_{f}^{n})\Big(\frac{\mathbf{H}}{A}\Big)_{f}^{n} \cdot \mathbf{S}_{f}
    + \sum \psi p_{f}^{n+1}\Big(\frac{\mathbf{H}}{A}\Big)_{f}^{n} \cdot \mathbf{S}_{f}
    = \sum \rho_{f}^{n}\frac{(\nabla p^{n+1})_{f}}{A_{f}^{n}} \cdot \mathbf{S}_{f} 
    \end{align}

上式等号左侧的两项分别用phiHbyA和divPhidp表示：

.. code-block:: C

    surfaceScalarField phiHbyA
    (
        "phiHbyA",
        fvc::interpolate(rho)*fvc::flux(HbyA)
    );

    const surfaceScalarField phid
    (
        "phid",
        fvc::interpolate(psi)*phiHbyA/fvc::interpolate(rho)
    );

    const fvScalarMatrix divPhidp(fvm::div(phid, p));
    phiHbyA -= divPhidp.flux();

等号右侧是一个laplacian项，表示为

.. code-block:: C

    const surfaceScalarField rhorAUf("rhorAUf", fvc::interpolate(rho*rAU));

    const surfaceScalarField& rhorAAtUf = simple.consistent() ? rhorAtUf() : rhorAUf;

    fvm::laplacian(rhorAAtUf, p)

因此，高速流组建的压力方程表示为

.. code-block:: C

    fvScalarMatrix pEqn
    (
        fvc::div(phiHbyA) + divPhidp
      - fvm::laplacian(rhorAAtUf, p)
      ==
        fvModels.source(psi, p, rho.name())
    );


在求解出压力场之后，还要继续修正速度场，根据下式可以得到符合通量守恒的速度场：

.. math::
    \begin{align}
    \mathbf{U}^{n+1} = \mathbf{U}' + \mathbf{U}^{n}
    = -\frac{\nabla p'}{A^{n}} + \Big(\frac{\mathbf{H}}{A}\Big)^{n} - \frac{\nabla p^{n}}{A^{n}}
    = \Big(\frac{\mathbf{H}}{A}\Big)^{n} - \frac{\nabla p^{n+1}}{A^{n}} 
    \end{align}

代码表示为

.. code-block:: C

    const volScalarField rAU("rAU", 1.0/UEqn.A());
    volVectorField HbyA(constrainHbyA(rAU*UEqn.H(), U, p));
    const volScalarField& rAAtU = simple.consistent() ? rAtU() : rAU;

    U = HbyA - rAAtU*fvc::grad(p);



完整的压力场求解策略以及速度场、密度场修正策略如下所示：

.. code-block:: C

    rho = thermo.rho();    // 计算密度场
    rho.relax();

    const volScalarField rAU("rAU", 1.0/UEqn.A());
    const surfaceScalarField rhorAUf("rhorAUf", fvc::interpolate(rho*rAU));

    tmp<volScalarField> rAtU
    (
        simple.consistent()
      ? volScalarField::New("rAtU", 1.0/(1.0/rAU - UEqn.H1()))
      : tmp<volScalarField>(nullptr)
    );
    tmp<surfaceScalarField> rhorAtUf
    (
        simple.consistent()
      ? surfaceScalarField::New("rhoRAtUf", fvc::interpolate(rho*rAtU()))
      : tmp<surfaceScalarField>(nullptr)
    );

    const volScalarField& rAAtU = simple.consistent() ? rAtU() : rAU;
    const surfaceScalarField& rhorAAtUf = simple.consistent() ? rhorAtUf() : rhorAUf;

    volVectorField HbyA(constrainHbyA(rAU*UEqn.H(), U, p));

    tUEqn.clear();

    surfaceScalarField phiHbyA
    (
        "phiHbyA",
        fvc::interpolate(rho)*fvc::flux(HbyA)
    );

    MRF.makeRelative(fvc::interpolate(rho), phiHbyA);

    bool closedVolume = false;

    // Update the pressure BCs to ensure flux consistency
    constrainPressure(p, rho, U, phiHbyA, rhorAAtUf, MRF);

    if (simple.transonic())    // 高速流情况
    {
        const surfaceScalarField phid
        (
            "phid",
            fvc::interpolate(psi)*phiHbyA/fvc::interpolate(rho)
        );

        const fvScalarMatrix divPhidp(fvm::div(phid, p));
        phiHbyA -= divPhidp.flux();

        if (simple.consistent())
        {
            phiHbyA += (rhorAAtUf - rhorAUf)*fvc::snGrad(p)*mesh.magSf();
            HbyA += (rAAtU - rAU)*fvc::grad(p);
        }

        while (simple.correctNonOrthogonal())
        {
            fvScalarMatrix pEqn    // 组建高速流的压力方程
            (
                fvc::div(phiHbyA) + divPhidp
              - fvm::laplacian(rhorAAtUf, p)
              ==
                fvModels.source(psi, p, rho.name())
            );

            // Relax the pressure equation to ensure diagonal-dominance
            pEqn.relax();

            pEqn.setReference
            (
                pressureReference.refCell(),
                pressureReference.refValue()
            );

            pEqn.solve();    // 求解压力方程得到压力场

            if (simple.finalNonOrthogonalIter())
            {
                phi = phiHbyA + pEqn.flux();    // 计算出符合质量守恒的质量通量
            }
        }
    }
    else    // 低速流情况
    {
        closedVolume = adjustPhi(phiHbyA, U, p);

        if (simple.consistent())
        {
            phiHbyA += (rhorAAtUf - rhorAUf)*fvc::snGrad(p)*mesh.magSf();
            HbyA += (rAAtU - rAU)*fvc::grad(p);
        }

        while (simple.correctNonOrthogonal())
        {
            fvScalarMatrix pEqn    // 组建低速流的压力方程
            (
                fvc::div(phiHbyA)
              - fvm::laplacian(rhorAAtUf, p)
              ==
                fvModels.source(psi, p, rho.name())
            );

            pEqn.setReference
            (
                pressureReference.refCell(),
                pressureReference.refValue()
            );

            pEqn.solve();    // 求解压力方程得到压力场

            if (simple.finalNonOrthogonalIter())
            {
                phi = phiHbyA + pEqn.flux();    // 计算出符合质量守恒的质量通量
            }
        }
    }

    #include "incompressible/continuityErrs.H"
    /* 计算连续性误差，文件位于src/finiteVolume/cfdTools/incompressible，所执行代码如下
        volScalarField contErr(fvc::div(phi));

        scalar sumLocalContErr = runTime.deltaTValue()*
            mag(contErr)().weightedAverage(mesh.V()).value();

        scalar globalContErr = runTime.deltaTValue()*
            contErr.weightedAverage(mesh.V()).value();
        cumulativeContErr += globalContErr;

        Info<< "time step continuity errors : sum local = " << sumLocalContErr
            << ", global = " << globalContErr
            << ", cumulative = " << cumulativeContErr
            << endl;
    */


    // Explicitly relax pressure for momentum corrector
    p.relax();

    U = HbyA - rAAtU*fvc::grad(p);    // 求解最终的速度场
    U.correctBoundaryConditions();
    fvConstraints.constrain(U);

    fvConstraints.constrain(p);

    // For closed-volume cases adjust the pressure and density levels
    // to obey overall mass continuity
    if (closedVolume && !thermo.incompressible())    // 对于封闭体积的算例，进行修正以满足质量守恒
    {
        p += (initialMass - fvc::domainIntegrate(psi*p))
            /fvc::domainIntegrate(psi);
        p.correctBoundaryConditions();
    }

    rho = thermo.rho();    // 使用求解出来的压力场更新密度场
    rho.relax();



rhoCentralFoam求解器
----------------------

rhoCentralFoam的directionInterpolate.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    namespace Foam
    {

    //- Interpolate field vf according to direction dir 根据方向dir来对场vf进行插值
    template<class Type>
    tmp<GeometricField<Type, fvsPatchField, surfaceMesh>> interpolate
    (
        const GeometricField<Type, fvPatchField, volMesh>& vf,
        const surfaceScalarField& dir,
        const word& reconFieldName = word::null
    )
    {
        tmp<GeometricField<Type, fvsPatchField, surfaceMesh>> tsf
        (
            fvc::interpolate    // 将插值场的变量和方向作为自变量
            (
                vf,
                dir,
                "reconstruct("
              + (reconFieldName != word::null ? reconFieldName : vf.name())
              + ')'
            )
        );

        GeometricField<Type, fvsPatchField, surfaceMesh>& sf = tsf.ref();

        sf.rename(vf.name() + '_' + dir.name());

        return tsf;
    }

    }



rhoCentralFoam的createFields.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


.. code-block:: C

    #include "createRDeltaT.H"

    Info<< "Reading thermophysical properties\n" << endl;

    autoPtr<psiThermo> pThermo
    (
        psiThermo::New(mesh)
    );
    psiThermo& thermo = pThermo();

    volScalarField& e = thermo.he();      // 创建能量场，这里是内能场

    Info<< "Reading field U\n" << endl;
    volVectorField U    // 创建定义在网格体中心的速度场U
    (
        IOobject
        (
            "U",
            runTime.timeName(),
            mesh,
            IOobject::MUST_READ,
            IOobject::AUTO_WRITE
        ),
        mesh
    );

    volScalarField rho    // 创建定义在网格体中心的密度场rho
    (
        IOobject
        (
            "rho",
            runTime.timeName(),
            mesh,
            IOobject::NO_READ,
            IOobject::AUTO_WRITE
        ),
        thermo.rho()    // 通过热物理模型定义方式求解rho
    );

    volVectorField rhoU    // 创建定义在网格体中心的rhoU场
    (
        IOobject
        (
            "rhoU",
            runTime.timeName(),
            mesh,
            IOobject::NO_READ,
            IOobject::NO_WRITE
        ),
        rho*U    // 通过密度场与速度场直接相乘得到
    );

    volScalarField rhoE    // 创建定义在网格体中心的rhoE场，由于加上了动能这里的E表示总能量
    (
        IOobject
        (
            "rhoE",
            runTime.timeName(),
            mesh,
            IOobject::NO_READ,
            IOobject::NO_WRITE
        ),
        rho*(e + 0.5*magSqr(U))    // 计算方法为 \rho \cdot (e + \frac{1}{2}|U|^{2})
    );

    surfaceScalarField pos    // 定义在网格面中心的场pos
    (
        IOobject
        (
            "pos",
            runTime.timeName(),
            mesh
        ),
        mesh,
        dimensionedScalar(dimless, 1.0)    // 该场是一个无量纲的1.0
    );

    surfaceScalarField neg    // 定义在网格面中心的场neg
    (
        IOobject
        (
            "neg",
            runTime.timeName(),
            mesh
        ),
        mesh,
        dimensionedScalar(dimless, -1.0)    // 该场是无量纲的-1.0
    );

    surfaceScalarField phi("phi", fvc::flux(rhoU));    // 定义在网格面中心的质量通量场phi，通过 (\rho U)_{f} \cdot S_{f} 得到

    Info<< "Creating turbulence model\n" << endl;
    autoPtr<compressible::momentumTransportModel> turbulence
    (
        compressible::momentumTransportModel::New
        (
            rho,
            U,
            phi,
            thermo
        )
    );

    Info<< "Creating thermophysical transport model\n" << endl;
    autoPtr<fluidThermophysicalTransportModel> thermophysicalTransport
    (
        fluidThermophysicalTransportModel::New(turbulence(), thermo)
    );


rhoCentralFoam的createFieldRefs.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    volScalarField& p = thermo.p();             // 根据热物理模型定义的方式获取定义在网格体中心的压力场p
    const volScalarField& T = thermo.T();       // 根据热物理模型定义的方式获取定义在网格体中心的温度场T
    const volScalarField& psi = thermo.psi();   // 根据热物理模型定义的方式获取定义在网格体中心的可压缩性场psi
    const volScalarField& mu = thermo.mu();     // 根据热物理模型定义的方式获取定义在网格体中心的动力粘度场mu

    bool inviscid(true);    // 初始化inviscid为true
    if (max(mu.primitiveField()) > 0.0)    // 如果场中动力粘度最大值大于零则设置inviscid为false
    {
        inviscid = false;
    }


rhoCentralFoam的readFluxScheme.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    word fluxScheme("Kurganov");    // 初始化fluxScheme为Kurganov
    if (mesh.schemes().dict().readIfPresent("fluxScheme", fluxScheme))    // 读取fvScheme文件中的fluxScheme字典设置
    {
        if ((fluxScheme == "Tadmor") || (fluxScheme == "Kurganov"))    // 有两种设置，分别为Tadmor和Kurganov
        {
            Info<< "fluxScheme: " << fluxScheme << endl;
        }
        else    // 其他设置都是不合法的，将报错
        {
            FatalErrorInFunction
                << "fluxScheme: " << fluxScheme
                << " is not a valid choice. "
                << "Options are: Tadmor, Kurganov"
                << abort(FatalError);
        }
    }


rhoCentralFoam的resetDeltaT.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

该文件在controlDict文件中设置为了adjustTimeStep模式时会使用到。首先定义了参数deltaT的初始化计算方式为

.. math::
    \begin{align}
    \text{deltaT} = \frac{\text{maxCo} \times \Delta t}{\text{CoNum} + \text{small}}
    \end{align}

之后根据库朗数更新deltaT的办法为

.. math::
    \begin{align}
    \text{deltaT} = \min\Big(\min(\text{deltaT}, \Delta t + 0.1\times \text{deltaT}),1.2\Delta t\Big) 
    \end{align}

.. code-block:: C

    if (adjustTimeStep)    // 如果在controlDict文件中设置为了adjustTimeStep模式
    {
        scalar deltaT = maxCo*runTime.deltaTValue()/(CoNum + small);    // 定义并初始化参数deltaT 
        deltaT = min  // 更新deltaT的值
        (
            min(deltaT, runTime.deltaTValue() + 0.1*deltaT),
            1.2*runTime.deltaTValue()
        );
        runTime.setDeltaT(min(deltaT, maxDeltaT));    // 重新设置时间步进长度为deltaT和maxDeltaT中的最小值

        Info<< "deltaT = " <<  runTime.deltaTValue() << endl;
    }


rhoCentralFoam的CentralCourantNo.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

该文件基于库朗数计算平均波速和最大波速。计算方法为

.. math::
    \begin{align}
    & \text{CoNum} = 0.5 \times \max_{\text{global}}\Big(\frac{\sum_{f}\text{amaxSf}}{V}\cdot \Delta t\Big)  \\
    & \text{meanCoNum} = 0.5 \times \Big(\frac{\sum_{\text{global}}(\sum_{f}\text{amaxSf})}{\sum_{\text{global}}V} \Big) \cdot \Delta t
    \end{align}

其中 :math:`\sum_{f}\text{amaxSf}` 表示在每个网格单元中对其各面上的amaxSf值进行求和，得到的是与网格单元数同维的标量场。

.. code-block:: C

    if (mesh.nInternalFaces())
    {
        scalarField sumAmaxSf(fvc::surfaceSum(amaxSf)().primitiveField());    // 将amaxSf按面求和得到sumAmaxSf

        CoNum = 0.5*gMax(sumAmaxSf/mesh.V().field())*runTime.deltaTValue();    // gMax表示全局最大值，涉及到并行

        meanCoNum =
            0.5*(gSum(sumAmaxSf)/gSum(mesh.V().field()))*runTime.deltaTValue();    // gSum表示全局求和，涉及到并行
    }

    Info<< "Mean and max Courant Numbers = "
        << meanCoNum << " " << CoNum << endl;



rhoCentralFoam的setRDeltaT.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

当使用当地局部时间步方法时会使用这个文件。

.. code-block:: C

    {
        volScalarField& rDeltaT = trDeltaT.ref();

        scalar rDeltaTSmoothingCoeff
        (
            runTime.controlDict().lookupOrDefault<scalar>
            (
                "rDeltaTSmoothingCoeff",
                0.02
            )
        );

        // Set the reciprocal time-step from the local Courant number
        rDeltaT.ref() = max
        (
            1/dimensionedScalar(dimTime, maxDeltaT),
            fvc::surfaceSum(amaxSf)()()
           /((2*maxCo)*mesh.V())
        );

        // Update the boundary values of the reciprocal time-step
        rDeltaT.correctBoundaryConditions();

        fvc::smooth(rDeltaT, rDeltaTSmoothingCoeff);

        Info<< "Flow time scale min/max = "
            << gMin(1/rDeltaT.primitiveField())
            << ", " << gMax(1/rDeltaT.primitiveField()) << endl;
    }



rhoCentralFoam.C
^^^^^^^^^^^^^^^^^^^

理论算法参考 `rhoCentralFoam解析 <http://dyfluid.com/rhocentralfoam.html>`_ 、 `间断初值双曲守恒问题的Lax-Friedrichs和后向欧拉数值解法 <https://blog.csdn.net/lusongno1/article/details/78708667>`_ 


rhoCentralFoam求解的连续性方程为

.. math::
    \begin{align}
    \frac{\partial \rho}{\partial t} + \nabla \cdot (\rho\mathbf{U}) = 0
    \end{align}

rhoCentralFoam求解的动量方程为

.. math::
    \begin{align}
    \frac{\partial \rho\mathbf{U}}{\partial t} 
    + \nabla \cdot (\rho\mathbf{UU}) 
    + \nabla p 
    - \nabla \cdot (\mu_{\text{Eff}} \nabla \mathbf{U})
    - \nabla \cdot \Big[ \mu_{\text{Eff}} \Big( (\nabla \mathbf{U})^{T} - \frac{2}{3}(\nabla \cdot \mathbf{U})\mathbf{I} \Big) \Big]
    = 0
    \end{align}

rhoCentralFoam求解的能量方程为

.. math::
    \begin{align}
    \frac{\partial \rho(e+\frac{1}{2}|\mathbf{U}|^{2})}{\partial t} 
    + \nabla \cdot \big(\rho\mathbf{U}(e+\frac{1}{2}|\mathbf{U}|^{2})\big)
    + \nabla \cdot (p \mathbf{U})
    - \nabla \cdot (\alpha_{\text{Eff}}\nabla e) 
    - \nabla \cdot (\boldsymbol{\tau} \cdot \mathbf{U}) 
    = 0
    \end{align}


在该求解器中所采用的中心差分算法引入了许多系数，包括

.. math::
    \begin{align}
    & c = \sqrt{\frac{c_{p}}{c_{v}}\frac{1}{\psi}} \\
    & a_{p} = \max\Big( \max(\mathbf{U}_{+}\cdot \mathbf{S}_{f}  + c_{+}|\mathbf{S}_{f}|, \mathbf{U}_{-}\cdot \mathbf{S}_{f}  + c_{-}|\mathbf{S}_{f}|) , 0.0\Big)  \\
    & a_{m} = \min\Big( \min(\mathbf{U}_{+}\cdot \mathbf{S}_{f}  - c_{+}|\mathbf{S}_{f}|, \mathbf{U}_{-}\cdot \mathbf{S}_{f}  - c_{-}|\mathbf{S}_{f}|) , 0.0\Big)  \\
    & a_{+} = \frac{a_{p}}{a_{p} - a_{m}}  \\
    & a_{-} = 1.0 - a_{+}
    \end{align}

其中下标 :math:`+,-` 表示定向插值到网格面。

质量通量项的计算方法为 :code:`phi = aphiv_pos*rho_pos + aphiv_neg*rho_neg;` ，即

.. math::
    \begin{align}
    \int_{V} \nabla \cdot (\rho \mathbf{U}) ~\mathrm{d}V
    = \sum_{f}(\rho \mathbf{U})_{f}\cdot\mathbf{S}_{f} 
    = \sum_{f}\Big( \rho_{+}(\mathbf{U}_{+}\cdot \mathbf{S}_{f})a_{+} + \rho_{-}(\mathbf{U}_{-}\cdot\mathbf{S}_{f})a_{-} \Big)
    \end{align}


动量方程的中间项如下进行计算：

.. math::
    \begin{align}
    &\int_{V} \Big( \nabla \cdot (\rho\mathbf{UU}) + \nabla p \Big)~\mathrm{d}V
    = \sum_{f}(\rho\mathbf{UU})_{f} \cdot \mathbf{S}_{f} + \sum_{f}p_{f}\mathbf{S}_{f}  \\
    &= \sum_{f}\Big( 
      (\mathbf{U}_{+}\cdot\mathbf{S}_{f}a_{+} - a_{m}a_{+})(\rho\mathbf{U})_{+} 
      + (\mathbf{U}_{-}\cdot\mathbf{S}_{f}a_{-} + a_{m}a_{+})(\rho\mathbf{U})_{-}
      + (a_{+}p_{+} + a_{-}p_{-})\mathbf{S}_{f}
      \Big)
    \end{align}

.. code-block:: C

    surfaceVectorField phiUp
    (
        (aphiv_pos*rhoU_pos + aphiv_neg*rhoU_neg)
      + (a_pos*p_pos + a_neg*p_neg)*mesh.Sf()
    );


能量方程的中间项如下进行计算：

.. math::
    \begin{align}
    &\int_{V}\Big( \nabla \cdot (\rho\mathbf{U}E) + \nabla \cdot (p\mathbf{U}) \Big)~\mathrm{d}V
    = \sum_{f}(\rho\mathbf{U}E)_{f}\cdot\mathbf{S}_{f} + \sum_{f}(p\mathbf{U})_{f}\cdot\mathbf{S}_{f}  \\
    &= \sum_{f}\Big(
      (\mathbf{U}_{+}\cdot\mathbf{S}_{f}a_{+} - a_{m}a_{+})(\rho_{+}E_{+} + p_{+})
      + (\mathbf{U}_{-}\cdot\mathbf{S}_{f}a_{-} + a_{m}a_{+})(\rho_{e}E_{-} + p_{-})
      + a_{m}a_{+}p_{+} - a_{m}a_{+}p_{-}
      \Big)
    \end{align}

其中 :math:`E_{+} = e_{+} + \frac{1}{2}|\mathbf{U}_{+}|^{2}` ， :math:`E_{-} = e_{-} + \frac{1}{2}|\mathbf{U}_{-}|^{2}` 。

.. code-block:: C

    surfaceScalarField phiEp
    (
        "phiEp",
        aphiv_pos*(rho_pos*(e_pos + 0.5*magSqr(U_pos)) + p_pos)
      + aphiv_neg*(rho_neg*(e_neg + 0.5*magSqr(U_neg)) + p_neg)
      + aSf*p_pos - aSf*p_neg
    );


有效动力粘度系数利用湍流模型的有效运动粘度系数来计算，为 :code:`volScalarField muEff("muEff", rho*turbulence->nuEff());` ，即 :math:`\mu_{\text{Eff}} = \rho \nu_{\text{Eff}}` 。动量方程粘性项的一部分如此进行计算 :code:`volTensorField tauMC("tauMC", muEff*dev2(Foam::T(fvc::grad(U))));` ，即

.. math::
    \begin{align}
    \int_{V}\nabla \cdot \Big[ \mu_{\text{Eff}} \Big( (\nabla \mathbf{U})^{T} - \frac{2}{3}(\nabla \cdot \mathbf{U})\mathbf{I} \Big) \Big]~\mathrm{d}V
    = \sum_{f} \Big[ \mu_{\text{Eff}} \Big( (\nabla \mathbf{U})_{\text{fvc}}^{T} - \frac{2}{3}\operatorname{tr}\big((\nabla\mathbf{U})_{\text{fvc}}^{T}\big) \mathbf{I} \Big) \Big]_{f}
    \end{align}


现在可以求解连续性方程得到密度场：

.. math::
    \begin{align}
    \Big(\frac{\partial \rho}{\partial t}\Big)_{\text{fvm}} + \sum_{f,\text{fvc}}(\rho \mathbf{U})_{f}\cdot\mathbf{S}_{f} = 0
    \quad \Rightarrow \quad 
    \Big(\frac{\partial \rho}{\partial t}\Big)_{\text{fvm}} + \sum_{f,\text{fvc}}\Big(\rho_{+}(\mathbf{U}_{+}\cdot \mathbf{S}_{f})a_{+} + \rho_{-}(\mathbf{U}_{-}\cdot\mathbf{S}_{f})a_{-}\Big) = 0
    \end{align}

.. code-block:: C

    solve(fvm::ddt(rho) + fvc::div(phi));

在rhoCentralFoam中首先求解了一次不考虑粘性的动量方程，即

.. math::
    \begin{align}
    \Big(\frac{\partial \rho\mathbf{U}}{\partial t} \Big)_{\text{fvm}} 
    + \sum_{f,\text{fvc}}\Big( (\rho\mathbf{UU})_{f}\cdot\mathbf{S}_{f} + p_{f}\mathbf{S}_{f} \Big)
    = 0
    \quad \Rightarrow \quad 
    \end{align}

.. math::
    \begin{align}
    \Big(\frac{\partial \rho\mathbf{U}}{\partial t} \Big)_{\text{fvm}}
    + \sum_{f,\text{fvc}}\Big(
          (\mathbf{U}_{+}\cdot\mathbf{S}_{f}a_{+} - a_{m}a_{+})(\rho_{+}E_{+} + p_{+})
          + (\mathbf{U}_{-}\cdot\mathbf{S}_{f}a_{-} + a_{m}a_{+})(\rho_{e}E_{-} + p_{-})
          + a_{m}a_{+}p_{+} - a_{m}a_{+}p_{-}
          \Big)
    = 0
    \end{align}

.. code-block:: C

    solve(fvm::ddt(rhoU) + fvc::div(phiUp));

通过求解上式可以得到更新后的动量密度场 :math:`\rho\mathbf{U}` ，然后通过 :math:`\rho\mathbf{U}/\rho` 的方式得到参考速度场。接下来考虑上粘性项的影响再求解一次动量方程：

.. math::
    \begin{align}
    \Big( \frac{\partial \rho\mathbf{U}}{\partial t} \Big)_{\text{fvm}} 
    - \Big( \frac{\partial \rho\mathbf{U}}{\partial t} \Big)_{\text{fvc}}
    - \sum_{f,\text{fvm}}\Big( \mu_{\text{Eff}} \nabla\mathbf{U} \Big)_{f}
    - \sum_{f,\text{fvc}}\Big[ \mu_{\text{Eff}} \Big( (\nabla \mathbf{U})_{\text{fvc}}^{T} - \frac{2}{3}\operatorname{tr}\big((\nabla\mathbf{U})_{\text{fvc}}^{T}\big) \mathbf{I} \Big) \Big]_{f}
    = 0
    \end{align}

.. code-block:: C

    if (!inviscid)
    {
        solve
        (
            fvm::ddt(rho, U) - fvc::ddt(rho, U)
          - fvm::laplacian(muEff, U)
          - fvc::div(tauMC)
        );
        rhoU = rho*U;
    }

如此就能得到求解出的速度场 :math:`\mathbf{U}` ，利用它更新一次动量密度场 :math:`\rho\mathbf{U}` 。


能量场中的应力张量做功项如下进行计算：

.. math::
    \begin{align}
    \int_{V} \nabla \cdot (\boldsymbol{\tau} \cdot \mathbf{U}) ~\mathrm{d}V
    = \sum_{f}\Big( (\mu_{\text{Eff}})_{f,\text{fvc}}|\mathbf{S}_{f}| (\nabla\mathbf{U})_{\text{fvc}} + \Big[ \mu_{\text{Eff}} \Big( (\nabla \mathbf{U})_{\text{fvc}}^{T} - \frac{2}{3}\operatorname{tr}\big((\nabla\mathbf{U})_{\text{fvc}}^{T}\big) \mathbf{I} \Big) \Big]_{f} \cdot \mathbf{S}_{f} \Big)
      \cdot (a_{+}\mathbf{U}_{+} + a_{-}\mathbf{U}_{-})
    \end{align}

.. code-block:: C

    surfaceScalarField sigmaDotU
    (
        "sigmaDotU",
        (
            fvc::interpolate(muEff)*mesh.magSf()*fvc::snGrad(U)
          + fvc::dotInterpolate(mesh.Sf(), tauMC)
        )
        & (a_pos*U_pos + a_neg*U_neg)
    );

于是能量方程可以进行求解：

.. math::
    \begin{align}
    \Big(\frac{\partial \rho E}{\partial t} \Big)_{\text{fvm}}
    + \sum_{f,\text{fvc}}\Big( (\rho\mathbf{U}E)_{f}\cdot\mathbf{S}_{f} + (p\mathbf{U})_{f}\cdot\mathbf{S}_{f} \Big)
    - \sum_{f,\text{fvc}}\Big( \boldsymbol{\tau} \cdot \mathbf{U} \Big)_{f}
    = 0
    \quad \Rightarrow \quad 
    \end{align}

.. math::
    \begin{align}
    \Big(\frac{\partial \rho E}{\partial t} \Big)_{\text{fvm}}
    &+ \sum_{f,\text{fvc}}\Big(
          (\mathbf{U}_{+}\cdot\mathbf{S}_{f}a_{+} - a_{m}a_{+})(\rho_{+}E_{+} + p_{+})
          + (\mathbf{U}_{-}\cdot\mathbf{S}_{f}a_{-} + a_{m}a_{+})(\rho_{e}E_{-} + p_{-})
          + a_{m}a_{+}p_{+} - a_{m}a_{+}p_{-}
          \Big)  \\
    &- \sum_{f,\text{fvc}}\Big( (\mu_{\text{Eff}})_{f,\text{fvc}}|\mathbf{S}_{f}| (\nabla\mathbf{U})_{\text{fvc}} + \Big[ \mu_{\text{Eff}} \Big( (\nabla \mathbf{U})_{\text{fvc}}^{T} - \frac{2}{3}\operatorname{tr}\big((\nabla\mathbf{U})_{\text{fvc}}^{T}\big) \mathbf{I} \Big) \Big]_{f} \cdot \mathbf{S}_{f} \Big)
          \cdot (a_{+}\mathbf{U}_{+} + a_{-}\mathbf{U}_{-})
    = 0
    \end{align}

.. code-block:: C

    solve    // 求解能量方程，得到rhoE
    (
        fvm::ddt(rhoE)
      + fvc::div(phiEp)
      - fvc::div(sigmaDotU)
    );

由此计算得到 :math:`\rho E` 后据此更新内能场 :math:`e = \rho E / \rho - \frac{1}{2}|\mathbf{U}|^{2}` 。

但是上式没有考虑热通量项，对于有粘场则还会再求解一次考虑了热通量贡献的能量方程：

.. math::
    \begin{align}
    \Big(\frac{\partial \rho e}{\partial t} \Big)_{\text{fvm}} 
    - \Big( \frac{\partial \rho e}{\partial t} \Big)_{\text{fvc}}
    - \sum_{f,\text{fvc}} \Big( \alpha_{\text{Eff}} \nabla e \Big)_{f}
    = 0
    \end{align}

.. code-block:: C

    if (!inviscid)
    {
        solve
        (
            fvm::ddt(rho, e) - fvc::ddt(rho, e)
          + thermophysicalTransport->divq(e)
        );
        thermo.correct();
        rhoE = rho*(e + 0.5*magSqr(U));
    }

由此求解出新的内能场 :math:`e` ，据此更新 :math:`\rho E = \rho (e + \frac{1}{2}|\mathbf{U}|^{2})` 的值。

最后通过密度场和可压缩性场求解出压力场 :code:`p.ref() = rho()/psi();` ，即 :math:`p = \frac{\rho}{\psi}` 就完成了本次时间步的内容，开始下一个时间步的循环。



.. code-block:: C

    #include "fvCFD.H"
    #include "psiThermo.H"
    #include "compressibleMomentumTransportModels.H"
    #include "fluidThermophysicalTransportModel.H"
    #include "fixedRhoFvPatchScalarField.H"
    #include "directionInterpolate.H"
    #include "localEulerDdtScheme.H"
    #include "fvcSmooth.H"

    int main(int argc, char *argv[])
    {
        #define NO_CONTROL
        #include "postProcess.H"

        #include "setRootCaseLists.H"
        #include "createTime.H"
        #include "createMesh.H"
        #include "createFields.H"
        #include "createFieldRefs.H"
        #include "createTimeControls.H"

        turbulence->validate();

        #include "readFluxScheme.H"

        dimensionedScalar v_zero("v_zero", dimVolume/dimTime, 0.0);    // 定义一个有量纲标量场v_zero，值为0.0，量纲为 m^{3}/t

        // Courant numbers used to adjust the time-step
        scalar CoNum = 0.0;        // 初始化参数CoNum为0.0
        scalar meanCoNum = 0.0;    // 初始化参数meanCoNum为0.0

        Info<< "\nStarting time loop\n" << endl;

        while (runTime.run())    // 开始时间步迭代步进
        {
            #include "readTimeControls.H"

            if (!LTS)    // 如果不采用当地时间步方法
            {
                #include "setDeltaT.H"    // 关于adjustTimeStep模式

                // Update the mesh for topology change, mesh to mesh mapping
                mesh.update();

                runTime++;

                // Move the mesh
                mesh.move();
            }

            // --- Directed interpolation of primitive fields onto faces 将原始场定向插值到面上

            surfaceScalarField rho_pos(interpolate(rho, pos));    // 密度场正向插值得到rho_pos
            surfaceScalarField rho_neg(interpolate(rho, neg));    // 密度场反向插值得到rho_neg

            surfaceVectorField rhoU_pos(interpolate(rhoU, pos, U.name()));    // rhoU场正向插值得到rhoU_pos
            surfaceVectorField rhoU_neg(interpolate(rhoU, neg, U.name()));    // rhoU场反向插值得到rhoU_neg

            volScalarField rPsi("rPsi", 1.0/psi);    // 创建一个定义在网格体中心的标量场rPsi，它是可压缩性场的倒数
            surfaceScalarField rPsi_pos(interpolate(rPsi, pos, T.name()));    // rPsi场正向插值得到rPsi_pos
            surfaceScalarField rPsi_neg(interpolate(rPsi, neg, T.name()));    // rPsi场反向插值得到rPsi_neg

            surfaceScalarField e_pos(interpolate(e, pos, T.name()));    // 能量场正向插值得到e_pos
            surfaceScalarField e_neg(interpolate(e, neg, T.name()));    // 能量场反向插值得到e_neg

            surfaceVectorField U_pos("U_pos", rhoU_pos/rho_pos);    // 速度场正向插值通过计算得到，即 U_{+} = \frac{(\rho U)_{+}}{\rho_{+}}
            surfaceVectorField U_neg("U_neg", rhoU_neg/rho_neg);    // 速度场反向插值通过计算得到，即 U_{-} = \frac{(\rho U)_{-}}{\rho_{-}}

            surfaceScalarField p_pos("p_pos", rho_pos*rPsi_pos);    // 压力场正向插值通过计算得到，即 p_{+} = \rho_{+} \cdot (\frac{1}{\psi})_{+}
            surfaceScalarField p_neg("p_neg", rho_neg*rPsi_neg);    // 压力场反向插值通过计算得到，即 p_{-} = \rho_{-} \cdot (\frac{1}{\psi})_{-}

            surfaceScalarField phiv_pos("phiv_pos", U_pos & mesh.Sf());    // 定义正向插值速度通量为 phiv_{+} = U_{+} \cdot S_{f}
            surfaceScalarField phiv_neg("phiv_neg", U_neg & mesh.Sf());    // 定义反向插值速度通量为 phiv_{-} = U_{-} \cdot S_{f}

            // Make fluxes relative to mesh-motion
            if (mesh.moving())    // 如果是动网格系统
            {
                phiv_pos -= mesh.phi();
                phiv_neg -= mesh.phi();
            }

            volScalarField c("c", sqrt(thermo.Cp()/thermo.Cv()*rPsi));    // 定义在网格体中心的标量场c，为 \sqrt{\frac{c_{p}}{c_{v}} \cdot \frac{1}{\psi}}
            surfaceScalarField cSf_pos    // 定义cSf的正向插值
            (
                "cSf_pos",
                interpolate(c, pos, T.name())*mesh.magSf()    // 通过 c_{+} \cdot |S_{f}| 计算
            );
            surfaceScalarField cSf_neg    // 定义cSf的反向插值
            (
                "cSf_neg",
                interpolate(c, neg, T.name())*mesh.magSf()    // 通过 c_{-} \cdot |S_{f}| 计算
            );

            surfaceScalarField ap
            (
                "ap",
                max(max(phiv_pos + cSf_pos, phiv_neg + cSf_neg), v_zero)
            );
            surfaceScalarField am
            (
                "am",
                min(min(phiv_pos - cSf_pos, phiv_neg - cSf_neg), v_zero)
            );

            surfaceScalarField a_pos("a_pos", ap/(ap - am));

            surfaceScalarField amaxSf("amaxSf", max(mag(am), mag(ap)));

            surfaceScalarField aSf("aSf", am*a_pos);

            if (fluxScheme == "Tadmor")    // 如果通量计算方法选择为Tadmor，则aSf和a_pos的值将有所不同
            {
                aSf = -0.5*amaxSf;
                a_pos = 0.5;
            }

            surfaceScalarField a_neg("a_neg", 1.0 - a_pos);

            phiv_pos *= a_pos;
            phiv_neg *= a_neg;

            surfaceScalarField aphiv_pos("aphiv_pos", phiv_pos - aSf);
            surfaceScalarField aphiv_neg("aphiv_neg", phiv_neg + aSf);

            // Reuse amaxSf for the maximum positive and negative fluxes estimated by the central scheme
            amaxSf = max(mag(aphiv_pos), mag(aphiv_neg));

            #include "centralCourantNo.H"    // 计算库朗数

            if (LTS)    // 如果使用当地局部时间步方法
            {
                #include "setRDeltaT.H"
                runTime++;
            }

            Info<< "Time = " << runTime.userTimeName() << nl << endl;

            phi = aphiv_pos*rho_pos + aphiv_neg*rho_neg;    // 计算质量通量

            surfaceVectorField phiUp    // 定义在网格面中心的矢量场phiUp
            (
                (aphiv_pos*rhoU_pos + aphiv_neg*rhoU_neg)
              + (a_pos*p_pos + a_neg*p_neg)*mesh.Sf()
            );

            surfaceScalarField phiEp    // 定义在网格面中心的标量场phiEp
            (
                "phiEp",
                aphiv_pos*(rho_pos*(e_pos + 0.5*magSqr(U_pos)) + p_pos)
              + aphiv_neg*(rho_neg*(e_neg + 0.5*magSqr(U_neg)) + p_neg)
              + aSf*p_pos - aSf*p_neg
            );

            // Make flux for pressure-work absolute
            if (mesh.moving())    // 如果是动网格系统还需要对phiEp进行修正
            {
                phiEp += mesh.phi()*(a_pos*p_pos + a_neg*p_neg);
            }

            volScalarField muEff("muEff", rho*turbulence->nuEff());    // 定义在网格体中心的标量场muEff有效动力粘度场，通过密度乘以有效运动粘度场得到
            volTensorField tauMC("tauMC", muEff*dev2(Foam::T(fvc::grad(U))));    // 定义在网格体中心的张量场tauMC

            // --- Solve density
            solve(fvm::ddt(rho) + fvc::div(phi));    // 通过连续性方程求解密度场

            // --- Solve momentum
            solve(fvm::ddt(rhoU) + fvc::div(phiUp));    // 通过动量方程求解rhoU，此时还没有考虑粘性

            U.ref() = rhoU()/rho();    // 通过求解得到的rhoU和rho相除得到速度场参考值
            U.correctBoundaryConditions();
            rhoU.boundaryFieldRef() == rho.boundaryField()*U.boundaryField();

            if (!inviscid)    // 如果是有粘场，即具有动力粘度
            {
                solve    // 求解含有粘性项的动量方程
                (
                    fvm::ddt(rho, U) - fvc::ddt(rho, U)
                  - fvm::laplacian(muEff, U)
                  - fvc::div(tauMC)
                );
                rhoU = rho*U;    // 更新rhoU场的值
            }

            // --- Solve energy
            surfaceScalarField sigmaDotU    // 应力张量做功项
            (
                "sigmaDotU",
                (
                    fvc::interpolate(muEff)*mesh.magSf()*fvc::snGrad(U)
                  + fvc::dotInterpolate(mesh.Sf(), tauMC)
                )
              & (a_pos*U_pos + a_neg*U_neg)
            );

            solve    // 求解能量方程，得到rhoE
            (
                fvm::ddt(rhoE)
              + fvc::div(phiEp)
              - fvc::div(sigmaDotU)
            );

            e = rhoE/rho - 0.5*magSqr(U);    // 通过上面得到的rhoE更新内能场e的值，采用总能量减去动能的方式计算
            e.correctBoundaryConditions();
            thermo.correct();    // 更新热物理模型中相关的参数
            rhoE.boundaryFieldRef() == rho.boundaryField()*(e.boundaryField() + 0.5*magSqr(U.boundaryField()));

            if (!inviscid)    // 如果是有粘场，即具有动力粘度
            {
                solve    // 求解带有湍流粘度项的能量方程，得到能量场e
                (
                    fvm::ddt(rho, e) - fvc::ddt(rho, e)
                  + thermophysicalTransport->divq(e)    // 表示的是热通量项
                );
                thermo.correct();                  // 更新热物理模型中相关的参数
                rhoE = rho*(e + 0.5*magSqr(U));    // 通过新计算得到的e更新rhoE的值
            }

            p.ref() = rho()/psi();    // 通过求解得到的密度场rho和可压缩性场psi相除得到压力场p
            p.correctBoundaryConditions();
            rho.boundaryFieldRef() == psi.boundaryField()*p.boundaryField();

            turbulence->correct();                 // 更新湍流模型相关参数
            thermophysicalTransport->correct();    // 更新热物理模型相关参数

            runTime.write();

            Info<< "ExecutionTime = " << runTime.elapsedCpuTime() << " s"
                << "  ClockTime = " << runTime.elapsedClockTime() << " s"
                << nl << endl;
        }

        Info<< "End\n" << endl;

        return 0;
    }



rhoCentralFoam的设置方法
^^^^^^^^^^^^^^^^^^^^^^^^^^^

根据其求解代码内容可知，当使用rhoCentralFoam求解器时，fvSchemes文件的内容为（使用laminar层流模型）：

.. code-block:: C

    fluxScheme      Kurganov;

    ddtSchemes
    {
        default         none;
        general         Euler;
        ddt(rho)        $general;
        ddt(rhoU)       $general;
        U               $general;
        ddt(rho,U)      $general;
        ddt(rhoE)       $general;
        T               $general;
        ddt(rho,e)      $general;
        p               $general;
    }

    gradSchemes
    {
        default         none;
        general         Gauss linear;
        grad(rho)       $general;
        grad(rhoU)      $general;
        grad(rPsi)      $general;
        grad(e)         $general;
        grad(c)         $general;
        grad(U)         $general;
    }

    divSchemes
    {
        default         none;
        general         Gauss linear;
        div(tauMC)      $general;
    }

    laplacianSchemes
    {
        default                 none;
        general                 Gauss linear limited corrected 0.5;
        laplacian(muEff,U)      $general;
        laplacian(alphahe,e)    $general;
    }

    interpolationSchemes
    {
        default                     none;
        general                     linear;
        flux(rhoU)                  $general;
        reconstruct(rho)            vanLeer;
        reconstruct(U)              vanLeerV;
        reconstruct(T)              vanLeer;
        dotInterpolate(Sf,tauMC)    $general;
        interpolate(muEff)          $general;
    }

    snGradSchemes
    {
        default         none;
        general         limited corrected 0.5;
        snGrad(U)       $general;
    }


fvSolution文件的内容为（使用laminar层流模型）：

.. code-block:: C

    solvers
    {
        "(rho|rhoU|rhoE)"
        {
            solver          smoothSolver;
            smoother        GaussSeidel;
            nSweeps         2;
            tolerance       1e-10;
        }

        U
        {
            solver          smoothSolver;
            smoother        GaussSeidel;
            nSweeps         2;
            tolerance       1e-09;
        }

        e
        {
            solver          smoothSolver;
            smoother        GaussSeidel;
            nSweeps         2;
            tolerance       1e-09;
        }
    }



interFoam求解器
-----------------

interFoam涉及的控制方程有：

.. math::
    \begin{align}
    \nabla \cdot \mathbf{U} = 0
    \end{align}

.. math::
    \begin{align}
      \frac{\partial \rho\mathbf{U}}{\partial t}
      + \nabla \cdot (\rho\mathbf{U})\mathbf{U}
      - \nabla \cdot [ \mu (\nabla\mathbf{U}) ]
    = - \nabla p
      -  (\mathbf{g} \cdot \mathbf{x})\nabla\rho
      + \sigma_{T}\kappa_{\alpha}\nabla\alpha 
    \end{align}

.. math::
    \begin{align}
      \frac{\partial \alpha }{\partial t}
      + \nabla \cdot \mathbf{U}\alpha 
    = 0 
    \end{align}

.. math::
    \begin{align}
    & \rho = \alpha \rho_{1} + (1 - \alpha )\rho_{2}  \\
    & \mu = \alpha \mu_{1} + (1 - \alpha )\mu_{2}
    \end{align}

两相流系统被当成一个混合系统，它的密度场和粘度系数场都不再是常数，两相交界面也必须足够尖锐与足够大才能通过网格捕捉到，同时假设了两相交界面处速度场是连续的。可以看到，方程中考虑了重力场和表面张力的作用。

实际上，上面给出的第二个方程与平常看到的有所不同。一般看到的形式为

.. math::
    \begin{align}
      \frac{\partial \rho\mathbf{U}}{\partial t}
      + \nabla \cdot (\rho\mathbf{U})\mathbf{U}
      - \nabla \cdot [ \mu (\nabla\mathbf{U}) ]
    = - \nabla P
      + \rho\mathbf{g}
      + \sigma_{T}\kappa_{\alpha}\nabla\alpha 
    \end{align}

其中 :math:`P` 是总压(total pressure)，而在OpenFOAM中采用的压强 :math:`p` 表示为总压减去液体静压：

.. math::
    \begin{align}
    p = P - \rho \mathbf{g}\cdot\mathbf{x}
    \end{align}

使用动压 :math:`p` 的表达形式改写上面的方程：

.. math::
    \begin{align}
    - \nabla P = - \nabla p - \nabla [\rho(\mathbf{g}\cdot\mathbf{x})]
               = - \nabla p - (\mathbf{g}\cdot\mathbf{x})\nabla \rho - \rho \nabla (\mathbf{g}\cdot\mathbf{x})
    \end{align}

.. math::
    \begin{align}
    \nabla (\mathbf{g}\cdot\mathbf{x}) 
    = \mathbf{g} \times (\nabla \times \mathbf{x})
      + \mathbf{x} \times (\nabla \times \mathbf{g})
      + (\mathbf{g} \cdot \nabla )\mathbf{x}
      + (\mathbf{x} \cdot \nabla )\mathbf{g}  
    \end{align}

根据 :math:`\mathbf{g} \times (\nabla \times \mathbf{x})=0` ， :math:`\mathbf{x} \times (\nabla \times \mathbf{g})=0` ， :math:`(\mathbf{g} \cdot \nabla )\mathbf{x}=\mathbf{g}` ， :math:`(\mathbf{x} \cdot \nabla )\mathbf{g}=0` 可知 :math:`\nabla (\mathbf{g}\cdot\mathbf{x}) = \mathbf{g}` ，从而

.. math::
    \begin{align}
    -\nabla P = -\nabla p - \nabla [\rho(\mathbf{g}\cdot \mathbf{x})]
              = -\nabla p - (\mathbf{g}\cdot \mathbf{x}) \nabla \rho - \rho\mathbf{g}
    \end{align}

最终就得到了OpenFOAM中所采用的方程形式。

.. note:: 正因为使用了 :math:`\nabla \rho` 的形式来描述重力项，在遇到水气界面等密度剧烈变化的情况时，会产生非常明显的数值耗散和误差。除此之外，在表面张力项，由于曲率 :math:`\kappa_{\alpha}` 的评估有时会有较大的误差，从而导致有时会在周边产生额外的速度场来平衡表面曲率误差。


interFoam求解器求解的步骤可以概括为：

1. 求解输运方程得到体积相分数 :math:`\alpha` ，不过在实现的时候方程额外添加了一项，修改成了
   
.. math::
    \begin{align}
      \frac{\partial \alpha }{\partial t}
    + \nabla \cdot \mathbf{U}\alpha 
    + \nabla \cdot (\mathbf{U}_{r}\alpha (1-\alpha ) )
    = 0  
    \end{align}

2. 修正流体和界面的参数，即计算 :math:`\rho` 和 :math:`\mu` 。
3. 使用PISO算法求解速度场和压力场，但与icoFoam不同的是添加了体积力。
   





interFoam.C
^^^^^^^^^^^^^^^^

.. code-block:: C

    #include "fvCFD.H"
    #include "interfaceCompression.H"
    #include "CMULES.H"                    // MULS算法
    #include "EulerDdtScheme.H"            // 欧拉离散格式
    #include "localEulerDdtScheme.H"       // 局部欧拉离散格式
    #include "CrankNicolsonDdtScheme.H"    // CrankNicolson离散格式
    #include "subCycle.H"                  // 亚循环。由于alpha是显式离散的，为了减少计算时间而引入
    #include "immiscibleIncompressibleTwoPhaseMixture.H"    // 物理模型
    #include "noPhaseChange.H"
    #include "incompressibleInterPhaseTransportModel.H"     // 湍流头文件
    #include "pimpleControl.H"
    #include "pressureReference.H"
    #include "fvModels.H"
    #include "fvConstraints.H"
    #include "CorrectPhi.H"          // 动量修正
    #include "fvcSmooth.H"


    int main(int argc, char *argv[])
    {
        #include "postProcess.H"

        #include "setRootCaseLists.H"
        #include "createTime.H"
        #include "createMesh.H"
        #include "initContinuityErrs.H"
        #include "createDyMControls.H"
        #include "createFields.H"
        #include "createFieldRefs.H"
        #include "initCorrectPhi.H"
        #include "createUfIfPresent.H"

        if (!LTS)    // 如果不采用局部欧拉格式
        {
            #include "CourantNo.H"           // 读取库朗数
            #include "setInitialDeltaT.H"    // 设置初始的DeltaT
        }

        Info<< "\nStarting time loop\n" << endl;

        while (pimple.run(runTime))
        {
            #include "readDyMControls.H"

            if (LTS)    // 如果使用局部欧拉格式
            {
                #include "setRDeltaT.H"
            }
            else        // 如果不使用局部欧拉格式
            {
                #include "CourantNo.H"
                #include "alphaCourantNo.H"
                #include "setDeltaT.H"
            }

            fvModels.preUpdateMesh();

            // Store divU from the previous mesh so that it can be mapped
            // and used in correctPhi to ensure the corrected phi has the
            // same divergence
            tmp<volScalarField> divU;

            if
            (
                correctPhi
             && !isType<twoPhaseChangeModels::noPhaseChange>(phaseChange)
             && mesh.topoChanged()
            )
            {
                // Construct and register divU for correctPhi
                divU = new volScalarField
                (
                    "divU0",
                    fvc::div(fvc::absolute(phi, U))
                );
            }

            // Update the mesh for topology change, mesh to mesh mapping
            bool topoChanged = mesh.update();

            // Do not apply previous time-step mesh compression flux
            // if the mesh topology changed
            if (topoChanged)
            {
                talphaPhi1Corr0.clear();
            }

            runTime++;

            Info<< "Time = " << runTime.userTimeName() << nl << endl;

            // --- Pressure-velocity PIMPLE corrector loop
            while (pimple.loop())
            {
                if (pimple.firstPimpleIter() || moveMeshOuterCorrectors)
                {
                    if
                    (
                        correctPhi
                     && !isType<twoPhaseChangeModels::noPhaseChange>(phaseChange)
                     && !divU.valid()
                    )
                    {
                        // Construct and register divU for correctPhi
                        divU = new volScalarField
                        (
                            "divU0",
                            fvc::div(fvc::absolute(phi, U))
                        );
                    }

                    // Move the mesh
                    mesh.move();

                    if (mesh.changing())
                    {
                        gh = (g & mesh.C()) - ghRef;
                        ghf = (g & mesh.Cf()) - ghRef;

                        MRF.update();

                        if (correctPhi)
                        {
                            #include "correctPhi.H"
                        }

                        mixture.correct();

                        if (checkMeshCourantNo)
                        {
                            #include "meshCourantNo.H"
                        }
                    }

                    divU.clear();
                }

                fvModels.correct();

                surfaceScalarField rhoPhi
                (
                    IOobject
                    (
                        "rhoPhi",
                        runTime.timeName(),
                        mesh
                    ),
                    mesh,
                    dimensionedScalar(dimMass/dimTime, 0)
                );

                #include "alphaControls.H"
                #include "alphaEqnSubCycle.H"    // 求解alpha

                turbulence.correctPhasePhi();

                mixture.correct();

                #include "UEqn.H"    // 求解U

                // --- Pressure corrector loop
                while (pimple.correct())
                {
                    #include "pEqn.H"    // 求解p
                }

                if (pimple.turbCorr())
                {
                    turbulence.correct();
                }
            }

            runTime.write();

            Info<< "ExecutionTime = " << runTime.elapsedCpuTime() << " s"
                << "  ClockTime = " << runTime.elapsedClockTime() << " s"
                << nl << endl;
        }

        Info<< "End\n" << endl;

        return 0;
    }


interFoam的UEqn.H
^^^^^^^^^^^^^^^^^^^

动量预测步中，考虑线性方程组：

.. math::
    \begin{align}
    A := \frac{\partial \rho[\mathbf{U}]}{\partial t} 
         + \nabla \cdot (\phi [\mathbf{U}]_{f})
         - \nabla \cdot (\mu \nabla [\mathbf{U}])
    \end{align}

于是动量方程可以离散成

.. math::
    \begin{align}
    A_{D}\mathbf{U} = A_{H} + \text{reconstruct}\bigg [ |\mathbf{S}_{f}| \Big( (\sigma_{T}\kappa_{\alpha })_{f}\nabla _{f}^{\perp}\alpha -(\mathbf{g}\cdot\mathbf{x})_{f}\nabla _{f}^{\perp}\rho -\nabla _{f}^{\perp}\rho  \Big) \bigg ]   
    \end{align}

可以看到，为了避免两相密度差距大造成速度场的奇怪振荡，使用了reconstruct操作。这个操作显式地通过面通量 :math:`a_{f}` 建立了网格面中心的场 :math:`\mathbf{a}` ，具体计算方法为

.. math::
    \begin{align}
    \mathbf{a} = \left ( \sum_{f}\mathbf{n}_{f} \otimes \mathbf{S}_{f} \right )^{-1}\cdot \left ( \sum_{f}\mathbf{n}_{f}(\mathbf{S}_{f}\cdot \mathbf{a}_{f} ) \right ) 
    \end{align}

其中 :math:`\mathbf{n}_{f}` 是网格面的单位矢量， :math:`\otimes` 表示外积。

上面的式子是基于这样的假设：

.. math::
    \begin{align}
    \sum_{f}\mathbf{n}_{f}(\mathbf{S}_{f}\cdot\mathbf{a})
    =  \sum_{f}\mathbf{n}_{f}(\mathbf{S}_{f}\cdot\mathbf{a}_{f})
    \end{align}

结合关系 :math:`\mathbf{n}_{f}(\mathbf{S}_{f}\cdot\mathbf{a}) = (\mathbf{n}_{f}\otimes\mathbf{S}_{f})\cdot\mathbf{a}` ，从而上面这个方程可以写成

.. math::
    \begin{align}
    \sum_{f}(\mathbf{n}_{f}\otimes\mathbf{S}_{f})\cdot\mathbf{a}
    =  \sum_{f}\mathbf{n}_{f}(\mathbf{S}_{f}\cdot\mathbf{a}_{f})
    \end{align}

根据外积与内积的性质，可以将求和符号放到括号内部：

.. math::
    \begin{align}
    \sum_{f}\big( (\mathbf{n}_{f} \otimes \mathbf{S}_{f})\cdot \mathbf{a} \big)
    = \left ( \sum_{f}(\mathbf{n}_{f} \otimes \mathbf{S}_{f}) \right ) \cdot \mathbf{a} 
    \end{align}

求逆矩阵移项就得到了 :math:`\mathbf{a}` 的表达式。


.. code-block:: C

    MRF.correctBoundaryVelocity(U);

    fvVectorMatrix UEqn
    (
        fvm::ddt(rho, U) + fvm::div(rhoPhi, U)
      + MRF.DDt(rho, U)
      + turbulence.divDevTau(rho, U)
     ==
       phaseChange.SU(rho, rhoPhi, U)
     + fvModels.source(rho, U)
    );

    UEqn.relax();

    fvConstraints.constrain(UEqn);

    if (pimple.momentumPredictor())
    {
        solve
        (
            UEqn
         ==
            fvc::reconstruct
            (
                (
                    mixture.surfaceTensionForce()    // 表面张力项
                  - ghf*fvc::snGrad(rho)             // 重力项
                  - fvc::snGrad(p_rgh)               // 压强梯度项
                ) * mesh.magSf()                     // 面矢量绝对值
            )
        );

        fvConstraints.constrain(U);
    }



interFoam的pEqn.H
^^^^^^^^^^^^^^^^^^^^

压力方程离散成了

.. math::
    \begin{align}
    \nabla \cdot \left ( \frac{1}{A_{D}} \big(\nabla p + (\mathbf{g}\cdot\mathbf{x})\nabla \rho - \sigma_{T}\kappa_{\alpha}\nabla \alpha \big)\right ) 
    = \nabla \cdot \left ( \frac{A_{H}}{A_{D}} \right )
    \end{align}

在求解动量方程时先不考虑压强的贡献得到通量：

.. math::
    \begin{align}
    \phi^{*} = \left ( \frac{A_{H}}{A_{D}}\right )_{f}\cdot \mathbf{S}_{f}
    + \phi_{g}
    + \phi_{e}
    \end{align}

.. math::
    \begin{align}
    \phi_{g}=\left ( \frac{1}{A_{D}}\right )_{f}|\mathbf{S}_{f}| \bigg( (\sigma _{T}\kappa_{\alpha})_{f} \nabla _{f}^{\perp}\alpha - (\mathbf{g}\cdot\mathbf{x})_{f}\nabla_{f}^{\perp}\rho \bigg)
    \end{align}

.. math::
    \begin{align}
    \phi_{e} = \frac{\gamma \rho}{A_{D}\Delta t}(\phi_{o}-\mathbf{S}_{f}\cdot\mathbf{U}_{f,o} ) 
    \end{align}

.. math::
    \begin{align}
    \gamma = 1 - \min\left ( \frac{|\phi_{o}-\mathbf{U}_{f,o}\cdot\mathbf{S}_{f}|}{|\phi_{o}|+\varepsilon } ,1 \right ) 
    \end{align}

此时的 :math:`\phi^{*}` 还不满足连续性方程，接下来需要进行压力修正，也就需要求解压力方程：

.. math::
    \begin{align}
    \nabla \cdot \left ( \frac{\nabla [p]}{A_{D}}\right ) 
    = \nabla \cdot \left ( \frac{A_{H}}{A_{D}} - (\mathbf{g} \cdot \mathbf{x})\nabla \rho +\sigma_{T}\kappa_{\alpha}\nabla \alpha  \right ) 
    \end{align}

于是可以修正通量为 :math:`\phi=\phi^{*}+\phi^{**}` ，其中

.. math::
    \begin{align}
    \phi^{**}=-|\mathbf{S}_{f}|\cdot \bigg( \big( \frac{1}{A_{D}}\big)_{f}\nabla _{f}^{\perp}p \bigg)
    \end{align}



.. note:: 

    - 使用 :code:`rAU` 表示 :math:`\frac{1}{A_{D}}` ；
    - 使用 :code:`rAUf` 表示 :math:`\left ( \frac{1}{A_{D}}\right )_{f}` ；
    - 使用 :code:`HbyA` 表示 :math:`\frac{A_{H}}{A_{D}}` ；
    - 使用 :code:`phiHbyA` 表示 :math:`\left ( \frac{A_{H}}{A_{D}}\right )_{f}\cdot \mathbf{S}_{f} + \phi_{e}` ；
    - 使用 :code:`phig` 表示 :math:`\phi_{g}` ；
    - 使用 :code:`p_rghEqn` 表示 :math:`\nabla \cdot \left ( \frac{A_{H}}{A_{D}} - (\mathbf{g} \cdot \mathbf{x})\nabla \rho +\sigma_{T}\kappa_{\alpha}\nabla \alpha  \right ) - \nabla \cdot \left ( \frac{\nabla [p]}{A_{D}}\right ) = S_{p}` ，注意这里添加了额外项 :code:`Sp_rgh` ；
    - 使用 :code:`p_rghEqn.flux()` 表示 :math:`\phi^{**}` ；




.. code-block:: C

    {
        if (rAU.valid())
        {
            rAU.ref() = 1.0/UEqn.A();
        }
        else
        {
            rAU = 1.0/UEqn.A();
        }

        surfaceScalarField rAUf("rAUf", fvc::interpolate(rAU()));
        volVectorField HbyA(constrainHbyA(rAU()*UEqn.H(), U, p_rgh));
        surfaceScalarField phiHbyA
        (
            "phiHbyA",
            fvc::flux(HbyA)    // phi^{*}的第一项
          + MRF.zeroFilter(fvc::interpolate(rho*rAU())*fvc::ddtCorr(U, phi, Uf))    // 表示的是\phi_{e}
        );
        MRF.makeRelative(phiHbyA);

        if (p_rgh.needReference())
        {
            fvc::makeRelative(phiHbyA, U);
            adjustPhi(phiHbyA, U, p_rgh);
            fvc::makeAbsolute(phiHbyA, U);
        }

        surfaceScalarField phig
        (
            (
                mixture.surfaceTensionForce()
              - ghf*fvc::snGrad(rho)
            )*rAUf*mesh.magSf()
        );

        phiHbyA += phig;    // 此时phiHbyA就表示成了完整的phi^{*}

        // Update the pressure BCs to ensure flux consistency
        constrainPressure(p_rgh, U, phiHbyA, rAUf, MRF);

        // Cache the phase change pressure source
        fvScalarMatrix Sp_rgh(phaseChange.Sp_rgh(rho, gh, p_rgh));

        while (pimple.correctNonOrthogonal())
        {
            fvScalarMatrix p_rghEqn    // 构建压力方程
            (
                fvc::div(phiHbyA) - fvm::laplacian(rAUf, p_rgh)
             == Sp_rgh
            );

            p_rghEqn.setReference
            (
                pressureReference.refCell(),
                getRefCellValue(p_rgh, pressureReference.refCell())
            );

            p_rghEqn.solve();    // 求解出压力p_rgh

            if (pimple.finalNonOrthogonalIter())
            {
                phi = phiHbyA + p_rghEqn.flux();    // 得到最终修正后的满足连续性方程的通量

                p_rgh.relax();

                U = HbyA + rAU()*fvc::reconstruct((phig + p_rghEqn.flux())/rAUf);    // 求解最终的速度场
                U.correctBoundaryConditions();
                fvConstraints.constrain(U);
            }
        }

        #include "continuityErrs.H"

        // Correct Uf if the mesh is moving
        fvc::correctUf(Uf, U, phi, MRF);

        // Make the fluxes relative to the mesh motion
        fvc::makeRelative(phi, U);

        p == p_rgh + rho*gh;

        if (p_rgh.needReference())
        {
            p += dimensionedScalar
            (
                "p",
                p.dimensions(),
                pressureReference.refValue()
              - getRefCellValue(p, pressureReference.refCell())
            );
            p_rgh = p - rho*gh;
        }

        if (!correctPhi)
        {
            rAU.clear();
        }
    }





自定义求解器
=================


passiveScalarFoam
-------------------

该求解器基于icoFoam进行修改。icoFoam求解器涉及的控制方程如下：

.. math::
    \begin{align}
    \nabla \cdot \mathbf{U} = 0
    \end{align}

.. math::
    \begin{align}
    \frac{\partial \mathbf{U}}{\partial t}
    + \nabla \mathbf{U}\mathbf{U}
    - \nabla \cdot [ \nu (\nabla\mathbf{U}) ] 
    = - \nabla p
    \end{align}

现在额外添加一个基于求解出的速度场的无源标量传输方程：

.. math::
    \begin{align}
    \frac{\partial s}{\partial t} + \nabla \cdot (\mathbf{U}s) = 0
    \end{align}


为了不污染OpenFOAM源程序，需要在自己的run文件夹内建立与OpenFOAM相同的求解器文件结构。在run文件夹内，建立applications/solvers/incompressible文件结构，然后将icoFoam文件夹复制到自己建立的该结构当中。

接下来修改各文件名字：修改该文件夹的名字为passiveScalarFoam，修改icoFoam.C为passiveScalarFoam.C，然后进入Make/files进行修改，其中第一句指定所需编译文件，第二句指定求解器存放位置：

.. code-block:: shell

    passiveScalarFoam.C

    EXE = $(FOAM_USER_APPBIN)/passiveScalarFoam

此时进入终端运行wclean和wmake验证更改名字没有导致编译错误。

接下来进入createFields.H添加定义在体中心的标量场 :math:`s` 。由于定义在体中心的标量场与压力场p是类似的，所以可以直接复制p的内容并修改名字为s作为标量场s的信息(直接放到原文件所有内容的最后即可)：


.. code-block:: C

    Info<< "Reading field s\n" << endl;
    volScalarField s
    (
        IOobject
        (
            "s",
            runTime.timeName(),
            mesh,
            IOobject::MUST_READ,
            IOobject::AUTO_WRITE
        ),
        mesh
    );

保险起见可以再次运行wmake进行编译验证没有任何错误发生。

接下来进入passiveScalarFoam.C进行求解方程的修改。在原PISO算法求解完U和p之后，进行runTime.write()之前，添加下面所需求解的方程：

.. code-block:: C

    solve(fvm::ddt(s)+fvm::div(phi,s));

然后运行wmake进行编译，如此就完成了求解器的修改。接下来可以使用cavity算例来验证一下求解情况。

修改cavity的名字为passiveCavity以区分原本用于icoFoam的算例。进入0文件建立s文件，因为s和p相似，可以直接复制p文件并修改其相应的名字，而量纲可以修改为无量纲，初始条件与边界条件保持相同：

.. code-block:: C

    FoamFile
    {
        format      ascii;
        class       volScalarField;
        object      s;
    }

    dimensions      [0 0 0 0 0 0 0];

    internalField   uniform 0;

    boundaryField
    {
        movingWall
        {
            type            zeroGradient;
        }

        fixedWalls
        {
            type            zeroGradient;
        }

        frontAndBack
        {
            type            empty;
        }
    }


接下来进入fvSchemes设置额外添加方程的离散格式：

.. code-block:: C

    divSchemes
    {
        default         none;
        div(phi,U)      Gauss linear;
        div(phi,s)      Gauss linearUpwind grad(s);
    }

然后进入fvSolution设置所添加方程离散后线性方程组的求解方法：

.. code-block:: C

    s
    {
        solver          smoothSolver;
        smoother        symGaussSeidel;
        tolerance       1e-05;
        relTol          0;
    }


同时修改controlDict的相关内容，然后运行blockMesh和passiveScalarFoam即可。

.. note:: 在后处理过程中可以发现，虽然所添加方程只有对流项，但是结果却呈现出扩散项的现象。这其实是数值耗散的问题。针对这一问题可以参考interFoam求解器是如何应对数值耗散问题的。



temInterFoam
--------------

该求解基于interFoam进行修改。interFoam涉及的控制方程有：

.. math::
    \begin{align}
    \nabla \cdot \mathbf{U} = 0
    \end{align}

.. math::
    \begin{align}
      \frac{\partial \rho\mathbf{U}}{\partial t}
      + \nabla \cdot (\rho\mathbf{U})\mathbf{U}
      - \nabla \cdot [ \mu (\nabla\mathbf{U}) ]
    = - \nabla p
      -  (\mathbf{g} \cdot \mathbf{x})\nabla\rho
      + \sigma_{T}\kappa_{\alpha}\nabla\alpha 
    \end{align}

.. math::
    \begin{align}
      \frac{\partial \alpha }{\partial t}
      + \nabla \cdot \mathbf{U}\alpha 
    = 0 
    \end{align}

.. math::
    \begin{align}
    & \rho = \alpha \rho_{1} + (1 - \alpha )\rho_{2}  \\
    & \mu = \alpha \mu_{1} + (1 - \alpha )\mu_{2}
    \end{align}

将要添加的控制方程需要求解温度的输运过程：

.. math::
    \begin{align}
      \frac{\partial \rho T}{\partial t}
      + \nabla \cdot (\rho \mathbf{U} T)
      - \nabla \cdot (D_{\text{eff}} \nabla T)
    = 0 
    \end{align}

有效扩散系数 :math:`D_{\text{eff}}` 表示为

.. math::
    \begin{align}
      D_{\text{eff}}
    = \frac{\alpha k_{1}}{C_{\text{v1}}}
      + \frac{(1 - \alpha )k_{2}}{C_{\text{v2}}}  
    \end{align}

其中 :math:`k_{1},k_{2},C_{v1},C_{v2}` 代表传导系数和两种流相的热容量。


新建文件结构applications/solvers/multiphase，将OpenFOAM的interFoam文件夹复制到该处，并修改名字为temInterFoam。进入该文件夹，修改interFoam.C名字为temInterFoam.C，并修改Make/files文件的内容为：

.. code-block:: shell

    temInterFoam.C

    EXE = $(FOAM_USER_APPBIN)/temInterFoam

然后运行wclean和wmake验证更改名字没有造成编译错误。

进入createFields.H文件，在最后添加传导系数的内容：

.. code-block:: C

    dimensionedScalar k1
    (
        "k",
        dimensionSet(1,1,-3,-1,0),
        mixture.subDict
        (
            mixture.phase1Name()
        ).lookup("k")
    );

    dimensionedScalar k2
    (
        "k",
        dimensionSet(1,1,-3,-1,0),
        mixture.subDict
        (
            mixture.phase2Name()
        ).lookup("k")
    );

    dimensionedScalar Cv1
    (
        "Cv",
        dimensionSet(0,2,-2,-1,0),
        mixture.subDict
        (
            mixture.phase1Name()
        ).lookup("Cv")
    );

    dimensionedScalar Cv2
    (
        "Cv",
        dimensionSet(0,2,-2,-1,0),
        mixture.subDict
        (
            mixture.phase2Name()
        ).lookup("Cv")
    );

.. note:: 这里可以运行wmake验证没有编译错误。如果只书写了phase1的信息就编译则会提示与phase2相关的错误。



同时复制p_rgh的内容修改得到T的信息：

.. code-block:: C

    Info<< "Reading field T\n" << endl;
    volScalarField T
    (
        IOobject
        (
            "T",
            runTime.timeName(),
            mesh,
            IOobject::MUST_READ,
            IOobject::AUTO_WRITE
        ),
        mesh
    );

运行wmake验证没有编译错误。

为了更好地组织代码，我们将与T相关的方程求解提取到TEqn.H当中。复制UEqn.H并清除其内容改名为TEqn.H，书写其内容：

.. code-block:: C

    volScalarField Deff
    (
        "Deff",
        (alpha1*k1/Cv1 + (scalar(1) - alpha1)*k2/Cv2)
    );

    solve
    (
          fvm::ddt(rho, T)
        + fvm::div(rhoPhi, T)
        - fvm::laplacian(Deff, T)
    );

然后需要将TEqn.H添加到temInterFoam.C里面。需要注意的是，添加位置在pimple loop内部但是在piso loop后面：

.. code-block:: C

    #include "TEqn.H"

进行wmake编译成功后就完成了temInterFoam求解器的编写，后续可以设置算例进行验证。






rhoSonicFoam
---------------

该求解器基于 `foam-extend3.1中的rhoSonicFoam <https://sourceforge.net/p/openfoam-extend/foam-extend-3.1/ci/v3.2/tree/applications/solvers/compressible/rhoSonicFoam/>`_  进行修改以适配OpenFOAM-10环境。


编译准备文件的内容如下：

.. code-block:: shell
    :caption: rhoSonicFoam/Make/files

    rhoSonicFoam.C

    EXE = $(FOAM_USER_APPBIN)/rhoSonicFoam



.. code-block:: shell
    :caption: rhoSonicFoam/Make/options

    EXE_INC = \
        -IBCs/lnInclude \
        -I$(LIB_SRC)/finiteVolume/lnInclude \
        -I$(LIB_SRC)/physicalProperties/lnInclude \
        -I$(LIB_SRC)/thermophysicalModels/basic/lnInclude \
        -I$(LIB_SRC)/thermophysicalModels/specie/lnInclude \
        -I$(LIB_SRC)/MomentumTransportModels/momentumTransportModels/lnInclude \
        -I$(LIB_SRC)/MomentumTransportModels/compressible/lnInclude \
        -I$(LIB_SRC)/ThermophysicalTransportModels/lnInclude \
        -I$(LIB_SRC)/meshTools/lnInclude

    EXE_LIBS = \
        -lfiniteVolume \
        -lfvModels \
        -lfvConstraints \
        -lfluidThermophysicalModels \
        -lspecie \
        -lmomentumTransportModels \
        -lcompressibleMomentumTransportModels \
        -lthermophysicalTransportModels \
        -lmeshTools


rhoSonicFoam求解的方程组如下所示：

.. math::
    \begin{align}
    \frac{\partial \rho}{\partial t}
    + \nabla \cdot (\rho\mathbf{U})
    = 0 
    \end{align}

.. math::
    \begin{align}
    \frac{\partial (\rho\mathbf{U})}{\partial t}
    + \nabla \cdot (\rho\mathbf{UU})
    = -\nabla p
    \end{align}

.. math::
    \begin{align}
    \frac{\partial (\rho E)}{\partial t}
    + \nabla \cdot (\rho \mathbf{U}E)
    = -\nabla \cdot (p\mathbf{U})
    \end{align}


求解器的求解步骤为：

**Step 1** 初始化压强场 :math:`p` 、内能场 :math:`e` 、可压缩性 :math:`\psi` 、密度场 :math:`\rho` 、速度场 :math:`\mathbf{U}` 以及 :math:`\rho\mathbf{U}` 场与 :math:`\rho E` 场；

**Step 2** 计算质量通量场 :math:`\phi^{n}` 和体积通量场 :math:`\phi_{v}^{n}` ；

**Step 3** 求解连续性方程 :math:`\frac{\partial \rho^{n+1}}{\partial t} + \sum \phi_{v}^{n}\rho^{n+1} = 0` ，得到新的密度场 :math:`\rho^{n+1}` ，并更新压强场 :math:`p^{n+1} = \rho^{n+1}/\psi^{n}` ；

**Step 4** 求解动量方程 :math:`\frac{\partial (\rho\mathbf{U})^{n+1}}{\partial t} + \sum \phi_{v}^{n}(\rho\mathbf{U})^{n+1} = -\nabla p^{n+1}` ，得到新的 :math:`(\rho\mathbf{U})^{n+1}` ，据此更新速度场 :math:`\mathbf{U}^{n+1} = (\rho\mathbf{U})^{n+1}/\rho^{n+1}` ，同时计算新的体积通量场 :math:`\phi_{v}^{n+1}` ；

**Step 5** 求解能量方程 :math:`\frac{\partial (\rho E)^{n+1}}{\partial t} + \sum \phi_{v}^{n}(\rho E)^{n+1} = - \sum \phi_{v}^{n+1}p^{n+1}` ，得到新的 :math:`(\rho E)^{n+1}` ，据此得到 :math:`e^{n+1} = \Big[(\rho E)^{n+1} - \frac{1}{2}\rho^{n+1}\Big|\mathbf{U}^{n+1}\Big|^{2}\Big]/\rho^{n+1}` ，并通过thermo.correct()更新温度场 :math:`T^{n+1}` 、可压缩性场 :math:`\psi^{n+1}` 等；

**Step 6** 该时间步求解完成，回到Step2开始循环进入下一时间步求解。


.. code-block:: C
    :caption: rhoSonicFoam/createFields.H
    
    Info<< "Reading thermodynamicProperties\n" << endl;
    
    autoPtr<fluidThermo> pThermo
    (
        fluidThermo::New(mesh)
    );
    fluidThermo& thermo = pThermo();
    thermo.validate(args.executable(), "h", "e");
    
    volScalarField& p = thermo.p();
    volScalarField& e = thermo.he();
    const volScalarField& psi = thermo.psi();
    const volScalarField& T = thermo.T();
    
    volScalarField rho
    (
        IOobject
        (
            "rho",
            runTime.timeName(),
            mesh,
            IOobject::READ_IF_PRESENT,
            IOobject::AUTO_WRITE
        ),
        thermo.rho(),
        p.boundaryField().types()
    );
    
    Info<< "Reading field U\n" << endl;
    volVectorField U
    (
        IOobject
        (
            "U",
            runTime.timeName(),
            mesh,
            IOobject::MUST_READ,
            IOobject::AUTO_WRITE
        ),
        mesh
    );
    
    volVectorField rhoU
    (
        IOobject
        (
            "rhoU",
            runTime.timeName(),
            mesh,
            IOobject::NO_READ,
            IOobject::NO_WRITE
        ),
        rho*U,
        U.boundaryField().types()
    );
    
    volScalarField rhoE
    (
        IOobject
        (
            "rhoE",
            runTime.timeName(),
            mesh,
            IOobject::NO_READ,
            IOobject::NO_WRITE
        ),
        rho*e + 0.5*rho*magSqr(U),
        T.boundaryField().types()
    );



.. code-block:: C
    :caption: rhoSonicFoam/rhoSonicFoam.C

    #include "fvCFD.H"
    #include "psiThermo.H"
    #include "compressibleMomentumTransportModels.H"
    #include "fluidThermophysicalTransportModel.H"
    #include "fvcSmooth.H"

    int main(int argc, char *argv[])
    {
        #include "postProcess.H"
        #include "setRootCaseLists.H"
        #include "createTime.H"
        #include "createMesh.H"
        #include "createFields.H"

        Info<< "\nStarting time loop\n" << endl;

        while (runTime.loop())
        {
            Info<< "Time = " << runTime.timeName() << nl << endl;

            surfaceScalarField phi("phi", fvc::flux(rhoU));
        
            surfaceScalarField phiv
            (
                IOobject
                (
                    "phiv",
                    runTime.timeName(),
                    mesh,
                    IOobject::NO_READ,
                    IOobject::NO_WRITE
                ),
                fvc::interpolate(rhoU)/fvc::interpolate(rho) & mesh.Sf()
            );

            scalar CoNum = max
            (
                mesh.surfaceInterpolation::deltaCoeffs()
               *mag(phiv)/mesh.magSf()
            ).value()*runTime.deltaT().value();

            Info<< "\nMax Courant Number = " << CoNum << endl;

            solve
            (
                fvm::ddt(rho)
              + fvm::div(phiv, rho)
            );

            p = rho/psi;
            
            solve
            (
                fvm::ddt(rhoU)
              + fvm::div(phiv, rhoU)
             ==
              - fvc::grad(p)
            );
            
            U == rhoU/rho;
            
            surfaceScalarField phiv2
            (
                IOobject
                (
                    "phiv2",
                    runTime.timeName(),
                    mesh,
                    IOobject::NO_READ,
                    IOobject::NO_WRITE
                ),
                fvc::interpolate(rhoU)/fvc::interpolate(rho) & mesh.Sf()
            );
        
            solve
            (
                fvm::ddt(rhoE)
              + fvm::div(phiv, rhoE)
             ==
              - fvc::div(phiv2, p)
            );
            e == (rhoE - 0.5*rho*magSqr(rhoU/rho))/rho;
            thermo.correct();
            
            runTime.write();

            Info<< "ExecutionTime = " << runTime.elapsedCpuTime() << " s"
                << "  ClockTime = " << runTime.elapsedClockTime() << " s"
                << nl << endl;
        }

        Info<< "End\n" << endl;

        return 0;
    }



rhoSonicTurbFoam
-------------------

该求解器在rhoSonicFoam的基础上添加湍流模型以及能量方程的热通量项。编译准备文件的内容如下：

.. code-block:: shell
    :caption: rhoSonicTurbFoam/Make/files

    rhoSonicTurbFoam.C

    EXE = $(FOAM_USER_APPBIN)/rhoSonicTurbFoam


.. code-block:: shell
    :caption: rhoSonicTurbFoam/Make/options

    EXE_INC = \
        -IBCs/lnInclude \
        -I$(LIB_SRC)/finiteVolume/lnInclude \
        -I$(LIB_SRC)/physicalProperties/lnInclude \
        -I$(LIB_SRC)/thermophysicalModels/basic/lnInclude \
        -I$(LIB_SRC)/thermophysicalModels/specie/lnInclude \
        -I$(LIB_SRC)/MomentumTransportModels/momentumTransportModels/lnInclude \
        -I$(LIB_SRC)/MomentumTransportModels/compressible/lnInclude \
        -I$(LIB_SRC)/ThermophysicalTransportModels/lnInclude \
        -I$(LIB_SRC)/meshTools/lnInclude

    EXE_LIBS = \
        -lfiniteVolume \
        -lfvModels \
        -lfvConstraints \
        -lfluidThermophysicalModels \
        -lspecie \
        -lmomentumTransportModels \
        -lcompressibleMomentumTransportModels \
        -lthermophysicalTransportModels \
        -lmeshTools

rhoSonicTurbFoam求解的方程组如下所示：

.. math::
    \begin{align}
    \frac{\partial \rho}{\partial t} + \nabla \cdot (\rho\mathbf{U}) = 0
    \end{align}

.. math::
    \begin{align}
    \frac{\partial (\rho\mathbf{U})}{\partial t}
    + \nabla \cdot (\rho\mathbf{UU})
    - \rho\mathbf{R}_{\text{eff}}
    = - \nabla p
    \end{align}

.. math::
    \begin{align}
    \frac{\partial (\rho e)}{\partial t}
    + \frac{\partial (\rho K)}{\partial t}
    + \nabla \cdot (\rho\mathbf{U}e)
    + \nabla \cdot (\rho\mathbf{U}K)
    + \nabla \cdot (p\mathbf{U})
    + \nabla \cdot \mathbf{q}
    = 0
    \end{align}


求解器的求解步骤为：

**Step 1** 初始化压力场 :math:`p^{n}` 、能量场 :math:`e` 、可压缩性场 :math:`\psi^{n}` 、密度场 :math:`\rho^{n}` 、速度场 :math:`\mathbf{U}^{n}` ，建立动能场 :math:`K^{n} = \frac{1}{2}|\mathbf{U}^{n}|^{2}` 、质量通量场 :math:`\phi^{n} = (\rho^{n}\mathbf{U}^{n})_{f}\cdot \mathbf{S}_{f}` 和体积通量场 :math:`\phi_{v}^{n} = \mathbf{U}_{f}^{n}\cdot\mathbf{S}_{f}` ；

**Step 2** 求解连续性方程 :math:`\frac{\partial \rho^{n+1}}{\partial t} + \sum \phi_{v}^{n}\rho^{n+1} = 0` ，得到新的密度场 :math:`\rho^{n+1}` ，据此更新压力场 :math:`p^{n+1} = \rho^{n+1}/\psi^{n}` ；

**Step 3** 求解动量方程 :math:`\frac{\partial \rho^{n+1}\mathbf{U}^{n+1}}{\partial t} + \sum \phi^{n}\mathbf{U}^{n+1} - \rho^{n+1}\mathbf{R}_{\text{eff}} = - \nabla p^{n+1}` ，得到新的速度场 :math:`\mathbf{U}^{n+1}` ，并据此更新质量通量场 :math:`\phi^{n+1} = (\rho^{n+1}\mathbf{U}^{n+1})_{f}\cdot \mathbf{S}_{f}` 、体积通量场 :math:`\phi_{v}^{n+1} = \mathbf{U}_{f}^{n+1}\cdot\mathbf{S}_{f}` 和动能场 :math:`K^{n+1}=\frac{1}{2}|\mathbf{U}^{n+1}|^{2}` ；

**Step 4** 求解能量方程 :math:`\frac{\partial \rho^{n+1}e^{n+1}}{\partial t} + \frac{\partial \rho^{n+1}K^{n+1}}{\partial t} + \sum\phi^{n+1}e^{n+1} + \sum \phi^{n+1}K^{n+1} + \sum\phi^{n+1}\frac{p^{n+1}}{\rho^{n+1}} + \nabla\cdot\mathbf{q} = 0` ，得到新的能量场 :math:`e^{n+1}` ，据此通过thermo.correct()更新温度场 :math:`T^{n+1}` 、可压缩性场 :math:`\psi^{n+1}` 等；

**Step 5** 更新湍流模型参数turbulence->correct()和热物理输运模型参数thermophysicalTransport->correct()；

**Step 6** 该时间步求解完毕，回到Step 2进入下一个时间步的循环。



.. code-block:: C
    :caption: rhoSonicTurbFoam/createFields.H

    Info<< "Reading thermodynamicProperties\n" << endl;

    autoPtr<fluidThermo> pThermo
    (
        fluidThermo::New(mesh)
    );
    fluidThermo& thermo = pThermo();
    thermo.validate(args.executable(), "h", "e");

    volScalarField& p = thermo.p();
    volScalarField& he = thermo.he();
    const volScalarField& psi = thermo.psi();

    volScalarField rho
    (
        IOobject
        (
            "rho",
            runTime.timeName(),
            mesh,
            IOobject::READ_IF_PRESENT,
            IOobject::AUTO_WRITE
        ),
        thermo.rho(),
        p.boundaryField().types()
    );

    Info<< "Reading field U\n" << endl;
    volVectorField U
    (
        IOobject
        (
            "U",
            runTime.timeName(),
            mesh,
            IOobject::MUST_READ,
            IOobject::AUTO_WRITE
        ),
        mesh
    );

    Info<< "Creating field kinetic energy K\n" << endl;
    volScalarField K("K", 0.5*magSqr(U));

    surfaceScalarField phi("phi", fvc::flux(rho*U));
    surfaceScalarField phiv("phiv", fvc::flux(U));

    Info<< "Creating turbulence model\n" << endl;
    autoPtr<compressible::momentumTransportModel> turbulence
    (
        compressible::momentumTransportModel::New
        (
            rho,
            U,
            phi,
            thermo
        )
    );

    Info<< "Creating thermophysical transport model\n" << endl;
    autoPtr<fluidThermophysicalTransportModel> thermophysicalTransport
    (
        fluidThermophysicalTransportModel::New(turbulence(), thermo)
    );



.. code-block:: C
    :caption: rhoSonicTurbFoam/rhoSonicTurbFoam.C

    #include "fvCFD.H"
    #include "psiThermo.H"
    #include "compressibleMomentumTransportModels.H"
    #include "fluidThermophysicalTransportModel.H"
    #include "fvcSmooth.H"

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    int main(int argc, char *argv[])
    {
        #include "postProcess.H"
        #include "setRootCaseLists.H"
        #include "createTime.H"
        #include "createMesh.H"
        #include "createFields.H"
        
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

        Info<< "\nStarting time loop\n" << endl;

        while (runTime.loop())
        {
            Info<< "Time = " << runTime.timeName() << nl << endl;

            scalar CoNum = max
            (
                mesh.surfaceInterpolation::deltaCoeffs()
               *mag(phiv)/mesh.magSf()
            ).value()*runTime.deltaT().value();

            Info<< "\nMax Courant Number = " << CoNum << endl;

            fvScalarMatrix rhoEqn
            (
                    fvm::ddt(rho)
                  + fvm::div(phiv, rho)
            );
        
            rhoEqn.relax();
            rhoEqn.solve();
        
            p = rho/psi;
            
            
            fvVectorMatrix UEqn
            (
                fvm::ddt(rho, U)
              + fvm::div(phi, U)
              + turbulence->divDevTau(U)
             ==
              - fvc::grad(p)
            );
            
            UEqn.relax();
            UEqn.solve();

            phi = fvc::flux(rho*U);
            phiv = fvc::flux(U);
            K = 0.5*magSqr(U);
            
            fvScalarMatrix EEqn
            (
                fvm::ddt(rho, he) + fvm::div(phi, he)
              + fvc::ddt(rho, K) + fvc::div(phi, K)
              + (
                he.name() == "e"
                  ? fvc::div(phi, p/rho)
                  : - fvc::ddt(p)
                )
              + thermophysicalTransport->divq(he)
            );

            EEqn.relax();
            EEqn.solve();
            thermo.correct();


        
            turbulence->correct();
            thermophysicalTransport->correct();

            runTime.write();


            Info<< "ExecutionTime = " << runTime.elapsedCpuTime() << " s"
                << "  ClockTime = " << runTime.elapsedClockTime() << " s"
                << nl << endl;
        }

        Info<< "End\n" << endl;

        return 0;
    }


dbns
-------

这是foam-extend中的密度基求解器模型库，通过对代码进行部分修改以适配OpenFOAM-10的环境。在Make文件夹中的files和options文件需要添加如下内容

.. code-block:: shell
    :caption: src/dbns/Make/files

    dbnsFlux/roeFlux/roeFlux.C
    dbnsFlux/rusanovFlux/rusanovFlux.C
    dbnsFlux/betaFlux/betaFlux.C
    dbnsFlux/hllcFlux/hllcFlux.C
    dbnsFlux/hllcALEFlux/hllcALEFlux.C

    basicNumericFlux/basicNumericFlux.C
    basicNumericFlux/newBasicNumericFlux.C
    numericFlux/numericFluxes.C

    multigrid/mgMeshLevel/mgMeshLevel.C
    multigrid/mgMeshLevel/fineMgMeshLevel.C
    multigrid/mgMeshLevel/coarseMgMeshLevel.C

    multigrid/mgFieldLevel/mgFieldLevel.C
    multigrid/mgFieldLevel/fineMgFieldLevel.C
    multigrid/mgFieldLevel/coarseMgFieldLevel.C

    timeStepping/localTimeStep/localTimeStep.C
    timeStepping/backwardDualDdtScheme/backwardDualDdtSchemes.C
    timeStepping/EulerLocalDdtScheme/EulerLocalDdtSchemes.C

    LIB = $(FOAM_USER_LIBBIN)/libdbns

.. attention:: 其中的多重网格和时间步进功能还没有修改完成。

.. code-block:: shell
    :caption: src/dbns/Make/options

    EXE_INC = \
        -I$(LIB_SRC)/finiteVolume/lnInclude \
        -I$(LIB_SRC)/meshTools/lnInclude \
        -I$(LIB_SRC)/physicalProperties/lnInclude \
        -I$(LIB_SRC)/thermophysicalModels/basic/lnInclude \
        -I$(LIB_SRC)/MomentumTransportModels/momentumTransportModels/lnInclude \
        -I$(LIB_SRC)/MomentumTransportModels/compressible/lnInclude \
        -I$(LIB_SRC)/ThermophysicalTransportModels/lnInclude \
        -I$(LIB_SRC)/dummyThirdParty/MGridGen/lnInclude

    LIB_LIBS = \
        -lfiniteVolume \
        -lmeshTools




dbnsFoam
^^^^^^^^^^^

使用dbnsFoam求解器时，fvSchemes文件内需要修改成

.. code-block:: C

    ddtSchemes
    {
        default         none;
        ddt(rho)        Euler;
        ddt(rhoU)       Euler;
        ddt(rhoE)       Euler;
        p               Euler;
    }

    gradSchemes
    {
        default         none;
        grad(p)    Gauss linear;
        grad(U)    Gauss linear;
        grad(T)    Gauss linear;
    }

    divSchemes
    {
        default         none;
        dbns
        {
            limiter    firstOrder;
            flux       hllc;
        }
    }

    laplacianSchemes
    {
        default         none;
    }

    interpolationSchemes
    {
        default           none;
        interpolate(sqrt((((Cp|Cv)*(Cp-Cv))*T)))    linear;
        interpolate(rho)    linear;
    }

    snGradSchemes
    {
        default         none;
    }


fvSolution文件需要修改成

.. code-block:: C

    solvers
    {
        rho
        {
            solver          smoothSolver;
            smoother        GaussSeidel;
            nSweeps         2;
            tolerance       1e-09;
            relTol          0.01;
        }

        rhoU
        {
            solver          smoothSolver;
            smoother        GaussSeidel;
            nSweeps         2;
            tolerance       1e-09;
            relTol          0.01;
        }

        rhoE
        {
            solver          smoothSolver;
            smoother        GaussSeidel;
            nSweeps         2;
            tolerance       1e-09;
            relTol          0.01;
        }
    }

    fieldBounds
    {
        p    0    1e16;
        T    10   1e16;
        rho  0    1e16;
    }


在编译该求解器时，Make文件夹内的files和options分别需要写入以下内容：

.. code-block:: shell
    :caption: applications/solvers/compressible/dbnsFoam/Make/files

    dbnsFoam.C

    EXE = $(FOAM_USER_APPBIN)/dbnsFoam


.. code-block:: shell
    :caption: applications/solvers/compressible/dbnsFoam/Make/options

    EXE_INC = \
        -I$(LIB_SRC)/finiteVolume/lnInclude \
        -I$(LIB_SRC)/physicalProperties/lnInclude \
        -I$(LIB_SRC)/thermophysicalModels/basic/lnInclude \
        -I$(LIB_SRC)/thermophysicalModels/specie/lnInclude \
        -I$(LIB_SRC)/MomentumTransportModels/momentumTransportModels/lnInclude \
        -I$(LIB_SRC)/MomentumTransportModels/compressible/lnInclude \
        -I$(LIB_SRC)/ThermophysicalTransportModels/lnInclude \
        -I$(LIB_SRC)/meshTools/lnInclude \
        -I../../../../src/dbns/lnInclude

    EXE_LIBS = \
        -lfiniteVolume \
        -lfvModels \
        -lfvConstraints \
        -lfluidThermophysicalModels \
        -lspecie \
        -lmomentumTransportModels \
        -lcompressibleMomentumTransportModels \
        -lthermophysicalTransportModels \
        -lmeshTools \
        -L$(FOAM_USER_LIBBIN) -ldbns


该求解器初始化场和湍流模型、热物理模型的createFields.H文件如下：

.. code-block:: C
    :caption: applications/solvers/compressible/dbnsFoam/createFields.H

    Info<< "Reading thermodynamicProperties\n" << endl;

    autoPtr<fluidThermo> pThermo
    (
        fluidThermo::New(mesh)
    );
    fluidThermo& thermo = pThermo();
    thermo.validate(args.executable(), "h", "e");


    volScalarField& p = thermo.p();
    volScalarField& h = thermo.he();    // should be enthalpy
    const volScalarField& T = thermo.T();

    volScalarField rho
    (
        IOobject
        (
            "rho",
            runTime.timeName(),
            mesh,
            IOobject::READ_IF_PRESENT,
            IOobject::AUTO_WRITE
        ),
        thermo.rho(),
        p.boundaryField().types()
    );

    Info<< "Reading field U\n" << endl;
    volVectorField U
    (
        IOobject
        (
            "U",
            runTime.timeName(),
            mesh,
            IOobject::MUST_READ,
            IOobject::AUTO_WRITE
        ),
        mesh
    );

    volVectorField rhoU
    (
        IOobject
        (
            "rhoU",
            runTime.timeName(),
            mesh,
            IOobject::NO_READ,
            IOobject::NO_WRITE
        ),
        rho*U,
        U.boundaryField().types()
    );

    volScalarField rhoE
    (
        IOobject
        (
            "rhoE",
            runTime.timeName(),
            mesh,
            IOobject::NO_READ,
            IOobject::NO_WRITE
        ),
        rho*(h + 0.5*magSqr(U)) - p,
        T.boundaryField().types()
    );

    // Create numeric flux
    autoPtr<basicNumericFlux> dbnsFluxPtr = basicNumericFlux::New
    (
        p,
        U,
        T,
        pThermo()
    );
    basicNumericFlux& dbnsFlux = dbnsFluxPtr();

    // Create mass flux alias for easier coupling with other code components
    const surfaceScalarField& phi = dbnsFlux.rhoFlux();

dbnsFoam求解器的主体结构代码如下：

.. code-block:: C
    :caption: applications/solvers/compressible/dbnsFoam/dbnsFoam.C

    #include "fvCFD.H"
    #include "psiThermo.H"
    #include "bound.H"
    #include "hllcFlux.H"
    #include "roeFlux.H"
    #include "rusanovFlux.H"
    #include "betaFlux.H"
    #include "MDLimiter.H"
    #include "firstOrderLimiter.H"
    #include "BarthJespersenLimiter.H"
    #include "VenkatakrishnanLimiter.H"
    #include "numericFlux.H"

    #include "compressibleMomentumTransportModels.H"
    #include "fluidThermophysicalTransportModel.H"

    int main(int argc, char *argv[])
    {
        #include "setRootCaseLists.H"
        #include "createTime.H"
        #include "createMesh.H"
        #include "createFields.H"
        #include "createTimeControls.H"

        Info<< "\nStarting time loop\n" << endl;

        // Runge-Kutta coefficient
        scalarList beta(4);
        beta[0] = 0.1100;
        beta[1] = 0.2766;
        beta[2] = 0.5000;
        beta[3] = 1.0000;

        // Switch off solver messages
        lduMatrix::debug = 0;

        while (runTime.loop())
        {
            #include "readTimeControls.H"
            #include "readFieldBounds.H"
            #include "acousticCourantNo.H"
            //#include "setDeltaT.H"  replace it by the following codes
            if (adjustTimeStep)
            {
                scalar maxDeltaTFact = maxCo/(CoNum + SMALL);
                scalar deltaTFact = min(min(maxDeltaTFact, 1.0 + 0.1*maxDeltaTFact), 1.2);

                runTime.setDeltaT
                (
                min
                (
                    deltaTFact*runTime.deltaT().value(),
                    maxDeltaT
                )
                );

                Info<< "deltaT = " <<  runTime.deltaT().value() << endl;
            }

            runTime++;

            Info<< "Time = " << runTime.timeName() << nl << endl;
            
            // Low storage Runge-Kutta time integration
            forAll (beta, i)
            {
                // Solve the approximate Riemann problem for this time step
                dbnsFlux.computeFlux();

                // Time integration
                solve
                (
                    1.0/beta[i]*fvm::ddt(rho)
                  + fvc::div(dbnsFlux.rhoFlux())
                );

                solve
                (
                    1.0/beta[i]*fvm::ddt(rhoU)
                  + fvc::div(dbnsFlux.rhoUFlux())
                );

                solve
                (
                    1.0/beta[i]*fvm::ddt(rhoE)
                  + fvc::div(dbnsFlux.rhoEFlux())
                );

                #include "updateFields.H"
            }

            runTime.write();

            Info<< "    ExecutionTime = "
                << runTime.elapsedCpuTime()
                << " s\n" << endl;
        }

        Info<< "End\n" << endl;

        return 0;
    }


dbnsTurbFoam
^^^^^^^^^^^^^^^

.. code-block:: shell
    :caption: applications/solvers/compressible/dbnsTurbFoam/Make/files

    dbnsTurbFoam.C

    EXE = $(FOAM_USER_APPBIN)/dbnsTurbFoam


.. code-block:: shell
    :caption: applications/solvers/compressible/dbnsTurbFoam/Make/options

    EXE_INC = \
        -I$(LIB_SRC)/finiteVolume/lnInclude \
        -I$(LIB_SRC)/physicalProperties/lnInclude \
        -I$(LIB_SRC)/thermophysicalModels/basic/lnInclude \
        -I$(LIB_SRC)/thermophysicalModels/specie/lnInclude \
        -I$(LIB_SRC)/MomentumTransportModels/momentumTransportModels/lnInclude \
        -I$(LIB_SRC)/MomentumTransportModels/compressible/lnInclude \
        -I$(LIB_SRC)/ThermophysicalTransportModels/lnInclude \
        -I$(LIB_SRC)/meshTools/lnInclude \
        -I../../../../src/dbns/lnInclude

    EXE_LIBS = \
        -lfiniteVolume \
        -lfvModels \
        -lfvConstraints \
        -lfluidThermophysicalModels \
        -lspecie \
        -lmomentumTransportModels \
        -lcompressibleMomentumTransportModels \
        -lthermophysicalTransportModels \
        -lmeshTools \
        -L$(FOAM_USER_LIBBIN) -ldbns


.. code-block:: C
    :caption: applications/solvers/compressible/dbnsTurbFoam/createFields.H

    Info<< "Reading thermodynamicProperties\n" << endl;

    autoPtr<fluidThermo> pThermo
    (
        fluidThermo::New(mesh)
    );
    fluidThermo& thermo = pThermo();
    thermo.validate(args.executable(), "h", "e");


    volScalarField& p = thermo.p();
    volScalarField& h = thermo.he();    // should be enthalpy
    const volScalarField& T = thermo.T();

    volScalarField rho
    (
        IOobject
        (
            "rho",
            runTime.timeName(),
            mesh,
            IOobject::READ_IF_PRESENT,
            IOobject::AUTO_WRITE
        ),
        thermo.rho(),
        p.boundaryField().types()
    );

    Info<< "Reading field U\n" << endl;
    volVectorField U
    (
        IOobject
        (
            "U",
            runTime.timeName(),
            mesh,
            IOobject::MUST_READ,
            IOobject::AUTO_WRITE
        ),
        mesh
    );

    volVectorField rhoU
    (
        IOobject
        (
            "rhoU",
            runTime.timeName(),
            mesh,
            IOobject::NO_READ,
            IOobject::NO_WRITE
        ),
        rho*U,
        U.boundaryField().types()
    );

    volScalarField rhoE
    (
        IOobject
        (
            "rhoE",
            runTime.timeName(),
            mesh,
            IOobject::NO_READ,
            IOobject::NO_WRITE
        ),
        rho*(h + 0.5*magSqr(U)) - p,
        T.boundaryField().types()
    );

    // Create numeric flux
    autoPtr<basicNumericFlux> dbnsFluxPtr = basicNumericFlux::New
    (
        p,
        U,
        T,
        pThermo()
    );
    basicNumericFlux& dbnsFlux = dbnsFluxPtr();

    // Create mass flux alias for easier coupling with other code components
    const surfaceScalarField& phi = dbnsFlux.rhoFlux();

    Info<< "Creating turbulence model\n" << endl;
    autoPtr<compressible::momentumTransportModel> turbulence
    (
        compressible::momentumTransportModel::New
        (
            rho,
            U,
            phi,
            thermo
        )
    );

    Info<< "Creating thermophysical transport model\n" << endl;
    autoPtr<fluidThermophysicalTransportModel> thermophysicalTransport
    (
        fluidThermophysicalTransportModel::New(turbulence(), thermo)
    );


.. code-block:: C
    :caption: applications/solvers/compressible/dbnsTurbFoam/dbnsTurbFoam.C

    #include "fvCFD.H"
    #include "psiThermo.H"
    #include "bound.H"
    #include "hllcFlux.H"
    #include "roeFlux.H"
    #include "rusanovFlux.H"
    #include "betaFlux.H"
    #include "MDLimiter.H"
    #include "firstOrderLimiter.H"
    #include "BarthJespersenLimiter.H"
    #include "VenkatakrishnanLimiter.H"
    #include "numericFlux.H"
    #include "compressibleMomentumTransportModels.H"
    #include "fluidThermophysicalTransportModel.H"

    int main(int argc, char *argv[])
    {
        #include "setRootCaseLists.H"
        #include "createTime.H"
        #include "createMesh.H"
        #include "createFields.H"
        #include "createTimeControls.H"

        Info<< "\nStarting time loop\n" << endl;

        // Runge-Kutta coefficient
        scalarList beta(4);
        beta[0] = 0.1100;
        beta[1] = 0.2766;
        beta[2] = 0.5000;
        beta[3] = 1.0000;

        // Switch off solver messages
        lduMatrix::debug = 0;

        while (runTime.loop())
        {
            #include "readTimeControls.H"
            #include "readFieldBounds.H"
            #include "acousticCourantNo.H"
            //#include "setDeltaT.H"  replace it by the following codes
            if (adjustTimeStep)
            {
                scalar maxDeltaTFact = maxCo/(CoNum + SMALL);
                scalar deltaTFact = min(min(maxDeltaTFact, 1.0 + 0.1*maxDeltaTFact), 1.2);

                runTime.setDeltaT
                (
                    min
                    (
                        deltaTFact*runTime.deltaT().value(),
                        maxDeltaT
                    )
                );

                Info<< "deltaT = " <<  runTime.deltaT().value() << endl;
            }

            runTime++;

            Info<< "Time = " << runTime.timeName() << nl << endl;
            
            // Low storage Runge-Kutta time integration
            forAll (beta, i)
            {
                // Solve the approximate Riemann problem for this time step
                dbnsFlux.computeFlux();

                // Time integration
                solve
                (
                    1.0/beta[i]*fvm::ddt(rho)
                  + fvc::div(dbnsFlux.rhoFlux())
                );

                solve
                (
                    1.0/beta[i]*fvm::ddt(rhoU)
                  + fvc::div(dbnsFlux.rhoUFlux())
                  + fvc::div(-rho*turbulence->nuEff()*dev(twoSymm(fvc::grad(U))))    // change from +fvc::div(turbulence->devRhoReff())
                );

                solve
                (
                    1.0/beta[i]*fvm::ddt(rhoE)
                  + fvc::div(dbnsFlux.rhoEFlux())
                  + fvc::div(-rho*turbulence->nuEff()*dev(twoSymm(fvc::grad(U))) & U)    // change from + fvc::div(turbulence->devRhoReff() & U)
                  - fvc::laplacian(thermophysicalTransport->alphaEff(), h)    // change from -fvc::laplacian(turbulence->alphaEff(), h)
                );
            
                #include "updateFields.H"
            }

            // Switch on solver messages for turbulence
            lduMatrix::debug = 1;

            turbulence->correct();
            thermophysicalTransport->correct();

            runTime.write();

            Info<< "    ExecutionTime = "
                << runTime.elapsedCpuTime()
                << " s\n" << endl;
        }

        Info<< "End\n" << endl;

        return 0;
    }


include
^^^^^^^^^^

.. code-block:: C
    :caption: src/dbns/include/readFieldBounds.H

    // Read field bounds
    dictionary fieldBounds = mesh.solution().subDict("fieldBounds");

    // Pressure bounds
    dimensionedScalar pMin("pMin", p.dimensions(), SMALL);
    dimensionedScalar pMax("pMax", p.dimensions(), 1e10);
    fieldBounds.lookup(p.name()) >> pMin.value() >> pMax.value();

    // Temperature bounds
    dimensionedScalar TMin("TMin", T.dimensions(), SMALL);
    dimensionedScalar TMax("TMax", T.dimensions(), 1e10);
    fieldBounds.lookup(T.name()) >> TMin.value() >> TMax.value();

    // Density bounds
    dimensionedScalar rhoMin("rhoMin", rho.dimensions(), SMALL);
    dimensionedScalar rhoMax("rhoMax", rho.dimensions(), 1e10);
    fieldBounds.lookup(rho.name()) >> rhoMin.value() >> rhoMax.value();


.. code-block:: C
    :caption: src/dbns/include/acousticCourantNo.H

    scalar CoNum = 0.0;
    scalar meanCoNum = 0.0;

    if (mesh.nInternalFaces())
    {

        volScalarField speed_of_sound = sqrt(thermo.Cp() / thermo.Cv() * (thermo.Cp() - thermo.Cv()) * T);
        surfaceScalarField acCo =
                (mag(phi) / (fvc::interpolate(rho) * mesh.magSf()) + fvc::interpolate(speed_of_sound))
                * mesh.surfaceInterpolation::deltaCoeffs() * runTime.deltaT();

        CoNum = gMax(acCo.internalField());

        meanCoNum = gSum(acCo.internalField()) / mesh.nInternalFaces();
    }

    Info<< "Acoustic Courant Number mean: " << meanCoNum
        << " max: " << CoNum << endl;


.. code-block:: C
    :caption: src/dbns/include/updateFields.H

    // Compute U
    U = rhoU/rho;
    U.correctBoundaryConditions();

    // Calculate enthalpy from rhoE
    const volScalarField Cp = thermo.Cp();
    const volScalarField Cv = thermo.Cv();

    // h = rhoE/rho - 0.5*magSqr(U) + p/rho;
    // Alternative formulation, Felipe Alves Portela TU Delft
    h = Cp/Cv*(rhoE/rho - 0.5*magSqr(U));
    h.correctBoundaryConditions();

    // Bound enthalpy
    dimensionedScalar CpMin = min(Cp);
    dimensionedScalar CpMax = max(Cp);

    dimensionedScalar hMin = CpMin*TMin;
    dimensionedScalar hMax = CpMax*TMax;

    //boundMinMax(h, hMin, hMax);
    bound(h, hMin);

    // Correct thermodynamics
    thermo.correct();

    // Bound density
    //boundMinMax(rho, rhoMin, rhoMax);
    bound(rho, rhoMin);

    // Compute p from rho
    p = rho*(thermo.Cp() - thermo.Cv())*T;
    p.correctBoundaryConditions();

    // Bound pressure
    //boundMinMax(p, pMin, pMax);
    bound(p, pMin);



numericFlux
^^^^^^^^^^^^^^

密度基求解器的单级数值通量类。数值通量对象如下进行创建与初始化：

.. code-block:: C
    :caption: src/dbns/numericFlux/numericFlux.C

    template<class Flux, class Limiter>
    Foam::numericFlux<Flux, Limiter>::numericFlux
    (
        const volScalarField& p,
        const volVectorField& U,
        const volScalarField& T,
        basicThermo& thermo
    )
    :
        numericFluxBase<Flux>(p.mesh()),
        p_(p),
        U_(U),
        T_(T),
        thermo_(thermo),
        rhoFlux_
        (
            IOobject
            (
                "phi",
                this->mesh().time().timeName(),
                this->mesh(),
                IOobject::NO_READ,
                IOobject::NO_WRITE
            ),
            (linearInterpolate(thermo_.rho()*U_) & this->mesh().Sf())
        ),
        rhoUFlux_
        (
            IOobject
            (
                "rhoUFlux",
                this->mesh().time().timeName(),
                this->mesh(),
                IOobject::NO_READ,
                IOobject::NO_WRITE
            ),
            rhoFlux_*linearInterpolate(U_)
        ),
        rhoEFlux_
        (
            IOobject
            (
                "rhoEFlux",
                this->mesh().time().timeName(),
                this->mesh(),
                IOobject::NO_READ,
                IOobject::NO_WRITE
            ),
            rhoFlux_*linearInterpolate(thermo.Cv()*T_ + 0.5*magSqr(U_))
        )
    {}


在求解器中调用的computeFlux函数执行了通量计算操作，它调用了相应的limiter，并依次计算每个网格面的数值通量。其中调用limiter的部分如下所示：

.. code-block:: C
    :caption: src/dbns/numericFlux/numericFlux.C

    const tmp<volVectorField> tgradP = fvc::grad(p_);
    const volVectorField& gradP = tgradP();

    const tmp<volTensorField> tgradU = fvc::grad(U_);
    const volTensorField& gradU = tgradU();

    const tmp<volVectorField> tgradT = fvc::grad(T_);
    const volVectorField& gradT = tgradT();

    MDLimiter<scalar, Limiter> scalarPLimiter(this->p_, gradP);
    MDLimiter<vector, Limiter> vectorULimiter(this->U_, gradU);
    MDLimiter<scalar, Limiter> scalarTLimiter(this->T_, gradT);

    const volScalarField& pLimiter = scalarPLimiter.phiLimiter();
    const volVectorField& ULimiter = vectorULimiter.phiLimiter();
    const volScalarField& TLimiter = scalarTLimiter.phiLimiter();

在计算网格内部的数值通量时如下进行计算：

.. code-block:: C
    :caption: src/dbns/numericFlux/numericFlux.C

    forAll (owner, faceI)
    {
        const label own = owner[faceI];
        const label nei = neighbour[faceI];

        const vector deltaRLeft = faceCentre[faceI] - cellCentre[own];
        const vector deltaRRight = faceCentre[faceI] - cellCentre[nei];

        // calculate fluxes with reconstructed primitive variables at faces
        Flux::evaluateFlux
        (
            rhoFlux_[faceI],
            rhoUFlux_[faceI],
            rhoEFlux_[faceI],
            p_[own] + pLimiter[own]*(deltaRLeft & gradP[own]),
            p_[nei] + pLimiter[nei]*(deltaRRight & gradP[nei]),
            U_[own] + cmptMultiply(ULimiter[own], (deltaRLeft & gradU[own])),
            U_[nei] + cmptMultiply(ULimiter[nei], (deltaRRight & gradU[nei])),
            T_[own] + TLimiter[own]*(deltaRLeft & gradT[own]),
            T_[nei] + TLimiter[nei]*(deltaRRight & gradT[nei]),
            R[own],
            R[nei],
            Cv[own],
            Cv[nei],
            Sf[faceI],
            magSf[faceI]
        );
    }


对于边界处的数值通量则如下进行计算（coupled边界条件则有所不同）：

.. code-block:: C
    :caption: src/dbns/numericFlux/numericFlux.C

    forAll (pp, facei)
    {
        // Calculate fluxes
        Flux::evaluateFlux
        (
            pRhoFlux[facei],
            pRhoUFlux[facei],
            pRhoEFlux[facei],
            pp[facei],
            pp[facei],
            pU[facei],
            pU[facei],
            pT[facei],
            pT[facei],
            pR[facei],
            pR[facei],
            pCv[facei],
            pCv[facei],
            pSf[facei],
            pMagSf[facei]
        );
    }

上述的计算数值通量所调用的evaluateFlux函数具体执行的内容由选取的Flux类型决定，其函数也在dbnsFlux中进行定义。


betaFlux
^^^^^^^^^^

.. code-block:: C
    :caption: src/dbns/dbnsFlux/betaFlux/betaFlux.C

    void Foam::betaFlux::evaluateFlux
    (
        scalar& rhoFlux,
        vector& rhoUFlux,
        scalar& rhoEFlux,
        const scalar& pLeft,
        const scalar& pRight,
        const vector& ULeft,
        const vector& URight,
        const scalar& TLeft,
        const scalar& TRight,
        const scalar& RLeft,
        const scalar& RRight,
        const scalar& CvLeft,
        const scalar& CvRight,
        const vector& Sf,
        const scalar& magSf
    ) const
    {
        // Step 1: decode rho left and right:
        scalar rhoLeft = pLeft/(RLeft*TLeft);
        scalar rhoRight = pRight/(RRight*TRight);

        // Decode left and right total energy:
        scalar eLeft = CvLeft*TLeft+0.5*magSqr(ULeft);
        scalar eRight = CvRight*TRight+0.5*magSqr(URight);

        // Adiabatic exponent is constant for ideal gas but if Cp=Cp(T) it must be computed for each cell and evaluated at each face through reconstruction
        const scalar kappaLeft = (CvLeft+RLeft)/CvLeft;
        const scalar kappaRight = (CvRight+RRight)/CvRight;

        // normal vector
        vector normalVector = Sf/magSf;

        // Compute left and right contravariant velocities:
        const scalar contrVLeft  = (ULeft & normalVector);
        const scalar contrVRight = (URight & normalVector);

        // Compute left and right total enthalpies:
        const scalar hLeft = eLeft + pLeft/rhoLeft;
        const scalar hRight = eRight + pRight/rhoRight;

        // Compute left and right velocity square
        const scalar qLeftSquare  = magSqr(ULeft);
        const scalar qRightSquare = magSqr(URight);

        // compute left and right speed of sound
        const scalar cLeft = sqrt(max((kappaLeft - 1)*(hLeft - 0.5*qLeftSquare), SMALL));
        const scalar cRight = sqrt(max((kappaRight - 1)*(hRight - 0.5*qRightSquare), SMALL));

        const scalar magULeft  = mag(ULeft);
        const scalar magURight = mag(URight);

        const scalar MLeft = mag(magULeft/cLeft);
        const scalar MRight = mag(magURight/cRight);

        // Compute beta parameter - this should be done in multidimensional way similarly to multidimensional limiters
        const scalar Mmax = max(MLeft, MRight);
        const scalar Mmin = min(MLeft, MRight);

        scalar beta = 0;

        if (Mmin > 0)
        {
            scalar alpha = 0.1;
            scalar r = sqrt(sqr(Mmax) - sqr(Mmin))/Mmin;

            if (r >= alpha)
            {
                beta = min(r,1);
            }
        }

        // Step 2: compute Roe averaged quantities for face:
        const scalar rhoTilde = sqrt(max(rhoLeft*rhoRight, SMALL));

        // Some temporary variables:
        const scalar rhoLeftSqrt = sqrt(max(rhoLeft, SMALL));
        const scalar rhoRightSqrt = sqrt(max(rhoRight, SMALL));

        const scalar wLeft = rhoLeftSqrt/(rhoLeftSqrt + rhoRightSqrt);
        const scalar wRight = 1 - wLeft;

        const vector UTilde = ULeft*wLeft + URight*wRight;
        const scalar hTilde = hLeft*wLeft + hRight*wRight;
        const scalar qTildeSquare = magSqr(UTilde);
        const scalar kappaTilde = kappaLeft*wLeft + kappaRight*wRight;

        // Speed of sound
        const scalar cTilde = sqrt(max((kappaTilde - 1)*(hTilde - 0.5*qTildeSquare), SMALL));

        // Roe averaged contravariant velocity
        const scalar contrVTilde = (UTilde & normalVector);

        // Step 3: compute primitive differences:
        const scalar deltaP = pRight - pLeft;
        const scalar deltaRho = rhoRight - rhoLeft;
        const vector deltaU = URight - ULeft;
        const scalar deltaContrV = (deltaU & normalVector);

        // Step 4: compute wave strengths:

        // Roe and Pike - formulation
        const scalar r1 = (deltaP - rhoTilde*cTilde*deltaContrV)/(2.0*sqr(cTilde));
        const scalar r2 = deltaRho - deltaP/sqr(cTilde);
        const scalar r3 = (deltaP + rhoTilde*cTilde*deltaContrV)/(2.0*sqr(cTilde));

        // Step 5: compute l vectors

        // rho row:
        const scalar l1rho = 1;
        const scalar l2rho = 1;
        const scalar l3rho = 0;
        const scalar l4rho = 1;

        // first U column
        const vector l1U = UTilde - cTilde*normalVector;

        // second U column
        const vector l2U = UTilde;

        // third U column
        const vector l3U = deltaU - deltaContrV*normalVector;

        // fourth U column
        const vector l4U = UTilde + cTilde*normalVector;

        // E row
        const scalar l1e = hTilde - cTilde*contrVTilde;
        const scalar l2e = 0.5*qTildeSquare;
        const scalar l3e = (UTilde & deltaU) - contrVTilde*deltaContrV;
        const scalar l4e = hTilde + cTilde*contrVTilde;

        // Step 6: compute eigenvalues

        scalar lambda1 = mag(contrVTilde - cTilde);
        scalar lambda2 = mag(contrVTilde);
        scalar lambda3 = mag(contrVTilde + cTilde);

        scalar lambdaMax = max(max(lambda1, lambda2), lambda3);

        scalar lambda1Max = beta*lambda1 + (1 - beta)*lambdaMax;
        scalar lambda2Max = beta*lambda2 + (1 - beta)*lambdaMax;
        scalar lambda3Max = beta*lambda3 + (1 - beta)*lambdaMax;

        // Step 7: check for Harten entropy correction


        // Components of deltaF1
        const scalar diffF11  = lambda1Max*r1*l1rho;
        const vector diffF124 = lambda1Max*r1*l1U;
        const scalar diffF15  = lambda1Max*r1*l1e;

        // Components of deltaF2
        const scalar diffF21  = lambda2Max*(r2*l2rho + rhoTilde*l3rho);
        const vector diffF224 = lambda2Max*(r2*l2U + rhoTilde*l3U);
        const scalar diffF25  = lambda2Max*(r2*l2e + rhoTilde*l3e);

        // Components of deltaF3
        const scalar diffF31  = lambda3Max*r3*l4rho;
        const vector diffF324 = lambda3Max*r3*l4U;
        const scalar diffF35  = lambda3Max*r3*l4e;

        // Step 8: compute left and right fluxes

        // Left flux 5-vector
        const scalar fluxLeft11 = rhoLeft*contrVLeft;
        const vector fluxLeft124 = ULeft*fluxLeft11 + normalVector*pLeft;
        const scalar fluxLeft15 = hLeft*fluxLeft11;

        // Right flux 5-vector
        const scalar fluxRight11 = rhoRight*contrVRight;
        const vector fluxRight124 = URight*fluxRight11 + normalVector*pRight;
        const scalar fluxRight15 = hRight*fluxRight11;

        // Step 9: compute face flux 5-vector
        const scalar flux1 = 0.5*(fluxLeft11 + fluxRight11 - (diffF11 + diffF21 + diffF31));
        const vector flux24 = 0.5*(fluxLeft124 + fluxRight124 - (diffF124 + diffF224 + diffF324));
        const scalar flux5 = 0.5*(fluxLeft15 + fluxRight15 - (diffF15 + diffF25 + diffF35));

        // Compute private data
        rhoFlux  = flux1*magSf;
        rhoUFlux = flux24*magSf;
        rhoEFlux = flux5*magSf;
    }

hllcFlux
^^^^^^^^^^

.. math::
    \begin{align}
    \kappa_{L} = \frac{R_{L} - C_{vL}}{C_{vL}} ,\quad \kappa_{R} = \frac{R_{R} - C_{vR}}{C_{vR}}
    \end{align}

.. math::
    \begin{align}
    \rho_{L} = \frac{p_{L}}{R_{L}T_{L}} ,\quad \rho_{R} = \frac{p_{R}}{R_{R}T_{R}}
    \end{align}

.. math::
    \begin{align}
    (\rho\mathbf{U})_{L} = \rho_{L}\mathbf{U}_{L} ,\quad (\rho\mathbf{U})_{R} = \rho_{R}\mathbf{U}_{R}
    \end{align}

.. math::
    \begin{align}
    (\rho E)_{L} = \rho_{L}(C_{vL}T_{L} + \frac{1}{2}|\mathbf{U}_{L}|^{2})
    ,\quad
    (\rho E)_{R} = \rho_{R}(C_{vR}T_{R} + \frac{1}{2}|\mathbf{U}_{R}|^{2})
    \end{align}

.. math::
    \begin{align}
    H_{L} = \frac{(\rho E)_{L} + p_{L}}{\rho_{L}}
    ,\quad
    H_{R} = \frac{(\rho E)_{R} + p_{R}}{\rho_{R}}
    \end{align}

.. math::
    \begin{align}
    a_{L} = \sqrt{\frac{\kappa_{L}p_{L}}{\rho_{L}}}
    ,\quad
    a_{R} = \sqrt{\frac{\kappa_{R}p_{R}}{\rho_{R}}}
    \end{align}

.. math::
    \begin{align}
    \tilde{\mathbf{U}} = \frac{\sqrt{\rho_{L}}}{\sqrt{\rho_{L}} + \sqrt{\rho_{R}}}\mathbf{U}_{L} + \frac{\sqrt{\rho_{R}}}{\sqrt{\rho_{L}} + \sqrt{\rho_{R}}}\mathbf{U}_{R}
    \end{align}

.. math::
    \begin{align}
    \tilde{H} = \frac{\sqrt{\rho_{L}}}{\sqrt{\rho_{L}} + \sqrt{\rho_{R}}}H_{L} + \frac{\sqrt{\rho_{R}}}{\sqrt{\rho_{L}} + \sqrt{\rho_{R}}}H_{R}
    \end{align}

.. math::
    \begin{align}
    \tilde{\kappa} = \frac{\sqrt{\rho_{L}}}{\sqrt{\rho_{L}} + \sqrt{\rho_{R}}}\kappa_{L} + \frac{\sqrt{\rho_{R}}}{\sqrt{\rho_{L}} + \sqrt{\rho_{R}}}\kappa_{R}
    \end{align}

.. math::
    \begin{align}
    \tilde{a} = \sqrt{(\tilde{\kappa} - 1) \Big(\tilde{H} - \frac{1}{2}(\tilde{\mathbf{U}} \cdot \mathbf{n}_{f})\Big)}
    \end{align}

.. math::
    \begin{align}
    S_{L} = \min\Big( \mathbf{U}_{L}\cdot\mathbf{n}_{f} - a_{L}, \tilde{\mathbf{U}}\cdot\mathbf{n}_{f} - \tilde{a} \Big)
    ,\quad
    S_{R} = \max\Big( \mathbf{U}_{R}\cdot\mathbf{n}_{f} + a_{R}, \tilde{\mathbf{U}}\cdot\mathbf{n}_{f} + \tilde{a} \Big)
    \end{align}

.. math::
    \begin{align}
    S_{*} = \frac{
    \rho_{R}(\mathbf{U}_{R}\cdot\mathbf{n}_{f})(S_{R} - \mathbf{U}_{R}\cdot\mathbf{n}_{f})
    - \rho_{L}(\mathbf{U}_{L}\cdot\mathbf{n}_{f})(S_{L} - \mathbf{U}_{L}\cdot\mathbf{n}_{f})
    + p_{L} - p_{R} 
    }{
    \rho_{R}(S_{R} - \mathbf{U}_{R}\cdot\mathbf{n}_{f}) - \rho_{L}(S_{L} - \mathbf{U}_{L}\cdot\mathbf{n}_{f})
    }
    \end{align}

.. math::
    \begin{align}
    p_{*L} = \rho_{L}(\mathbf{U}_{L}\cdot\mathbf{n}_{f} - S_{L})(\mathbf{U}_{L}\cdot\mathbf{n}_{f} - S_{*}) + p_{L}
    ,\quad
    p_{*R} = \rho_{R}(\mathbf{U}_{R}\cdot\mathbf{n}_{f} - S_{R})(\mathbf{U}_{R}\cdot\mathbf{n}_{f} - S_{*}) + p_{R}
    ,\quad
    p_{*} = p_{*L} = p_{*R}
    \end{align}


如果 :math:`S_{L} > 0` ，则

.. math::
    \begin{align}
    \mathbf{F} =
    \begin{bmatrix}
    (\mathbf{U}_{L}\cdot\mathbf{n}_{f}) \rho_{L} S_{f} \\
    \Big((\mathbf{U}_{L}\cdot\mathbf{n}_{f}) (\rho\mathbf{U})_{L} + p_{L}\mathbf{n}_{f}\Big)S_{f} \\
    (\mathbf{U}_{L}\cdot\mathbf{n}_{f})\big((\rho E)_{L} + p_{L}\big)S_{f}
    \end{bmatrix}
    \end{align}


如果 :math:`S_{*} > 0` ，则

.. math::
    \begin{align}
    \mathbf{F} = 
    \begin{bmatrix}
    S_{*}\frac{S_{L} - \mathbf{U}_{L}\cdot\mathbf{n}_{f}}{S_{L} - S_{*}}\rho_{L}S_{f} \\
    \Big( S_{*}\frac{(S_{L} - \mathbf{U}_{L}\cdot\mathbf{n}_{f})(\rho\mathbf{U})_{L} + (p_{*} - p_{L})\mathbf{n}_{f}}{S_{L} - S_{*}} + p_{*}\mathbf{n}_{f} \Big)S_{f} \\
    S_{*}\Big(\frac{(S_{L} - \mathbf{U}_{L}\cdot\mathbf{n}_{f})(\rho E)_{L} - p_{L}(\mathbf{U}_{L}\cdot\mathbf{n}_{f}) + p_{*}S_{*}}{S_{L} - S_{*}} + p_{*}\Big)S_{f}
    \end{bmatrix}
    \end{align}

如果 :math:`S_{R} > 0` ，则

.. math::
    \begin{align}
    \mathbf{F} = 
    \begin{bmatrix}
    S_{*}\frac{S_{R} - \mathbf{U}_{R}\cdot\mathbf{n}_{f}}{S_{L} - S_{*}}\rho_{R}S_{f} \\
    \Big( S_{*}\frac{(S_{R} - \mathbf{U}_{R}\cdot\mathbf{n}_{f})(\rho\mathbf{U})_{R} + (p_{*} - p_{R})\mathbf{n}_{f}}{S_{R} - S_{*}} + p_{*}\mathbf{n}_{f} \Big)S_{f} \\
    S_{*}\Big(\frac{(S_{R} - \mathbf{U}_{R}\cdot\mathbf{n}_{f})(\rho E)_{R} - p_{R}(\mathbf{U}_{R}\cdot\mathbf{n}_{f}) + p_{*}S_{*}}{S_{R} - S_{*}} + p_{*}\Big)S_{f}
    \end{bmatrix}
    \end{align}

如果 :math:`S_{R} < 0` ，则

.. math::
    \begin{align}
    \mathbf{F} =
    \begin{bmatrix}
    (\mathbf{U}_{R}\cdot\mathbf{n}_{f}) \rho_{R} S_{f} \\
    \Big((\mathbf{U}_{R}\cdot\mathbf{n}_{f}) (\rho\mathbf{U})_{R} + p_{R}\mathbf{n}_{f}\Big)S_{f} \\
    (\mathbf{U}_{R}\cdot\mathbf{n}_{f})\big((\rho E)_{R} + p_{R}\big)S_{f}
    \end{bmatrix}
    \end{align}



.. code-block:: C
    :caption: src/dbns/dbnsFlux/hllcFlux/hllcFlux.C

    void Foam::hllcFlux::evaluateFlux
    (
        scalar& rhoFlux,
        vector& rhoUFlux,
        scalar& rhoEFlux,
        const scalar& pLeft,
        const scalar& pRight,
        const vector& ULeft,
        const vector& URight,
        const scalar& TLeft,
        const scalar& TRight,
        const scalar& RLeft,
        const scalar& RRight,
        const scalar& CvLeft,
        const scalar& CvRight,
        const vector& Sf,
        const scalar& magSf
    ) const
    {
        // Step 1: decode left and right:
        // normal vector
        const vector normalVector = Sf/magSf;

        // Ratio of specific heat capacities
        const scalar kappaLeft = (RLeft + CvLeft)/CvLeft;
        const scalar kappaRight = (RRight + CvRight)/CvRight;

        // Compute conservative variables assuming perfect gas law

        // Density
        const scalar rhoLeft = pLeft/(RLeft*TLeft);
        const scalar rhoRight = pRight/(RRight*TRight);

        // DensityVelocity
        const vector rhoULeft = rhoLeft*ULeft;
        const vector rhoURight = rhoRight*URight;

        // DensityTotalEnergy
        const scalar rhoELeft = rhoLeft*(CvLeft*TLeft+0.5*magSqr(ULeft));
        const scalar rhoERight = rhoRight*(CvRight*TRight+0.5*magSqr(URight));

        // Compute left and right total enthalpies:
        const scalar HLeft = (rhoELeft + pLeft)/rhoLeft;
        const scalar HRight = (rhoERight + pRight)/rhoRight;

        // Compute qLeft and qRight (q_{l,r} = U_{l,r} \bullet n)
        const scalar qLeft = (ULeft & normalVector);
        const scalar qRight = (URight & normalVector);

        // Speed of sound, for left and right side, assuming perfect gas
        const scalar aLeft = Foam::sqrt(max(0.0,kappaLeft * pLeft/rhoLeft));

        const scalar aRight = Foam::sqrt(max(0.0,kappaRight * pRight/rhoRight));


        // Step 2:
        // needs rho_{l,r}, U_{l,r}, H_{l,r}, kappa_{l,r}, Gamma_{l,r}, q_{l,r}

        // Compute Roe weights
        const scalar rhoLeftSqrt = Foam::sqrt(max(0.0,rhoLeft));
        const scalar rhoRightSqrt = Foam::sqrt(max(0.0,rhoRight));

        const scalar wLeft = rhoLeftSqrt/stabilise((rhoLeftSqrt + rhoRightSqrt),VSMALL);

        const scalar wRight = 1 - wLeft;

        // Roe averaged velocity
        const vector UTilde = wLeft*ULeft + wRight*URight;

        // Roe averaged contravariant velocity
        const scalar contrUTilde = (UTilde & normalVector);

        // Roe averaged total enthalpy
        const scalar HTilde = wLeft*HLeft + wRight*HRight;

        // Roe averaged kappa
        // TODO: needs to be verified!
        const scalar kappaTilde = wLeft*kappaLeft + wRight*kappaRight;

        // Speed of sound with Roe reconstruction values
        // TODO: not sure if the correct (flow speed) and kappa is used here
        const scalar aTilde = Foam::sqrt(max(0 ,(kappaTilde - 1)*(HTilde - 0.5*sqr(contrUTilde))));

        // Step 3: compute signal speeds for face:
        const scalar SLeft  = min(qLeft-aLeft, contrUTilde-aTilde);
        const scalar SRight = max(contrUTilde+aTilde, qRight+aRight);

        const scalar SStar = (rhoRight*qRight*(SRight-qRight) - rhoLeft*qLeft*(SLeft - qLeft) + pLeft - pRight )/stabilise((rhoRight*(SRight-qRight)-rhoLeft*(SLeft-qLeft)),VSMALL);

        // Compute pressure in star region from the right side
        const scalar pStarRight = rhoRight*(qRight - SRight)*(qRight - SStar) + pRight;

        // Should be equal to the left side
        const scalar pStarLeft  = rhoLeft*(qLeft -  SLeft)*(qLeft - SStar) + pLeft;

        // Give a warning if this is not the case
        if (mag(pStarRight - pStarLeft) > 1e-6)
        {
            Info << "mag(pStarRight-pStarLeft) > VSMALL " << endl;
        }

        // Use pStarRight for pStar, as in theory, pStarRight == pStarLeft
        const scalar pStar = pStarRight;

        // Step 4: upwinding - compute states:
        scalar convectionSpeed = 0.0;
        scalar rhoState = 0.0;
        vector rhoUState = vector::zero;
        scalar rhoEState = 0.0;
        scalar pState = 0.0;

        if (pos(SLeft))
        {
            // compute F_l
            convectionSpeed = qLeft;
            rhoState  = rhoLeft;
            rhoUState = rhoULeft;
            rhoEState = rhoELeft;
            pState = pLeft;
        }
        else if (pos(SStar))
        {
            scalar omegaLeft = scalar(1.0)/stabilise((SLeft - SStar), VSMALL);

            // Compute left star region
            convectionSpeed = SStar;
            rhoState  = omegaLeft*(SLeft - qLeft)*rhoLeft;
            rhoUState = omegaLeft*((SLeft - qLeft)*rhoULeft + (pStar - pLeft)*normalVector);
            rhoEState = omegaLeft*((SLeft - qLeft)*rhoELeft - pLeft*qLeft + pStar*SStar);
            pState = pStar;
        }
        else if (pos(SRight))
        {
            scalar omegaRight = scalar(1.0)/stabilise((SRight - SStar), VSMALL);

            // compute right star region
            convectionSpeed = SStar;
            rhoState  = omegaRight*(SRight - qRight)*rhoRight;
            rhoUState = omegaRight*((SRight - qRight)*rhoURight + (pStar - pRight)*normalVector);
            rhoEState = omegaRight*((SRight - qRight)*rhoERight - pRight*qRight + pStar*SStar);
            pState = pStar;
        }
        else if (neg(SRight))
        {
            // compute F_r
            convectionSpeed = qRight;
            rhoState  = rhoRight;
            rhoUState = rhoURight;
            rhoEState = rhoERight;
            pState = pRight;
        }
        else
        {
            Info << "Error in HLLC Riemann solver" << endl;
        }

        rhoFlux  = (convectionSpeed*rhoState)*magSf;
        rhoUFlux = (convectionSpeed*rhoUState + pState*normalVector)*magSf;
        rhoEFlux = (convectionSpeed*(rhoEState + pState))*magSf;
    }


hllcALEFlux
^^^^^^^^^^^^^

.. code-block:: C
    :caption: src/dbns/dbnsFlux/hllcALEFlux/hllcALEFlux.C

    void Foam::hllcALEFlux::evaluateFlux
    (
        scalar& rhoFlux,
        vector& rhoUFlux,
        scalar& rhoEFlux,
        const scalar& pLeft,
        const scalar& pRight,
        const vector& ULeft,
        const vector& URight,
        const scalar& TLeft,
        const scalar& TRight,
        const scalar& RLeft,
        const scalar& RRight,
        const scalar& CvLeft,
        const scalar& CvRight,
        const vector& Sf,
        const scalar& magSf,
        const vector& dotX
    ) const
    {
        // Step 1: decode left and right:
        // normal vector
        const vector normalVector = Sf/magSf;

        // Ratio of specific heat capacities
        const scalar kappaLeft = (RLeft + CvLeft)/CvLeft;
        const scalar kappaRight = (RRight + CvRight)/CvRight;

        // Compute conservative variables assuming perfect gas law

        // Density
        const scalar rhoLeft = pLeft/(RLeft*TLeft);
        const scalar rhoRight = pRight/(RRight*TRight);

        // DensityVelocity
        const vector rhoULeft = rhoLeft*ULeft;
        const vector rhoURight = rhoRight*URight;

        // DensityTotalEnergy
        const scalar rhoELeft = rhoLeft*(CvLeft*TLeft + 0.5*magSqr(ULeft));
        const scalar rhoERight = rhoRight*(CvRight*TRight + 0.5*magSqr(URight));

        // Compute left and right total enthalpies:
        const scalar HLeft = (rhoELeft + pLeft)/rhoLeft;
        const scalar HRight = (rhoERight + pRight)/rhoRight;

        // Compute velocity relative to mesh
        const vector URelLeft = ULeft - dotX;
        const vector URelRight = URight - dotX;

        // Compute qLeft and qRight (q_{l,r} = U_{l,r} \bullet n)
        const scalar qLeft = (URelLeft & normalVector);
        const scalar qRight = (URelRight & normalVector);

        // Speed of sound, for left and right side, assuming perfect gas
        const scalar aLeft = Foam::sqrt(max(0 , kappaLeft*pLeft/rhoLeft));
        const scalar aRight = Foam::sqrt(max(0, kappaRight*pRight/rhoRight));


        // Step 2:
        // needs rho_{l,r}, U_{l,r}, H_{l,r}, kappa_{l,r}, Gamma_{l,r}, q_{l,r}
        // compute Roe weights
        const scalar rhoLeftSqrt = Foam::sqrt(max(0.0,rhoLeft));
        const scalar rhoRightSqrt = Foam::sqrt(max(0.0,rhoRight));

        const scalar wLeft = rhoLeftSqrt / stabilise((rhoLeftSqrt + rhoRightSqrt),VSMALL);
        const scalar wRight = 1 - wLeft;

        // Roe averaged velocity
        const vector UTilde = wLeft*ULeft + wRight*URight;

        // Roe averaged relative face velocity
        const scalar contrURelTilde = ((UTilde - dotX) & normalVector);

        // Roe averaged contravariant velocity
        const scalar contrUTilde = (UTilde & normalVector);

        // Roe averaged total enthalpy
        const scalar HTilde = wLeft*HLeft + wRight*HRight;

        // Roe averaged kappa
        // TODO: needs to be verified!
        const scalar kappaTilde = wLeft*kappaLeft + wRight*kappaRight;

        // Speed of sound with Roe reconstruction values
        // TODO: not sure if the correct (flow speed) and kappa is used here
        const scalar aTilde = Foam::sqrt(max(0.0,(kappaTilde-1.0)*(HTilde-0.5*sqr(contrUTilde))));

        // Step 3: compute signal speeds for face:
        const scalar SLeft  = min(qLeft-aLeft,   contrURelTilde-aTilde);
        const scalar SRight = max(qRight+aRight, contrURelTilde+aTilde);

        const scalar SStar = (rhoRight*qRight*(SRight-qRight)
        - rhoLeft*qLeft*(SLeft - qLeft) + pLeft - pRight )/
            stabilise((rhoRight*(SRight-qRight)-rhoLeft*(SLeft-qLeft)),VSMALL);

        // Compute pressure in star region from the right side
        const scalar pStarRight = rhoRight*(qRight - SRight)*(qRight - SStar) + pRight;

        // Should be equal to the left side
        const scalar pStarLeft  = rhoLeft*(qLeft -  SLeft)*(qLeft - SStar) + pLeft;

        // Give a warning if this is not the case
        if ( mag(pStarRight-pStarLeft) > 1e-6 )
        {
            Info << "mag(pStarRight-pStarLeft) > VSMALL " << endl;
        }

        // Use pStarRight for pStar, as in theory, pStarRight == pStarLeft
        const scalar pStar = pStarRight;

        // Step 4: upwinding - compute states:
        scalar convectionSpeed = 0.0;
        scalar rhoState = 0.0;
        vector rhoUState = vector::zero;
        scalar rhoEState = 0.0;
        scalar pState = 0.0;

        // TODO: Maybe one can use pos/neg implementation, but then one has to evaluate all 4 states at each iteration!
        // label A = pos(SLeft);
        // label B = pos(SStar);
        // label C = pos(SRight);
        // please double check the bool operators again, if one want's to implement this!!!
        // scalar convectionSpeed = A*B*C*qLeft+(1-A)*B*C*SStar +(1-A)*(1-B)*C*SStar+(1-A)*(1-B)*(1-C)*qRight:

        if (pos(SLeft))
        {
            // Compute F_l
            convectionSpeed = qLeft;
            rhoState  = rhoLeft;
            rhoUState = rhoULeft;
            rhoEState = rhoELeft;
            pState = pLeft;
        }
        else if (pos(SStar))
        {
            scalar omegaLeft = scalar(1.0)/stabilise((SLeft - SStar), VSMALL);

            // Compute left star region
            convectionSpeed = SStar;
            rhoState  = omegaLeft*(SLeft - qLeft)*rhoLeft;
            rhoUState = omegaLeft*((SLeft - qLeft)*rhoULeft + (pStar - pLeft)*normalVector);
            rhoEState = omegaLeft*((SLeft - qLeft)*rhoELeft - pLeft*qLeft + pStar*SStar);
            pState = pStar;
        }
        else if (pos(SRight))
        {
            scalar omegaRight = scalar(1.0)/stabilise((SRight - SStar), VSMALL);

            // Compute right star region
            convectionSpeed = SStar;
            rhoState  = omegaRight*(SRight - qRight)*rhoRight;
            rhoUState = omegaRight*((SRight - qRight)*rhoURight + (pStar - pRight)*normalVector);
            rhoEState = omegaRight*((SRight - qRight)*rhoERight - pRight*qRight + pStar*SStar);
            pState = pStar;
        }
        else if (neg(SRight))
        {
            // Compute F_r
            convectionSpeed = qRight;
            rhoState  = rhoRight;
            rhoUState = rhoURight;
            rhoEState = rhoERight;
            pState = pRight;
        }
        else
        {
            Info << "Error in HLLC Riemann solver" << endl;
        }

        rhoFlux  = (convectionSpeed*rhoState)*magSf;
        rhoUFlux = (convectionSpeed*rhoUState+pState*normalVector)*magSf;
        rhoEFlux = (convectionSpeed*(rhoEState+pState) + pState*(dotX & normalVector))*magSf;
    }



roeFlux
^^^^^^^^^^

.. code-block:: C
    :caption: src/dbns/dbnsFlux/roeFlux/roeFlux.C

    void Foam::roeFlux::evaluateFlux
    (
        scalar& rhoFlux,
        vector& rhoUFlux,
        scalar& rhoEFlux,
        const scalar& pLeft,
        const scalar& pRight,
        const vector& ULeft,
        const vector& URight,
        const scalar& TLeft,
        const scalar& TRight,
        const scalar& RLeft,
        const scalar& RRight,
        const scalar& CvLeft,
        const scalar& CvRight,
        const vector& Sf,
        const scalar& magSf
    ) const
    {
        // Step 1: decode rho left and right:
        scalar rhoLeft = pLeft/(RLeft*TLeft);
        scalar rhoRight = pRight/(RRight*TRight);

        // Decode left and right total energy:
        scalar eLeft = CvLeft*TLeft + 0.5*magSqr(ULeft);
        scalar eRight = CvRight*TRight + 0.5*magSqr(URight);

        // Adiabatic exponent is constant for ideal gas but if Cp=Cp(T) it must be computed for each cell and evaluated at each face through reconstruction
        const scalar kappaLeft = (CvLeft + RLeft)/CvLeft;
        const scalar kappaRight = (CvRight + RRight)/CvRight;

        // normal vector
        vector normalVector = Sf/magSf;

        // Compute left and right contravariant velocities:
        const scalar contrVLeft  = (ULeft & normalVector);
        const scalar contrVRight = (URight & normalVector);

        // Compute left and right total enthalpies:
        const scalar hLeft = eLeft + pLeft/rhoLeft;
        const scalar hRight = eRight + pRight/rhoRight;

        // Step 2: compute Roe averged quantities for face:
        const scalar rhoTilde = sqrt(max(rhoLeft*rhoRight, SMALL));

        // Some temporary variables:
        const scalar rhoLeftSqrt = sqrt(max(rhoLeft, SMALL));
        const scalar rhoRightSqrt = sqrt(max(rhoRight, SMALL));

        const scalar wLeft = rhoLeftSqrt/(rhoLeftSqrt + rhoRightSqrt);
        const scalar wRight = 1 - wLeft;

        const vector UTilde = ULeft*wLeft + URight*wRight;
        const scalar hTilde = hLeft*wLeft + hRight*wRight;
        const scalar qTildeSquare = magSqr(UTilde);
        const scalar kappaTilde = kappaLeft*wLeft + kappaRight*wRight;

        // Speed of sound
        const scalar cTilde = sqrt(max((kappaTilde - 1)*(hTilde - 0.5*qTildeSquare), SMALL));

        // Roe averaged contravariant velocity
        const scalar contrVTilde = (UTilde & normalVector);

        // Step 3: compute primitive differences:
        const scalar deltaP = pRight - pLeft;
        const scalar deltaRho = rhoRight - rhoLeft;
        const vector deltaU = URight - ULeft;
        const scalar deltaContrV = (deltaU & normalVector);

        // Step 4: compute wave strengths:

        // Roe and Pike - formulation
        const scalar r1 = (deltaP - rhoTilde*cTilde*deltaContrV)/(2.0*sqr(cTilde));
        const scalar r2 = deltaRho - deltaP/sqr(cTilde);
        const scalar r3 = (deltaP + rhoTilde*cTilde*deltaContrV)/(2.0*sqr(cTilde));

        // Step 5: compute l vectors

        // rho row:
        const scalar l1rho = 1;
        const scalar l2rho = 1;
        const scalar l3rho = 0;
        const scalar l4rho = 1;

        // first U column
        const vector l1U = UTilde - cTilde*normalVector;

        // second U column
        const vector l2U = UTilde;

        // third U column
        const vector l3U = deltaU - deltaContrV*normalVector;

        // fourth U column
        const vector l4U = UTilde + cTilde*normalVector;

        // E row
        const scalar l1e = hTilde - cTilde*contrVTilde;
        const scalar l2e = 0.5*qTildeSquare;
        const scalar l3e = (UTilde & deltaU) - contrVTilde*deltaContrV;
        const scalar l4e = hTilde + cTilde*contrVTilde;

        // Step 6: compute eigenvalues

        // derived from algebra by hand, only for Euler equation usefull
        scalar lambda1 = mag(contrVTilde - cTilde);
        scalar lambda2 = mag(contrVTilde);
        scalar lambda3 = mag(contrVTilde + cTilde);

        // Step 7: check for Harten entropy correction

        // const scalar eps = 0.1*cTilde; // adjustable parameter

        // if (lambda1 < eps || lambda2 < eps || lambda3 < eps)
        // {
        //     lambda1 = (sqr(lambda1) + sqr(eps))/(2.0*eps);
        //     lambda2 = (sqr(lambda2) + sqr(eps))/(2.0*eps);
        //     lambda3 = (sqr(lambda3) + sqr(eps))/(2.0*eps);
        // }

        // Step 7a: Alternative entropy correction: Felipe Portela, 9/Oct/2013

        const scalar UL = ULeft & normalVector;
        const scalar UR = URight & normalVector;
        const scalar cLeft = sqrt(max((kappaLeft - 1)*(hLeft - 0.5*magSqr(ULeft)), SMALL));
        const scalar cRight = sqrt(max((kappaRight - 1)*(hRight - 0.5*magSqr(URight)), SMALL));

        // First eigenvalue: U - c
        scalar eps = 2*max(0,(UR - cRight) - (UL - cLeft));
        if (lambda1 < eps)
        {
            lambda1 = (sqr(lambda1) + sqr(eps))/(2.0*eps);
        }

        // Second eigenvalue: U
        eps = 2*max(0, UR - UL);
        if (lambda2 < eps)
        {
            lambda2 = (sqr(lambda2) + sqr(eps))/(2.0*eps);
        }

        // Third eigenvalue: U + c
        eps = 2*max(0,(UR + cRight) - (UL + cLeft));
        if (lambda3 < eps)
        {
            lambda3 = (sqr(lambda3) + sqr(eps))/(2.0*eps);
        }


        // Step 8: Compute flux differences

        // Components of deltaF1
        const scalar diffF11 = lambda1*r1*l1rho;
        const vector diffF124 = lambda1*r1*l1U;
        const scalar diffF15 = lambda1*r1*l1e;

        // Components of deltaF2
        const scalar diffF21 = lambda2*(r2*l2rho + rhoTilde*l3rho);
        const vector diffF224 = lambda2*(r2*l2U + rhoTilde*l3U);
        const scalar diffF25 = lambda2*(r2*l2e + rhoTilde*l3e);

        // Components of deltaF3
        const scalar diffF31 = lambda3*r3*l4rho;
        const vector diffF324 = lambda3*r3*l4U;
        const scalar diffF35 = lambda3*r3*l4e;

        // Step 9: compute left and right fluxes

        // Left flux 5-vector
        const scalar fluxLeft11 = rhoLeft*contrVLeft;
        const vector fluxLeft124 = ULeft*fluxLeft11 + normalVector*pLeft;
        const scalar fluxLeft15 = hLeft*fluxLeft11;

        // Right flux 5-vector
        const scalar fluxRight11 = rhoRight*contrVRight;
        const vector fluxRight124 = URight*fluxRight11 + normalVector*pRight;
        const scalar fluxRight15 = hRight*fluxRight11;

        // Step 10: compute face flux 5-vector
        const scalar flux1 = 0.5*(fluxLeft11 + fluxRight11 - (diffF11 + diffF21 + diffF31));
        const vector flux24 = 0.5*(fluxLeft124 + fluxRight124 - (diffF124 + diffF224 + diffF324));
        const scalar flux5 = 0.5*(fluxLeft15 + fluxRight15 - (diffF15 + diffF25 + diffF35));

        // Compute private data
        rhoFlux  = flux1*magSf;
        rhoUFlux = flux24*magSf;
        rhoEFlux = flux5*magSf;
    }



rusanovFlux
^^^^^^^^^^^^^

.. code-block:: C

    void Foam::rusanovFlux::evaluateFlux
    (
        scalar& rhoFlux,
        vector& rhoUFlux,
        scalar& rhoEFlux,
        const scalar& pLeft,
        const scalar& pRight,
        const vector& ULeft,
        const vector& URight,
        const scalar& TLeft,
        const scalar& TRight,
        const scalar& RLeft,
        const scalar& RRight,
        const scalar& CvLeft,
        const scalar& CvRight,
        const vector& Sf,
        const scalar& magSf
    ) const
    {
        // Step 1: decode rho left and right:
        scalar rhoLeft = pLeft/(RLeft*TLeft);
        scalar rhoRight = pRight/(RRight*TRight);

        // Decode left and right total energy:
        scalar eLeft = CvLeft*TLeft + 0.5*magSqr(ULeft);
        scalar eRight = CvRight*TRight + 0.5*magSqr(URight);

        // Adiabatic exponent is constant for ideal gas but if Cp=Cp(T) it must be computed for each cell and evaluated at each face through reconstruction
        const scalar kappaLeft = (CvLeft+RLeft)/CvLeft;
        const scalar kappaRight = (CvRight+RRight)/CvRight;

        // normal vector
        vector normalVector = Sf/magSf;

        // Compute left and right contravariant velocities:
        const scalar contrVLeft  = (ULeft & normalVector);
        const scalar contrVRight = (URight & normalVector);

        // Compute left and right total enthalpies:
        const scalar hLeft = eLeft + pLeft/rhoLeft;
        const scalar hRight = eRight + pRight/rhoRight;

        // Step 2: compute Roe averged quantities for face:
        const scalar rhoTilde = sqrt(max(rhoLeft*rhoRight, SMALL));

        // Some temporary variables:
        const scalar rhoLeftSqrt = sqrt(max(rhoLeft, SMALL));
        const scalar rhoRightSqrt = sqrt(max(rhoRight, SMALL));

        const scalar wLeft = rhoLeftSqrt/(rhoLeftSqrt + rhoRightSqrt);
        const scalar wRight = 1 - wLeft;

        const vector UTilde = ULeft*wLeft + URight*wRight;
        const scalar hTilde = hLeft*wLeft + hRight*wRight;
        const scalar qTildeSquare = magSqr(UTilde);
        const scalar kappaTilde = kappaLeft*wLeft + kappaRight*wRight;

        // Speed of sound
        const scalar cTilde = sqrt(max((kappaTilde - 1)*(hTilde - 0.5*qTildeSquare), SMALL));

        // Roe averaged contravariant velocity
        const scalar contrVTilde = (UTilde & normalVector);

        // Step 3: compute primitive differences:
        const scalar deltaP = pRight - pLeft;
        const scalar deltaRho = rhoRight - rhoLeft;
        const vector deltaU = URight - ULeft;
        const scalar deltaContrV = (deltaU & normalVector);

        // Step 4: compute wave strengths:

        // Roe and Pike - formulation
        const scalar r1 = (deltaP - rhoTilde*cTilde*deltaContrV)/(2.0*sqr(cTilde));
        const scalar r2 = deltaRho - deltaP/sqr(cTilde);
        const scalar r3 = (deltaP + rhoTilde*cTilde*deltaContrV)/(2.0*sqr(cTilde));

        // Step 5: compute l vectors

        // rho row:
        const scalar l1rho = 1;
        const scalar l2rho = 1;
        const scalar l3rho = 0;
        const scalar l4rho = 1;

        // first U column
        const vector l1U = UTilde - cTilde*normalVector;

        // second U column
        const vector l2U = UTilde;

        // third U column
        const vector l3U = deltaU - deltaContrV*normalVector;

        // fourth U column
        const vector l4U = UTilde + cTilde*normalVector;

        // E row
        const scalar l1e = hTilde - cTilde*contrVTilde;
        const scalar l2e = 0.5*qTildeSquare;
        const scalar l3e = (UTilde & deltaU) - contrVTilde*deltaContrV;
        const scalar l4e = hTilde + cTilde*contrVTilde;

        // Step 6: compute eigenvalues

        // derived from algebra by hand, only for Euler equation usefull
        scalar lambda1 = mag(contrVTilde - cTilde);
        scalar lambda2 = mag(contrVTilde);
        scalar lambda3 = mag(contrVTilde + cTilde);

        scalar lambdaMax = max(max(lambda1,lambda2),lambda3);

        // Step 7: Compute flux differences

        // Components of deltaF1
        const scalar diffF11 = lambdaMax*r1*l1rho;
        const vector diffF124 = lambdaMax*r1*l1U;
        const scalar diffF15 = lambdaMax*r1*l1e;

        // Components of deltaF2
        const scalar diffF21 = lambdaMax*(r2*l2rho + rhoTilde*l3rho);
        const vector diffF224 = lambdaMax*(r2*l2U + rhoTilde*l3U);
        const scalar diffF25 = lambdaMax*(r2*l2e + rhoTilde*l3e);

        // Components of deltaF3
        const scalar diffF31 = lambdaMax*r3*l4rho;
        const vector diffF324 = lambdaMax*r3*l4U;
        const scalar diffF35 = lambdaMax*r3*l4e;

        // Step 8: compute left and right fluxes

        // Left flux 5-vector
        const scalar fluxLeft11 = rhoLeft*contrVLeft;
        const vector fluxLeft124 = ULeft*fluxLeft11 + normalVector*pLeft;
        const scalar fluxLeft15 = hLeft*fluxLeft11;

        // Right flux 5-vector
        const scalar fluxRight11 = rhoRight*contrVRight;
        const vector fluxRight124 = URight*fluxRight11 + normalVector*pRight;
        const scalar fluxRight15 = hRight*fluxRight11;

        // Step 10: compute face flux 5-vector
        const scalar flux1 = 0.5*(fluxLeft11 + fluxRight11 - (diffF11 + diffF21 + diffF31));
        const vector flux24 = 0.5*(fluxLeft124 + fluxRight124 - (diffF124 + diffF224 + diffF324));
        const scalar flux5 = 0.5*(fluxLeft15 + fluxRight15 - (diffF15 + diffF25 + diffF35));

        // Compute private data
        rhoFlux  = flux1*magSf;
        rhoUFlux = flux24*magSf;
        rhoEFlux = flux5*magSf;
    }




MDLimiter
^^^^^^^^^^^^

在使用limiter时首先如下构建基本对象并初始化：

.. code-block:: C
    :caption: src/dbns/limiter/MDLimiter.H

    MDLimiter
    (
        const GeoFieldType& phi,
        const GeoGradFieldType& gradPhi
    )
    :
        mesh_(phi.mesh()),
        phi_(phi),
        gradPhi_(gradPhi),
        phiLimiter_
        (
            IOobject
            (
                "phiLimiter",
                mesh_.time().timeName(),
                mesh_,
                IOobject::NO_READ,
                IOobject::NO_WRITE
            ),
            mesh_,
            dimensioned<Type>("pLimiter", dimless, pTraits<Type>::one)
        )
    {
        //...
    }

在网格内部面上的limiter的值如下进行计算：

.. code-block:: C
    :caption: src/dbns/limiter/MDLimiter.H

    forAll (owner, faceI)
    {
        const label& own = owner[faceI];
        const label& nei = neighbour[faceI];

        vector deltaRLeft = faceCentre[faceI] - cellCentre[own];
        vector deltaRRight = faceCentre[faceI] - cellCentre[nei];

        // Find minimal limiter value in each cell

        // Owner side
        limitFunction.limiter
        (
            phiLimiterIn[own],
            cellVolume[own],
            phiMaxIn[own] - phi_[own],
            phiMinIn[own] - phi_[own],
            (deltaRLeft & gradPhiIn[own])
        );

        // Neighbour side
        limitFunction.limiter
        (
            phiLimiterIn[nei],
            cellVolume[nei],
            phiMaxIn[nei] - phi_[nei],
            phiMinIn[nei] - phi_[nei],
            (deltaRRight & gradPhiIn[nei])
        );
    }

一般边界面上不需要设置limiter，而coupled边界条件需要特殊处理。上述调用的limiter()函数的执行内容由具体选取的limiter类型决定。



firstOrderLimiter
^^^^^^^^^^^^^^^^^^^

一阶limiter实际上就是没有设置limiter，将limiter的值全部设置为零。

.. code-block:: C
    :caption: src/dbns/limiter/firstOrderLimiter.H

    //- Set scalar limiter value
    inline void limiter
    (
        scalar& lim,
        const scalar& cellVolume,
        const scalar& deltaOneMax,
        const scalar& deltaOneMin,
        const scalar& deltaTwo
    )
    {
        lim = 0;
    }

    //- Set Type limiter
    template<class Type>
    inline void limiter
    (
        Type& lim,
        const scalar& cellVolume,
        const Type& deltaOneMax,
        const Type& deltaOneMin,
        const Type& extrapolate
    )
    {
        lim = pTraits<Type>::zero;
    }


BarthJespersenLimiter
^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C
    :caption: src/dbns/limiter/BarthJespersenLimiter.H

    inline void limiter
    (
        scalar& lim,
        const scalar& cellVolume,
        const scalar& deltaOneMax,
        const scalar& deltaOneMin,
        const scalar& extrapolate
    )
    {
        if (mag(extrapolate) < SMALL)
        {
            return;
        }

        if (extrapolate - deltaOneMax > SMALL)
        {
            lim = min(lim, deltaOneMax/extrapolate);
        }
        else if (extrapolate - deltaOneMin < -SMALL)
        {
            lim = min(lim, deltaOneMin/extrapolate);
        }
    }

    //- Set Type limiter
    template<class Type>
    inline void limiter
    (
        Type& lim,
        const scalar& cellVolume,
        const Type& deltaOneMax,
        const Type& deltaOneMin,
        const Type& extrapolate
    )
    {
        for (direction cmpt = 0; cmpt < Type::nComponents; cmpt++)
        {
            limiter
            (
                lim.component(cmpt),
                cellVolume,
                deltaOneMax.component(cmpt),
                deltaOneMin.component(cmpt),
                extrapolate.component(cmpt)
            );
        }
    }


VenkatakrishnanLimiter
^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C
    :caption: src/dbns/limiter/VenkatakrishnanLimiter.H

    VenkatakrishnanLimiter()
    :
        k_(5)
    {}

    //- Set scalar limiter value
    inline void limiter
    (
        scalar& lim,
        const scalar& cellVolume,
        const scalar& deltaOneMax,
        const scalar& deltaOneMin,
        const scalar& extrapolate
    )
    {
        scalar epsilonSquare = pow3(k_)*cellVolume;

        if (mag(extrapolate) < SMALL)
        {
            // Limiter remains unchanged
            return;
        }
        else if (extrapolate > VSMALL)
        {
            lim = max
            (
                0,
                min
                (
                    (
                        (sqr(deltaOneMax) + epsilonSquare)*extrapolate
                      + 2*sqr(extrapolate)*deltaOneMax
                    )/
                    stabilise
                    (
                        extrapolate*
                        (
                            sqr(deltaOneMax)
                          + 2*sqr(extrapolate)
                          + deltaOneMax*extrapolate
                          + epsilonSquare
                        ),
                        SMALL
                    ),
                    lim
                )
            );
        }
        else if (extrapolate < VSMALL)
        {
            lim = max
            (
                0,
                min
                (
                    (
                        (sqr(deltaOneMin) + epsilonSquare)*extrapolate
                      + 2*sqr(extrapolate)*deltaOneMin
                    )/
                    stabilise
                    (
                        extrapolate*
                        (
                            sqr(deltaOneMin)
                          + 2*sqr(extrapolate)
                          + deltaOneMin*extrapolate
                          + epsilonSquare
                        ),
                        SMALL
                    ),
                    lim
                )
            );
        }
    }

    //- Set Type limiter
    template<class Type>
    inline void limiter
    (
        Type& lim,
        const scalar& cellVolume,
        const Type& deltaOneMax,
        const Type& deltaOneMin,
        const Type& extrapolate
    )
    {
        for (direction cmpt = 0; cmpt < Type::nComponents; cmpt++)
        {
            limiter
            (
                lim.component(cmpt),
                cellVolume,
                deltaOneMax.component(cmpt),
                deltaOneMin.component(cmpt),
                extrapolate.component(cmpt)
            );
        }
    }

