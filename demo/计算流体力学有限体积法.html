<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>计算流体力学有限体积法 &mdash; MyKnowledge MyKnowledge 文档</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script src="../_static/translations.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="AutoCAD" href="AutoCAD.html" />
    <link rel="prev" title="流体力学" href="%E6%B5%81%E4%BD%93%E5%8A%9B%E5%AD%A6.html" />
    <link href="../_static/style.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> MyKnowledge
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="%E5%BE%AE%E7%A7%AF%E5%88%86.html">微积分</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0.html">线性代数</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0.html">复变函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86.html">电路原理</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF.html">数字电路</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF.html">模拟电路</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90%E4%B8%8E%E7%AE%97%E6%B3%95.html">数值分析与算法</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%95%B0%E7%90%86%E6%96%B9%E7%A8%8B.html">数理方程</a></li>
<li class="toctree-l1"><a class="reference internal" href="%E6%B5%81%E4%BD%93%E5%8A%9B%E5%AD%A6.html">流体力学</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">计算流体力学有限体积法</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">扩散项的空间离散</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id3">在矩形计算域的二维扩散项</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">对离散方程的评价</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id5">零和规则</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">反号规则</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id7">边界条件</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#dirichlet">Dirichlet边界条件</a></li>
<li class="toctree-l4"><a class="reference internal" href="#neumann">Neumann边界条件</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id8">混合边界条件</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id9">对称边界条件</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id10">界面扩散系数</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id11">非笛卡尔正交网格</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id12">非正交非结构化网格</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id13">非正交性</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id14">最小修正法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id15">正交修正法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id16">过松弛法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id17">梯度计算</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id18">非正交网格的线性方程</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id19">偏斜度</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id20">各向异性扩散</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id21">迭代解过程的欠松弛</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id22">梯度计算</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id23">笛卡尔网格中的梯度计算</a></li>
<li class="toctree-l3"><a class="reference internal" href="#green-gauss">Green-Gauss梯度</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#compact-stencil">Compact Stencil</a></li>
<li class="toctree-l4"><a class="reference internal" href="#extended-stencil">Extended Stencil</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id24">最小二乘法梯度</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id25">将梯度插值到网格面</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id26">对流项的离散化</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id27">一维稳态对流扩散</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id28">解析解</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id29">数值解</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id30">初步推导：中心差分格式</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id31">迎风格式</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="AutoCAD.html">AutoCAD</a></li>
<li class="toctree-l1"><a class="reference internal" href="C%2B%2B.html">C++</a></li>
<li class="toctree-l1"><a class="reference internal" href="Latex.html">Latex</a></li>
<li class="toctree-l1"><a class="reference internal" href="OpenFOAM.html">OpenFOAM</a></li>
<li class="toctree-l1"><a class="reference internal" href="OpenFOAM%E7%AE%97%E4%BE%8B%E8%BF%90%E8%A1%8C%E6%A1%88%E4%BE%8B.html">OpenFOAM算例运行案例</a></li>
<li class="toctree-l1"><a class="reference internal" href="Python.html">Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="Salome.html">Salome</a></li>
<li class="toctree-l1"><a class="reference internal" href="Solidworks.html">Solidworks</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">MyKnowledge</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>计算流体力学有限体积法</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/demo/计算流体力学有限体积法.rst.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1>计算流体力学有限体积法<a class="headerlink" href="#id1" title="此标题的永久链接"></a></h1>
<section id="id2">
<h2>扩散项的空间离散<a class="headerlink" href="#id2" title="此标题的永久链接"></a></h2>
<section id="id3">
<h3>在矩形计算域的二维扩散项<a class="headerlink" href="#id3" title="此标题的永久链接"></a></h3>
<p>如图所示的是一个由规则笛卡尔网格划分的简单矩形计算域，在这个计算域中将要离散下面这个稳定态扩散方程：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
- \nabla \cdot (\Gamma^{\phi} \nabla\phi) = Q^{\phi}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\phi\)</span> 表示一个标量变量（例如温度、质量分数、湍流动能等等）， <span class="math notranslate nohighlight">\(Q^{\phi}\)</span> 表示计算域中单位体积 <span class="math notranslate nohighlight">\(\phi\)</span> 的产生量， <span class="math notranslate nohighlight">\(\Gamma^{\phi}\)</span> 表示扩散系数。</p>
<figure class="align-center">
<img alt="../_images/二维均一笛卡尔网格.png" src="../_images/二维均一笛卡尔网格.png" />
</figure>
<p>根据散度项的Gauss法离散，上面的方程可以离散为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\sum_{f\sim nb(C)} (-\Gamma^{\phi}\nabla\phi)_{f} \cdot\mathbf{S}_{f} = Q_{C}^{\phi} V_{C}
\end{align}\]</div>
<p>对于如图所示的网格，上式可以展开写成</p>
<div class="math notranslate nohighlight">
\[\begin{align}
(- \Gamma^{\phi} \nabla\phi)_{e} \cdot \mathbf{S}_{e}
+ (- \Gamma^{\phi} \nabla\phi)_{w} \cdot \mathbf{S}_{w}
+ (- \Gamma^{\phi} \nabla\phi)_{n} \cdot \mathbf{S}_{n}
+ (- \Gamma^{\phi} \nabla\phi)_{s} \cdot \mathbf{S}_{s}
= Q_{C}^{\phi}V_{C}
\end{align}\]</div>
<p>对于如图所示的均一笛卡尔网格，网格面法向量可以如下表示</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; \mathbf{S}_{e} = + (\Delta y)_{e} \mathbf{i} = \| \mathbf{S}_{e} \| \mathbf{i} = S_{e}\mathbf{i},
&amp;&amp; \mathbf{S}_{w} = - (\Delta y)_{w} \mathbf{i} = - \| \mathbf{S}_{w} \| \mathbf{i} = -S_{w}\mathbf{i}, \\
&amp; \mathbf{S}_{n} = + (\Delta x)_{n} \mathbf{j} = \| \mathbf{S}_{n} \| \mathbf{j} = S_{n}\mathbf{j},
&amp;&amp; \mathbf{S}_{s} = - (\Delta x)_{s} \mathbf{j} = - \| \mathbf{S}_{s} \| \mathbf{j} = -S_{s}\mathbf{j}
\end{align}\end{split}\]</div>
<p>于是，对于右边的网格面，其扩散通量为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
- (\Gamma^{\phi}\nabla \phi)_{e} \cdot \mathbf{S}_{e}
= - \Gamma_{e}^{\phi} \Big( \frac{\partial \phi}{\partial x}\mathbf{i} + \frac{\partial \phi}{\partial y}\mathbf{j} \Big) \cdot S_{e} \mathbf{i}
= - \Gamma_{e}^{\phi}(\Delta y)_{e} \Big(\frac{\partial \phi}{\partial x} \Big)_{e}
\end{align}\]</div>
<p>根据之前讨论的单积分点离散守恒方程的内容，扩散通量可以写成如下通用形式：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
-(\Gamma^{\phi}\nabla\phi)_{e}\cdot\mathbf{S}_{e}
= \text{FluxT}_{e} = \text{FluxC}_{e}\phi_{C} + \text{FluxF}_{e}\phi_{F} + \text{FluxV}_{e}
\end{align}\]</div>
<p>为了确定 <span class="math notranslate nohighlight">\(\text{FluxC}_{e},\text{FluxF}_{e},\text{FluxV}_{e}\)</span> 这三个系数，就需要取一个剖面利用相邻两个单元来计算梯度。假设 <span class="math notranslate nohighlight">\(\phi\)</span> 在网格形心中线性分布，那么在 <span class="math notranslate nohighlight">\(e\)</span> 面上沿着 <span class="math notranslate nohighlight">\(\mathbf{i}\)</span> 方向的梯度可以写成</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\Big(\frac{\partial \phi}{\partial x} \Big)_{e} = \frac{\phi_{E} - \phi_{C}}{(\delta x)_{e}}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\((\delta x)_{e}\)</span> 是待求网格形心点与右侧相邻网格形心点的距离。将上式代入到 <span class="math notranslate nohighlight">\(e\)</span> 面的扩散项离散方程，得到</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\text{FluxT}_{e} = - \Gamma^{\phi} (\Delta y)_{e} \frac{\phi_{E} - \phi_{C}}{\delta x_{e}} = \Gamma^{\phi}_{e} \frac{(\Delta y)_{e}}{\delta x_{e}}(\phi_{C} - \phi_{E})
\end{align}\]</div>
<p>额外引入一个符号进行简化，定义</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\text{gDiff}_{e} = \frac{(\Delta y)_{e}}{\delta x_{e}} = \frac{\| \mathbf{S}_{e} \|}{\| \mathbf{d}_{CE} \|} = \frac{S_{e}}{d_{CE}}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\mathbf{d}_{CE}\)</span> 是单元C和E形心之间的距离向量。于是， <span class="math notranslate nohighlight">\(e\)</span> 面扩散通量的通用形式的系数就确定为了</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\text{FluxC}_{e} = \Gamma_{e}^{\phi}\text{gDiff}_{e} ,\quad
\text{FluxF}_{e} = -\Gamma_{e}^{\phi}\text{gDiff}_{e} ,\quad
\text{FluxV}_{e} = 0
\end{align}\]</div>
<p>类似的操作也可以应用于 <span class="math notranslate nohighlight">\(w,n,s\)</span> 面上，然后就得到</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; \text{FluxT}_{w} = \text{FluxC}_{w}\phi_{C} + \text{FluxF}_{w}\phi_{N} + \text{FluxV}_{w} \\
&amp; \text{FluxT}_{n} = \text{FluxC}_{n}\phi_{C} + \text{FluxF}_{n}\phi_{N} + \text{FluxV}_{n} \\
&amp; \text{FluxT}_{s} = \text{FluxC}_{s}\phi_{C} + \text{FluxF}_{s}\phi_{N} + \text{FluxV}_{s}
\end{align}\end{split}\]</div>
<p>其中</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; \text{FluxC}_{w} = \Gamma_{w}^{\phi}\text{gDiff}_{w} ,\quad \text{FluxF}_{w} = -\Gamma_{w}^{\phi}\text{gDiff}_{w} ,\quad \text{FluxV}_{w} = 0 \\
&amp; \text{FluxC}_{n} = \Gamma_{n}^{\phi}\text{gDiff}_{n} ,\quad \text{FluxF}_{n} = -\Gamma_{n}^{\phi}\text{gDiff}_{n} ,\quad \text{FluxV}_{n} = 0 \\
&amp; \text{FluxC}_{s} = \Gamma_{s}^{\phi}\text{gDiff}_{s} ,\quad \text{FluxF}_{s} = -\Gamma_{s}^{\phi}\text{gDiff}_{s} ,\quad \text{FluxV}_{s} = 0 \\
\end{align}\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
\text{gDiif}_{w} = \frac{\| \mathbf{S}_{w} \|}{\| \mathbf{d}_{CW} \|} = \frac{(\Delta x)_{w}}{\delta y_{w}} = \frac{S_{w}}{d_{CW}}
,\quad
\text{gDiif}_{n} = \frac{\| \mathbf{S}_{n} \|}{\| \mathbf{d}_{CN} \|} = \frac{(\Delta x)_{n}}{\delta y_{n}} = \frac{S_{n}}{d_{CN}}
,\quad
\text{gDiif}_{s} = \frac{\| \mathbf{S}_{s} \|}{\| \mathbf{d}_{CS} \|} = \frac{(\Delta x)_{s}}{\delta y_{s}} = \frac{S_{s}}{d_{CS}}
\end{align}\]</div>
<p>将上述离散结果全部代入到扩散方程，则可以表示成如下的线性方程：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
a_{C}\phi_{C} + \sum_{F\sim NB(C)}a_{F}\phi_{F} = b_{C}
\end{align}\]</div>
<p>其中</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; a_{C} = \sum_{f\sim nb(C)}\text{FluxC}_{f} \\
&amp; a_{F} = \text{FluxF}_{f} = -\Gamma^{\phi}_{f} \text{gDiff}_{f} \\
&amp; b_{C} = Q_{C}^{\phi}V_{C} - \sum_{f\sim nb(C)}\text{FluxV}_{f}
\end{align}\end{split}\]</div>
<p>这里的 <span class="math notranslate nohighlight">\(F\)</span> 表示与单元C相邻的单元(E,W,N,S)， <span class="math notranslate nohighlight">\(f\)</span> 表示单元C的相邻面(e,w,n,s)。</p>
</section>
<section id="id4">
<h3>对离散方程的评价<a class="headerlink" href="#id4" title="此标题的永久链接"></a></h3>
<p>一个合适的离散方法应该得到一个能够反映原始守恒方程所有特性的线性方程。之前介绍了离散方法的一些特性，接下来继续说明离散方程系数必须满足的两条规则。</p>
<section id="id5">
<h4>零和规则<a class="headerlink" href="#id5" title="此标题的永久链接"></a></h4>
<p>回顾离散流程，第一个主要估计产生于变量 <span class="math notranslate nohighlight">\(\phi\)</span> 在横跨单元表面的单元形心之间的插值。有人会问为什么使用一阶方法而不使用更高阶的方法。为了回答这个问题，可以考虑一个一维无源传导方程，在这些条件下离散方程简化为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
a_{C}\phi_{C} + a_{E}\phi_{E} + a_{W}\phi_{W} = 0
\end{align}\]</div>
<p>其中</p>
<div class="math notranslate nohighlight">
\[\begin{align}
a_{E} = -\Gamma_{e}^{\phi}\text{gDiff}_{e} ,\quad
a_{W} = -\Gamma_{w}^{\phi}\text{gDiff}_{w} ,\quad
a_{C} = -(a_{E} + a_{W})
\end{align}\]</div>
<p>在没有源项的情况下， <span class="math notranslate nohighlight">\(\phi\)</span> 的变化仅仅出现在扩散中，并且满足Fourier’s law（椭圆方程）。因此， <span class="math notranslate nohighlight">\(\phi_{e}\)</span> 或 <span class="math notranslate nohighlight">\(\phi_{w}\)</span> 的值应该分别处于 <span class="math notranslate nohighlight">\(\phi_{C}\)</span> 与 <span class="math notranslate nohighlight">\(\phi_{E}\)</span> 之间和 <span class="math notranslate nohighlight">\(\phi_{C}\)</span> 与 <span class="math notranslate nohighlight">\(\phi_{W}\)</span> 之间，而线性方法是一定能够保证这件事的。当采用二阶方法时，可能会导致插值到面上的值高于或低于网格形心上的值，这是不符合物理规律的。对于其他更高阶的方法也是如此。如果需要绝对保证合乎物理的结果，那么就应该使用线性方法。另外，当网格大小减小时所采用的离散方法就会变得没那么重要，因为所有估计在网格单元趋于零的时候都会取到一个相同的解析值。更进一步地，在不考虑任何源项的情况下，多维温度扩散方程化简为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
- \nabla \cdot (\Gamma^{\phi}\nabla\phi) = 0
\end{align}\]</div>
<p>上式表明 <span class="math notranslate nohighlight">\(\phi\)</span> 和 <span class="math notranslate nohighlight">\(\phi + \text{const}\)</span> 都是上面的扩散方程的解。一个一致的离散方法应该反映出这个特性，也就是说，离散方程应该满足</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\left.\begin{array}{c}
a_{C}\phi_{C} + \sum\limits_{F \sim NB(C)} a_{F}\phi_{F} = 0 \\
a_{C}(\phi_{C} + \text{const}) + \sum\limits_{F \sim NB(C)}a_{F}(\phi_{F} + \text{const}) = 0
\end{array}\right\} \Rightarrow
a_{C} + \sum_{F \sim NB(C)}a_{F} = 0
\end{align}\end{split}\]</div>
<p>上述方程可以进一步将系数的关系写成</p>
<div class="math notranslate nohighlight">
\[\begin{align}
a_{C} = -\sum_{F \sim NB(C)}a_{F}
\quad \text{or}\quad
\sum_{F\sim NB(C)}\frac{a_{F}}{a_{C}} = -1
\end{align}\]</div>
<p>因此， <span class="math notranslate nohighlight">\(\phi_{C}\)</span> 可以被视为相邻量的加权和，并且在无源项的时候它总是由相邻的 <span class="math notranslate nohighlight">\(\phi_{F}\)</span> 值限制有界。而当有源项的时候， <span class="math notranslate nohighlight">\(\phi_{C}\)</span> 不必以这种方式限制有界，也就可以高于相邻值，但是这是完全符合物理的。超出值将由源项 <span class="math notranslate nohighlight">\(S_{C}^{\phi}\)</span> 的模相对于相邻节点系数 <span class="math notranslate nohighlight">\(a_{F}\)</span> 的大小来决定。</p>
</section>
<section id="id6">
<h4>反号规则<a class="headerlink" href="#id6" title="此标题的永久链接"></a></h4>
<p>上面的论述也同时说明了系数 <span class="math notranslate nohighlight">\(a_{C}\)</span> 和 <span class="math notranslate nohighlight">\(a_{F}\)</span> 是反号的。这具有重要的物理意义，它表明当 <span class="math notranslate nohighlight">\(\phi_{F}\)</span> 增大/减小时， <span class="math notranslate nohighlight">\(\phi_{C}\)</span> 的值应当随之增大/减小。这基本上与有界性有关，这表明满足这个性质的充分条件是相邻系数和主系数的符号相反。如果不是，那么有界性性质可能就不成立。</p>
</section>
</section>
<section id="id7">
<h3>边界条件<a class="headerlink" href="#id7" title="此标题的永久链接"></a></h3>
<p>我们都知道任何常微分方程或偏微分方程的解析解都需要给定合适的边界条件才能确定其中的常数。因此，即使控制方程是一样的，使用不同的边界条件也会得到完全不同的结果。数值解也遵循同样的道理，数值解遵循相同的约束，需要正确和准确地实现边界条件，因为由数值近似引入的这些条件的任何微小变化都会导致所考虑问题的错误解。边界条件将与被离散化的项相关。对于传导/扩散问题，会遇到狄利克雷、诺伊曼、混合和对称边界条件类型，下面将详细介绍。</p>
<p>边界条件应用于边界元素，边界元素在边界上有一个或多个面。 <span class="math notranslate nohighlight">\(\phi\)</span> 的离散值存储在边界单元的中心处和边界面的中心处。设 <span class="math notranslate nohighlight">\(C\)</span> 为如图所示边界元的形心，边界面的形心记为 <span class="math notranslate nohighlight">\(b\)</span> ，边界面的面向量 <span class="math notranslate nohighlight">\(S_{b}\)</span> 指向向外。与前面一样，单元格 <span class="math notranslate nohighlight">\(C\)</span> 的离散化过程产生</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\sum_{f \sim nb(C)}(\mathbf{J}^{\phi,D} \cdot \mathbf{S})_{f} = Q_{C}^{\phi}V_{C}
\end{align}\]</div>
<p>对内面通量还是跟之前所述的那样进行离散，而对边界通量进行的离散则需要构造对 <span class="math notranslate nohighlight">\(\phi_{C}\)</span> 的线性化，也即</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\mathbf{J}_{b}^{\phi,D} \cdot \mathbf{S}_{b} = \text{FluxT}_{b} = -\Gamma_{b}^{\phi}(\nabla \phi)_{b} \cdot \mathbf{S}_{b} = \text{FluxC}_{b}\phi_{C} + \text{FluxV}_{b}
\end{align}\]</div>
<p>边界条件的定义包括指定未知的边界值 <span class="math notranslate nohighlight">\(\phi_{b}\)</span> ，或者指定边界通量 <span class="math notranslate nohighlight">\(\mathbf{J}_{b}^{\phi,D}\)</span> 。这样就导出了不同边界条件类型的扩散问题在边界元处的离散方程。</p>
<section id="dirichlet">
<h4>Dirichlet边界条件<a class="headerlink" href="#dirichlet" title="此标题的永久链接"></a></h4>
<p>Dirichlet边界条件就是一种直接指定 <span class="math notranslate nohighlight">\(\phi\)</span> 在边界上的值的条件，即</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\phi_{b} = \phi_{\text{specified}}
\end{align}\]</div>
<figure class="align-center">
<img alt="../_images/扩散项Dirichlet边界条件.png" src="../_images/扩散项Dirichlet边界条件.png" />
</figure>
<p>对于如图的情况，有</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\text{FluxT}_{b} = -\Gamma_{b}^{\phi}(\nabla \phi)_{b} \cdot \mathbf{S}_{b}
= - \Gamma_{b}^{\phi} \frac{\| \mathbf{S}_{b} \|}{\| \mathbf{d}_{Cb} \|}(\phi_{b} - \phi_{C})
= \text{FluxC}_{b}\phi_{C} + \text{FluxV}_{b}
\end{align}\]</div>
<p>其中</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; \text{FluxC}_{b} = \Gamma_{b}^{\phi}\text{gDiff}_{b} \\
&amp; \text{FluxV}_{b} = -\Gamma_{b}^{\phi}\text{gDiff}_{b}\phi_{b} \\
&amp; \text{gDiff}_{b} = \frac{S_{b}}{d_{Cb}}
\end{align}\end{split}\]</div>
<p>因此对于图中所示的 <span class="math notranslate nohighlight">\(C\)</span> 单元，系数 <span class="math notranslate nohighlight">\(a_{E}\)</span> 为零，离散方程化简为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
a_{C}\phi_{C} + a_{W}\phi_{W} + a_{N}\phi_{N} + a_{S}\phi_{S} = b_{C}
\end{align}\]</div>
<p>其中</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; a_{E} = 0 \\
&amp; a_{W} = \text{FluxF}_{w} = -\Gamma_{w}^{\phi}\text{gDiff}_{w} \\
&amp; a_{N} = \text{FluxF}_{n} = -\Gamma_{n}^{\phi}\text{gDiff}_{n} \\
&amp; a_{S} = \text{FluxF}_{s} = -\Gamma_{s}^{\phi}\text{gDiff}_{s} \\
&amp; a_{C} = \text{FluxC}_{b} + \sum_{f \sim nb(C)}\text{FluxC}_{f} = \text{FluxC}_{b} + (\text{FluxC}_{w} + \text{FluxC}_{n} + \text{FluxC}_{s}) \\
&amp; b_{C} = Q_{C}^{\phi}V_{C} - \Big( \text{FluxV}_{b} + \sum_{f \sim nb(C)}\text{FluxV}_{f} \Big)
\end{align}\end{split}\]</div>
<p>从上面的离散方程中可以看到如下的特点：</p>
<ol class="arabic simple">
<li><p>系数 <span class="math notranslate nohighlight">\(\text{FluxC}_{b}\)</span> 要比其他相邻系数更大，因为 <span class="math notranslate nohighlight">\(b\)</span> 更靠近 <span class="math notranslate nohighlight">\(C\)</span> 形心，也因此对 <span class="math notranslate nohighlight">\(\phi_{C}\)</span> 有更重要的影响。</p></li>
<li><p>系数 <span class="math notranslate nohighlight">\(a_{C}\)</span> 仍然是所有相邻系数的和（包括 <span class="math notranslate nohighlight">\(\text{FluxC}_{b}\)</span> ）。这意味着对于边界处的单元有 <span class="math notranslate nohighlight">\(\sum\limits_{F \sim NB(C)}|a_{F}|/|a_{C}| &lt; 1\)</span> ，给出了满足Scarborough判据的第二个必要条件，从而保证了线性方程组在任意一次迭代中的收敛性。</p></li>
<li><p><span class="math notranslate nohighlight">\(\text{FluxV}_{b}\)</span> 现在位于方程右手边，也就是 <span class="math notranslate nohighlight">\(b_{C}\)</span> 的一部分，因为它不包含任何未知数。</p></li>
</ol>
</section>
<section id="neumann">
<h4>Neumann边界条件<a class="headerlink" href="#neumann" title="此标题的永久链接"></a></h4>
<p>如果在边界处指定了 <span class="math notranslate nohighlight">\(\phi\)</span> 的通量(或表面的法线梯度)则称为Neumann边界条件。在这种情况下，指定的通量满足</p>
<div class="math notranslate nohighlight">
\[\begin{align}
- (\Gamma^{\phi}\nabla\phi)_{b} \cdot \mathbf{i} = q_{b}
\end{align}\]</div>
<figure class="align-center">
<img alt="../_images/扩散项Neumann边界条件.png" src="../_images/扩散项Neumann边界条件.png" />
</figure>
<p>可以进一步表示成与扩散通量有关，即</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\mathbf{J}_{b}^{\phi,D} \cdot \mathbf{S}_{b}
= - (\Gamma^{\phi}\nabla\phi)_{b} \cdot \| \mathbf{S}_{b} \| \mathbf{i}
= \text{FluxC}_{b}\phi_{C} + \text{FluxV}_{b}
= q_{b} \| \mathbf{S}_{b} \|
\end{align}\]</div>
<p>其中</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; \text{FluxC}_{b} = 0 \\
&amp; \text{FluxV}_{b} = q_{b}S_{b} = q_{b}(\Delta y)_{C}
\end{align}\end{split}\]</div>
<p>这里假设通量分量是正的，当它们的作用方向与所使用的坐标系相同。因此， <span class="math notranslate nohighlight">\(q_{b}\)</span> 将直接放入边界单元 <span class="math notranslate nohighlight">\(C\)</span> 的离散方程当中：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
a_{C}\phi_{C} + a_{W}\phi_{W} + a_{N}\phi_{N} + a_{S}\phi_{S} = b_{C}
\end{align}\]</div>
<p>其中</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; a_{E} = 0 \\
&amp; a_{W} = \text{FluxF}_{w} = -\Gamma_{w}^{\phi}\text{gDiff}_{w} \\
&amp; a_{N} = \text{FluxF}_{n} = -\Gamma_{n}^{\phi}\text{gDiff}_{n} \\
&amp; a_{S} = \text{FluxF}_{s} = -\Gamma_{s}^{\phi}\text{gDiff}_{s} \\
&amp; a_{C} = \sum_{f \sim nb(C)}\text{FluxC}_{f} = -(a_{W} + a_{N} + a_{S}) \\
&amp; b_{C} = Q_{C}^{\phi}V_{C} - \Big( \text{FluxV}_{b} + \sum_{f \sim nb(C)}\text{FluxV}_{f} \Big)
\end{align}\end{split}\]</div>
<p>从上面的离散方程可以看出如下特征：</p>
<ol class="arabic simple">
<li><p>Neumann边界条件不会对主导系数 <span class="math notranslate nohighlight">\(a_{C}\)</span> 产生贡献。</p></li>
<li><p>如果 <span class="math notranslate nohighlight">\(q_{b}\)</span> 和 <span class="math notranslate nohighlight">\(S_{C}^{\phi}\)</span> 都是零，那么 <span class="math notranslate nohighlight">\(\phi_{C}\)</span> 将被其相邻量限制有界。否则， <span class="math notranslate nohighlight">\(\phi_{C}\)</span> 将可能超过或低于其相邻值 <span class="math notranslate nohighlight">\(\phi\)</span> ，这种情况是允许的。例如，如果 <span class="math notranslate nohighlight">\(\phi\)</span> 表示温度，那么 <span class="math notranslate nohighlight">\(q_{b}\)</span> 表示应用在边界上的热通量。因此，如果热量添加到边界上，那么在靠近边界的区域其温度要比内部区域要更高。</p></li>
<li><p>一旦 <span class="math notranslate nohighlight">\(\phi_{C}\)</span> 被计算出来，那么边界上的值 <span class="math notranslate nohighlight">\(\phi_{b}\)</span> 就可以如下计算</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{align}
\phi_{b} = \frac{\Gamma_{b}^{\phi}\text{gDiff}_{b}\phi_{C} - q_{b}}{\Gamma_{b}^{\phi}\text{gDiff}_{b}}
\end{align}\]</div>
<ol class="arabic simple" start="4">
<li><p>Neumann条件可以被认为是有限体积法的自然边界条件，因为对于指定通量为零的情况，不需要对面进行任何离散化，而指定值为零(Dirichlet条件)仍然需要进行离散化。</p></li>
</ol>
</section>
<section id="id8">
<h4>混合边界条件<a class="headerlink" href="#id8" title="此标题的永久链接"></a></h4>
<p>混合边界条件，如图所示，是指边界上的信息通过对流传递系数( <span class="math notranslate nohighlight">\(h_{\infty}\)</span> )和 <span class="math notranslate nohighlight">\(\phi\)</span> 周围值( <span class="math notranslate nohighlight">\(\phi_{\infty}\)</span> )给出的情况，可以表示为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\mathbf{J}_{b}^{\phi,D} \cdot \mathbf{S}_{b}
= - (\Gamma^{\phi}\nabla\phi)_{b} \cdot \mathbf{i} S_{b}
= - h_{\infty} (\phi_{\infty} - \phi_{b})(\Delta y)_{C}
\end{align}\]</div>
<p>也可以展开写成</p>
<div class="math notranslate nohighlight">
\[\begin{align}
- \Gamma_{b}^{\phi}S_{b}\Big( \frac{\phi_{b} - \phi_{C}}{\delta x_{b}} \Big)
= - h_{\infty} (\phi_{\infty} - \phi_{b}) S_{b}
\end{align}\]</div>
<figure class="align-center">
<img alt="../_images/扩散项混合边界条件.png" src="../_images/扩散项混合边界条件.png" />
</figure>
<p>从上式我们可以得到 <span class="math notranslate nohighlight">\(\phi_{b}\)</span> 的表达式：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\phi_{b} = \frac{h_{\infty}\phi_{\infty} + (\Gamma_{b}^{\phi}/\delta x_{b})\phi_{C}}{h_{\infty} + (\Gamma_{b}^{\phi}/\delta x_{b})}
\end{align}\]</div>
<p>将上式代入到最开始边界条件的定义式，通量方程就变成了</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\mathbf{J}_{b}^{\phi,D} \cdot \mathbf{S}_{b}
= - \Big[ \frac{h_{\infty}(\Gamma_{b}^{\phi}/\delta x_{b})}{h_{\infty} + (\Gamma_{b}^{\phi}/\delta x_{b})}S_{b} \Big] (\phi_{\infty} - \phi_{C})
= \text{FluxC}_{b}\phi_{C} + \text{FluxV}_{b}
\end{align}\]</div>
<p>下面记 <span class="math notranslate nohighlight">\(R_{eq} = \frac{h_{\infty}(\Gamma_{b}^{\phi}/\delta x_{b})}{h_{\infty} + (\Gamma_{b}^{\phi}/\delta x_{b})}S_{b}\)</span> ，则其中</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\text{FluxC}_{b} = R_{eq} ,\quad
\text{FluxV}_{b} = -R_{eq}\phi_{\infty}
\end{align}\]</div>
<p>根据上式，在边界处的单元的离散方程就变成了如下形式：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
a_{C}\phi_{C} + a_{W}\phi_{W} + a_{N}\phi_{N} + a_{S}\phi_{S} = b_{C}
\end{align}\]</div>
<p>其中</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; a_{E} = 0 \\
&amp; a_{W} = \text{FluxF}_{w} = -\Gamma_{w}^{\phi}\text{gDiff}_{w} \\
&amp; a_{N} = \text{FluxF}_{n} = -\Gamma_{n}^{\phi}\text{gDiff}_{n} \\
&amp; a_{S} = \text{FluxF}_{s} = -\Gamma_{s}^{\phi}\text{gDiff}_{s} \\
&amp; a_{C} = \text{FluxC}_{b} + \sum_{f \sim nb(C)}\text{FluxC}_{f} = (\text{FluxC}_{b} + \text{FluxC}_{w} + \text{FluxC}_{n} + \text{FluxC}_{s}) \\
&amp; b_{C} = Q_{C}^{\phi}V_{C} - \Big( \text{FluxV}_{b} + \sum_{f \sim nb(C)}\text{FluxV}_{f} \Big)
\end{align}\end{split}\]</div>
</section>
<section id="id9">
<h4>对称边界条件<a class="headerlink" href="#id9" title="此标题的永久链接"></a></h4>
<p>沿着对称边界，到标量变量边界的法向通量为零。因此，对称边界条件等价于通量值设为零的Neumann边界条件，也即 <span class="math notranslate nohighlight">\(\text{FluxC}_{b} = \text{FluxV}_{b} = 0\)</span> 。因此，对称边界条件的离散方程通过设置 <span class="math notranslate nohighlight">\(q_{b}=0\)</span> 得到，即</p>
<div class="math notranslate nohighlight">
\[\begin{align}
a_{C}\phi_{C} + a_{W}\phi_{W} + a_{N}\phi_{N} + a_{S}\phi_{S} = b_{C}
\end{align}\]</div>
<p>其中</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; a_{E} = 0 \\
&amp; a_{W} = \text{FluxF}_{w} = -\Gamma_{w}^{\phi}\text{gDiff}_{w} \\
&amp; a_{N} = \text{FluxF}_{n} = -\Gamma_{n}^{\phi}\text{gDiff}_{n} \\
&amp; a_{S} = \text{FluxF}_{s} = -\Gamma_{s}^{\phi}\text{gDiff}_{s} \\
&amp; a_{C} = \sum_{f \sim nb(C)}\text{FluxC}_{f} = - (a_{W} + a_{N} + a_{S}) \\
&amp; b_{C} = Q_{C}^{\phi}V_{C} - \sum_{f \sim nb(C)}\text{FluxV}_{f}
\end{align}\end{split}\]</div>
</section>
</section>
<section id="id10">
<h3>界面扩散系数<a class="headerlink" href="#id10" title="此标题的永久链接"></a></h3>
<p>在上述离散方程中，我们分别使用了 <span class="math notranslate nohighlight">\(\Gamma_{e}^{\phi},\Gamma_{w}^{\phi},\Gamma_{n}^{\phi},\Gamma_{s}^{\phi}\)</span> 来表示 <span class="math notranslate nohighlight">\(\Gamma^{\phi}\)</span> 在单元 <span class="math notranslate nohighlight">\(e,w,n,s\)</span> 面上的值。当扩散系数随位置变化的时候，网格形心将会存储这些数值，然后就需要根据这些形心处的值来计算网格界面值。当然，下面的讨论与均匀扩散系数的情况无关。</p>
<p>如果考虑能量方程，讨论可能会变得更清楚，在这种情况下，扩散系数代表所使用的材料的热传导系数而 <span class="math notranslate nohighlight">\(\phi\)</span> 表示温度。非均匀热传导发生在非均匀材料和/或热导率与温度有关的时候。在一般的关于 <span class="math notranslate nohighlight">\(\phi\)</span> 的微分方程中，扩散系数 <span class="math notranslate nohighlight">\(\Gamma^{\phi}\)</span> 都将用相同的方式进行处理。在湍流中经常会遇到 <span class="math notranslate nohighlight">\(\Gamma^{\phi}\)</span> 的显著变化，这里的 <span class="math notranslate nohighlight">\(\Gamma^{\phi}\)</span> 可能表示湍流粘度或湍流传导性系数。因此，我们需要找到一个能够处理非均一 <span class="math notranslate nohighlight">\(\Gamma^{\phi}\)</span> 的合适算法。</p>
<p>一种简单的处理方法就是利用单元 <span class="math notranslate nohighlight">\(C\)</span> 及其相邻单元的 <span class="math notranslate nohighlight">\(\Gamma^{\phi}\)</span> 进行线性估计，因此，对于 <span class="math notranslate nohighlight">\(e\)</span> 面的插值可以这样得到：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\Gamma_{e}^{\phi} = (1 -g_{e})\Gamma_{C}^{\phi} + g_{e}\Gamma_{E}^{\phi}
\end{align}\]</div>
<p>其中插值因子 <span class="math notranslate nohighlight">\(g_{e}\)</span> 是关于形心与插值面距离的比值，定义为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
g_{e} = \frac{d_{Ce}}{d_{Ce} + d_{eE}}
\end{align}\]</div>
<p>因此，对于一个笛卡尔网格，如果网格面位于网格形心点的中间，那么 <span class="math notranslate nohighlight">\(g_{e}=0.5\)</span> ，并且 <span class="math notranslate nohighlight">\(\Gamma_{e}^{\phi}\)</span> 就是 <span class="math notranslate nohighlight">\(\Gamma_{C}^{\phi}\)</span> 和 <span class="math notranslate nohighlight">\(\Gamma_{E}^{\phi}\)</span> 的算术平均值。对于其他面的系数也可以类似得到：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
g_{w} = \frac{d_{Cw}}{d_{Cw} + d_{wW}} ,\quad
g_{n} = \frac{d_{Cn}}{d_{Cn} + d_{nN}} ,\quad
g_{s} = \frac{d_{Cs}}{d_{Cs} + d_{sS}}
\end{align}\]</div>
<p>因此，只计算一次单元各网格面的系数就足够了。此外，使用距离而不是体积将导致相同的插值因子，因为这里的网格是笛卡尔的。</p>
<p>这种基本方法在某些情况下会导致相当不正确的结果，不能准确地处理，例如，复合材料中可能发生的传导率的突然变化。不过，有一种比这简单得多的选择。在开发这种替代方案时，我们认识到界面上的局部电导率值不是主要考虑的问题，相反，我们的主要目标是获得界面处扩散通量的良好表示。对于如图所示的一维问题，假设单元C由导热系数为 <span class="math notranslate nohighlight">\(\Gamma_{C}^{\phi}\)</span> 的材料组成，而单元E由导热系数为 <span class="math notranslate nohighlight">\(\Gamma_{E}^{\phi}\)</span> 的材料组成。对于C点与E点之间的非均质网格面，一维无源分析得到(假设界面E两侧的通量相同)：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\mathbf{J}_{e}^{\phi,D} \cdot \mathbf{S}_{e}
= \frac{\phi_{C} - \phi_{e}}{\cfrac{(\delta x)_{Ce}}{\Gamma_{C}^{\phi}}}
= \frac{\phi_{e} - \phi_{E}}{\cfrac{(\delta x)_{eE}}{\Gamma_{E}^{\phi}}}
= \frac{\phi_{C} - \phi_{E}}{\cfrac{(\delta x)_{Ce}}{\Gamma_{C}^{\phi}} + \cfrac{(\delta x)_{eE}}{\Gamma_{E}^{\phi}}}
= \frac{\phi_{C} - \phi_{E}}{\cfrac{(\delta x)_{CE}}{\Gamma_{e}^{\phi}}}
\end{align}\]</div>
<figure class="align-center">
<img alt="../_images/在单元面上的插值.png" src="../_images/在单元面上的插值.png" />
</figure>
<p>由此得出平板的有效热传导率为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{(\delta x)_{CE}}{\Gamma_{e}^{\phi}}
= \frac{(\delta x)_{Ce}}{\Gamma_{C}^{\phi}} + \frac{(\delta x)_{eE}}{\Gamma_{E}^{\phi}}
\quad \Rightarrow \quad
\frac{1}{\Gamma_{e}^{\phi}} = \Big( \frac{1-g_{e}}{\Gamma_{E}^{\phi}} + \frac{g_{e}}{\Gamma_{C}^{\phi}}  \Big)
\end{align}\]</div>
<p>当网格面位于C和E的中间时，有 <span class="math notranslate nohighlight">\(g_{e}=0.5\)</span> ，上式就化简为了</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\Gamma_{e}^{\phi} = \frac{2 \Gamma_{C}^{\phi} \Gamma_{E}^{\phi}}{\Gamma_{C}^{\phi} + \Gamma_{E}^{\phi}}
\end{align}\]</div>
<p>也就是说， <span class="math notranslate nohighlight">\(\Gamma_{e}^{\phi}\)</span> 是 <span class="math notranslate nohighlight">\(\Gamma_{C}^{\phi}\)</span> 和 <span class="math notranslate nohighlight">\(\Gamma_{E}^{\phi}\)</span> 的调和平均值，而不是开始所采用的算术平均值。</p>
<p>值得注意的是，非连续扩散系数的调和平均值插值仅适用于一维扩散。然而，它在多维情况下的应用具有重要的优势。如果使用这种类型的插值，在处理共轭界面时就不需要做任何特别的事情，固体和流体的网格被简单地视为相同区域的一部分，在网格质心处存储不同的扩散系数。通过将扩散系数计算为共享网格面质心处的调和平均值，可以正确计算出共轭界面处的扩散通量。</p>
</section>
<section id="id11">
<h3>非笛卡尔正交网格<a class="headerlink" href="#id11" title="此标题的永久链接"></a></h3>
<p>现在让我们考虑一个没有沿着 <span class="math notranslate nohighlight">\(x,y\)</span> 坐标的正交网格，如图所示，这样的网格可以通过将之前的笛卡尔网格旋转某个角度得到。该网格的离散化方程应该与笛卡尔网格的离散化方程完全相同。对于相似的边界条件，应得到相同的解。</p>
<figure class="align-center">
<img alt="../_images/非笛卡尔正交网格.png" src="../_images/非笛卡尔正交网格.png" />
</figure>
<p>再次考虑稳态扩散方程</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\nabla \cdot \mathbf{J}^{\phi,D} = Q^{\phi}
\end{align}\]</div>
<p>跟之前一样，它的离散形式为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\sum_{f \sim nb(C)} - (\Gamma^{\phi} \nabla\phi)_{f} \cdot \mathbf{S}_{f} = Q_{C}^{\phi}V_{C}
\end{align}\]</div>
<p>单独考虑在 <span class="math notranslate nohighlight">\(e\)</span> 面的离散，就得到了</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\mathbf{J}_{e}^{\phi,D} \cdot \mathbf{S}_{e}
= - \Gamma_{e}^{\phi} (\nabla \phi \cdot \mathbf{n})_{e} S_{e}
= - \Gamma_{e}^{\phi} \Big( \frac{\partial \phi}{\partial n} \Big)_{e} S_{e}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\((\nabla \phi \cdot \mathbf{n})_{e} = \Big( \frac{\partial \phi}{\partial n} \Big)_{e}\)</span> 是 <span class="math notranslate nohighlight">\(\phi\)</span> 在 <span class="math notranslate nohighlight">\(e\)</span> 面上沿 <span class="math notranslate nohighlight">\(\mathbf{n}\)</span> 方向的梯度。再次沿着 <span class="math notranslate nohighlight">\(\mathbf{n}\)</span> 方向使用线性方法，该梯度就可以写成</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\Big( \frac{\partial \phi}{\partial n} \Big)_{e} = \frac{\phi_{E} - \phi_{C}}{d_{CE}}
\end{align}\]</div>
<p>其他项的离散化过程与笛卡尔网格一样，最终得到相同的离散化方程。</p>
</section>
<section id="id12">
<h3>非正交非结构化网格<a class="headerlink" href="#id12" title="此标题的永久链接"></a></h3>
<section id="id13">
<h4>非正交性<a class="headerlink" href="#id13" title="此标题的永久链接"></a></h4>
<p>在前面所述的网格构型中，通量都是与网格面正交的，然而一般来说，结构化含曲线的网格以及非结构网格都是非正交的。因此，面法向量 <span class="math notranslate nohighlight">\(\mathbf{S}_{f}\)</span> 和连接相邻网格单元质心的向量 <span class="math notranslate nohighlight">\(\mathbf{CF}\)</span> 并不在同一直线上，如图所示。在这种情况下，面法向梯度就不能够写成关于 <span class="math notranslate nohighlight">\(\phi_{F}\)</span> 和 <span class="math notranslate nohighlight">\(\phi_{C}\)</span> 的函数，因为它有一个垂直于 <span class="math notranslate nohighlight">\(\mathbf{CF}\)</span> 方向的分量。</p>
<figure class="align-center">
<img alt="../_images/非正交网格系统中的网格单元关系.png" src="../_images/非正交网格系统中的网格单元关系.png" />
</figure>
<p>所以，只有在正交网格的情况下，面法向梯度才能写成下面的形式：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
(\nabla \phi \cdot \mathbf{n})_{f}
= \Big( \frac{\partial \phi}{\partial n} \Big)_{f}
= \frac{\phi_{F} - \phi_{C}}{\| \mathbf{r}_{F} - \mathbf{r}_{C} \|}
= \frac{\phi_{F} - \phi_{C}}{d_{CF}}
\end{align}\]</div>
<p>在非正交网格中，就需要引入一个描述相邻网格质心方向的新的单位向量 <span class="math notranslate nohighlight">\(\mathbf{e}\)</span> ，它可以表示为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\mathbf{e} = \frac{\mathbf{r}_{F} - \mathbf{r}_{C}}{\| \mathbf{r}_{F} - \mathbf{r}_{C} \|} = \frac{\mathbf{d}_{CF}}{d_{CF}}
\end{align}\]</div>
<p>那么，在 <span class="math notranslate nohighlight">\(\mathbf{e}\)</span> 方向的梯度就可以写成</p>
<div class="math notranslate nohighlight">
\[\begin{align}
(\nabla \phi \cdot \mathbf{e})_{f}
= \Big( \frac{\partial \phi}{\partial e} \Big)_{f}
= \frac{\phi_{F} - \phi_{C}}{\| \mathbf{r}_{F} - \mathbf{r}_{C} \|}
= \frac{\phi_{F} - \phi_{C}}{d_{CF}}
\end{align}\]</div>
<p>因此，为了实现非正交网格中通量的线性化，面法向量应该写成两个向量的和，即</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\mathbf{S}_{f} = \mathbf{E}_{f} + \mathbf{T}_{f}
\end{align}\]</div>
<p>如此，面法向梯度就可以写成关于 <span class="math notranslate nohighlight">\(\phi_{F}\)</span> 、 <span class="math notranslate nohighlight">\(\phi_{C}\)</span> 的函数加上修正项的形式，即</p>
<div class="math notranslate nohighlight">
\[\begin{align}
(\nabla \phi)_{f} \cdot \mathbf{S}_{f}
= (\nabla\phi)_{f} \cdot \mathbf{E}_{f} + (\nabla\phi)_{f} \cdot \mathbf{T}
= E_{f}\Big( \frac{\partial \phi}{\partial e} \Big)_{f} + (\nabla\phi)_{f} \cdot \mathbf{T}_{f}
= E_{f}\frac{\phi_{F} - \phi_{C}}{d_{CF}} + (\nabla \phi)_{f} \cdot \mathbf{T}_{f}
\end{align}\]</div>
<p>上式右侧第一项表示与正交网格类似的贡献项，右侧第二项称为交叉扩散项或非正交扩散项，这是由于网格非正交性造成的。分解 <span class="math notranslate nohighlight">\(\mathbf{S}_{f}\)</span> 的方式是可选的，它们将会采用不同的非正交扩散项。</p>
</section>
<section id="id14">
<h4>最小修正法<a class="headerlink" href="#id14" title="此标题的永久链接"></a></h4>
<p>如图所示，最小修正法(Minimum Correction Approach)采用 <span class="math notranslate nohighlight">\(\mathbf{E}_{f}\)</span> 和 <span class="math notranslate nohighlight">\(\mathbf{T}_{f}\)</span> 相互垂直的形式来分解 <span class="math notranslate nohighlight">\(\mathbf{S}_{f}\)</span> 。当非正交性增加时， <span class="math notranslate nohighlight">\(\phi_{F},\phi_{C}\)</span> 对扩散通量的贡献减小。在这种情况下，向量 <span class="math notranslate nohighlight">\(\mathbf{E}_{f}\)</span> 可以这样表示：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\mathbf{E}_{f} = (\mathbf{e} \cdot \mathbf{S}_{f})\mathbf{e} = (S_{f}\cos\theta)\mathbf{e}
\end{align}\]</div>
<figure class="align-center">
<img alt="../_images/最小修正法的面法向量分解方式.png" src="../_images/最小修正法的面法向量分解方式.png" />
</figure>
</section>
<section id="id15">
<h4>正交修正法<a class="headerlink" href="#id15" title="此标题的永久链接"></a></h4>
<p>在正交修正法(Orthogonal Correction Approach)中，来自 <span class="math notranslate nohighlight">\(\phi_{F},\phi_{C}\)</span> 的贡献不论非正交角度如何，都与正交网格的情况保持相同，如图所示。为了实现这一点， <span class="math notranslate nohighlight">\(\mathbf{E}_{f}\)</span> 被定义为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\mathbf{E}_{f} = S_{f}\mathbf{e}
\end{align}\]</div>
<figure class="align-center">
<img alt="../_images/正交修正法的面法向量分解方式.png" src="../_images/正交修正法的面法向量分解方式.png" />
</figure>
</section>
<section id="id16">
<h4>过松弛法<a class="headerlink" href="#id16" title="此标题的永久链接"></a></h4>
<p>在过松弛法(Over-Relaxed Approach)中，来自 <span class="math notranslate nohighlight">\(\phi_{F},\phi_{C}\)</span> 的贡献的重要性被强制随着非正交性的增加而提高，如图所示。需要通过选择 <span class="math notranslate nohighlight">\(\mathbf{T}_{f}\)</span> 垂直于 <span class="math notranslate nohighlight">\(\mathbf{S}_{f}\)</span> 来实现。 <span class="math notranslate nohighlight">\(\mathbf{E}_{f}\)</span> 通过下式进行计算：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\mathbf{E}_{f} = \Big( \frac{S_{f}}{\cos\theta} \Big)\mathbf{e}
= \Big( \frac{S_{f}^{2}}{S_{f}\cos\theta} \Big)\mathbf{e}
= \frac{\mathbf{S}_{f} \cdot \mathbf{S}_{f}}{\mathbf{e} \cdot \mathbf{S}_{f}}\mathbf{e}
\end{align}\]</div>
<figure class="align-center">
<img alt="../_images/过松弛法的面法向量分解方式.png" src="../_images/过松弛法的面法向量分解方式.png" />
</figure>
<p>总的来说，在非正交网格中，网格单元的面扩散通量无法仅仅通过相邻两个单元质心的值计算得到，必须额外添加一项表示非正交性的贡献。这一额外添加的项称为交叉扩散项(cross diffusion)，计算方式有</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
(\nabla\phi)_{f} \cdot \mathbf{T}_{f}
= (\nabla\phi)_{f} \cdot (\mathbf{S}_{f} - \mathbf{E}_{f})
= \left \{ \begin{array}{l}
(\nabla \phi)_{f} \cdot (\mathbf{n} - \cos\theta \mathbf{e})S_{f} \quad \text{minimum correction} \\
(\nabla \phi)_{f} \cdot (\mathbf{n} - \mathbf{e})S_{f} \quad \text{normal correction} \\
(\nabla \phi)_{f} \cdot \Big( \mathbf{n} - \frac{1}{\cos\theta}\mathbf{e} \Big) \quad \text{over-relaxed}
\end{array} \right .
\end{align}\end{split}\]</div>
<p>对于正交网格， <span class="math notranslate nohighlight">\(\mathbf{n}\)</span> 和 <span class="math notranslate nohighlight">\(\mathbf{e}\)</span> 共线，因此交叉扩散项为零。而当交叉扩散项不为零的时候，它不能够写成关于 <span class="math notranslate nohighlight">\(\phi_{F}\)</span> 和 <span class="math notranslate nohighlight">\(\phi_{C}\)</span> 的函数，因此它将会作为源项添加到线性方程组当中。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>交叉扩散项不能用节点值表示。由于这一事实，它将以延迟修正的方式处理，即使用当前梯度场计算其值，并将其作为源项添加到代数方程的右侧。</p>
</div>
</section>
<section id="id17">
<h4>梯度计算<a class="headerlink" href="#id17" title="此标题的永久链接"></a></h4>
<p>在一维算域或多维正交算域中离散扩散项的时候，可以发现 <span class="math notranslate nohighlight">\(\phi\)</span> 的梯度可以显式地写成关于单元节点 <span class="math notranslate nohighlight">\(\phi\)</span> 值的函数。但是在非正交网格中，扩散项的计算要更加复杂，梯度的非正交分量无法线性化并写成关于单元节点值的形式，而是必须移到方程右边并显式地求值。这意味着要首先计算得到梯度然后才能计算非正交性在离散方程中的贡献。一种广泛使用的计算单元上梯度的方法是Green-Gauss定理，对于任何封闭体积 <span class="math notranslate nohighlight">\(V\)</span> ，总有：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\int_{V}\nabla \phi~\mathrm{d}V = \oint_{\partial V}\phi~\mathrm{d}\mathbf{S}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\mathrm{d}\mathbf{S}\)</span> 是指向封闭曲面外侧的面积微元法向量。为了得到该方程的离散形式，考虑应用平均值定理：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\overline{\nabla \phi}V = \int_{V}\nabla\phi~\mathrm{d}V
\end{align}\]</div>
<p>联立上面两个方程即可得到单元C的平均梯度计算方法：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\overline{\nabla \phi_{C}} = \frac{1}{V_{C}}\oint_{\partial V_{C}}\phi_{f}\mathbf{S}_{f}
\end{align}\]</div>
<p>上式右侧对单元面的积分可以通过面心值与网格面面积相乘来估计，于是</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\nabla\phi_{C} = \frac{1}{V_{C}}\sum_{f\sim nb(C)} \phi_{f}\mathbf{S}_{f}
\end{align}\]</div>
<p>单元面上的梯度可以通过加权平均单元质心处的梯度来得到，即</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\nabla\phi_{f} = g_{C}\nabla\phi_{C} + g_{F}\nabla \phi_{F}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(g_{C},g_{F}\)</span> 是与网格面 <span class="math notranslate nohighlight">\(f\)</span> 相对于节点C和F的位置有关的几何插值因子。</p>
</section>
<section id="id18">
<h4>非正交网格的线性方程<a class="headerlink" href="#id18" title="此标题的永久链接"></a></h4>
<p>将网格面法向量 <span class="math notranslate nohighlight">\(\mathbf{S}_{f}\)</span> 分解成 <span class="math notranslate nohighlight">\(\mathbf{E}_{f}\)</span> 和 <span class="math notranslate nohighlight">\(\mathbf{T}_{f}\)</span> 两个向量，并将其等效表达式代入到扩散通量半离散方程，得到</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\sum_{f\sim nb(C)}\Big( \mathbf{J}_{f}^{\phi,D}\cdot \mathbf{S}_{f} \Big)
&amp;= \sum_{f\sim nb(C)}\Big( -(\Gamma^{\phi}\nabla\phi)_{f} \cdot (\mathbf{E}_{f} + \mathbf{T}_{f}) \Big) \\
&amp;= \sum_{f\sim nb(C)}\Big( -(\Gamma^{\phi}\nabla\phi)_{f} \cdot \mathbf{E}_{f} \Big) + \sum_{f\sim nb(C)}\Big( -(\Gamma^{\phi}\nabla\phi)_{f}\cdot \mathbf{T}_{f} \Big) \\
&amp;= \sum_{f\sim nb(C)}\Big( -\Gamma_{f}^{\phi}E_{f}\frac{\phi_{F}-\phi_{C}}{d_{CF}} \Big) + \sum_{f\sim nb(C)}\Big( -(\Gamma^{\phi}\nabla\phi)_{f}\cdot \mathbf{T}_{f} \Big) \\
&amp;= \sum_{f\sim nb(C)}\Gamma_{f}^{\phi}\text{gDiff}_{f}(\phi_{C} - \phi_{F}) + \sum_{f\sim nb(C)}\Big( -(\Gamma^{\phi}\nabla\phi)_{f}\cdot \mathbf{T}_{f} \Big) \\
&amp;= \Big( \sum_{f\sim nb(C)}\text{FluxC}_{f} \Big)\phi_{C} + \sum_{f\sim nb(C)}(\text{FluxF}_{f}\phi_{F}) + \sum_{f\sim nb(C)}(\text{FluxV}_{f})
\end{align}\end{split}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\text{gDiff}_{f}\)</span> 是一个几何扩散系数，定义为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\text{gDiff}_{f} = \frac{E_{f}}{d_{CF}}
\end{align}\]</div>
<p>利用上述形式的扩散通量并展开，最终得到非结构化/结构化非正交网格的离散化扩散方程形式为：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
a_{C}\phi_{C} + \sum_{F\sim NB(C)}a_{F}\phi_{F} = b_{C}
\end{align}\]</div>
<p>其中</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; a_{F} = \text{FluxF}_{f} = -\Gamma_{f}^{\phi}\text{gDiff}_{f} \\
&amp; a_{C} = \sum_{f\sim nb(C)}\text{FluxC}_{f} = - \sum_{f\sim nb(C)}\text{FluxF}_{f} = \sum_{f\sim nb(C)}\Gamma_{f}^{\phi}\text{gDiff}_{f} \\
&amp; b_{C} = Q_{C}^{\phi}V_{C} - \sum_{f\sim nb(C)}(\text{FluxV}_{f}) = Q_{C}^{\phi}V_{C} + \sum_{f\sim nb(C)}\Big( (\Gamma^{\phi}\nabla\phi)_{f} \cdot \mathbf{T}_{f} \Big)
\end{align}\end{split}\]</div>
<div class="admonition attention">
<p class="admonition-title">注意</p>
<p>注意方程右边非正交项的符号变化。</p>
</div>
</section>
</section>
<section id="id19">
<h3>偏斜度<a class="headerlink" href="#id19" title="此标题的永久链接"></a></h3>
<p>在计算关于 <span class="math notranslate nohighlight">\(\phi\)</span> 的离散方程时，总是要估计其在网格面上的值，而在网格面上的估计值应该是整个网格面上的平均值。在离散化过程的不同步骤中，总是假设变量在网格单元节点之间呈线性分布，当这一观点延续到变量沿面变化的时候，那么任何变量的面平均值都应该在网格面的面心处找到。通常的做法是使用线性插值到网格面，并且在网格面与连接相邻单元节点的直线之间的交点处来估计网格面的值。</p>
<p>但是，当网格倾斜时，单元间连线不一定穿过网格面的质心，如图所示， <span class="math notranslate nohighlight">\(CF\)</span> 连线在网格面上的交点为 <span class="math notranslate nohighlight">\(f'\)</span> ，与网格面的面心 <span class="math notranslate nohighlight">\(f\)</span> 并不重合。为了保证离散方法整体具有二阶精度，所有面的积分都需要在 <span class="math notranslate nohighlight">\(f\)</span> 处进行，因此需要找到从 <span class="math notranslate nohighlight">\(f'\)</span> 处的值修正得到 <span class="math notranslate nohighlight">\(f\)</span> 处的值的方法。</p>
<p>偏斜度修正(skewness correction)通过将 <span class="math notranslate nohighlight">\(f\)</span> 处的 <span class="math notranslate nohighlight">\(\phi\)</span> 展开为 <span class="math notranslate nohighlight">\(f'\)</span> 处的泰勒展开式来实现，即</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\phi_{f} = \phi_{f'} + (\nabla\phi)_{f'} \cdot \mathbf{d}_{f'f}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\mathbf{d}_{f'f}\)</span> 表示一个由交点 <span class="math notranslate nohighlight">\(f'\)</span> 指向面心 <span class="math notranslate nohighlight">\(f\)</span> 的向量。</p>
<figure class="align-center">
<img alt="../_images/存在偏斜度的网格.png" src="../_images/存在偏斜度的网格.png" />
</figure>
</section>
<section id="id20">
<h3>各向异性扩散<a class="headerlink" href="#id20" title="此标题的永久链接"></a></h3>
<p>前面讨论的扩散方程都假设材料在各个方向上都具有相同的扩散系数，即认为介质是各向同性的。对于介质扩散系数与方向有关的情况，称为各项异性。如果材料是各项异性的，那么其半离散扩散方程为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\sum_{f\sim nb(C)}(-\boldsymbol{\kappa}^{\phi} \cdot \nabla\phi)_{f} \cdot \mathbf{S}_{f} = S_{C}^{\phi}V_{C}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\boldsymbol{\kappa}^{\phi}\)</span> 是一个二阶对称张量。考虑一个一般的三维情况，上式等号左边的项可以改写为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
(-\boldsymbol{\kappa}^{\phi} \cdot \nabla\phi)_{f} \cdot \mathbf{S}_{f}
&amp; = - \begin{bmatrix}
\boldsymbol{\kappa}_{11}^{\phi} &amp; \boldsymbol{\kappa}_{12}^{\phi} &amp; \boldsymbol{\kappa}_{13}^{\phi} \\
\boldsymbol{\kappa}_{21}^{\phi} &amp; \boldsymbol{\kappa}_{22}^{\phi} &amp; \boldsymbol{\kappa}_{23}^{\phi} \\
\boldsymbol{\kappa}_{31}^{\phi} &amp; \boldsymbol{\kappa}_{32}^{\phi} &amp; \boldsymbol{\kappa}_{33}^{\phi}
\end{bmatrix}_{f}
\begin{bmatrix}
\frac{\partial \phi}{\partial x} \\
\frac{\partial \phi}{\partial y} \\
\frac{\partial \phi}{\partial z}
\end{bmatrix}_{f}
\cdot \mathbf{S}_{f}
= - \begin{bmatrix}
\boldsymbol{\kappa}_{11}^{\phi}\frac{\partial \phi}{\partial x} + \boldsymbol{\kappa}_{12}^{\phi}\frac{\partial \phi}{\partial y} + \boldsymbol{\kappa}_{13}^{\phi}\frac{\partial \phi}{\partial z} \\
\boldsymbol{\kappa}_{21}^{\phi}\frac{\partial \phi}{\partial x} + \boldsymbol{\kappa}_{22}^{\phi}\frac{\partial \phi}{\partial y} + \boldsymbol{\kappa}_{23}^{\phi}\frac{\partial \phi}{\partial z} \\
\boldsymbol{\kappa}_{31}^{\phi}\frac{\partial \phi}{\partial x} + \boldsymbol{\kappa}_{32}^{\phi}\frac{\partial \phi}{\partial y} + \boldsymbol{\kappa}_{33}^{\phi}\frac{\partial \phi}{\partial z}
\end{bmatrix}_{f}
\begin{bmatrix}
S^{x} \\ S^{y} \\ S^{z}
\end{bmatrix}_{f}
\\
&amp; = - \begin{bmatrix}
\frac{\partial \phi}{\partial x} &amp; \frac{\partial \phi}{\partial y} &amp; \frac{\partial \phi}{\partial z}
\end{bmatrix}_{f}
\begin{bmatrix}
\boldsymbol{\kappa}_{11}^{\phi} &amp; \boldsymbol{\kappa}_{21}^{\phi} &amp; \boldsymbol{\kappa}_{31}^{\phi} \\
\boldsymbol{\kappa}_{12}^{\phi} &amp; \boldsymbol{\kappa}_{22}^{\phi} &amp; \boldsymbol{\kappa}_{32}^{\phi} \\
\boldsymbol{\kappa}_{13}^{\phi} &amp; \boldsymbol{\kappa}_{23}^{\phi} &amp; \boldsymbol{\kappa}_{33}^{\phi}
\end{bmatrix}_{f}
\begin{bmatrix}
S^{x} \\ S^{y} \\ S^{z}
\end{bmatrix}_{f}
= -(\nabla \phi)_{f} \cdot \Big[ (\boldsymbol{\kappa}^{\phi})^{T}\cdot \mathbf{S}\Big]_{f}
= -(\nabla \phi)_{f} \cdot \mathbf{S}_{f}'
\end{align}\end{split}\]</div>
<p>将其代入到原半离散方程中，即可得到</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\sum_{f\sim nb(C)}(-\nabla\phi)_{f} \cdot \mathbf{S}_{f}' = Q_{C}^{\phi}V_{C}
\end{align}\]</div>
<p>显然，上面的形式可以简单地通过将 <span class="math notranslate nohighlight">\(\Gamma^{\phi}\)</span> 设为 <span class="math notranslate nohighlight">\(1\)</span> 并将 <span class="math notranslate nohighlight">\(\mathbf{S}_{f}\)</span> 替换为 <span class="math notranslate nohighlight">\(\mathbf{S}_{f}\)</span> 得到。这也就意味着同样的代码可以用于求解各向同性和各向异性的问题。</p>
</section>
<section id="id21">
<h3>迭代解过程的欠松弛<a class="headerlink" href="#id21" title="此标题的永久链接"></a></h3>
<p>对于一般的扩散问题， <span class="math notranslate nohighlight">\(\Gamma^{\phi}\)</span> 可能是关于未知因变量 <span class="math notranslate nohighlight">\(\phi\)</span> 的函数，网格也可能是高度非正交的，具有较大的需要使用延迟修正方法处理的交叉扩散项。因此，在迭代的过程中， <span class="math notranslate nohighlight">\(\phi\)</span> 的较大变化会会导致较大的源项以及较大的系数变化，这可能会导致迭代求解过程发散。这种发散通常是由于系数和交叉扩散项引入的非线性，使得源项受到尚未收敛的当前解场的高度影响。</p>
<p>为了促进收敛并稳定迭代求解过程，就需要减缓 <span class="math notranslate nohighlight">\(\phi\)</span> 在迭代过程中的变化，这通过欠松弛(under-relaxation)的技术来实现。引入欠松弛的方法有很多，这里先介绍其中一种。首先考虑一般的离散方程：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
a_{C}\phi_{C} + \sum_{F\sim NB(C)}a_{F}\phi_{F} = b_{C}
\end{align}\]</div>
<p>上式可以改写成</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\phi_{C} = \frac{-\sum\limits_{F\sim NB(C)}a_{F}\phi_{F} + b_{C}}{a_{C}}
\end{align}\]</div>
<p>将 <span class="math notranslate nohighlight">\(\phi_{C}\)</span> 在前一次迭代得到的值记作 <span class="math notranslate nohighlight">\(\phi_{C}^{*}\)</span> 。如果将 <span class="math notranslate nohighlight">\(\phi_{C}^{*}\)</span> 添加到上式的右侧，则有</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\phi_{C} = \phi_{C}^{*}
+ \left ( \frac{-\sum\limits_{F\sim NB(C)}a_{F}\phi_{F} + b_{C}}{a_{C}} - \phi_{C}^{*} \right)
\end{align}\]</div>
<p>其中，括号内的表达式表示当前迭代对 <span class="math notranslate nohighlight">\(\phi_{C}\)</span> 产生的变化量。这个变化量可以通过引入松弛因子 <span class="math notranslate nohighlight">\(\lambda^{\phi}\)</span> 来修改，即</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\phi_{C} = \phi_{C}^{*}
+ \lambda ^{\phi}\left ( \frac{-\sum\limits_{F\sim NB(C)}a_{F}\phi_{F} + b_{C}}{a_{C}} - \phi_{C}^{*} \right)
\end{align}\]</div>
<p>将其写回一般离散方程的形式，得到</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{a_{C}}{\lambda^{\phi}}\phi_{C}
+ \sum_{F\sim NB(C)}a_{F}\phi_{F}
= b_{C}
+ \frac{(1-\lambda^{\phi})a_{C}}{\lambda^{\phi}}\phi_{C}^{\phi}
\end{align}\]</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在收敛点上， <span class="math notranslate nohighlight">\(\phi_{C}\)</span> 和 <span class="math notranslate nohighlight">\(\phi_{C}^{*}\)</span> 将会相等，与松弛因子的取值无关。并且在收敛点上， <span class="math notranslate nohighlight">\(\phi_{C}\)</span> 满足原始离散方程。这是所有松弛方法都应当满足的特性。</p>
</div>
<p>根据松弛因子的取值，可以将方程分为欠松弛( <span class="math notranslate nohighlight">\(0&lt;\lambda^{\phi}&lt;1\)</span> )或过松弛( <span class="math notranslate nohighlight">\(\lambda^{\phi}&gt;1\)</span> )两种。在CFD中通常使用欠松弛方程。当松弛因子接近1时，表明几乎没有松弛操作；当松弛因子接近0时，将会产生非常强的欠松弛效果并使得迭代过程的变化及其缓慢。</p>
<div class="admonition attention">
<p class="admonition-title">注意</p>
<p>松弛因子的最优选择总是与问题相关的，没有通用的一种规则。影响松弛因子取值的因素包括所解决问题的类型、方程组的大小（计算域网格数量）、网格间距和拓展速率、采用的迭代方法等。通常来说，松弛因子是根据经验或初步计算结果来分配的。此外，没有必要在整个计算域使用相同的欠松弛值，并且在迭代过程中也可以取不同的值。</p>
</div>
<p>含松弛算法的离散方程可以简单地从原始离散方程得到，只需要修改对应系数：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
a_{C} \leftarrow \frac{a_{C}}{\lambda^{\phi}}
,\quad
b_{C} \leftarrow b_{C} + \frac{(1-\lambda^{\phi})a_{C}}{\lambda^{\phi}}\phi_{C}^{*}
\end{align}\]</div>
</section>
</section>
<section id="id22">
<h2>梯度计算<a class="headerlink" href="#id22" title="此标题的永久链接"></a></h2>
<section id="id23">
<h3>笛卡尔网格中的梯度计算<a class="headerlink" href="#id23" title="此标题的永久链接"></a></h3>
<p>对于如图所示的一维问题，使用均一网格离散，假设单元质心之间的变化时线性的，就可以得到在单元面e处的导数表达式：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\Big(\frac{\mathrm{d}\phi}{\mathrm{d}x}\Big)_{e}
= \frac{\phi_{E} - \phi_{C}}{x_{E} - x_{C}}
= \frac{\phi_{E} - \phi_{C}}{\delta x_{e}}
\end{align}\]</div>
<p>类似的，在单元质心C处的导数也可以用相邻单元的值来表示：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\Big(\frac{\mathrm{d}\phi}{\mathrm{d}x}\Big)_{C}
= \frac{\phi_{e} - \phi_{w}}{x_{e} - x_{w}}
= \frac{\Big(\cfrac{\phi_{E}-\phi_{C}}{2}\Big)-\Big(\cfrac{\phi_{C}+\phi_{W}}{2}\Big)}{\Delta x_{C}}
= \frac{\phi_{E} - \phi_{W}}{2\Delta x_{C}}
\end{align}\]</div>
<p>上式常被称为一阶导的中心差分估计。</p>
<p>对于多维的笛卡尔网格，导数可以通过应用相同的原理沿各自的坐标方向来计算。例如，考虑如图所示的二维网格，使用上述的中心差分近似，得到x和y方向的偏导数为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\Big(\frac{\partial \phi}{\partial x}\Big)_{C}
= \frac{\phi_{E} - \phi_{W}}{x_{E} - x_{W}}
,\qquad
\Big(\frac{\partial \phi}{\partial y}\Big)_{C}
= \frac{\phi_{N} - \phi_{S}}{x_{N} - x_{S}}
\end{align}\]</div>
<p>对于三维网格，z方向也可以写出类似的式子。但是，在处理非结构化网格的时候，上述方法就不再适用，就需要寻找更加通用的计算梯度的方法。</p>
<figure class="align-center">
<img alt="../_images/笛卡尔网格中的梯度计算.png" src="../_images/笛卡尔网格中的梯度计算.png" />
</figure>
</section>
<section id="green-gauss">
<h3>Green-Gauss梯度<a class="headerlink" href="#green-gauss" title="此标题的永久链接"></a></h3>
<p>这是计算梯度最广泛使用的方法之一。前一章已经介绍过，这里不再赘述。相反，我们将给出方程的最终形式，并介绍一些计算面值的附加方法。</p>
<p>如前一章所推导，体积为 <span class="math notranslate nohighlight">\(V_{C}\)</span> 的单元C质心处的梯度可以如下计算：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\nabla \phi_{C} = \frac{1}{V_{C}}\sum_{f\sim nb(C)}\phi_{f}\mathbf{S}_{f}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(f\)</span> 表示网格面， <span class="math notranslate nohighlight">\(\mathbf{S}_{f}\)</span> 表示网格面法向量。在使用上述方程之前，还需要确定 <span class="math notranslate nohighlight">\(\phi_{f}\)</span> 的表示。有两种计算它的路线，一种是基于相邻单元网格面的紧凑模板；另一种是基于相邻单元顶点的更广域的模板，该拓展模板涉及的单元格数量大约是紧凑模板的两倍。对于隐式方法，紧凑模板更加方便，因为它能够得到更紧凑的雅可比矩阵。但是，广域模板为重建带来了更多的信息，因此结果再预期上是更加准确的。</p>
<section id="compact-stencil">
<h4>Compact Stencil<a class="headerlink" href="#compact-stencil" title="此标题的永久链接"></a></h4>
<p>对于如图(a)(b)所示的二维和三维网格系统，一个简单的计算 <span class="math notranslate nohighlight">\(\phi_{f}\)</span> 的方式为使用两个网格单元的平均值。在这个情况下 <span class="math notranslate nohighlight">\(\phi_{f}\)</span> 可以如下计算：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\phi_{f} = g_{C}\phi_{C} + (1-g_{C})\phi_{F}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(g_{C}\)</span> 为几何权重因子，定义为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
g_{C} = \frac{\| \mathbf{r}_{F} - \mathbf{r}_{f} \|}{\| \mathbf{r}_{F} - \mathbf{r}_{C} \|} = \frac{d_{Ff}}{d_{FC}}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\mathbf{r}\)</span> 表示坐标向量， <span class="math notranslate nohighlight">\(d\)</span> 表示两点之间的距离。当网格面位于两个网格单元的中心时， <span class="math notranslate nohighlight">\(\phi_{f}\)</span> 就能表示为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\phi_{f} = \frac{\phi_{C} + \phi_{F}}{2}
\end{align}\]</div>
<p>这种方法在二维和三维情况下很容易实现，所有涉及的操作都是基于网格面的，不需要额外的网格连接。在精度方面，上述关系仅仅在 <span class="math notranslate nohighlight">\(\mathbf{CF}\)</span> 和网格面 <span class="math notranslate nohighlight">\(\mathbf{S}_{f}\)</span> 的交点与网格面 <span class="math notranslate nohighlight">\(\mathbf{S}_{f}\)</span> 的面心重合时，即与高斯积分点 <span class="math notranslate nohighlight">\(f\)</span> 重合时，才能得到二阶逼近结果。因此，除了上述特殊情况之外，通常无法实现梯度的二阶精确表示。</p>
<figure class="align-center">
<img alt="../_images/无偏斜度的网格梯度计算.png" src="../_images/无偏斜度的网格梯度计算.png" />
</figure>
<p>一般的结构化非正交网格或非结构化网格通常不满足这种条件，如图(c)(d)所示。网格的偏斜度(skewness)导致 <span class="math notranslate nohighlight">\(\mathbf{CF}\)</span> 和网格面 <span class="math notranslate nohighlight">\(\mathbf{S}_{f}\)</span> 相交于点 <span class="math notranslate nohighlight">\(f'\)</span> ，与网格面质心点 <span class="math notranslate nohighlight">\(f\)</span> 不同。在这种情况下，需要对插值的 <span class="math notranslate nohighlight">\(\phi_{f'}\)</span> 进行修正来得到 <span class="math notranslate nohighlight">\(\phi_{f}\)</span> 。修正方程为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\phi_{f} &amp;= \phi_{f'} + \text{correction} \\
&amp;= \phi_{f'} + (\nabla\phi)_{f'} \cdot (\mathbf{r}_{f} - \mathbf{r}_{f'}) \\
&amp;= g_{C}\Big( \phi_{C} + (\nabla\phi)_{C} \cdot (\mathbf{r}_{f} - \mathbf{r}_{C}) \Big)
+ (1 - g_{C}) \Big( \phi_{F} + (\nabla\phi)_{F} \cdot (\mathbf{r}_{f} - \mathbf{r}_{F})\Big) \\
&amp;= \phi_{f'} + g_{C}(\nabla\phi)_{C} \cdot (\mathbf{r}_{f} - \mathbf{r}_{C})
+ (1 - g_{C}) (\nabla\phi)_{F} \cdot (\mathbf{r}_{f} - \mathbf{r}_{F})
\end{align}\end{split}\]</div>
<p>由于 <span class="math notranslate nohighlight">\(g_{C}\)</span> 依赖于 <span class="math notranslate nohighlight">\(f'\)</span> ，上式表明可以通过迭代来获得梯度的改进估计值。在每次迭代中，使用前一次迭代中计算的梯度结果来计算网格面的平均值，然后使用这些网格面平均值来计算梯度的新估计值。</p>
<div class="admonition attention">
<p class="admonition-title">注意</p>
<p>进行过多的迭代可能会导致数值振荡，因此通常不会进行两次以上的迭代。</p>
</div>
<figure class="align-center">
<img alt="../_images/存在偏斜度的网格梯度计算.png" src="../_images/存在偏斜度的网格梯度计算.png" />
</figure>
<p>在这种情况下，计算 <span class="math notranslate nohighlight">\(g_{C}\)</span> 需要确定 <span class="math notranslate nohighlight">\(\mathbf{CF}\)</span> 和网格面  <span class="math notranslate nohighlight">\(S_{f}\)</span> 的交点 <span class="math notranslate nohighlight">\(f'\)</span> 的位置。有三种方法可以实现这一目的：</p>
<p><strong>方法一</strong> ：在这个方法中， <span class="math notranslate nohighlight">\(f'\)</span> 认为就是 <span class="math notranslate nohighlight">\(\mathbf{CF}\)</span> 和网格面 <span class="math notranslate nohighlight">\(S_{f}\)</span> 的交点。引入网格面单位法向量 <span class="math notranslate nohighlight">\(\mathbf{n} = \mathbf{S}_{f} / \| \mathbf{S}_{f} \|\)</span> ，以及沿CF方向的单位向量 <span class="math notranslate nohighlight">\(\mathbf{e} = \mathbf{CF} / \| \mathbf{CF} \|\)</span> ， <span class="math notranslate nohighlight">\(f'\)</span> 点的位置可以利用 <span class="math notranslate nohighlight">\(\mathbf{n}\)</span> 和线段 <span class="math notranslate nohighlight">\(ff'\)</span> 的正交性得到，即</p>
<div class="math notranslate nohighlight">
\[\begin{align}
(\mathbf{r}_{f} - \mathbf{r}_{f'}) \cdot \mathbf{n} = 0
\end{align}\]</div>
<p>并且，因为 <span class="math notranslate nohighlight">\(f'\)</span> 是在CF上的一个点，于是向量 <span class="math notranslate nohighlight">\(\mathbf{Cf'}\)</span> 可以用 <span class="math notranslate nohighlight">\(\mathbf{e}\)</span> 来表示：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\mathbf{Cf'} = (\mathbf{r}_{f'} - \mathbf{r}_{C}) = k\mathbf{e}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(k\)</span> 是一个标量。联立上面两个式子得到</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\mathbf{r}_{f'} = \frac{\mathbf{r}_{f} \cdot \mathbf{n}}{\mathbf{e} \cdot \mathbf{n}}\mathbf{e}
\end{align}\]</div>
<p>上式确定出了 <span class="math notranslate nohighlight">\(f'\)</span> 的位置，于是可以如下计算 <span class="math notranslate nohighlight">\(g_{C}\)</span> ：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
g_{C} = \frac{\| \mathbf{r}_{F} - \mathbf{r}_{f'} \|}{\| \mathbf{r}_{F} - \mathbf{r}_{C} \|} = \frac{d_{Ff'}}{d_{FC}}
\end{align}\]</div>
<p>那么，计算过程包括以下步骤：在第一次迭代中，计算整个域的梯度场如下：</p>
<ol class="arabic simple">
<li><p>计算 <span class="math notranslate nohighlight">\(\phi_{f'}\)</span> ： <span class="math notranslate nohighlight">\(\phi_{f'} = g_{C}\phi_{C} + (1-g_{C})\phi_{F}\)</span> ；</p></li>
<li><p>计算 <span class="math notranslate nohighlight">\(\nabla\phi_{C}\)</span> ： <span class="math notranslate nohighlight">\(\nabla\phi_{C} = \frac{1}{V_{C}}\sum_{f\sim nb(C)}\phi_{f'}\mathbf{S}_{f}\)</span> ；</p></li>
</ol>
<p>从第二次迭代开始，按照以下步骤修正梯度场：</p>
<ol class="arabic simple" start="3">
<li><p>更新 <span class="math notranslate nohighlight">\(\phi_{f}\)</span> ： <span class="math notranslate nohighlight">\(\phi_{f} = \phi_{f'} + g_{C}(\nabla\phi)_{C} \cdot (\mathbf{r}_{f} - \mathbf{r}_{C}) + (1 - g_{C})(\nabla\phi)_{F} \cdot (\mathbf{r}_{f} - \mathbf{r}_{F})\)</span> ；</p></li>
<li><p>更新 <span class="math notranslate nohighlight">\(\nabla\phi_{C}\)</span> ： <span class="math notranslate nohighlight">\(\nabla\phi_{C} = \frac{1}{V_{C}}\sum\limits_{f\sim nb(C)}\phi_{f}\mathbf{S}_{f}\)</span> ；</p></li>
<li><p>返回步骤3并重复。</p></li>
</ol>
<p><strong>方法二</strong> ：在该方法中将 <span class="math notranslate nohighlight">\(f'\)</span> 点取为CF的中点，如图所示，这样方程可以得到化简。在整个计算域的梯度计算过程如下：在第一次迭代中，计算整个域的梯度场如下：</p>
<ol class="arabic simple">
<li><p>计算 <span class="math notranslate nohighlight">\(\phi_{f'}\)</span> ： <span class="math notranslate nohighlight">\(\phi_{f'} = \frac{\phi_{C} - \phi_{F}}{2}\)</span> ；</p></li>
<li><p>计算 <span class="math notranslate nohighlight">\(\nabla\phi_{C}\)</span> ： <span class="math notranslate nohighlight">\(\nabla\phi_{C} = \frac{1}{V_{C}}\sum_{f\sim nb(C)}\phi_{f'}\mathbf{S}_{f}\)</span> ；</p></li>
</ol>
<p>从第二次迭代开始，按照以下步骤修正梯度场：</p>
<ol class="arabic simple" start="3">
<li><p>更新 <span class="math notranslate nohighlight">\(\phi_{f}\)</span> ： <span class="math notranslate nohighlight">\(\phi_{f} = \phi_{f'} + 0.5 \times [(\nabla\phi)_{C} + (\nabla\phi)_{F}] \cdot [\mathbf{r}_{f} - 0.5\times (\mathbf{r}_{C} + \mathbf{r}_{F})]\)</span> ；</p></li>
<li><p>更新 <span class="math notranslate nohighlight">\(\nabla\phi_{C}\)</span> ： <span class="math notranslate nohighlight">\(\nabla\phi_{C} = \frac{1}{V_{C}}\sum\limits_{f\sim nb(C)}\phi_{f}\mathbf{S}_{f}\)</span> ；</p></li>
<li><p>返回步骤3并重复。</p></li>
</ol>
<figure class="align-center">
<img alt="../_images/取f'为CF的中点.png" src="../_images/取f'为CF的中点.png" />
</figure>
<p><strong>方法三</strong> ：该方法选取的 <span class="math notranslate nohighlight">\(f'\)</span> 使得 <span class="math notranslate nohighlight">\(ff'\)</span> 最短，也即 <span class="math notranslate nohighlight">\(ff'\)</span> 与 <span class="math notranslate nohighlight">\(CF\)</span> 垂直，如图所示。这能在第一次迭代计算梯度的时候提高精度。在这个情况下， <span class="math notranslate nohighlight">\(f'\)</span> 通过最小化 <span class="math notranslate nohighlight">\(f\)</span> 和 <span class="math notranslate nohighlight">\(f'\)</span> 的距离来计算得到。一般地， <span class="math notranslate nohighlight">\(\mathbf{r}_{f'}\)</span> 能够如下表示：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\mathbf{r}_{f'} = \mathbf{r}_{C} + q(\mathbf{r}_{F} - \mathbf{r}_{C})
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(0&lt;q&lt;1\)</span> 。用 <span class="math notranslate nohighlight">\(d\)</span> 来表示距离 <span class="math notranslate nohighlight">\(ff'\)</span> ，则其平方可以表示为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
d^{2} &amp;= (\mathbf{r}_{f} - \mathbf{r}_{f'}) \cdot (\mathbf{r}_{f} - \mathbf{r}_{f'}) \\
      &amp;= [\mathbf{r}_{f} - \mathbf{r}_{C} - q(\mathbf{r}_{F} - \mathbf{r}_{C})] \cdot [\mathbf{r}_{f} - \mathbf{r}_{C} - q(\mathbf{r}_{F} - \mathbf{r}_{C})] \\
      &amp;= (\mathbf{r}_{f} - \mathbf{r}_{C}) \cdot (\mathbf{r}_{f} - \mathbf{r}_{C}) - 2q(\mathbf{r}_{f} - \mathbf{r}_{C}) \cdot (\mathbf{r}_{F} - \mathbf{r}_{C}) + q^{2}(\mathbf{r}_{F} - \mathbf{r}_{C}) \cdot (\mathbf{r}_{F} - \mathbf{r}_{C})
\end{align}\end{split}\]</div>
<p>求函数 <span class="math notranslate nohighlight">\(d^{2}\)</span> 关于 <span class="math notranslate nohighlight">\(q\)</span> 的最小值，得到</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\partial (d^{2})}{\partial q} = 0
\quad \Rightarrow \quad
-2(\mathbf{r}_{f} - \mathbf{r}_{C})\cdot (\mathbf{r}_{F} - \mathbf{r}_{C}) + 2q(\mathbf{r}_{F} - \mathbf{r}_{C}) \cdot (\mathbf{r}_{F} - \mathbf{r}_{C}) = 0
\end{align}\]</div>
<p>求解上式可以得到 <span class="math notranslate nohighlight">\(q\)</span> 的表达式为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
q = -\frac{\mathbf{r}_{Cf} \cdot \mathbf{r}_{CF}}{\mathbf{r}_{CF} \cdot \mathbf{r}_{CF}}
\end{align}\]</div>
<figure class="align-center">
<img alt="../_images/取f'令距离ff'最短.png" src="../_images/取f'令距离ff'最短.png" />
</figure>
<p>在得知了 <span class="math notranslate nohighlight">\(q\)</span> 的值后，在整个计算域中梯度的计算过程如下：在第一次迭代中，计算整个域的梯度场如下：</p>
<ol class="arabic simple">
<li><p>计算 <span class="math notranslate nohighlight">\(\mathbf{r}_{f'}\)</span> ： <span class="math notranslate nohighlight">\(\mathbf{r}_{f'} = \mathbf{r}_{C} - \frac{\mathbf{r}_{Cf} \cdot \mathbf{r}_{CF}}{\mathbf{r}_{CF} \cdot \mathbf{r}_{CF}} (\mathbf{r}_{C} - \mathbf{r}_{F})\)</span> ；</p></li>
<li><p>计算 <span class="math notranslate nohighlight">\(g_{C}\)</span> ： <span class="math notranslate nohighlight">\(g_{C} = \| \mathbf{r}_{F} - \mathbf{r}_{f'} \| / \| \mathbf{r}_{F} - \mathbf{r}_{C} \|\)</span> ；</p></li>
<li><p>计算 <span class="math notranslate nohighlight">\(\phi_{f'}\)</span> ： <span class="math notranslate nohighlight">\(\phi_{f'} = \frac{\phi_{C} - \phi_{F}}{2}\)</span> ；</p></li>
<li><p>计算 <span class="math notranslate nohighlight">\(\nabla\phi_{C}\)</span> ： <span class="math notranslate nohighlight">\(\nabla\phi_{C} = \frac{1}{V_{C}}\sum_{f\sim nb(C)}\phi_{f'}\mathbf{S}_{f}\)</span> ；</p></li>
</ol>
<p>从第二次迭代开始，按照以下步骤修正梯度场：</p>
<ol class="arabic simple" start="5">
<li><p>计算 <span class="math notranslate nohighlight">\(\nabla\phi_{f'}\)</span> ： <span class="math notranslate nohighlight">\(\nabla\phi_{f'} = g_{C}\nabla\phi_{C} + (1 - g_{C})\nabla\phi_{F}\)</span></p></li>
<li><p>更新 <span class="math notranslate nohighlight">\(\phi_{f}\)</span> ： <span class="math notranslate nohighlight">\(\phi_{f} = \phi_{f'} + 0.5 \times [(\nabla\phi)_{C} + (\nabla\phi)_{F}] \cdot [\mathbf{r}_{f} - 0.5\times (\mathbf{r}_{C} + \mathbf{r}_{F})]\)</span> ；</p></li>
<li><p>更新 <span class="math notranslate nohighlight">\(\nabla\phi_{C}\)</span> ： <span class="math notranslate nohighlight">\(\nabla\phi_{C} = \frac{1}{V_{C}}\sum\limits_{f\sim nb(C)}\phi_{f}\mathbf{S}_{f}\)</span> ；</p></li>
<li><p>返回步骤5并重复。</p></li>
</ol>
</section>
<section id="extended-stencil">
<h4>Extended Stencil<a class="headerlink" href="#extended-stencil" title="此标题的永久链接"></a></h4>
<p>网格面面心 <span class="math notranslate nohighlight">\(f\)</span> 处的 <span class="math notranslate nohighlight">\(\phi_{f}\)</span> 值可以通过网格面顶点处的值的平均来计算。这就需要估计在顶点处的值，而在顶点节点的值可以通过围绕该顶点的网格质心处的值进行加权平均得到，如图所示。权重系数认为是顶点到网格质心距离的倒数，于是在顶点处的值可以表示为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\phi_{n} = \frac{\sum\limits_{k=1}^{NB(n)}\cfrac{\phi_{F_{k}}}{\| \mathbf{r}_{n} - \mathbf{r}_{F_{k}} \|}}{\sum\limits_{k=1}^{NB(n)}\cfrac{1}{\| \mathbf{r}_{n} - \mathbf{r}_{F_{k}} \|}}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(n\)</span> 表示顶点节点， <span class="math notranslate nohighlight">\(F_{k}\)</span> 表示相邻的网格质心节点， <span class="math notranslate nohighlight">\(NB(n)\)</span> 表示围绕顶点节点 <span class="math notranslate nohighlight">\(n\)</span> 的所有网格质心节点， <span class="math notranslate nohighlight">\(\| \mathbf{r}_{n} - \mathbf{r}_{F_{k}}\)</span> 表示顶点节点到相邻网格质心节点的距离。</p>
<figure class="align-center">
<img alt="../_images/由临近网格质心值加权平均得到顶点值.png" src="../_images/由临近网格质心值加权平均得到顶点值.png" />
</figure>
<p>一旦得到了顶点处的值 <span class="math notranslate nohighlight">\(\phi_{n}\)</span> ，那么面心上的值 <span class="math notranslate nohighlight">\(\phi_{f}\)</span> 就可以能够顺利得到。在二维情况下， <span class="math notranslate nohighlight">\(\phi_{f}\)</span> 的计算方式为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\phi_{f} = \frac{\phi_{n_{1}} + \phi_{n_{2}}}{2}
\end{align}\]</div>
<p>于是在C处的梯度可以如下计算：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\nabla\phi_{C} = \frac{1}{V_{C}}\sum_{f\sim nb(C)}\phi_{f}\mathbf{S}_{f}
= \frac{1}{V_{C}}\sum_{f\sim nb(C)}\Big( \frac{\phi_{n_{1}} + \phi_{n_{2}}}{2} \Big)_{f} \mathbf{S}_{f}
\end{align}\]</div>
<p>在三维情况下，计算要稍微复杂一些，因为面顶点的数量取决于网格面的类型。通过顶点值确定 <span class="math notranslate nohighlight">\(\phi_{f}\)</span> 的方式为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\phi_{f} = \frac{\sum\limits_{k=1}^{nb(f)}\cfrac{\phi_{n_{k}}}{\| \mathbf{r}_{n_{k}} - \mathbf{r}_{f} \|}}{\sum\limits_{k=1}^{nb(f)}\cfrac{1}{\| \mathbf{r}_{n_{k}} - \mathbf{r}_{f} \|}}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(n\)</span> 表示网格面 <span class="math notranslate nohighlight">\(f\)</span> 的顶点数量。一旦计算出 <span class="math notranslate nohighlight">\(\phi_{f}\)</span> ，则可以通过下式计算出C处的梯度：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\nabla\phi_{C} = \frac{1}{V_{C}}\sum_{f\sim nb(C)}\phi_{f}\mathbf{S}_{f}
\end{align}\]</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>这种方法的缺点之一是，来自网格面错误的一侧信息也会参与到变量的加权平均值。虽然这可以通过使用Cabello所讨论的迎风偏梯度来克服，但是基于迎风偏梯度的高阶算法不仅需要更高的内存开销来存储用于迎风偏梯度计算的单元信息，又增加了编码复杂度。</p>
</div>
</section>
</section>
<section id="id24">
<h3>最小二乘法梯度<a class="headerlink" href="#id24" title="此标题的永久链接"></a></h3>
<p>使用最小二乘法来计算梯度在达到的计算精度阶数、所使用的stencil方面具有更大的灵活性。这种灵活性是有代价的，因为它需要对stencil terms进行适当的加权，而加权的计算增加了计算成本。</p>
<p>考虑一个控制体积以及它的相邻网格，在质心C和F之间的变量值可以表示为 <span class="math notranslate nohighlight">\((\phi_{F} - \phi_{C})\)</span> ，如果网格单元的梯度 <span class="math notranslate nohighlight">\((\nabla \phi_{C})\)</span> 是确定的，那么就有：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\phi_{F} = \phi_{C} + (\nabla\phi)_{C} \cdot (\mathbf{r}_{F} - \mathbf{r}_{C})
\end{align}\]</div>
<p>但是，除非计算域是线性的，否则网格单元梯度就不能被确定，因为C所具有的相邻单元比梯度向量的分量还要多。在最小二乘法中，梯度通过一个优化过程来确定，这个优化就是找到下面定义的 <span class="math notranslate nohighlight">\(G_{C}\)</span> 的最小值：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
G_{C} &amp;= \sum_{k=1}^{NB(C)}\Big( w_{k}\big(\phi_{F_{k}} - (\phi_{C} + \nabla\phi_{C} \cdot \mathbf{r}_{CF_{k}}) \big)^{2} \Big) \\
      &amp;= \sum_{k=1}^{NB(C)}\left \{ w_{k}\Big[ \Delta\phi_{k} - \Big( \Delta x_{k} (\frac{\partial \phi}{\partial x} )_{C} + \Delta y_{k}(\frac{\partial \phi}{\partial y} )_{C} + \Delta z_{k}(\frac{\partial \phi}{\partial z} )_{C} \Big) \Big]^{2} \right \}
\end{align}\end{split}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(w_{k}\)</span> 是权重因子。其他各项的具体含义为：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\Delta\phi_{k} = \phi_{F_{k}} - \phi_{C}
,\quad
\Delta x_{k} = \mathbf{r}_{CF_{k}} \cdot \mathbf{i}
,\quad
\Delta y_{k} = \mathbf{r}_{CF_{k}} \cdot \mathbf{j}
,\quad
\Delta z_{k} = \mathbf{r}_{CF_{k}} \cdot \mathbf{k}
\end{align}\]</div>
<p>函数 <span class="math notranslate nohighlight">\(G_{C}\)</span> 通过下面这个条件来实现最小化：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\partial G_{C}}{\partial \Big(\cfrac{\partial \phi}{\partial x} \Big)}
= \frac{\partial G_{C}}{\partial \Big(\cfrac{\partial \phi}{\partial y} \Big)}
= \frac{\partial G_{C}}{\partial \Big(\cfrac{\partial \phi}{\partial z} \Big)}
= 0
\end{align}\]</div>
<p>由上式得到含三个未知数的三个方程：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; \sum_{k=1}^{NB(C)}\left \{ 2 w_{k}\Delta x_{k} \Big[-\Delta\phi_{k} + \Delta x_{k} (\frac{\partial \phi}{\partial x} )_{C} + \Delta y_{k}(\frac{\partial \phi}{\partial y} )_{C} + \Delta z_{k}(\frac{\partial \phi}{\partial z} )_{C} \Big] \right \} = 0 \\
&amp; \sum_{k=1}^{NB(C)}\left \{ 2 w_{k}\Delta y_{k} \Big[-\Delta\phi_{k} + \Delta x_{k} (\frac{\partial \phi}{\partial x} )_{C} + \Delta y_{k}(\frac{\partial \phi}{\partial y} )_{C} + \Delta z_{k}(\frac{\partial \phi}{\partial z} )_{C} \Big] \right \} = 0 \\
&amp; \sum_{k=1}^{NB(C)}\left \{ 2 w_{k}\Delta z_{k} \Big[-\Delta\phi_{k} + \Delta x_{k} (\frac{\partial \phi}{\partial x} )_{C} + \Delta y_{k}(\frac{\partial \phi}{\partial y} )_{C} + \Delta z_{k}(\frac{\partial \phi}{\partial z} )_{C} \Big] \right \} = 0
\end{align}\end{split}\]</div>
<p>上面的方程组可以写成矩阵形式：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\begin{bmatrix}
\sum\limits_{k=1}^{NB(C)}w_{k}\Delta x_{k}\Delta x_{k} &amp; \sum\limits_{k=1}^{NB(C)}w_{k}\Delta x_{k}\Delta y_{k} &amp; \sum\limits_{k=1}^{NB(C)}w_{k}\Delta x_{k}\Delta z_{k} \\
\sum\limits_{k=1}^{NB(C)}w_{k}\Delta y_{k}\Delta x_{k} &amp; \sum\limits_{k=1}^{NB(C)}w_{k}\Delta y_{k}\Delta y_{k} &amp; \sum\limits_{k=1}^{NB(C)}w_{k}\Delta y_{k}\Delta z_{k} \\
\sum\limits_{k=1}^{NB(C)}w_{k}\Delta z_{k}\Delta x_{k} &amp; \sum\limits_{k=1}^{NB(C)}w_{k}\Delta z_{k}\Delta y_{k} &amp; \sum\limits_{k=1}^{NB(C)}w_{k}\Delta z_{k}\Delta z_{k}
\end{bmatrix}
\begin{bmatrix}
\Big(\cfrac{\partial \phi}{\partial x} \Big)_{C} \\ \Big(\cfrac{\partial \phi}{\partial y} \Big)_{C} \\ \Big(\cfrac{\partial \phi}{\partial z} \Big)_{C}
\end{bmatrix}
=
\begin{bmatrix}
\sum\limits_{k=1}^{NB(C)}w_{k}\Delta x_{k}\Delta\phi_{k} \\
\sum\limits_{k=1}^{NB(C)}w_{k}\Delta y_{k}\Delta\phi_{k} \\
\sum\limits_{k=1}^{NB(C)}w_{k}\Delta z_{k}\Delta\phi_{k}
\end{bmatrix}
\end{align}\end{split}\]</div>
<p>上述方程组的解就是所要的梯度 <span class="math notranslate nohighlight">\((\nabla\phi)_{C}\)</span> 。一个解存在说明上述方程组左侧的系数矩阵不是奇异的。并且，权重因子 <span class="math notranslate nohighlight">\(w_{k}\)</span> 的选择将会影响最后计算出的梯度值。例如，如果所有相邻单元的 <span class="math notranslate nohighlight">\(w_{k}\)</span> 都设置为 <span class="math notranslate nohighlight">\(1\)</span> ，那么所有相邻单元在计算梯度的时候都会有相同的权重，无论它们距离C有多远。实际上，离C更远的点会有更重要的影响，因为误差函数更容易受到它们的误差的影响。</p>
<p>另一种设置 <span class="math notranslate nohighlight">\(w_{k}\)</span> 的方式就是使用CF距离的倒数，即</p>
<div class="math notranslate nohighlight">
\[\begin{align}
w_{k} = \frac{1}{| \mathbf{r}_{F_{k}} - \mathbf{r}_{C} |} = \frac{1}{\sqrt{\Delta x_{F_{x}}^{2} + \Delta y_{F_{k}}^{2} + \Delta z_{F_{k}}^{2}} }
\end{align}\]</div>
<p>也可以为上述距离倒数取上 <span class="math notranslate nohighlight">\(n\)</span> 次幂，即</p>
<div class="math notranslate nohighlight">
\[\begin{align}
w_{k} = \frac{1}{| \mathbf{r}_{F_{k}} - \mathbf{r}_{C} |^{n}} \qquad (n=1,2,3,\cdots)
\end{align}\]</div>
<p>实际上，基于散度的梯度计算方式是最小二乘法的一种特殊情形。这可以通过笛卡尔网格来说明，在这种情况下，最小二乘法所需求解的矩阵化简为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\begin{bmatrix}
x_{E} - x_{W} &amp; 0 &amp; 0 \\
0 &amp; y_{N} - y_{S} &amp; 0 \\
0 &amp; 0 &amp; z_{T} - z_{B}
\end{bmatrix}
\begin{bmatrix}
(\partial \phi / \partial x)_{C} \\
(\partial \phi / \partial y)_{C} \\
(\partial \phi / \partial z)_{C}
\end{bmatrix}
=
\begin{bmatrix}
\phi_{E} - \phi_{W} \\
\phi_{N} - \phi_{S} \\
\phi_{T} - \phi_{B}
\end{bmatrix}
\end{align}\end{split}\]</div>
<p>求解上述方程组，于是可以得到</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\Big(\frac{\partial \phi}{\partial x} \Big)_{C} = \frac{\phi_{E} - \phi_{W}}{x_{E} - x_{W}}
,\quad
\Big(\frac{\partial \phi}{\partial y} \Big)_{C} = \frac{\phi_{N} - \phi_{S}}{y_{N} - y_{S}}
,\quad
\Big(\frac{\partial \phi}{\partial z} \Big)_{C} = \frac{\phi_{T} - \phi_{B}}{z_{T} - z_{B}}
\end{align}\]</div>
<p>上面的结果表明基于散度的梯度是最小二乘法的特殊情形。最后，容易证明计算得到的梯度的精度至少是一阶的。这可以从泰勒展开式中看到：围绕节点C处的值 <span class="math notranslate nohighlight">\(\phi\)</span> 可以写成</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\phi(\mathbf{r}) - \phi(\mathbf{r}_{C}) = (\nabla\phi)_{C} \cdot (\mathbf{r} - \mathbf{r}_{C}) + O(\mathbf{r}^{2})
\end{align}\]</div>
<p>当求解 <span class="math notranslate nohighlight">\((\nabla\phi)_{C}\)</span> 时就有 <span class="math notranslate nohighlight">\(O(\mathbf{r})\)</span> 。</p>
</section>
<section id="id25">
<h3>将梯度插值到网格面<a class="headerlink" href="#id25" title="此标题的永久链接"></a></h3>
<p>前面已经叙述过，在非结构网格中离散扩散项需要添加修正项，而修正项涉及到在网格面上的梯度值。因此，在这种情况下，梯度需要从网格质心处插值到网格面心处。如图所示，网格面上的梯度所涉及到的stencil可以从周围一圈的值等效到只与面相接的stencil。</p>
<figure class="align-center">
<img alt="../_images/梯度插值到网格面涉及的stencil.png" src="../_images/梯度插值到网格面涉及的stencil.png" />
</figure>
<p>如图所示，与网格面相接的网格单元C、F质心处的梯度值分别为 <span class="math notranslate nohighlight">\(\nabla\phi_{C}\)</span> 和 <span class="math notranslate nohighlight">\(\nabla\phi_{F}\)</span> ，插值到面上的梯度 <span class="math notranslate nohighlight">\(\overline{\nabla\phi_{f}}\)</span> 可以通过节点C、F处的值平均得到。取与网格面相接的单元作为stencil非常重要，因为这不能简单地通过平均来保证。除了平均之外，还需要迫使插值到面上的梯度在沿CF方向的值与通过节点CF定义的局部梯度相等，所以有</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\nabla \phi_{f} = \overline{\nabla\phi_{f}} + \Big[ \frac{\phi_{F} - \phi_{C}}{d_{CF}} - (\overline{\nabla\phi_{f}} \cdot \mathbf{e}_{CF}) \Big]\mathbf{e}_{CF}
\end{align}\]</div>
<p>其中</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\overline{\nabla\phi_{f}} = g_{C}\nabla\phi_{C} + g_{F}\nabla\phi_{F}
,\quad
\mathbf{e}_{CF} = \frac{\mathbf{d}_{CF}}{d_{CF}}
,\quad
\mathbf{d}_{CF} = \mathbf{r}_{F} - \mathbf{r}_{C}
\end{align}\]</div>
<p>这个方法在结构化或非结构化网格都适用。对于非结构化网格，虽然用于网格面梯度的stencil可能不会减少，但是网格面梯度的计算仍然将基于横跨该网格面的网格节点。</p>
<figure class="align-center">
<img alt="../_images/插值到网格面上的梯度计算方式.png" src="../_images/插值到网格面上的梯度计算方式.png" />
</figure>
</section>
</section>
<section id="id26">
<h2>对流项的离散化<a class="headerlink" href="#id26" title="此标题的永久链接"></a></h2>
<section id="id27">
<h3>一维稳态对流扩散<a class="headerlink" href="#id27" title="此标题的永久链接"></a></h3>
<p>首先考虑简单的一维稳定对流扩散方程：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\mathrm{d} (\rho u\phi)}{\mathrm{d} x} - \frac{\mathrm{d} }{\mathrm{d} x}\Big( \Gamma^{\phi} \frac{\mathrm{d} \phi}{\mathrm{d} x} \Big) = 0
\end{align}\]</div>
<p>该方程具有解析解，因此可以与各种数值结果进行对比。</p>
<section id="id28">
<h4>解析解<a class="headerlink" href="#id28" title="此标题的永久链接"></a></h4>
<p>对于一维稳态问题，其连续性方程为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\mathrm{d} (\rho u)}{\mathrm{d} x} = 0
\end{align}\]</div>
<p>上式表明 <span class="math notranslate nohighlight">\(\rho u\)</span> 是常数。于是，对一维稳定对流扩散方程的x进行积分得到</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\rho u\phi - \Gamma^{\phi}\frac{\mathrm{d} \phi}{\mathrm{d} x} = c_{1}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(c_{1}\)</span> 是积分常数，它的值与所使用的边界条件有关。整理上式可以得到</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\mathrm{d} \phi}{\mathrm{d} x} = \frac{\rho u}{\Gamma^{\phi}}\phi - \frac{c_{1}}{\Gamma^{\phi}}
\end{align}\]</div>
<p>进行一次变量代换，上式可以改写为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\mathrm{d} \Phi}{\mathrm{d} x} = \frac{\rho u}{\Gamma^{\phi}}\Phi
\end{align}\]</div>
<p>其中</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\Phi = \frac{\rho u}{\Gamma^{\phi}} \phi - \frac{c_{1}}{\Gamma^{\phi}}
\end{align}\]</div>
<p>分离变量并积分，上式的解为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\mathrm{d} \Phi}{\Phi} = \frac{\rho u}{\Gamma^{\phi}}\mathrm{d}x
\quad \Rightarrow \quad
\ln(\Phi) = \frac{\rho u}{\Gamma^{\phi}}x + c_{3}
\quad \Rightarrow \quad
\Phi = c_{2}e^{(\rho u/\Gamma^{\phi})x}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(c_{2}\)</span> 为另一个积分常数。将其代换回原变量，得到通解为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\phi = \frac{c_{2}\Gamma^{\phi}e^{(\rho u/\Gamma^{\phi})x} + c_{1}}{\rho u}
\end{align}\]</div>
<p>因此，W和E两点之间的解析解如图所示，且满足</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\phi - \phi_{W}}{\phi_{E} - \phi_{W}} = \frac{\exp(Pe_{L}\cfrac{x - x_{W}}{L}) - 1}{\exp(Pe_{L}) - 1}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(Pe_{L}\)</span> 是基于长度 <span class="math notranslate nohighlight">\(L\)</span> 的Péclet数，它表示对流输运率和扩散输运率的比值，定义为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
Pe_{L} = \frac{\rho u L}{\Gamma^{\phi}} \qquad(L = x_{E} - x_{W})
\end{align}\]</div>
<p>对不同的 <span class="math notranslate nohighlight">\(Pe_{L}\)</span> 值计算上式，结果如图所示，可以看到，W和E之间的变化从纯扩散问题的线性轮廓变成了高 <span class="math notranslate nohighlight">\(Pe_{L}\)</span> 数时的阶梯形轮廓。</p>
<figure class="align-center">
<img alt="../_images/一维稳态对流扩散问题.png" src="../_images/一维稳态对流扩散问题.png" />
</figure>
</section>
<section id="id29">
<h4>数值解<a class="headerlink" href="#id29" title="此标题的永久链接"></a></h4>
<p>对一维稳态对流扩散方程的离散可以从对一维单元积分得到，即</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\int_{V_{c}}[\nabla \cdot (\rho\mathbf{U}\phi) - \nabla\cdot (\Gamma^{\phi}\nabla\phi)]~\mathrm{d}V = 0
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\mathbf{U} = u\mathbf{i}\)</span> 是速度矢量。对流方程可以写成对流通量与扩散通量的形式，即</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\int_{V_{c}}\nabla \cdot (\mathbf{J}^{\phi,C} + \mathbf{J}^{\phi,D})~\mathrm{d}V = 0
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\mathbf{J}^{\phi,C} = \rho\mathbf{U}\phi\)</span> ， <span class="math notranslate nohighlight">\(\mathbf{J}^{\phi,D} = -\Gamma^{\phi}\nabla\phi\)</span> 。于是，根据散度定理，体积积分可以转换为表面积分，即</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\int_{V_{c}}\nabla \cdot (\mathbf{J}^{\phi,C} + \mathbf{J}^{\phi,D})~\mathrm{d}V
= \int_{\partial V_{c}}(\mathbf{J}^{\phi,C} + \mathbf{J}^{\phi,D})\cdot \mathrm{d}\mathbf{S}
= \int_{\partial V_{c}}\Big[ \rho u\phi\mathbf{i} - \Gamma^{\phi}\frac{\mathrm{d}\phi}{\mathrm{d}x}\mathbf{i} \Big] \cdot \mathrm{d}\mathbf{S}
= 0
\end{align}\]</div>
<p>将表面积分替换为网格表面的通量求和，上式就变成了</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\sum_{f\sim nb(C)}\Big( \rho u\phi\mathbf{i} - \Gamma^{\phi}\frac{\mathrm{d}\phi}{\mathrm{d}x}\mathbf{i}\Big)_{f} \cdot \mathbf{S}_{f} = 0
\end{align}\]</div>
<p>注意到网格表面的速度矢量在单元的不同侧会反号，那么上式对于一个固定截面的情况下可以展开成下面的形式：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\Big[ (\rho u\Delta y\phi)_{e} - \Big( \Gamma^{\phi}\frac{\mathrm{d} \phi}{\mathrm{d} x}\Delta y \Big)_{e} \Big]
- \Big[ (\rho u\Delta y\phi)_{w} - \Big( \Gamma^{\phi}\frac{\mathrm{d} \phi}{\mathrm{d} x}\Delta y \Big)_{w} \Big]
= 0
\end{align}\]</div>
<p><span class="math notranslate nohighlight">\(u\)</span> 在网格面上的值是已知的，并且梯度可以用前面叙述的方法进行离散。问题是，如何根据相邻节点的值离散网格面的值 <span class="math notranslate nohighlight">\(\phi_{e}\)</span> 和 <span class="math notranslate nohighlight">\(\phi_{w}\)</span> 。用来确定这些网格面上的值的方法称为“对流格式”。</p>
</section>
<section id="id30">
<h4>初步推导：中心差分格式<a class="headerlink" href="#id30" title="此标题的永久链接"></a></h4>
<p>一个很直接的想法就是使用与扩散项类似的线性插值方法。因此，在给定网格面上的值 <span class="math notranslate nohighlight">\(\phi\)</span> 就可以如下计算：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\phi(x) = k_{0} + k_{1}(x - x_{C})
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(k_{0}\)</span> 和 <span class="math notranslate nohighlight">\(k_{1}\)</span> 是通过网格面相邻网格节点得到的常数。因此，对于网格面 <span class="math notranslate nohighlight">\(e\)</span> ，根据 <span class="math notranslate nohighlight">\(x=x_{E}\)</span> 处满足 <span class="math notranslate nohighlight">\(\phi=\phi_{E}\)</span> 以及 <span class="math notranslate nohighlight">\(x=x_{C}\)</span> 处满足 <span class="math notranslate nohighlight">\(\phi=\phi_{C}\)</span> 的条件，由上式分析 <span class="math notranslate nohighlight">\(x=x_{e}\)</span> 处的值得到</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\phi_{e} = \phi_{C} + \frac{\phi_{E} - \phi_{C}}{x_{E} - x_{C}}(x_{e} - x_{C})
\end{align}\]</div>
<p>这就是基本的中心差分格式，它可以通过泰勒二阶展开式得到，也就意味着它具有二阶精度。对于如图所示的均一网格，上式可以化简为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\phi_{e} = \frac{\phi_{C} + \phi_{E}}{2}
\end{align}\]</div>
<figure class="align-center">
<img alt="../_images/中心差分格式.png" src="../_images/中心差分格式.png" />
</figure>
<p>因此，在经过上述的线性方式离散扩散项之后，那么方程第一项就可以写成</p>
<div class="math notranslate nohighlight">
\[\begin{align}
(\rho u\Delta y\phi)_{e} - \Big( \Gamma^{\phi}\frac{\mathrm{d} \phi}{\mathrm{d} x}\Delta y \Big)_{e}
= (\rho u\Delta y)_{e}\frac{\phi_{E} + \phi_{C}}{2} - \Big( \Gamma^{\phi}\frac{\Delta y}{\delta x} \Big)_{e} (\phi_{E} - \phi_{C})
= \text{FluxC}_{e}\phi_{C} + \text{FluxF}_{e}\phi_{E} + \text{FluxV}_{e}
\end{align}\]</div>
<p>其中</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\text{FluxC}_{e} = \Gamma^{\phi}_{e}\frac{\Delta y_{e}}{\delta x_{e}} + \frac{(\rho u\Delta y)_{e}}{2}
,\quad
\text{FluxF}_{e} = -\Gamma^{\phi}_{e}\frac{\Delta y_{e}}{\delta x_{e}} + \frac{(\rho u\Delta y)_{e}}{2}
,\quad
\text{FluxV}_{e} = 0
\end{align}\]</div>
<p>类似的，方程的第二项可以写成</p>
<div class="math notranslate nohighlight">
\[\begin{align}
- \Big[ (\rho u\Delta y\phi)_{w} - \Big( \Gamma^{\phi}\frac{\mathrm{d} \phi}{\mathrm{d} x}\Delta y \Big)_{w} \Big]
= - \Big[ (\rho u\Delta y)_{w}\frac{\phi_{W} + \phi_{C}}{2} - \Big( \Gamma^{\phi}\frac{\Delta y}{\delta x} \Big)_{w}(\phi_{C} - \phi_{W}) \Big]
= \text{FluxC}_{w}\phi_{C} + \text{FluxF}_{w}\phi_{W} + \text{FluxV}_{w}
\end{align}\]</div>
<p>其中</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\text{FluxC}_{w} = \Gamma^{\phi}_{w}\frac{\Delta y_{w}}{\delta x_{w}} - \frac{(\rho u\Delta y)_{w}}{2}
,\quad
\text{FluxF}_{w} = -\Gamma^{\phi}_{w}\frac{\Delta y_{w}}{\delta x_{w}} - \frac{(\rho u\Delta y)_{w}}{2}
,\quad
\text{FluxV}_{w} = 0
\end{align}\]</div>
<p>将上述方程全部代入到对流扩散方程中，得到</p>
<div class="math notranslate nohighlight">
\[\begin{align}
a_{C}\phi_{C} + a_{E}\phi_{E} + a_{W}\phi_{W} = 0
\end{align}\]</div>
<p>其中</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; a_{E} = \text{FluxF}_{e} = -\Gamma^{\phi}_{e}\frac{\Delta y_{e}}{\delta x_{e}} + \frac{(\rho u\Delta y)_{e}}{2} \\
&amp; a_{W} = \text{FluxF}_{w} = -\Gamma^{\phi}_{w}\frac{\Delta y_{w}}{\delta x_{w}} - \frac{(\rho u\Delta y)_{w}}{2} \\
&amp; a_{C} = \text{FluxC}_{e} + \text{FluxC}_{w} = \Big( \frac{(\rho u\Delta y)_{e}}{2} + \Gamma^{\phi}_{e}\frac{\Delta y_{e}}{\delta x_{e}} \Big) + \Big( -\frac{(\rho u\Delta y)_{w}}{2} + \Gamma^{\phi}_{w}\frac{\Delta y_{w}}{\delta x_{w}}\Big)
\end{align}\end{split}\]</div>
<p>在这个一维问题中 <span class="math notranslate nohighlight">\(\Delta y_{e} = \Delta y_{w}\)</span> ，并且不失一般性地可以设为 <span class="math notranslate nohighlight">\(1\)</span> 。同时，根据连续性方程可知 <span class="math notranslate nohighlight">\((\rho u\Delta y)_{e} - (\rho u\Delta y)_{w} = 0\)</span> 。假设扩散系数是均一的，那么上面的离散方程系数就可以简化为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; a_{E} = - \frac{\Gamma^{\phi}}{x_{E} - x_{C}} + \frac{(\rho u)_{e}}{2} \\
&amp; a_{W} = - \frac{\Gamma^{\phi}}{x_{C} - x_{W}} - \frac{(\rho u)_{w}}{2} \\
&amp; a_{C} = - (a_{E} + a_{W})
\end{align}\end{split}\]</div>
<p>将上述系数代入到离散方程当中，那么 <span class="math notranslate nohighlight">\(\phi_{C}\)</span> 的值满足</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\phi_{C} - \phi_{W}}{\phi_{E} - \phi_{W}} = \frac{a_{E}}{a_{E} + a_{W}}
\end{align}\]</div>
<p>如果网格是均一的，那么上述方程可以写成关于 <span class="math notranslate nohighlight">\(Pe_{L}\)</span> 的形式：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\phi_{C} - \phi_{W}}{\phi_{E} - \phi_{W}} = \frac{1}{2}\Big(1 - \frac{Pe_{L}}{2}\Big)
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(L\)</span> 是 <span class="math notranslate nohighlight">\((x_{E} - x_{W})\)</span> ，也就是两个单元的大小。</p>
<p>这个问题的解析解可以通过令 <span class="math notranslate nohighlight">\((x-x_{W})/L=0.5\)</span> 得到：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\phi_{C} - \phi_{W}}{\phi_{E} - \phi_{W}} = \frac{e^{Pe_{L}/2} - 1}{e^{Pe_{L}}-1}
\end{align}\]</div>
<p>如图所示，中心差分数值解与解析解在 <span class="math notranslate nohighlight">\(Pe_{L}\)</span> 值较低的时候非常接近，但是当 <span class="math notranslate nohighlight">\(Pe_{L}\)</span> 增大到一定值之后，中心差分格式的数值解就与解析解的结果有相当的差距而变得非物理。</p>
<figure class="align-center">
<img alt="../_images/中心差分数值解与解析解的对比.png" src="../_images/中心差分数值解与解析解的对比.png" />
</figure>
<p>这个非物理现象意味着中心差分格式在推导的时候存在非物理的假设。如图所示，C点的扩散过程对C点上游和下游条件的影响相同，而对流过程是一个高度定向的过程，仅仅在流动方向上传递特性。因此，对迎风和顺风节点赋予相同的权重的线性近似，在扩散项处理中是非常好的；但是，它不能描述处对流的方向偏好，对于对流项，阶跃方法更加合适，这就是原因所在。</p>
<p>因此，只要扩散过程是主要的传递机制，使用线性方法就能够得到符合物理的结果。但是，一旦对流过程压倒扩散过程，仍使用线性方法就会得到非物理结果。容易计算出发生这种情况的Péclet数的值——假设流动为x正方向，当系数 <span class="math notranslate nohighlight">\(a_{E}\)</span> 为正的时候就会导致非物理结果（如果流动为x负方向则考虑 <span class="math notranslate nohighlight">\(a_{W}\)</span> ）：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
- \Gamma^{\phi}_{e} \frac{\Delta y_{e}}{\delta x_{e}} + \frac{(\rho u\Delta y)_{e}}{2} &gt; 0
\quad \Rightarrow \quad
\frac{(\rho u)_{e}\delta x_{e}}{\Gamma^{\phi}_{e}} &gt; 2
\end{align}\]</div>
<p>定义网格的Péclet数为 <span class="math notranslate nohighlight">\(Pe = \frac{\rho u\delta x}{\Gamma^{\phi}}\)</span> ，其中对于均一网格来说就等于 <span class="math notranslate nohighlight">\(Pe_{L}\)</span> 的一般，于是上述条件就可以改写成</p>
<div class="math notranslate nohighlight">
\[\begin{align}
Pe &gt; 2
\end{align}\]</div>
<p>因此，对于网格Péclet数大于 <span class="math notranslate nohighlight">\(2\)</span> 的情况，离散化过程变得不再一致，因为现在相邻值的增加C处值的减小，而这反过来又将导致相邻值进一步增大，并且误差被放大。这个问题可以通过减小网格的大小来是单元Péclet数小于 <span class="math notranslate nohighlight">\(2\)</span> 来避免，然而对于许多实际情况，存储和计算需求的增加可能太大而无法承担。此外，对于纯对流流动（如欧拉流），则是根本不可行的，所以需要其他措施。</p>
</section>
<section id="id31">
<h4>迎风格式<a class="headerlink" href="#id31" title="此标题的永久链接"></a></h4>
<p>线性对称方法给两个节点提供了相同的权重，在网格面上没有方向偏重，这适用于无方向性现象的椭圆型项（如扩散项），但对于对流项来说是不合适的。一种更适合对流过程的格式是迎风格式。如图所示，迎风格式基本上模拟了对流过程的基本物理过程，因为网格表面值依赖于迎风节点值，即依赖于流动方向。在这个情况下，网格面上的值如下得到：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\phi_{e} = \left\{\begin{array}{ll}\phi_{C} \quad \text{if}~\dot{m}_{e}&gt;0 \\ \phi_{E} \quad \text{if}~\dot{m}_{e}&lt;0 \end{array}\right.
,\quad
\phi_{w} = \left\{\begin{array}{ll}\phi_{C} \quad \text{if}~\dot{m}_{e}&gt;0 \\ \phi_{W} \quad \text{if}~\dot{m}_{e}&lt;0 \end{array}\right.
\end{align}\end{split}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\dot{m}_{e}\)</span> 和 <span class="math notranslate nohighlight">\(\dot{m}_{w}\)</span> 分别是在网格面 <span class="math notranslate nohighlight">\(e\)</span> 和 <span class="math notranslate nohighlight">\(w\)</span> 的质量通量：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; \dot{m}_{e} = (\rho\mathbf{U}\cdot \mathbf{S})_{e} = (\rho uS)_{e} = (\rho u \Delta y)_{e} \\
&amp; \dot{m}_{w} = (\rho\mathbf{U}\cdot \mathbf{S})_{w} = -(\rho uS)_{w} = -(\rho u\Delta y)_{w}
\end{align}\end{split}\]</div>
<figure class="align-center">
<img alt="../_images/一阶迎风格式.png" src="../_images/一阶迎风格式.png" />
</figure>
<p>因此，在网格面 <span class="math notranslate nohighlight">\(e\)</span> 的对流通量可以写成</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\dot{m}_{e}\phi_{e} = \max(\dot{m}_{e}, 0)\phi_{C} - \max(-\dot{m}_{e}, 0)\phi_{E}
= \text{FluxC}_{e}^{Conv}\phi_{C} + \text{FluxF}_{e}^{Conv}\phi_{E} + \text{FluxV}_{e}^{Conv}
\end{align}\]</div>
<p>其中</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\text{FluxC}_{e}^{Conv} = \max(\dot{m}_{e}, 0)
,\quad
\text{FluxF}_{e}^{Conv} = -\max(-\dot{m}_{e}, 0)
,\quad
\text{FluxV}_{e}^{Conv} = 0
\end{align}\]</div>
<p>类似地，可以得到在网格面 <span class="math notranslate nohighlight">\(w\)</span> 的对流通量可以写成</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\dot{m}_{w}\phi_{w} = \max(\dot{m}_{w}, 0)\phi_{C} - \max(-\dot{m}_{w}, 0)\phi_{W}
= \text{FluxC}_{w}^{Conv}\phi_{C} + \text{FluxF}_{w}^{Conv}\phi_{W} + \text{FluxV}_{w}^{Conv}
\end{align}\]</div>
<p>其中</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\text{FluxC}_{w}^{Conv} = \max(\dot{m}_{w}, 0)
,\quad
\text{FluxF}_{w}^{Conv} = -\max(-\dot{m}_{w}, 0)
,\quad
\text{FluxV}_{w}^{Conv} = 0
\end{align}\]</div>
<p>同时考虑扩散通量的贡献（以上标Diff表示），将它们全部代入离散方程当中得到</p>
<div class="math notranslate nohighlight">
\[\begin{align}
(\text{FluxC}_{e}^{Conv} + \text{FluxC}_{e}^{Diff} + \text{FluxC}_{w}^{Conv} + \text{FluxC}_{w}^{Diff})\phi_{C}
+ (\text{FluxF}_{e}^{Conv} + \text{FluxF}_{e}^{Diff})\phi_{E}
+ (\text{FluxF}_{w}^{Conv} + \text{FluxF}_{w}^{Diff})\phi_{W}
= 0
\end{align}\]</div>
<p>上式可以整合为下面的形式：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
a_{C}\phi_{C} + a_{E}\phi_{E} + a_{W}\phi_{W} = 0
\end{align}\]</div>
<p>其中</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; a_{E} = \text{FluxF}_{e}^{Conv} + \text{FluxF}_{e}^{Diff} = -\max(-\dot{m}_{e}, 0) - \Gamma^{\phi}_{e}\frac{S_{e}}{\delta x_{e}} \\
&amp; a_{W} = \text{FluxF}_{w}^{Conv} + \text{FluxF}_{w}^{Diff} = -\max(-\dot{m}_{w}, 0) - \Gamma^{\phi}_{w}\frac{S_{w}}{\delta x_{w}} \\
&amp; a_{C} = \sum_{f}\Big( \text{FluxC}_{f}^{Conv} + \text{FluxC}_{f}^{Diff} \Big)
= \max(\dot{m}_{e}, 0) + \max(\dot{m}_{w}, 0) + \Gamma^{\phi}_{e}\frac{S_{e}}{\delta x_{e}} + \Gamma^{\phi}_{w}\frac{S_{w}}{\delta x_{w}}
= - (a_{E} + a_{W}) + (\dot{m}_{e} + \dot{m}_{w}) \\
&amp; b_{C} = - \sum_{f} \Big( \text{FluxV}_{f}^{Conv} + \text{FluxV}_{f}^{Diff} \Big) = 0
\end{align}\end{split}\]</div>
<p>容易发现，迎风格式能够得到负的相邻单元系数，并且根据连续性方程，可以得到主要节点的系数满足</p>
<div class="math notranslate nohighlight">
\[\begin{align}
a_{C} = -(a_{W} + a_{E})
\end{align}\]</div>
<p>这就保证了有界条件。将连续性约束代入到系数表达式，并考虑均一网格、扩散系数为常数，那么</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\phi_{C} - \phi_{W}}{\phi_{E} - \phi_{W}}
= \frac{2 + \max(-Pe_{L}, 0)}{4 + \max(-Pe_{L}, 0) + \max(Pe_{L}, 0)}
= \frac{2 + \max(-Pe_{L}, 0)}{4 + |Pe_{L}|}
\end{align}\]</div>
<p>如图所示，在 <span class="math notranslate nohighlight">\(Pe_{L}\)</span> 值较低的时候，迎风格式没有中心差分格式那么精确，这也是可以理解的，因为迎风格式只有一阶精度而线性格式有二阶精度。当 <span class="math notranslate nohighlight">\(Pe_{L}\)</span> 值较高时，中心差分格式不再稳定，因为它的解无界且非物理；而迎风格式虽然不是很精确，但物理趋势是正确的。因此，准确性和稳定性之间存在一种权衡。使用迎风格式能在较高Péclet数的情况下仍有良好的表现与有界性，但是这是牺牲精度来实现的。另一方面，二阶中心差分格式在超过一定Péclet数后变得不稳定，从而导致物理上错误的解。</p>
<figure class="align-center">
<img alt="../_images/迎风格式与解析解的对比.png" src="../_images/迎风格式与解析解的对比.png" />
</figure>
</section>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="%E6%B5%81%E4%BD%93%E5%8A%9B%E5%AD%A6.html" class="btn btn-neutral float-left" title="流体力学" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="AutoCAD.html" class="btn btn-neutral float-right" title="AutoCAD" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2022-2023, Koishi.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a>开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
