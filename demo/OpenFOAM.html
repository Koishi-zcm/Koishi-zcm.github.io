<!DOCTYPE html>
<html class="writer-html4" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>OpenFOAM &mdash; MyKnowledge MyKnowledge 文档</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
        <script async="async" type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="OpenFOAM算例运行案例" href="OpenFOAM算例运行案例.html" />
    <link rel="prev" title="Linux" href="Linux.html" />
    <link href="../_static/style.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            MyKnowledge
          </a>
              <div class="version">
                1.01
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="微积分.html">微积分</a></li>
<li class="toctree-l1"><a class="reference internal" href="线性代数.html">线性代数</a></li>
<li class="toctree-l1"><a class="reference internal" href="复变函数.html">复变函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="电路原理.html">电路原理</a></li>
<li class="toctree-l1"><a class="reference internal" href="数字电路.html">数字电路</a></li>
<li class="toctree-l1"><a class="reference internal" href="模拟电路.html">模拟电路</a></li>
<li class="toctree-l1"><a class="reference internal" href="数值分析与算法.html">数值分析与算法</a></li>
<li class="toctree-l1"><a class="reference internal" href="数理方程.html">数理方程</a></li>
<li class="toctree-l1"><a class="reference internal" href="流体力学.html">流体力学</a></li>
<li class="toctree-l1"><a class="reference internal" href="计算流体力学有限体积法.html">计算流体力学有限体积法</a></li>
<li class="toctree-l1"><a class="reference internal" href="AutoCAD.html">AutoCAD</a></li>
<li class="toctree-l1"><a class="reference internal" href="C++.html">C++</a></li>
<li class="toctree-l1"><a class="reference internal" href="Latex.html">Latex</a></li>
<li class="toctree-l1"><a class="reference internal" href="Linux.html">Linux</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">OpenFOAM</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">网格生成</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#blockmesh">blockMesh</a></li>
<li class="toctree-l3"><a class="reference internal" href="#snappyhexmesh">snappyHexMesh</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id2">生成背景网格</a></li>
<li class="toctree-l4"><a class="reference internal" href="#surfacefeaturesdict">surfaceFeaturesDict</a></li>
<li class="toctree-l4"><a class="reference internal" href="#meshqualitydict">meshQualityDict</a></li>
<li class="toctree-l4"><a class="reference internal" href="#snappyhexmeshdict">snappyHexMeshDict</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id3">snappyHexMeshDict模板</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id4">网格检查</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id5">残差监控</a></li>
<li class="toctree-l2"><a class="reference internal" href="#physicalproperties">physicalProperties文件</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">热物理模型</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#thermotype">thermoType</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#hethermo">heThermo</a></li>
<li class="toctree-l4"><a class="reference internal" href="#psithermo">psiThermo</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#type">type</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#hepsithermo">hePsiThermo</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#mixture">mixture</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#puremixture">pureMixture</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#transport">transport</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#const">const</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#thermo">thermo</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#hconst">hConst</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#equationofstate">equationOfState</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#perfectgas">perfectGas</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#specie">specie</a></li>
<li class="toctree-l3"><a class="reference internal" href="#energy">energy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#sensibleenthalpy">sensibleEnthalpy</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sensibleinternalenergy">sensibleInternalEnergy</a></li>
<li class="toctree-l4"><a class="reference internal" href="#absoluteenthalpy">absoluteEnthalpy</a></li>
<li class="toctree-l4"><a class="reference internal" href="#absoluteinternalenergy">absoluteInternalEnergy</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#thermophysicaltransport">ThermophysicalTransport</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id7">场设置</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id8">边界条件</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id10">通用边界条件</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#fixedvalue">fixedValue</a></li>
<li class="toctree-l4"><a class="reference internal" href="#zerogradient">zeroGradient</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fixedgradient">fixedGradient</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mixed">mixed</a></li>
<li class="toctree-l4"><a class="reference internal" href="#directionmixed">directionMixed</a></li>
<li class="toctree-l4"><a class="reference internal" href="#basicsymmetry">basicSymmetry</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inletoutlet">inletOutlet</a></li>
<li class="toctree-l4"><a class="reference internal" href="#freestream">freestream</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id11">速度边界条件</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#noslip">noSlip</a></li>
<li class="toctree-l4"><a class="reference internal" href="#partialslip">partialSlip</a></li>
<li class="toctree-l4"><a class="reference internal" href="#slip">slip</a></li>
<li class="toctree-l4"><a class="reference internal" href="#freestreamvelocity">freestreamVelocity</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pressureinletvelocity">pressureInletVelocity</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pressureinletuniformvelocity">pressureInletUniformVelocity</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pressuredirectedinletvelocity">pressureDirectedInletVelocity</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pressureinletoutletvelocity">pressureInletOutletVelocity</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pressuredirectedinletoutletvelocity">pressureDirectedInletOutletVelocity</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id12">压强边界条件</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pressure">pressure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#freestreampressure">freestreamPressure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dynamicpressure">dynamicPressure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#totalpressure">totalPressure</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id13">温度边界条件</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#totaltemperature">totalTemperature</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id14">无反射边界条件</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#advective">advective</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wavetransmissive">waveTransmissive</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id16">自定义边界条件</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#codedfixedvalue">codedFixedValue</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id17">壁面函数</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id18">壁面函数的推导</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id19">壁面函数代码解读</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#nutwallfunction">nutWallFunction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kqrwallfunction">kqRWallFunction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#klowrewallfunction">kLowReWallFunction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#v2wallfunction">v2WallFunction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fwallfunction">fWallFunction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#epsilonwallfunction">epsilonWallFunction</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id20">湍流模型</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#laminar">laminar模型</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ras">RAS模型</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#kepsilon">kEpsilon</a></li>
<li class="toctree-l4"><a class="reference internal" href="#komega">kOmega</a></li>
<li class="toctree-l4"><a class="reference internal" href="#komegasst">kOmegaSST</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#fvshemes">fvShemes离散格式设置</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#interpolationschemes">插值格式interpolationSchemes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#linear">linear</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cubic">cubic</a></li>
<li class="toctree-l4"><a class="reference internal" href="#downwind">downwind</a></li>
<li class="toctree-l4"><a class="reference internal" href="#upwind">upwind</a></li>
<li class="toctree-l4"><a class="reference internal" href="#linearupwind">linearUpwind</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nvd-tvd">NVD/TVD格式</a></li>
<li class="toctree-l4"><a class="reference internal" href="#minmod">Minmod</a></li>
<li class="toctree-l4"><a class="reference internal" href="#vanleer">vanLeer</a></li>
<li class="toctree-l4"><a class="reference internal" href="#muscl">MUSCL</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ospre">OSPRE</a></li>
<li class="toctree-l4"><a class="reference internal" href="#quick">QUICK</a></li>
<li class="toctree-l4"><a class="reference internal" href="#umist">UMIST</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#sngradschemes">面法向梯度格式snGradSchemes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ddtschemes">时间一阶导项格式ddtSchemes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#backward">backward</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cranknicolson">CrankNicolson</a></li>
<li class="toctree-l4"><a class="reference internal" href="#euler">Euler</a></li>
<li class="toctree-l4"><a class="reference internal" href="#slts">SLTS</a></li>
<li class="toctree-l4"><a class="reference internal" href="#steadystate">steadyState</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#d2dt2schemes">时间二阶导项格式d2dt2Schemes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#gradschemes">梯度项格式gradSchemes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#divschemes">散度项格式divSchemes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#laplacianschemes">拉普拉斯项格式laplacianSchemes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fluxrequired">需要计算通量的场fluxRequired</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#fvsolution">fvSolution代数方程组求解设置</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#solvers">solvers设置</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id22">耦合算法设置</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id23">欠松弛处理设置</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#controldict">controlDict设置</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id24">常规设置</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id25">运行时加载库或者函数控制</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id26">后处理</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#postprocess">postProcess</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#age">age</a></li>
<li class="toctree-l4"><a class="reference internal" href="#courantno">CourantNo</a></li>
<li class="toctree-l4"><a class="reference internal" href="#machno">MachNo</a></li>
<li class="toctree-l4"><a class="reference internal" href="#forces">forces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#forcecoeffs">forceCoeffs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#lambda2">Lambda2</a></li>
<li class="toctree-l4"><a class="reference internal" href="#q">Q</a></li>
<li class="toctree-l4"><a class="reference internal" href="#yplus">yPlus</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id27">场计算</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id28">流率计算</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id29">提取制图</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id30">拉格朗日数据</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id31">监控极值</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id32">数据格式</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id33">压力工具</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id34">探针</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id35">外挂求解器</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id36">可视化工具</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#paraview">ParaView</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id37">画截面上的流线</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id38">运算函数定义</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id39">张量运算符</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id40">求解器代码解读</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id41">文件信息读取</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id42">源项处理策略</a></li>
<li class="toctree-l3"><a class="reference internal" href="#laplacianfoam">laplacianFoam求解器</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#laplacianfoamcreatefields-h">laplacianFoam的createFields.H</a></li>
<li class="toctree-l4"><a class="reference internal" href="#laplacianfoam-c">laplacianFoam.C</a></li>
<li class="toctree-l4"><a class="reference internal" href="#laplacianfoamwrite-h">laplacianFoam的write.H</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#scalartransportfoam">scalarTransportFoam求解器</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#scalartransportfoamcreatefields-h">scalarTransportFoam的createFields.H</a></li>
<li class="toctree-l4"><a class="reference internal" href="#scalartransportfoam-c">scalarTransportFoam.C</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#potentialfoam">potentialFoam求解器</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#potentialfoamcreatefields-h">potentialFoam的createFields.H</a></li>
<li class="toctree-l4"><a class="reference internal" href="#potentialfoam-c">potentialFoam.C</a></li>
<li class="toctree-l4"><a class="reference internal" href="#potentialfoamcreatecontrols-h">potentialFoam的createControls.H</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#icofoam">icoFoam求解器</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#icofoamcreatefields-h">icoFoam的createFields.H</a></li>
<li class="toctree-l4"><a class="reference internal" href="#icofoam-c">icoFoam.C</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#pisofoam">pisoFoam求解器</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pisofoamcreatefields-h">pisoFoam的createFields.H</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pisofoam-c">pisoFoam.C</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pisofoamueqn-h">pisoFoam的UEqn.H</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pisofoampeqn-h">pisoFoam的pEqn.H</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#rhopimplefoam">rhoPimpleFoam求解器</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#rhopimplefoamcreatefields-h">rhoPimpleFoam的createFields.H</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rhopimplefoam-c">rhoPimpleFoam.C</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rhopimplefoamueqn-h">rhoPimpleFoam的UEqn.H</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rhopimplefoameeqn-h">rhoPimpleFoam的EEqn.H</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rhopimplefoampeqn-h">rhoPimpleFoam的pEqn.H</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#rhosimplefoam">rhoSimpleFoam求解器</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#rhosimplefoamcreatefields-h">rhoSimpleFoam的createFields.H</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rhosimplefoam-c">rhoSimpleFoam.C</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rhosimplefoamueqn-h">rhoSimpleFoam的UEqn.H</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rhosimplefoameeqn-h">rhoSimpleFoam的EEqn.H</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rhosimplefoampeqn-h">rhoSimpleFoam的pEqn.H</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#rhocentralfoam">rhoCentralFoam求解器</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#rhocentralfoamdirectioninterpolate-h">rhoCentralFoam的directionInterpolate.H</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rhocentralfoamcreatefields-h">rhoCentralFoam的createFields.H</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rhocentralfoamcreatefieldrefs-h">rhoCentralFoam的createFieldRefs.H</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rhocentralfoamreadfluxscheme-h">rhoCentralFoam的readFluxScheme.H</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rhocentralfoamresetdeltat-h">rhoCentralFoam的resetDeltaT.H</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rhocentralfoamcentralcourantno-h">rhoCentralFoam的CentralCourantNo.H</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rhocentralfoamsetrdeltat-h">rhoCentralFoam的setRDeltaT.H</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rhocentralfoam-c">rhoCentralFoam.C</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id44">rhoCentralFoam的设置方法</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#interfoam">interFoam求解器</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#interfoam-c">interFoam.C</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interfoamueqn-h">interFoam的UEqn.H</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interfoampeqn-h">interFoam的pEqn.H</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id45">自定义求解器</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#passivescalarfoam">passiveScalarFoam</a></li>
<li class="toctree-l3"><a class="reference internal" href="#teminterfoam">temInterFoam</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rhosonicfoam">rhoSonicFoam</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rhosonicturbfoam">rhoSonicTurbFoam</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dbns">dbns</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#dbnsfoam">dbnsFoam</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dbnsturbfoam">dbnsTurbFoam</a></li>
<li class="toctree-l4"><a class="reference internal" href="#include">include</a></li>
<li class="toctree-l4"><a class="reference internal" href="#numericflux">numericFlux</a></li>
<li class="toctree-l4"><a class="reference internal" href="#betaflux">betaFlux</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hllcflux">hllcFlux</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hllcaleflux">hllcALEFlux</a></li>
<li class="toctree-l4"><a class="reference internal" href="#roeflux">roeFlux</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rusanovflux">rusanovFlux</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mdlimiter">MDLimiter</a></li>
<li class="toctree-l4"><a class="reference internal" href="#firstorderlimiter">firstOrderLimiter</a></li>
<li class="toctree-l4"><a class="reference internal" href="#barthjespersenlimiter">BarthJespersenLimiter</a></li>
<li class="toctree-l4"><a class="reference internal" href="#venkatakrishnanlimiter">VenkatakrishnanLimiter</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="OpenFOAM算例运行案例.html">OpenFOAM算例运行案例</a></li>
<li class="toctree-l1"><a class="reference internal" href="Python.html">Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="Salome.html">Salome</a></li>
<li class="toctree-l1"><a class="reference internal" href="Solidworks.html">Solidworks</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">MyKnowledge</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">OpenFOAM</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/demo/OpenFOAM.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="openfoam">
<h1>OpenFOAM<a class="headerlink" href="#openfoam" title="永久链接至标题">¶</a></h1>
<div class="section" id="id1">
<h2>网格生成<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<div class="section" id="blockmesh">
<h3>blockMesh<a class="headerlink" href="#blockmesh" title="永久链接至标题">¶</a></h3>
<p>blockMesh能够创建具有分级和弯曲边缘的参数网格，其运行根据式位于 <code class="code docutils literal notranslate"><span class="pre">constant/polyMesh</span></code> 文件中的 <code class="code docutils literal notranslate"><span class="pre">blockMeshDict</span></code> 字典文件。 <code class="code docutils literal notranslate"><span class="pre">blockMeshDict</span></code> 文件的包含的关键词如下所示：</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="22%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">关键词</th>
<th class="head">含义</th>
<th class="head">例子</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">convertToMeters</span></code></td>
<td>顶点坐标的放缩比例</td>
<td>取0.01时长度单位为毫米</td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">vertices</span></code></td>
<td>顶点坐标集合</td>
<td>原点坐标为 <code class="code docutils literal notranslate"><span class="pre">(0</span> <span class="pre">0</span> <span class="pre">0)</span></code></td>
</tr>
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">edges</span></code></td>
<td>用来指定圆弧或样条曲线边缘</td>
<td>用两个顶点标签和中间经过点坐标指定圆弧 <code class="code docutils literal notranslate"><span class="pre">arc</span> <span class="pre">1</span> <span class="pre">4</span> <span class="pre">(0.939</span> <span class="pre">0.342</span> <span class="pre">-0.5)</span></code></td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">block</span></code></td>
<td>顶点标签集合和网格大小</td>
<td><code class="code docutils literal notranslate"><span class="pre">hex</span> <span class="pre">(0</span> <span class="pre">1</span> <span class="pre">2</span> <span class="pre">3</span> <span class="pre">4</span> <span class="pre">5</span> <span class="pre">6</span> <span class="pre">7)</span> <span class="pre">(10</span> <span class="pre">10</span> <span class="pre">1)</span> <span class="pre">simpleGrading</span> <span class="pre">(1</span> <span class="pre">1</span> <span class="pre">1)</span></code></td>
</tr>
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">patches</span></code></td>
<td>面的集合</td>
<td><code class="code docutils literal notranslate"><span class="pre">symmetryPlan</span> <span class="pre">base</span> <span class="pre">(</span> <span class="pre">(0</span> <span class="pre">1</span> <span class="pre">2</span> <span class="pre">3)</span> <span class="pre">)</span></code></td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">mergePatchPairs</span></code></td>
<td>合并的面的集合</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>顶点的描述是按照坐标点列表的方式进行的，从上往下依次表示顶点标签的递增，例如下面是一个block的顶点集合表示方式：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">vertices</span>
<span class="p">(</span>
        <span class="p">(</span><span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>  <span class="p">)</span>    <span class="c1">// 标签0</span>
        <span class="p">(</span><span class="mi">1</span>     <span class="mi">0</span>     <span class="mf">0.1</span><span class="p">)</span>    <span class="c1">// 标签1</span>
        <span class="p">(</span><span class="mf">1.1</span>   <span class="mi">1</span>     <span class="mf">0.1</span><span class="p">)</span>    <span class="c1">// 标签2</span>
        <span class="p">(</span><span class="mi">0</span>     <span class="mi">1</span>     <span class="mf">0.1</span><span class="p">)</span>    <span class="c1">// 标签3</span>
        <span class="p">(</span><span class="o">-</span><span class="mf">0.1</span>  <span class="o">-</span><span class="mf">0.1</span>  <span class="mi">1</span>  <span class="p">)</span>    <span class="c1">// 标签4</span>
        <span class="p">(</span><span class="mf">1.3</span>   <span class="mi">0</span>     <span class="mf">1.2</span><span class="p">)</span>    <span class="c1">// 标签5</span>
        <span class="p">(</span><span class="mf">1.4</span>   <span class="mf">1.1</span>   <span class="mf">1.3</span><span class="p">)</span>    <span class="c1">// 标签6</span>
        <span class="p">(</span><span class="mi">0</span>     <span class="mi">1</span>     <span class="mf">1.1</span><span class="p">)</span>    <span class="c1">// 标签7</span>
<span class="p">);</span>
</pre></div>
</div>
<p>边缘的描述需要使用两个顶点标签，不过同样要用关键词指定边缘类型，不同类型还要求更进一步的补充点坐标信息，下面是可用的关键词：</p>
<table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="25%" />
<col width="36%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">关键词</th>
<th class="head">含义</th>
<th class="head">补充信息</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">arc</span></code></td>
<td>圆弧</td>
<td>一个中间插值点坐标</td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">simpleSpline</span></code></td>
<td>样条曲线</td>
<td>一系列插值点坐标</td>
</tr>
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">polyLine</span></code></td>
<td>一组线</td>
<td>一系列插值点坐标</td>
</tr>
<tr class="row-odd"><td><code class="code docutils literal notranslate"><span class="pre">polySpline</span></code></td>
<td>一组样条曲线</td>
<td>一系列插值点坐标</td>
</tr>
<tr class="row-even"><td><code class="code docutils literal notranslate"><span class="pre">line</span></code></td>
<td>直线</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>下面是通过标签1顶点和标签5顶点定义的圆弧边缘，该圆弧通过了坐标为 <code class="code docutils literal notranslate"><span class="pre">(1.1</span>&#160; <span class="pre">0.0</span>&#160; <span class="pre">0.5)</span></code> 的点：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">edges</span>
<span class="p">(</span>
        <span class="n">arc</span>  <span class="mi">1</span>  <span class="mi">5</span>  <span class="p">(</span><span class="mf">1.1</span>  <span class="mf">0.0</span>  <span class="mf">0.5</span><span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<p>网格块的定义涉及到点标签集、三个方向的网格数量、非均匀化比例的定义。一个block将会涉及到8个顶点标签，顶点标签的顺序决定了该网格块的坐标方向，也就会影响加密的设置顺序。顶点标签与坐标方向有下面的关系：</p>
<ul class="simple">
<li>第一个顶点标签决定了坐标系的原点；</li>
<li>从第一个顶点标签位置指向第二个顶点标签位置决定了 <span class="math notranslate nohighlight">\(x_{1}\)</span> 方向；</li>
<li>从第二个顶点标签位置到第三个顶点标签位置决定了 <span class="math notranslate nohighlight">\(x_{2}\)</span> 方向；</li>
<li>前四个顶点标签位置决定了 <span class="math notranslate nohighlight">\(x_{3}=0\)</span> 的平面位置；</li>
<li>从第一个标签位置指向第五个标签位置决定了 <span class="math notranslate nohighlight">\(x_{3}\)</span> 方向；</li>
<li>剩余三个标签类似地依次从第二、三、四个标签位置沿 <span class="math notranslate nohighlight">\(x_{3}\)</span> 方向移动得到。</li>
</ul>
</div>
<div class="section" id="snappyhexmesh">
<h3>snappyHexMesh<a class="headerlink" href="#snappyhexmesh" title="永久链接至标题">¶</a></h3>
<div class="section" id="id2">
<h4>生成背景网格<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h4>
<p>该功能可以通过三角面片模型文件(stl,obj,vtk,…)来创建网格，该模型文件应当放置在constant/triSurface文件夹内。同时还需要背景网格来决定计算域和基本网格密度，通常通过blockMesh来生成，而由于一般来说都是要生成长方体规则网格，所以可以按照下面的格式来书写blockMeshDict文件（根据需要修改大小以及边界面类型）：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>convertToMeters 1;

    xmin      -3;
    xmax      3;
    ymin      -3;
    ymax      3;
    zmin      0;
    zmax      10;

    xcells    40;
    ycells    40;
    zcells    40;

vertices
(
    ($xmin $ymin $zmin)
    ($xmax $ymin $zmin)
    ($xmax $ymax $zmin)
    ($xmin $ymax $zmin)

    ($xmin $ymin $zmax)
    ($xmax $ymin $zmax)
    ($xmax $ymax $zmax)
    ($xmin $ymax $zmax)
);

blocks
(
    hex (0 1 2 3 4 5 6 7) ($xcells $ycells $zcells) simpleGrading (1 1 1)
);

boundary
(
    inlet
    {
        type patch;
        faces
        (
            (0 4 7 3)
        );
    }
    outlet
    {
        type patch;
        faces
        (
            (1 2 6 5)
        );
    }
    ground
    {
        type patch;
        faces
        (
            (0 3 2 1)
        );
    }
    top
    {
        type patch;
        faces
        (
            (4 5 6 7)
        );
    }
    side1
    {
        type patch;
        faces
        (
            (0 1 5 4)
        );
    }
    side2
    {
        type patch;
        faces
        (
            (3 7 6 2)
        );
    }
);


mergePatchPairs
(
);
</pre></div>
</div>
</div>
<div class="section" id="surfacefeaturesdict">
<h4>surfaceFeaturesDict<a class="headerlink" href="#surfacefeaturesdict" title="永久链接至标题">¶</a></h4>
<p>然后需要设置位于system文件夹中的surfaceFeaturesDict文件、snappyHexMeshDict文件以及meshQualityDict文件，这三个文件的模板可以从教程案例中复制得到。</p>
<p>首先说明surfaceFeaturesDict文件，它用来提取模型文件的表面特征，需要指定模型文件以及调用的程序，其模板为：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cm">/*--------------------------------*- C++ -*----------------------------------*\</span>
<span class="cm">  =========                 |</span>
<span class="cm">  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox</span>
<span class="cm">   \\    /   O peration     | Website:  https://openfoam.org</span>
<span class="cm">    \\  /    A nd           | Version:  10</span>
<span class="cm">     \\/     M anipulation  |</span>
<span class="cm">\*---------------------------------------------------------------------------*/</span>
<span class="n">FoamFile</span>
<span class="p">{</span>
    <span class="n">format</span>      <span class="n">ascii</span><span class="p">;</span>
    <span class="n">class</span>       <span class="n">dictionary</span><span class="p">;</span>
    <span class="n">object</span>      <span class="n">surfaceFeaturesDict</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //</span>

<span class="n">surfaces</span> <span class="p">(</span><span class="s">&quot;combined.stl&quot;</span><span class="p">);</span>
<span class="n">includedAngle</span> <span class="mi">150</span><span class="p">;</span>

<span class="cp">#include</span><span class="cpf">Etc &quot;caseDicts/surface/surfaceFeaturesDict.cfg&quot;</span><span class="cp"></span>

<span class="c1">// ************************************************************************* //</span>
</pre></div>
</div>
<p>完成后就可以在算例目录下在终端输入：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>surfaceFeatures
</pre></div>
</div>
<p>如此就能从几何文件中提取出特征边缘，并在triSurface文件夹内生成cylinder.eMesh文件。</p>
</div>
<div class="section" id="meshqualitydict">
<h4>meshQualityDict<a class="headerlink" href="#meshqualitydict" title="永久链接至标题">¶</a></h4>
<p>meshQualityDict文件几乎不需要改动，其内容只有调用相应程序：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cm">/*--------------------------------*- C++ -*----------------------------------*\</span>
<span class="cm">  =========                 |</span>
<span class="cm">  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox</span>
<span class="cm">   \\    /   O peration     | Website:  https://openfoam.org</span>
<span class="cm">    \\  /    A nd           | Version:  10</span>
<span class="cm">     \\/     M anipulation  |</span>
<span class="cm">\*---------------------------------------------------------------------------*/</span>
<span class="n">FoamFile</span>
<span class="p">{</span>
    <span class="n">format</span>      <span class="n">ascii</span><span class="p">;</span>
    <span class="n">class</span>       <span class="n">dictionary</span><span class="p">;</span>
    <span class="n">object</span>      <span class="n">meshQualityDict</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //</span>

<span class="cp">#include</span><span class="cpf">Etc &quot;caseDicts/mesh/generation/meshQualityDict.cfg&quot;</span><span class="cp"></span>

<span class="c1">//- minFaceWeight (0 -&gt; 0.5)</span>
<span class="c1">//minFaceWeight 0.02;</span>

<span class="c1">// ************************************************************************* //</span>
</pre></div>
</div>
</div>
<div class="section" id="snappyhexmeshdict">
<h4>snappyHexMeshDict<a class="headerlink" href="#snappyhexmeshdict" title="永久链接至标题">¶</a></h4>
<p>完成上述文件后就可以开始对snappyHexMeshDict文件进行修改。该文件中涉及的关键词如下：</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="54%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">关键词</th>
<th class="head">含义</th>
<th class="head">常见赋值</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>castellatedMesh</td>
<td>是否创建堞状网格</td>
<td>true</td>
</tr>
<tr class="row-odd"><td>snap</td>
<td>是否进行表面贴合</td>
<td>true</td>
</tr>
<tr class="row-even"><td>addLayers</td>
<td>是否添加表面边界层</td>
<td>false</td>
</tr>
<tr class="row-odd"><td>mergeTolerance</td>
<td>合并公差作为初始网格边界框的分数</td>
<td>1e-6</td>
</tr>
<tr class="row-even"><td rowspan="5">debug</td>
<td>控制中间网格和网线打印的写入</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>只写最终网格</td>
<td>0</td>
</tr>
<tr class="row-even"><td>写中间网格</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>用cellLevel写volScalarField进行后期处理</td>
<td>2</td>
</tr>
<tr class="row-even"><td>将当前交叉点写入.obj文件</td>
<td>4</td>
</tr>
<tr class="row-odd"><td>geometry</td>
<td>所使用的表面图形的信息</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>castellatedMeshControls</td>
<td>生成蜂窝网格的控制信息</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>snapControls</td>
<td>表面贴合的控制信息</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>addLayersControls</td>
<td>表面边界层添加的控制信息</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>meshQualityControls</td>
<td>网格质量的控制信息</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<div class="section" id="geometry">
<h5>geometry<a class="headerlink" href="#geometry" title="永久链接至标题">¶</a></h5>
<p>在geometry关键词内设置所需的几何文件以及体加密信息。下面是一个简单的案例：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">geometry</span>
<span class="p">{</span>
    <span class="n">cylinder</span>    <span class="c1">// 模型边界面的自定义命名</span>
    <span class="p">{</span>
        <span class="n">type</span> <span class="n">triSurfaceMesh</span><span class="p">;</span>
        <span class="n">file</span> <span class="s">&quot;cylinder.stl&quot;</span><span class="p">;</span>    <span class="c1">// 所用文件</span>
    <span class="p">}</span>

    <span class="n">refinementBox</span>    <span class="c1">// 体加密区域的自定义命名</span>
    <span class="p">{</span>
        <span class="n">type</span> <span class="n">searchableBox</span><span class="p">;</span>    <span class="c1">// 体加密类型</span>
        <span class="n">min</span>  <span class="p">(</span>  <span class="o">-</span><span class="mi">5</span>   <span class="o">-</span><span class="mi">5</span>   <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">max</span>  <span class="p">(</span><span class="mi">15</span> <span class="mi">15</span>  <span class="mi">5</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>如果在stl文件中已经自行定义了各个solid的名字，那么就可以添加 <code class="code docutils literal notranslate"><span class="pre">regions</span></code> 关键字来提取这些面域，进而在后续的面加密中各自进行处理。例如：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">geometry</span>
<span class="p">{</span>
    <span class="n">cylinder</span>    <span class="c1">// 模型边界面的自定义命名</span>
    <span class="p">{</span>
        <span class="n">type</span> <span class="n">triSurfaceMesh</span><span class="p">;</span>
        <span class="n">file</span> <span class="s">&quot;cylinder.stl&quot;</span><span class="p">;</span>    <span class="c1">// 所用文件</span>

        <span class="n">regions</span>
        <span class="p">{</span>
            <span class="n">top</span> <span class="p">{</span> <span class="n">name</span> <span class="n">top</span><span class="p">;</span> <span class="p">}</span>
            <span class="n">bottom</span> <span class="p">{</span> <span class="n">name</span> <span class="n">bottom</span><span class="p">;</span> <span class="p">}</span>
            <span class="n">wall</span> <span class="p">{</span> <span class="n">name</span> <span class="n">wall</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">refinementBox</span>    <span class="c1">// 体加密区域的自定义命名</span>
    <span class="p">{</span>
        <span class="n">type</span> <span class="n">searchableBox</span><span class="p">;</span>    <span class="c1">// 体加密类型</span>
        <span class="n">min</span>  <span class="p">(</span>  <span class="o">-</span><span class="mi">5</span>   <span class="o">-</span><span class="mi">5</span>   <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">max</span>  <span class="p">(</span><span class="mi">15</span> <span class="mi">15</span>  <span class="mi">5</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>体加密除了上述方块体加密设置，还有其他可选加密方式：</p>
<table border="1" class="docutils">
<colgroup>
<col width="36%" />
<col width="22%" />
<col width="19%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">加密类型</th>
<th class="head">类型含义</th>
<th class="head">所需参数</th>
<th class="head">参数解释</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td rowspan="2">searchableBox</td>
<td rowspan="2">立方体</td>
<td>min</td>
<td>最小对角点坐标</td>
</tr>
<tr class="row-odd"><td>max</td>
<td>最大对角点坐标</td>
</tr>
<tr class="row-even"><td rowspan="3">searchableCylinder</td>
<td rowspan="3">圆柱</td>
<td>point1</td>
<td>中轴线端点1</td>
</tr>
<tr class="row-odd"><td>point2</td>
<td>中轴线端点2</td>
</tr>
<tr class="row-even"><td>radius</td>
<td>外圆半径</td>
</tr>
<tr class="row-odd"><td rowspan="2">searchableSphere</td>
<td rowspan="2">球</td>
<td>Centre</td>
<td>中心点坐标</td>
</tr>
<tr class="row-even"><td>radius</td>
<td>球半径</td>
</tr>
<tr class="row-odd"><td rowspan="6">searchableCone</td>
<td rowspan="6">圆锥体（空心）</td>
<td>point1</td>
<td>中轴线端点1</td>
</tr>
<tr class="row-even"><td>point2</td>
<td>中轴线端点2</td>
</tr>
<tr class="row-odd"><td>radius1</td>
<td>断面1外圆半径</td>
</tr>
<tr class="row-even"><td>radius2</td>
<td>断面2外圆半径</td>
</tr>
<tr class="row-odd"><td>innerRadius1</td>
<td>断面1内圆半径</td>
</tr>
<tr class="row-even"><td>innerRadius2</td>
<td>断面2内圆半径</td>
</tr>
<tr class="row-odd"><td rowspan="5">searchableRotatedBox</td>
<td rowspan="5">旋转立方体</td>
<td>origin</td>
<td>最小对角点坐标</td>
</tr>
<tr class="row-even"><td>span</td>
<td>XYZ方向尺寸长度</td>
</tr>
<tr class="row-odd"><td>e1</td>
<td>几何i方向向量</td>
</tr>
<tr class="row-even"><td>e2</td>
<td>几何j方向向量</td>
</tr>
<tr class="row-odd"><td>e3</td>
<td>几何k方向向量</td>
</tr>
<tr class="row-even"><td rowspan="2">searchableExtrudedCircle</td>
<td rowspan="2">圆管</td>
<td>file</td>
<td>导入曲线文件</td>
</tr>
<tr class="row-odd"><td>radius</td>
<td>圆管半径</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="castellatedmeshcontrols">
<h5>castellatedMeshControls<a class="headerlink" href="#castellatedmeshcontrols" title="永久链接至标题">¶</a></h5>
<p>全局网格细化参数在castellatedMeshControls中设置，其目的为细化背景网格，通过细化背景网格以使几何特征与几何表面上拥有一定网格量，以提高几何特征捕捉的准确性。同时通过参数设置，保证网格细化时尺寸变化尽量平缓。在该关键词内需要设置的内容包括：</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="6%" />
<col width="6%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">关键词</th>
<th class="head">含义</th>
<th class="head">常用赋值</th>
<th class="head">备注</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>maxGlobalCells</td>
<td>全局最大网格量</td>
<td>2e+06</td>
<td>该功能主要目的是保证网格细化过程中，避免划分网格量太大，导致计算机内存溢出。当划分网格量超过此值时，细化过程将立即终止。此时，局部细化功能可能终止运行。</td>
</tr>
<tr class="row-odd"><td>maxLocalCells</td>
<td>单核最大网格量</td>
<td>1e+06</td>
<td>该参数主要应用于网格并行计算，其指定了细化网格过程中每个处理器处理的最大数量网格数。设置该参数时请保证一定的富余量，经常重新平衡每个处理器计算量将减慢网格生成过程。</td>
</tr>
<tr class="row-even"><td>maxLoadUnbalance</td>
<td>最大负载平衡参数</td>
<td>0.1</td>
<td>该参数主要应用于网格并行计算。当该参数值为0时，即强制负载平衡，即各处理器间处理的网格量严格保持单元总数/计算核数。较低的值可能会导致系统频繁的均衡网格负载量。而参数值设置为1时，则完全禁用网格均衡操作。</td>
</tr>
<tr class="row-odd"><td>minRefinementCells</td>
<td>最小细化单元数</td>
<td>0</td>
<td>该参数指定了需细化特征的最小单元数。若特征上网格单元数量小于该参数，则停止对其细化。</td>
</tr>
<tr class="row-even"><td>nCellsBetweenLevels</td>
<td>缓冲层数</td>
<td>3</td>
<td>若用户设置参数值为1，则表示不添加过渡区域。越大的值可使得网格大小过渡越平缓，但将导致网格量增加。</td>
</tr>
<tr class="row-odd"><td>resolveFeatureAngle</td>
<td>自动检测角</td>
<td>30</td>
<td>当曲率变化角超过该参数值时，特征区域网格使用最大面细化等级，而低于此角度的特征均采用最小面细化级别。默认参数值为30，参数值设置为360时，表示关闭此功能。该参数生效的前置条件：(1)面细化参数中最小和最大细化等级需不同。(2)面贴合过程中特征捕捉需采用隐式方法。</td>
</tr>
<tr class="row-even"><td>locationInMesh</td>
<td>网格域控制点</td>
<td>(-3.25 -2.25 1.25)</td>
<td>指定需要保留背景网格表面与封闭几何表面之间的网格，还是封闭几何内部的网格。保留区域网格中需包含指定的参数点，该点的位置不能和网格单元的面或边重合。</td>
</tr>
<tr class="row-odd"><td>allowFreeStandingZoneFaces</td>
<td>允许有独立面</td>
<td>false</td>
<td>该参数定义是否允许几何中有独立的面存在。若设置参数值为false，则表示在refinementSurfaces中指定的faceZones仅位于相应cellZones的边界上，作为不同域之间交界面。若该参数值为true，则允许此faceZones作为独立面域（例如：挡板界面等）。如果用户没有指定faceZones，则该参数不生效。</td>
</tr>
<tr class="row-even"><td>features</td>
<td>需要细化的特性信息</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>refinementRegions</td>
<td>用于细化的区域的信息</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>refinementSurfaces</td>
<td>用于细化的曲面的信息</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>一般情况下，castellatedMeshControls可以按照如下方式设置：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">castellatedMeshControls</span>
<span class="p">{</span>
    <span class="n">features</span>
    <span class="p">(</span>
      <span class="p">{</span> <span class="n">file</span>  <span class="s">&quot;cylinder.eMesh&quot;</span><span class="p">;</span> <span class="n">level</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">);</span>

    <span class="n">refinementSurfaces</span>
    <span class="p">{</span>
        <span class="n">cylinder</span>    <span class="c1">// 对应之前定义的几何表面名称</span>
        <span class="p">{</span>
            <span class="n">level</span> <span class="p">(</span><span class="mi">3</span> <span class="mi">3</span><span class="p">);</span>
            <span class="n">patchInfo</span> <span class="p">{</span> <span class="n">type</span> <span class="n">wall</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">refinementRegions</span>
    <span class="p">{</span>
        <span class="n">refinementBox</span>    <span class="c1">// 对应之前定义的加密区域名称</span>
        <span class="p">{</span>
            <span class="n">mode</span>    <span class="n">inside</span><span class="p">;</span>
            <span class="n">level</span>   <span class="mi">2</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">locationInMesh</span> <span class="p">(</span><span class="o">-</span><span class="mf">3.25</span> <span class="o">-</span><span class="mf">2.25</span> <span class="mf">1.25</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果在之前 <code class="code docutils literal notranslate"><span class="pre">geometry</span></code> 部分指明了不同的regions，那么在 <code class="code docutils literal notranslate"><span class="pre">refinementSurfaces</span></code> 就可以针对不同的面域进行不同程度的细化，同时赋予不同的边界类型：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">castellatedMeshControls</span>
<span class="p">{</span>
    <span class="n">features</span>
    <span class="p">(</span>
      <span class="p">{</span> <span class="n">file</span>  <span class="s">&quot;cylinder.eMesh&quot;</span><span class="p">;</span> <span class="n">level</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">);</span>

    <span class="n">refinementSurfaces</span>
    <span class="p">{</span>
        <span class="n">cylinder</span>    <span class="c1">// 对应之前定义的几何表面名称</span>
        <span class="p">{</span>
            <span class="n">level</span> <span class="p">(</span><span class="mi">0</span> <span class="mi">0</span><span class="p">);</span>

            <span class="n">regions</span>
            <span class="p">{</span>
                <span class="n">top</span>
                <span class="p">{</span>
                    <span class="n">level</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">1</span><span class="p">);</span>
                    <span class="n">patchInfo</span> <span class="p">{</span> <span class="n">type</span> <span class="n">patch</span><span class="p">;</span> <span class="p">}</span>
                <span class="p">}</span>
                <span class="n">bottom</span>
                <span class="p">{</span>
                    <span class="n">level</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">1</span><span class="p">);</span>
                    <span class="n">patchInfo</span> <span class="p">{</span> <span class="n">type</span> <span class="n">patch</span><span class="p">;</span> <span class="p">}</span>
                <span class="p">}</span>
                <span class="n">wall</span>
                <span class="p">{</span>
                    <span class="n">level</span> <span class="p">(</span><span class="mi">2</span> <span class="mi">2</span><span class="p">);</span>
                    <span class="n">patchInfo</span> <span class="p">{</span> <span class="n">type</span> <span class="n">wall</span><span class="p">;</span> <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">refinementRegions</span>
    <span class="p">{</span>
        <span class="n">refinementBox</span>    <span class="c1">// 对应之前定义的加密区域名称</span>
        <span class="p">{</span>
            <span class="n">mode</span>    <span class="n">inside</span><span class="p">;</span>
            <span class="n">level</span>   <span class="mi">2</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">locationInMesh</span> <span class="p">(</span><span class="o">-</span><span class="mf">3.25</span> <span class="o">-</span><span class="mf">2.25</span> <span class="mf">1.25</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="snapcontrols">
<h5>snapControls<a class="headerlink" href="#snapcontrols" title="永久链接至标题">¶</a></h5>
<p>面贴合参数在snapControls中设置，主要目的是将体网格节点移动到几何表面上，贴合体网格中锯齿状表面。在该关键词内需要设置的内容包括：</p>
<table border="1" class="docutils">
<colgroup>
<col width="6%" />
<col width="5%" />
<col width="2%" />
<col width="87%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">关键词</th>
<th class="head">含义</th>
<th class="head">常用赋值</th>
<th class="head">备注</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>tolerance</td>
<td>捕捉点最大相对距离</td>
<td>5</td>
<td>建议2-5之间。该参数指定贴合算法中捕捉与特征面相关网格节点的最大相对距离，实际捕捉距离为tolerance参数值乘以相邻体网格尺寸。参数值必须大于或等于1，如果值太低，则可能无法使偏差较大的网格节点移动到几何表面上。较高的值有助于增加几何的捕捉范围，但如果参数值设置过高，则有可能捕捉到与表面无关的网格节点。</td>
</tr>
<tr class="row-odd"><td>nSolveIter</td>
<td>网格贴合最大迭代次数</td>
<td>100</td>
<td>该参数指定了网格贴合算法的最大迭代次数。较高的值会提高网格的质量，网格一致性更好，但网格划分时间会更长。简单模型可以将该参数值设置为100，若贴合后网格质量不太理想，可尝试将该参数值增加到300。</td>
</tr>
<tr class="row-even"><td>nSmoothPatch</td>
<td>面平滑迭代次数</td>
<td>0</td>
<td>0表示初始网格外形。该参数指定了表面上网格贴合的平滑迭代次数。增加迭代次数可以使曲面上网格平滑、贴合性更好，且能降低曲面上网格的歪斜率，但可能导致曲率突变特征（如直角等）弱化。</td>
</tr>
<tr class="row-odd"><td>nSmoothInternal</td>
<td>体网格平滑迭代次数</td>
<td>0</td>
<td>建议参数值与nSmoothPatch参数值一致。在执行网格平滑迭代时，边界面网格平滑迭代nSmoothPatch将与内部体网格平滑迭代nSmoothInternal联合使用。平滑迭代顺序为优先执行一次面平滑迭代（nSmoothPatch），再执行一次体网格平滑迭代（nSmoothInterna），以此循环。若用户设置nSmoothInternal参数值大于nSmoothPatch值时，平滑迭代次数统一采用nSmoothPatch参数值。默认值为零，表示禁用体网格平滑迭代。</td>
</tr>
<tr class="row-even"><td>nRelaxIter</td>
<td>贴合松弛迭代次数</td>
<td>8</td>
<td>一般为5-8之间。该参数指定贴合过程中松弛迭代次数，用以消除质量较差的单元或网格节点。如果迭代完成后网格仍存在质量较差单元，则用户可以尝试增加此迭代次数，较高的值将确保更好的网格质量，但会花费更多计算时间。</td>
</tr>
<tr class="row-odd"><td>nFeatureSnapIter</td>
<td>特征边捕捉迭代次数</td>
<td>10</td>
<td>该参数指定了特征捕捉迭代次数，以将网格点捕捉到表面边缘。如果在nFeatureSnaplter迭代后局部特征区域网格没有达到足够的质量标准，则取消该区域特征边捕捉并恢复到之前状态。未指定该参数，特征捕捉功能将被禁用。</td>
</tr>
<tr class="row-even"><td>nFaceSplitInterval</td>
<td>面拆分迭代</td>
<td>5</td>
<td>当系统执行完特征边捕捉迭代步骤后，若网格边缘与特征边未完全对齐，则有可能在特征边处网格产生凹面。从而导致在添加边界层时，其投影体网格的非正交性增大。如果体网格不满足质量要求，则取消该处边界层生成。nFaceSplitInterval参数默认值为-1（禁用），使用建议参数值设置为特征边捕捉迭代（nFeatureSnaplter）次数的一半。</td>
</tr>
<tr class="row-odd"><td>explicitFeatureSnap</td>
<td>显式特征捕捉</td>
<td>true</td>
<td>显示特征捕捉方法需要用户自定义特征边文件（.eMesh），并且指定特征边的细化等级（通过castellatedMeshControls子字典中features参数指定）。</td>
</tr>
<tr class="row-even"><td>implicitFeatureSnap</td>
<td>隐式特征捕捉</td>
<td>false</td>
<td>隐式方法不需要用户提取几何特征边，其特征识别自动化程度优于显示特征捕捉方法。它使用全局细化参数中resolveFeatureAngle参数识别曲面几何特征（例如：面的相交线、曲率变化较大的曲面特征）。但在尖角特征或者挡板界面处，显示方法捕捉特征效果优于隐式方法。</td>
</tr>
<tr class="row-odd"><td>multiRegionFeatureSnap</td>
<td>多域特征捕捉</td>
<td>false</td>
<td>该参数用于捕捉多域网格间的特征面，这对于具有多个区域（例如流体区域和固体区域）的网格进行共轭传热模拟或类似操作很重要。该参数生效的前置条件为采用显示特征捕捉方法explicitFeatureSnap。使用该参数时，它会加强特征面两边网格贴合，即内部区域和外部区域，这可能会导致特征面处网格歪斜率上升。</td>
</tr>
</tbody>
</table>
<p>一般情况下，snapControls采用下面的设置就已经能够得到相对可以接受的网格了：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">snapControls</span>
<span class="p">{</span>
    <span class="n">explicitFeatureSnap</span>    <span class="nb">true</span><span class="p">;</span>
    <span class="n">implicitFeatureSnap</span>    <span class="nb">false</span><span class="p">;</span>
    <span class="n">multiRegionFeatureSnap</span> <span class="nb">false</span><span class="p">;</span>

    <span class="n">tolerance</span>           <span class="mi">5</span><span class="p">;</span>
    <span class="n">nSolveIter</span>          <span class="mi">100</span><span class="p">;</span>
    <span class="n">nSmoothPatch</span>        <span class="mi">0</span><span class="p">;</span>
    <span class="n">nSmoothInternal</span>     <span class="mi">0</span><span class="p">;</span>
    <span class="n">nRelaxIter</span>          <span class="mi">8</span><span class="p">;</span>
    <span class="n">nFeatureSnapIter</span>    <span class="mi">10</span><span class="p">;</span>
    <span class="n">nFaceSplitInterval</span>  <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="addlayerscontrols">
<h5>addLayersControls<a class="headerlink" href="#addlayerscontrols" title="永久链接至标题">¶</a></h5>
<p>在划分边界层时，需要在全局参数设置中激活边界层划分功能，即将addLayers值设置为true。边界层配置参数在addLayersControls子字典中设置，其参数类型可分为基本参数与高级控制参数：</p>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="10%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">关键词</th>
<th class="head">含义</th>
<th class="head">备注</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>relativeSizes</td>
<td>是否采用相对临近单元尺寸比值</td>
<td>设置为true时，边界层厚度参数值为相对于邻近曲面上的体网格单元大小的比值；设置为false时，边界层厚度参数值直接由绝对单位的值(单位.米)定义</td>
</tr>
<tr class="row-odd"><td>expansionRatio</td>
<td>边界层膨胀比</td>
<td>两个相邻层的厚度比，该值越大，各层间的高度差越大</td>
</tr>
<tr class="row-even"><td>finalLayerThickness</td>
<td>边界层最后一层厚度</td>
<td>确保边界层最后一层网格不大于该值</td>
</tr>
<tr class="row-odd"><td>firstLayerThickness</td>
<td>边界层第一层的厚度</td>
<td>指定距离曲面最近的边界层的高度，确保边界层第一层网格不大于该值</td>
</tr>
<tr class="row-even"><td>thickness</td>
<td>边界层总厚度</td>
<td>所有边界层的最大厚度。设置较大的边界层总厚度值会导致体网格收缩位移相应增大，体网格变形量增加将导致网格质量降低。当网格质量小于用户设置网格质量控制参数时，系统将取消此处边界层网格划分。</td>
</tr>
<tr class="row-odd"><td>minThickness</td>
<td>最小总层厚度</td>
<td>所有边界层的总体最小厚度。若边界层挤出区域厚度小于该值，则该区域将不会生成边界层</td>
</tr>
<tr class="row-even"><td>nGrow</td>
<td>最大取消边界层单元数</td>
<td>指定未设置边界层的相邻面相交处边界层的过渡层数。这有助于将边界层过渡到特征边附近</td>
</tr>
<tr class="row-odd"><td>nSurfaceLayers</td>
<td>边界层层数</td>
<td>需在指定面设置边界层基本参数中输入，为强制性参数</td>
</tr>
<tr class="row-even"><td>maxFaceThicknessRatio</td>
<td>表面网格最大纵横比</td>
<td>当要在高度扭曲的单元上（特别是在角落）生成边界层时，纵横比高于此值的单元上边界层停止生成，以保证边界层网格质量</td>
</tr>
<tr class="row-odd"><td>featureAngle</td>
<td>边界层最大面夹角</td>
<td>当两个曲面之间的法向夹角小于参数featureAngle值时，允许两个曲面的相交边处体网格向域内收缩，形成边界层划分区域</td>
</tr>
<tr class="row-even"><td>slipFeatureAngle</td>
<td>边界层滑移角度</td>
<td>使边界层面边缘处顶点延边界面滑动，以保证边界层在边缘处的划分空间。建议使用70-80之间的最佳值来限制层的滑动，默认值为featureAngle的一半</td>
</tr>
<tr class="row-odd"><td>nBufferCellsNoExtrude</td>
<td>边界层终止面的缓冲单元数</td>
<td>为边界层终止端创建缓冲收缩区，即逐渐降低边界层数。设置值小于0，则表示在终止端立即停止边界层</td>
</tr>
<tr class="row-even"><td>nSmoothThickness</td>
<td>边界层厚度平滑迭代次数</td>
<td>边界层网格生成前，需要根据投影厚度值收缩现有体网格，可通过nSmoothThickness值设置投影厚度值的迭代次数</td>
</tr>
<tr class="row-odd"><td>nSmoothSurfaceNormals</td>
<td>边界层曲面法线平滑迭代次数</td>
<td>边界层网格生成前，需要根据曲面法线方向收缩现有体网格，可通过nSmoothSurfaceNormals指定曲面法线平滑迭代次数</td>
</tr>
<tr class="row-even"><td>minMedianAxisAngle</td>
<td>拾取中间轴点的角度</td>
<td>这指定用于拾取中间轴点的角度。建议值为90度</td>
</tr>
<tr class="row-odd"><td>maxThicknessToMedialRatio</td>
<td>层厚度与中间轴长度的最大比率</td>
<td>当比率大于指定值时，层生长减少。建议值为0.3</td>
</tr>
<tr class="row-even"><td>nRelaxIter</td>
<td>体网格收缩迭代次数</td>
<td>单步投影厚度值的迭代中，系统需根据投影厚度值计算体网格收缩松弛系数。该值越大越有利于提高体网格网格质量。建议值为5</td>
</tr>
<tr class="row-odd"><td>nSmoothNormals</td>
<td>体网格平滑迭代次数</td>
<td>体网格收缩时，可通过nSmoothNormals指定体网格间移动方向的迭代次数。该值越高，体网格间平滑性越好，但网格划分时间越长。建议值为3</td>
</tr>
<tr class="row-even"><td>nLayerIter</td>
<td>边界层添加的最大总迭代次数</td>
<td>如果达到此迭代次数，边界层网格划分将立即停止，并保留最后一次迭代生成的边界层。建议值为50-60</td>
</tr>
<tr class="row-odd"><td>nRelaxedIter</td>
<td>宽松质量控制标准的起始迭代次数</td>
<td>划分边界层网格时会优先使用meshQualityControls中基础质量控制参数，检测网格是否满足要求。若边界层添加算法迭代次数达到用户设置nRelaxedIter参数值后，网格依然不能达到质量控制要求，则在此后的迭代中软件将采用用户设置的宽松质量控制标准值。参数建议值为20</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="meshqualitycontrols">
<h5>meshQualityControls<a class="headerlink" href="#meshqualitycontrols" title="永久链接至标题">¶</a></h5>
<p>meshQualityControls关键词中设置网格质量控制参数。在snappyHexMesh执行全局参数控制、面贴合、局部细化以及边界层生成时，程序都会依据网格质量控制参数不断调整网格迭代，同时，当网格位移或拓扑更改操作导致单元或面网格质量降低时，可根据控制参数撤消移动或拓扑更改操作以将网格还原为之前满足网格质量标准的状态。在该关键词内需要设定的内容如下：</p>
<table border="1" class="docutils">
<colgroup>
<col width="6%" />
<col width="10%" />
<col width="3%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">关键词</th>
<th class="head">含义</th>
<th class="head">常见赋值</th>
<th class="head">备注</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>maxNonOrtho</td>
<td>最大非正交角</td>
<td>65</td>
<td>该参数指定允许的最大非正交角，其通过计算相邻两单元中心点向量与公共面法向量的夹角，此值为0时表示相邻两个网格完全正交。默认参考值为65，当设置为180时，表示关闭此项控制。该参数是衡量网格质量的主要指标之一。</td>
</tr>
<tr class="row-odd"><td>maxBoundarySkewness</td>
<td>最大边界面网格偏斜度</td>
<td>20</td>
<td>此参数指定边界面网格允许的最大偏斜度。其定义一个面或体与理想几何(即等边或等角)的接近程度。默认参考值为20，当设置小于0的值时，表示关闭此项控制。</td>
</tr>
<tr class="row-even"><td>maxInternalSkewness</td>
<td>最大内部面网格偏斜度</td>
<td>4</td>
<td>参数计算方式与最大边界面网格偏斜度一致，不过其主要测试内部网格质量。默认参考值为4，当设置小于0的值时，表示关闭此项控制。该参数是衡量网格质量的主要指标之一。</td>
</tr>
<tr class="row-odd"><td>maxConcave</td>
<td>最大凹度</td>
<td>80</td>
<td>该参数用于检查构成面的内凹角度，以允许低于该角度的凹面。0表示直面，小于0表示凸面。默认参考值为80，当设置为180时，表示关闭此项控制。</td>
</tr>
<tr class="row-even"><td>minFlatness</td>
<td>最小平整值</td>
<td>0.5</td>
<td>最小投影面积和实际面积的比值，该参数值为1时，表示检测面为平面。默认参数为0.5，设置为-1时，表示禁用此项控制。</td>
</tr>
<tr class="row-odd"><td>minVol</td>
<td>最小单元体积</td>
<td>1e-13</td>
<td>该参数为允许最小金字塔单元体积，其为网格绝对体积参数（单位m3），默认参数为1e-13。设置为较大的负值时（例如-1e30），表示禁用此项控制。该参数是衡量网格质量的主要指标之一。</td>
</tr>
<tr class="row-even"><td>minArea</td>
<td>最小网格面面积</td>
<td>-1</td>
<td>该参数为允许最小网格面的面积，默认为-1，该参数设置为负值时，表示禁用此项控制。</td>
</tr>
<tr class="row-odd"><td>minTwist</td>
<td>最小面扭曲</td>
<td>0.05</td>
<td>使用面中心将面分解为三角形单元，并通过相邻两个单元中心点向量与分解后三角形面法向量的点积计算面扭曲值。默认参考值为0.05，当设置参数小于-1时，表示关闭此项控制。</td>
</tr>
<tr class="row-even"><td>minDeterminant</td>
<td>最小归一化单元行列式值</td>
<td>0.001</td>
<td>通过计算每一个六面体的雅可比行列式值，然后标准化行列式的矩阵来表征单元的变形。参数值取值范围为0到1，参数值设置为1 表示只允许有理想六面体网格；如果某单元行列式的值为0，则这个立方体有一个或多个退化的边。参数值设置小于或等于0表示允许有负体积单元，默认参数值为0.001。</td>
</tr>
<tr class="row-odd"><td>minFaceWeight</td>
<td>相邻网格间面权重最小值</td>
<td>0.05</td>
<td>其定义了面相对于相邻单元间中心的相对位置（正交时为0.5），计算方法是先计算出单元中心到公共面中心长度L1，再计算出相邻单元中心到公共面中心长度L2，面权重值等于L1与L2的最小值除以L1与L2之和。较小的面权重值表示相邻网格尺寸相差较大。参数值取值范围为0到0.5，默认参考值为0.05。</td>
</tr>
<tr class="row-even"><td>minVolRatio</td>
<td>相邻网格间的最小体积膨胀率</td>
<td>0.01</td>
<td>该参数指定允许相邻网格间的最小体积膨胀率, 参数值取值范围为0到1， 默认参考值为0.01。较大的比值会导致插值结果误差较大。</td>
</tr>
<tr class="row-odd"><td>minTriangleTwist</td>
<td>最小三角单元扭曲值</td>
<td>-1</td>
<td>该参数表示允许最小三角单元扭曲值，通过使用面中心将面分解为三角形单元，然后依据相邻的三角形单元法向量的点积计算出三角形面扭曲值。默认参数值为-1，表示禁用此功能。若参数值大于0，则启用此功能项。其主要目的为确保生成网格与Fluent网格的兼容性。</td>
</tr>
<tr class="row-even"><td>minTetQuality</td>
<td>?</td>
<td>1e-30</td>
<td>通过网格单元中心和面中心将单元分解为四面体，然后根据圆周半径（Rc）和四面体体积（Vtet）计算四面体单元质量。对于一些跟踪算例时（如流线计算），该参数需要设置为一个较小正值，以确保内部单元质量检查正常运行。默认参数值为1e-30。</td>
</tr>
<tr class="row-odd"><td>nSmoothScale</td>
<td>每次网格缩放恢复迭代时的平滑次数</td>
<td>4</td>
<td>snappyHexMesh网格划分过程中可将局部网格缩放到之前网格质量满足标准的状态。可通过nSmoothScale参数指定每次网格缩放恢复迭代时的平滑次数，参数默认值为4。</td>
</tr>
<tr class="row-even"><td>errorReduction</td>
<td>误差点处的缩放位移量</td>
<td>0.75</td>
<td>errorReduction参数同nSmoothScale参数一样应用于网格缩放恢复迭代，用户可通过该参数减小误差点处的缩放位移量，参数默认值为0.75。</td>
</tr>
<tr class="row-odd"><td>relaxed</td>
<td>相对宽松的上述标准列表</td>
<td>?</td>
<td>在划分边界层网格时会优先使用meshQualityControls中基础质量控制参数，检测网格是否满足要求。若边界层添加算法迭代次数达到用户设置nRelaxedIter参数值后，网格依然不能达到质量控制要求，则在此后的迭代中软件将采用设置的宽松质量控制标准值，以提高边界层网格的覆盖率。</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id3">
<h4>snappyHexMeshDict模板<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h4>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cm">/*--------------------------------*- C++ -*----------------------------------*\</span>
<span class="cm">  =========                 |</span>
<span class="cm">  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox</span>
<span class="cm">   \\    /   O peration     | Website:  https://openfoam.org</span>
<span class="cm">    \\  /    A nd           | Version:  10</span>
<span class="cm">     \\/     M anipulation  |</span>
<span class="cm">\*---------------------------------------------------------------------------*/</span>
<span class="n">FoamFile</span>
<span class="p">{</span>
    <span class="n">format</span>      <span class="n">ascii</span><span class="p">;</span>
    <span class="n">class</span>       <span class="n">dictionary</span><span class="p">;</span>
    <span class="n">object</span>      <span class="n">snappyHexMeshDict</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //</span>

<span class="cp">#include</span><span class="cpf">Etc &quot;caseDicts/mesh/generation/snappyHexMeshDict.cfg&quot;</span><span class="cp"></span>

<span class="n">castellatedMesh</span> <span class="nb">true</span><span class="p">;</span>
<span class="n">snap</span>            <span class="nb">true</span><span class="p">;</span>
<span class="n">addLayers</span>       <span class="nb">true</span><span class="p">;</span>  <span class="c1">// create boundary layers</span>

<span class="n">geometry</span>
<span class="p">{</span>
    <span class="n">combined</span>
    <span class="p">{</span>
        <span class="n">type</span> <span class="n">triSurfaceMesh</span><span class="p">;</span>
        <span class="n">file</span> <span class="s">&quot;combined.stl&quot;</span><span class="p">;</span>

        <span class="n">regions</span>
        <span class="p">{</span>
            <span class="n">sideFace</span> <span class="p">{</span> <span class="n">name</span> <span class="n">sideFace</span><span class="p">;</span> <span class="p">}</span>
            <span class="n">topFace</span> <span class="p">{</span> <span class="n">name</span> <span class="n">topFace</span><span class="p">;</span> <span class="p">}</span>
            <span class="n">leftFace</span> <span class="p">{</span> <span class="n">name</span> <span class="n">leftFace</span><span class="p">;</span> <span class="p">}</span>
            <span class="n">rightFace</span> <span class="p">{</span> <span class="n">name</span> <span class="n">rightFace</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/*</span>
<span class="cm">    refinementBox</span>
<span class="cm">    {</span>
<span class="cm">        type searchableBox;</span>
<span class="cm">        min  (-4 -4 -1);</span>
<span class="cm">        max  ( 4  4  4);</span>
<span class="cm">    }</span>
<span class="cm">    */</span>
<span class="p">};</span>

<span class="n">castellatedMeshControls</span>
<span class="p">{</span>
    <span class="n">features</span>
    <span class="p">(</span>
      <span class="p">{</span> <span class="n">file</span>  <span class="s">&quot;combined.eMesh&quot;</span><span class="p">;</span> <span class="n">level</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">);</span>

    <span class="n">refinementSurfaces</span>
    <span class="p">{</span>
        <span class="n">combined</span>
        <span class="p">{</span>
        <span class="n">level</span> <span class="p">(</span><span class="mi">0</span> <span class="mi">0</span><span class="p">);</span>

            <span class="n">regions</span>
            <span class="p">{</span>
            <span class="n">sideFace</span>
            <span class="p">{</span>
                <span class="n">level</span> <span class="p">(</span><span class="mi">0</span> <span class="mi">0</span><span class="p">);</span>
                <span class="n">patchInfo</span> <span class="p">{</span> <span class="n">type</span> <span class="n">patch</span><span class="p">;</span> <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">topFace</span>
            <span class="p">{</span>
                <span class="n">level</span> <span class="p">(</span><span class="mi">0</span> <span class="mi">0</span><span class="p">);</span>
                <span class="n">patchInfo</span> <span class="p">{</span> <span class="n">type</span> <span class="n">patch</span><span class="p">;</span> <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">leftFace</span>
            <span class="p">{</span>
                <span class="n">level</span> <span class="p">(</span><span class="mi">0</span> <span class="mi">0</span><span class="p">);</span>
                <span class="n">patchInfo</span> <span class="p">{</span> <span class="n">type</span> <span class="n">patch</span><span class="p">;</span> <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">rightFace</span>
            <span class="p">{</span>
                <span class="n">level</span> <span class="p">(</span><span class="mi">0</span> <span class="mi">0</span><span class="p">);</span>
                <span class="n">patchInfo</span> <span class="p">{</span> <span class="n">type</span> <span class="n">patch</span><span class="p">;</span> <span class="p">}</span>
            <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="cm">/*</span>
<span class="cm">    refinementRegions</span>
<span class="cm">    {</span>
<span class="cm">        refinementBox</span>
<span class="cm">        {</span>
<span class="cm">            mode    inside;</span>
<span class="cm">            level   1;</span>
<span class="cm">        }</span>
<span class="cm">    }</span>
<span class="cm">    */</span>



    <span class="n">locationInMesh</span> <span class="p">(</span><span class="mi">0</span> <span class="mi">0</span> <span class="mf">2.25</span><span class="p">);</span>

    <span class="n">resolveFeatureAngle</span>    <span class="mi">15</span><span class="p">;</span>
    <span class="n">nCellsBetweenLevels</span>    <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">snapControls</span>
<span class="p">{</span>
    <span class="n">explicitFeatureSnap</span>    <span class="nb">true</span><span class="p">;</span>
    <span class="n">implicitFeatureSnap</span>    <span class="nb">false</span><span class="p">;</span>
    <span class="n">multiRegionFeatureSnap</span> <span class="nb">false</span><span class="p">;</span>

    <span class="n">nSmoothPatch</span>        <span class="mi">0</span><span class="p">;</span>
    <span class="n">nSmoothInternal</span>     <span class="mi">0</span><span class="p">;</span>
    <span class="n">tolerance</span>           <span class="mi">5</span><span class="p">;</span>
    <span class="n">nSolveIter</span>          <span class="mi">100</span><span class="p">;</span>
    <span class="n">nRelaxIter</span>          <span class="mi">10</span><span class="p">;</span>
    <span class="n">nFeatureSnapIter</span>    <span class="mi">10</span><span class="p">;</span>
    <span class="n">nFaceSplitInterval</span>  <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">addLayersControls</span>
<span class="p">{</span>
    <span class="n">layers</span>
    <span class="p">{</span>
        <span class="n">sideFace</span>
        <span class="p">{</span>
            <span class="n">nSurfaceLayers</span> <span class="mi">3</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">relativeSizes</span>       <span class="nb">false</span><span class="p">;</span>
    <span class="n">expansionRatio</span>      <span class="mf">1.2</span><span class="p">;</span>
    <span class="n">finalLayerThickness</span> <span class="mf">0.15</span><span class="p">;</span>
    <span class="n">minThickness</span>        <span class="mf">0.0</span><span class="p">;</span>
    <span class="n">nGrow</span>               <span class="mi">0</span><span class="p">;</span>

    <span class="n">featureAngle</span>             <span class="mi">130</span><span class="p">;</span>
    <span class="n">nRelaxIter</span>               <span class="mi">30</span><span class="p">;</span>
    <span class="n">nSmoothSurfaceNormals</span>    <span class="mi">3</span><span class="p">;</span>
    <span class="n">nSmoothNormals</span>           <span class="mi">8</span><span class="p">;</span>
    <span class="n">nSmoothThickness</span>         <span class="mi">10</span><span class="p">;</span>
    <span class="n">maxFaceThicknessRatio</span>    <span class="mf">0.5</span><span class="p">;</span>
    <span class="n">maxThicknessToMedialRatio</span>  <span class="mi">1</span><span class="p">;</span>
    <span class="n">minMedianAxisAngle</span>       <span class="mi">130</span><span class="p">;</span>
    <span class="n">nBufferCellsNoExtrude</span>    <span class="mi">0</span><span class="p">;</span>
    <span class="n">nLayerIter</span>               <span class="mi">50</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">meshQualityControls</span>
<span class="p">{</span>
    <span class="cp">#include</span> <span class="cpf">&quot;meshQualityDict&quot;</span><span class="cp"></span>

    <span class="n">maxNonOrtho</span>             <span class="mi">65</span><span class="p">;</span>
    <span class="n">maxBoundarySkewness</span>     <span class="mi">20</span><span class="p">;</span>
    <span class="n">maxInternalSkewness</span>     <span class="mi">4</span><span class="p">;</span>
    <span class="n">maxConcave</span>              <span class="mi">80</span><span class="p">;</span>
    <span class="n">minFlatness</span>             <span class="mf">0.5</span><span class="p">;</span>
    <span class="n">minArea</span>                 <span class="mf">0.01</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">writeFlags</span>
<span class="cm">(</span>
<span class="cm">    scalarLevels</span>
<span class="cm">    layerSets</span>
<span class="cm">    layerFields</span>
<span class="cm">);</span>
<span class="cm">*/</span>

<span class="n">mergeTolerance</span> <span class="mf">1e-6</span><span class="p">;</span>

<span class="c1">// ************************************************************************* //</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id4">
<h3>网格检查<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>在通过blockMesh或snappyHexMesh生成网格之后，可以在算例目录下运行下面的命令来查看网格质量是否合格：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>checkMesh
</pre></div>
</div>
</div>
</div>
<div class="section" id="id5">
<h2>残差监控<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<p>在算例目录下输入下面的命令：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>foamGet residuals
</pre></div>
</div>
<p>选择第一个文件，就会在system文件夹内创建residuals文件，其基本内容如下所示：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="cpf">Etc &quot;caseDicts/postProcessing/numerical/residuals.cfg&quot;</span><span class="cp"></span>

<span class="n">fields</span> <span class="p">(</span><span class="n">p</span> <span class="n">U</span><span class="p">);</span>
</pre></div>
</div>
<p>其中 <code class="code docutils literal notranslate"><span class="pre">fields</span></code> 关键词决定了之后运行的时候需要检测残差变化的变量，可以根据需要自行添加变量名。在写好residuals文件之后，还需要进入controlDict文件中添加下面的内容：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">functions</span>
<span class="p">{</span>
        <span class="cp">#include</span><span class="cpf">Func    residuals</span><span class="cp"></span>
<span class="p">}</span>
</pre></div>
</div>
<p>如此就设定好了残差检测。运行算例之后，就会创建postProcessing/residuals/0/residuals.dat文件，其中记录了之前设置变量的残差变化数据集。</p>
<p>该数据文件的数据是右对齐的，而且通过空格分隔。如果将其转换为csv文件然后用Python来读取，则可以通过下面的方式来进行：（核心是指定分隔符为多位空格”s+”）</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s2">&quot;line.csv&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;\s+&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="physicalproperties">
<h2>physicalProperties文件<a class="headerlink" href="#physicalproperties" title="永久链接至标题">¶</a></h2>
<p>physicalProperties文件给定所有流体属性的参数值，按照“物理量名+量纲+数值”的形式进行定义。量纲由方括号内的七个数定义，七个数代表SI标准和USCS标准的量纲的幂：</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="29%" />
<col width="23%" />
<col width="31%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">编号</th>
<th class="head">名称</th>
<th class="head">SI单位</th>
<th class="head">USCS单位</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>质量</td>
<td>kg</td>
<td>lbm</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>长度</td>
<td>m</td>
<td>ft</td>
</tr>
<tr class="row-even"><td>3</td>
<td>时间</td>
<td>s</td>
<td>s</td>
</tr>
<tr class="row-odd"><td>4</td>
<td>温度</td>
<td>K</td>
<td>°R</td>
</tr>
<tr class="row-even"><td>5</td>
<td>物质的量</td>
<td>kg/mol</td>
<td>lbmol</td>
</tr>
<tr class="row-odd"><td>6</td>
<td>电流</td>
<td>A</td>
<td>A</td>
</tr>
<tr class="row-even"><td>7</td>
<td>光强</td>
<td>cd</td>
<td>cd</td>
</tr>
</tbody>
</table>
<p>常见的物理特性参数的关键字与其对应的量纲如下：</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="14%" />
<col width="13%" />
<col width="36%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">物理特性</th>
<th class="head">符号</th>
<th class="head">关键字</th>
<th class="head">量纲</th>
<th class="head">dimensionSet</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>运动粘度</td>
<td><span class="math notranslate nohighlight">\(\nu\)</span></td>
<td><code class="code docutils literal notranslate"><span class="pre">nu</span></code></td>
<td><span class="math notranslate nohighlight">\(\mathrm{m^{2}\cdot s^{-1}}\)</span></td>
<td><code class="code docutils literal notranslate"><span class="pre">[0</span> <span class="pre">2</span> <span class="pre">-1</span> <span class="pre">0</span> <span class="pre">0</span> <span class="pre">0</span> <span class="pre">0]</span></code></td>
</tr>
<tr class="row-odd"><td>密度</td>
<td><span class="math notranslate nohighlight">\(\rho\)</span></td>
<td><code class="code docutils literal notranslate"><span class="pre">rho</span></code></td>
<td><span class="math notranslate nohighlight">\(\mathrm{kg\cdot m^{-3}}\)</span></td>
<td><code class="code docutils literal notranslate"><span class="pre">[1</span> <span class="pre">-3</span> <span class="pre">0</span> <span class="pre">0</span> <span class="pre">0</span> <span class="pre">0</span> <span class="pre">0]</span></code></td>
</tr>
</tbody>
</table>
<p>应力分析是会用到的物理特性参数：</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="14%" />
<col width="14%" />
<col width="39%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">物理特性</th>
<th class="head">符号</th>
<th class="head">关键字</th>
<th class="head">量纲</th>
<th class="head">dimensionSet</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>密度</td>
<td><span class="math notranslate nohighlight">\(\rho\)</span></td>
<td><code class="code docutils literal notranslate"><span class="pre">rho</span></code></td>
<td><span class="math notranslate nohighlight">\(\mathrm{kg\cdot m^{-3}}\)</span></td>
<td><code class="code docutils literal notranslate"><span class="pre">[1</span> <span class="pre">-3</span> <span class="pre">0</span> <span class="pre">0</span> <span class="pre">0</span> <span class="pre">0</span> <span class="pre">0]</span></code></td>
</tr>
<tr class="row-odd"><td>杨氏模量</td>
<td><span class="math notranslate nohighlight">\(E\)</span></td>
<td><code class="code docutils literal notranslate"><span class="pre">E</span></code></td>
<td><span class="math notranslate nohighlight">\(\mathrm{Pa}\)</span></td>
<td><code class="code docutils literal notranslate"><span class="pre">[1</span> <span class="pre">-1</span> <span class="pre">-2</span> <span class="pre">0</span> <span class="pre">0</span> <span class="pre">0</span> <span class="pre">0]</span></code></td>
</tr>
<tr class="row-even"><td>泊松比</td>
<td><span class="math notranslate nohighlight">\(\nu\)</span></td>
<td><code class="code docutils literal notranslate"><span class="pre">nu</span></code></td>
<td>&#160;</td>
<td><code class="code docutils literal notranslate"><span class="pre">[0</span> <span class="pre">0</span> <span class="pre">0</span> <span class="pre">0</span> <span class="pre">0</span> <span class="pre">0</span> <span class="pre">0]</span></code></td>
</tr>
<tr class="row-odd"><td>比热容</td>
<td><span class="math notranslate nohighlight">\(C_{p}\)</span></td>
<td><code class="code docutils literal notranslate"><span class="pre">Cp</span></code></td>
<td><span class="math notranslate nohighlight">\(\mathrm{J\cdot kg^{-1}\cdot K^{-1}}\)</span></td>
<td><code class="code docutils literal notranslate"><span class="pre">[0</span> <span class="pre">2</span> <span class="pre">-2</span> <span class="pre">-1</span> <span class="pre">0</span> <span class="pre">0</span> <span class="pre">0]</span></code></td>
</tr>
<tr class="row-even"><td>热导率</td>
<td><span class="math notranslate nohighlight">\(\kappa\)</span></td>
<td><code class="code docutils literal notranslate"><span class="pre">kappa</span></code></td>
<td><span class="math notranslate nohighlight">\(\mathrm{W\cdot m^{-1}\cdot K^{-1}}\)</span></td>
<td><code class="code docutils literal notranslate"><span class="pre">[1</span> <span class="pre">1</span> <span class="pre">-3</span> <span class="pre">-1</span> <span class="pre">0</span> <span class="pre">0</span> <span class="pre">0]</span></code></td>
</tr>
<tr class="row-odd"><td>热膨胀系数</td>
<td><span class="math notranslate nohighlight">\(\alpha\)</span></td>
<td><code class="code docutils literal notranslate"><span class="pre">alphav</span></code></td>
<td><span class="math notranslate nohighlight">\(\mathrm{K^{-1}}\)</span></td>
<td><code class="code docutils literal notranslate"><span class="pre">[0</span> <span class="pre">0</span> <span class="pre">0</span> <span class="pre">-1</span> <span class="pre">0</span> <span class="pre">0</span> <span class="pre">0]</span></code></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id6">
<h2>热物理模型<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<p>每个调用热物理模型库的求解器均会构建一个具体的热物理模型类。每个组分都需要输入基本的热物理参数。他们必须以组分名作为关键词，其后是子字典，包含的参数主要有specie、thermoDynamics、transport。下面是一个经典的设置案例：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">thermoType</span>
<span class="p">{</span>
    <span class="n">type</span>            <span class="n">hePsiThermo</span><span class="p">;</span>
    <span class="n">mixture</span>         <span class="n">pureMixture</span><span class="p">;</span>
    <span class="n">transport</span>       <span class="k">const</span><span class="p">;</span>
    <span class="n">thermo</span>          <span class="n">hConst</span><span class="p">;</span>
    <span class="n">equationOfState</span> <span class="n">perfectGas</span><span class="p">;</span>
    <span class="n">specie</span>          <span class="n">specie</span><span class="p">;</span>
    <span class="n">energy</span>          <span class="n">sensibleInternalEnergy</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">mixture</span>
<span class="p">{</span>
    <span class="n">specie</span>
    <span class="p">{</span>
        <span class="n">molWeight</span>       <span class="mi">352</span><span class="p">;</span>  <span class="c1">// 摩尔质量g/mol</span>
    <span class="p">}</span>
    <span class="n">thermodynamics</span>
    <span class="p">{</span>
        <span class="n">Cp</span>              <span class="mi">385</span><span class="p">;</span>  <span class="c1">// J/(kg.K)</span>
        <span class="n">Hf</span>              <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">transport</span>
    <span class="p">{</span>
        <span class="n">mu</span>              <span class="mf">1.83e-5</span><span class="p">;</span>  <span class="c1">// Pa.s</span>
        <span class="n">Pr</span>              <span class="mf">1.155</span><span class="p">;</span>    <span class="c1">// 普朗特数</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="thermotype">
<h3>thermoType<a class="headerlink" href="#thermotype" title="永久链接至标题">¶</a></h3>
<p>在physicalProperties文件中的thermoType关键词下指定运行中的热物理模型。</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="34%" />
<col width="58%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">热物理模型类</th>
<th class="head">简介</th>
<th class="head">涉及求解器</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>psiThermo</td>
<td>固定组分、基于可压缩性 <span class="math notranslate nohighlight">\(\psi = (RT)^{-1}\)</span> 的热物理模型库， <span class="math notranslate nohighlight">\(R\)</span> 为理想气体常数， <span class="math notranslate nohighlight">\(T\)</span> 为温度</td>
<td>调用该类的求解器主要为可压缩求解器，例如rhoCentralFoam、uncoupledKinematicParcelFoam以及coldEngineFoam</td>
</tr>
<tr class="row-odd"><td>rhoThermo</td>
<td>固定组分、基于密度 <span class="math notranslate nohighlight">\(\rho\)</span> 的热物理模型库</td>
<td>调用该类的求解器主要为传热类求解器，例如 buoyantSimpleFoam、buoyantPimpleFoam、rhoPorousSimpleFoam、twoPhaseEulerFoam以及thermoFoam</td>
</tr>
<tr class="row-even"><td>psiReactionThermo</td>
<td>基于可压缩性 <span class="math notranslate nohighlight">\(\psi\)</span> 的附加反应的热物理模型库</td>
<td>调用该类的求解器主要为燃烧求解器，例如sprayFoam、engineFoam、fireFoam、reactingFoam，以及一些拉格朗日求解器，例如coalChemistryFoam</td>
</tr>
<tr class="row-odd"><td>psiuReactionThermo</td>
<td>基于未燃气体可压缩性 <span class="math notranslate nohighlight">\(\psi u\)</span> 的反应混合热物理模型库</td>
<td>调用该类的求解器主要为燃烧求解器，这些求解器的物理模型基于层流火焰速度以及回归变量，如XiFoam、XiEngineFoam和PDRFoam</td>
</tr>
<tr class="row-even"><td>rhoReactionThermo</td>
<td>基于密度 <span class="math notranslate nohighlight">\(\rho\)</span> 的反应混合热物理模型库</td>
<td>调用该类的求解器主要为chtMultiRegionFoam以及一些燃烧求解器，如chemFoam、rhoReactinFoam、rhoReactingBuoyantFoam， 以及一些拉格朗日求解器，如reactingParcelFoam和simpleReactingParcelFoam</td>
</tr>
<tr class="row-odd"><td>multiPhaseMixtureThermo</td>
<td>多相流热物理模型库</td>
<td>调用该类的求解器主要为可压缩多相界面捕获求解器，如compressibleInterFoam、compressibleMultiphaseInterFoam</td>
</tr>
</tbody>
</table>
<div class="section" id="hethermo">
<h4>heThermo<a class="headerlink" href="#hethermo" title="永久链接至标题">¶</a></h4>
<div class="literal-block-wrapper docutils container" id="id46">
<div class="code-block-caption"><span class="caption-text">src/thermophysicalModels/basic/heThermo/heThermo.C</span><a class="headerlink" href="#id46" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">template</span>
<span class="o">&lt;</span>
    <span class="n">class</span> <span class="n">CellMixture</span><span class="p">,</span>
    <span class="n">class</span> <span class="n">PatchFaceMixture</span><span class="p">,</span>
    <span class="n">class</span> <span class="n">Method</span><span class="p">,</span>
    <span class="n">class</span> <span class="p">...</span> <span class="n">Args</span>
<span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">volScalarField</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">volScalarFieldProperty</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">word</span><span class="o">&amp;</span> <span class="n">psiName</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">dimensionSet</span><span class="o">&amp;</span> <span class="n">psiDim</span><span class="p">,</span>
    <span class="n">CellMixture</span> <span class="n">cellMixture</span><span class="p">,</span>
    <span class="n">PatchFaceMixture</span> <span class="n">patchFaceMixture</span><span class="p">,</span>
    <span class="n">Method</span> <span class="n">psiMethod</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span> <span class="p">...</span> <span class="n">args</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">tPsi</span>    <span class="c1">// 利用传入的名称和量纲创建该物理量对象</span>
    <span class="p">(</span>
        <span class="n">volScalarField</span><span class="o">::</span><span class="n">New</span>
        <span class="p">(</span>
            <span class="n">IOobject</span><span class="o">::</span><span class="n">groupName</span><span class="p">(</span><span class="n">psiName</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">group</span><span class="p">()),</span>
            <span class="n">this</span><span class="o">-&gt;</span><span class="n">T_</span><span class="p">.</span><span class="n">mesh</span><span class="p">(),</span>
            <span class="n">psiDim</span>
        <span class="p">)</span>
    <span class="p">);</span>

    <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">psi</span> <span class="o">=</span> <span class="n">tPsi</span><span class="p">.</span><span class="n">ref</span><span class="p">();</span>

    <span class="n">forAll</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">T_</span><span class="p">,</span> <span class="n">celli</span><span class="p">)</span>    <span class="c1">// 利用传入的cellMixture规定的psiMethod来计算网格体心处该物理量的值</span>
    <span class="p">{</span>
        <span class="n">psi</span><span class="p">[</span><span class="n">celli</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">this</span><span class="o">-&gt;*</span><span class="n">cellMixture</span><span class="p">)(</span><span class="n">celli</span><span class="p">).</span><span class="o">*</span><span class="n">psiMethod</span><span class="p">)(</span><span class="n">args</span><span class="p">[</span><span class="n">celli</span><span class="p">]</span> <span class="p">...);</span>
    <span class="p">}</span>

    <span class="n">volScalarField</span><span class="o">::</span><span class="n">Boundary</span><span class="o">&amp;</span> <span class="n">psiBf</span> <span class="o">=</span> <span class="n">psi</span><span class="p">.</span><span class="n">boundaryFieldRef</span><span class="p">();</span>

    <span class="n">forAll</span><span class="p">(</span><span class="n">psiBf</span><span class="p">,</span> <span class="n">patchi</span><span class="p">)</span>    <span class="c1">// 利用传入的patchFaceMixture规定的psiMethod来计算边界处该物理量的值</span>
    <span class="p">{</span>
        <span class="n">fvPatchScalarField</span><span class="o">&amp;</span> <span class="n">pPsi</span> <span class="o">=</span> <span class="n">psiBf</span><span class="p">[</span><span class="n">patchi</span><span class="p">];</span>

        <span class="n">forAll</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">T_</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">],</span> <span class="n">facei</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">pPsi</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">this</span><span class="o">-&gt;*</span><span class="n">patchFaceMixture</span><span class="p">)(</span><span class="n">patchi</span><span class="p">,</span> <span class="n">facei</span><span class="p">).</span><span class="o">*</span><span class="n">psiMethod</span><span class="p">)(</span><span class="n">args</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">][</span><span class="n">facei</span><span class="p">]</span> <span class="p">...);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">tPsi</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">CellMixture</span><span class="p">,</span> <span class="n">class</span> <span class="n">Method</span><span class="p">,</span> <span class="n">class</span> <span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">scalarField</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">cellSetProperty</span>
<span class="p">(</span>
    <span class="n">CellMixture</span> <span class="n">cellMixture</span><span class="p">,</span>
    <span class="n">Method</span> <span class="n">psiMethod</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">labelList</span><span class="o">&amp;</span> <span class="n">cells</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span> <span class="p">...</span> <span class="n">args</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="c1">// Note: Args are fields for the set, not for the mesh as a whole. The cells list is only used to get the mixture.</span>
    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">scalarField</span><span class="o">&gt;</span> <span class="n">tPsi</span><span class="p">(</span><span class="n">new</span> <span class="n">scalarField</span><span class="p">(</span><span class="n">cells</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>    <span class="c1">// 在传入的网格位置创建该物理量的对象</span>
    <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">psi</span> <span class="o">=</span> <span class="n">tPsi</span><span class="p">.</span><span class="n">ref</span><span class="p">();</span>

    <span class="n">forAll</span><span class="p">(</span><span class="n">cells</span><span class="p">,</span> <span class="n">celli</span><span class="p">)</span>    <span class="c1">// 利用传入的cellMixture规定的psiMethod来计算该物理量的值</span>
    <span class="p">{</span>
        <span class="n">psi</span><span class="p">[</span><span class="n">celli</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">this</span><span class="o">-&gt;*</span><span class="n">cellMixture</span><span class="p">)(</span><span class="n">cells</span><span class="p">[</span><span class="n">celli</span><span class="p">]).</span><span class="o">*</span><span class="n">psiMethod</span><span class="p">)(</span><span class="n">args</span><span class="p">[</span><span class="n">celli</span><span class="p">]</span> <span class="p">...);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">tPsi</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">PatchFaceMixture</span><span class="p">,</span> <span class="n">class</span> <span class="n">Method</span><span class="p">,</span> <span class="n">class</span> <span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">scalarField</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">patchFieldProperty</span>
<span class="p">(</span>
    <span class="n">PatchFaceMixture</span> <span class="n">patchFaceMixture</span><span class="p">,</span>
    <span class="n">Method</span> <span class="n">psiMethod</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">label</span> <span class="n">patchi</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span> <span class="p">...</span> <span class="n">args</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">scalarField</span><span class="o">&gt;</span> <span class="n">tPsi</span>    <span class="c1">// 在网格边界处新建该物理量的对象</span>
    <span class="p">(</span>
        <span class="n">new</span> <span class="n">scalarField</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">T_</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">].</span><span class="n">size</span><span class="p">())</span>
    <span class="p">);</span>
    <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">psi</span> <span class="o">=</span> <span class="n">tPsi</span><span class="p">.</span><span class="n">ref</span><span class="p">();</span>

    <span class="n">forAll</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">T_</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">],</span> <span class="n">facei</span><span class="p">)</span>    <span class="c1">// 利用传入的patchFaceMixture规定的psiMethod来计算该物理量的值</span>
    <span class="p">{</span>
        <span class="n">psi</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">this</span><span class="o">-&gt;*</span><span class="n">patchFaceMixture</span><span class="p">)(</span><span class="n">patchi</span><span class="p">,</span> <span class="n">facei</span><span class="p">).</span><span class="o">*</span><span class="n">psiMethod</span><span class="p">)(</span><span class="n">args</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="p">...);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">tPsi</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">UIndirectList</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">cellSetScalarList</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">psi</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">labelList</span><span class="o">&amp;</span> <span class="n">cells</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">UIndirectList</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">cells</span><span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">UniformField</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">cellSetScalarList</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">uniformGeometricScalarField</span><span class="o">&amp;</span> <span class="n">psi</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">labelList</span><span class="o">&amp;</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">psi</span><span class="p">.</span><span class="n">primitiveField</span><span class="p">();</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span>
<span class="n">heBoundaryCorrection</span><span class="p">(</span><span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">volScalarField</span><span class="o">::</span><span class="n">Boundary</span><span class="o">&amp;</span> <span class="n">hBf</span> <span class="o">=</span> <span class="n">h</span><span class="p">.</span><span class="n">boundaryFieldRef</span><span class="p">();</span>

    <span class="n">forAll</span><span class="p">(</span><span class="n">hBf</span><span class="p">,</span> <span class="n">patchi</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">isA</span><span class="o">&lt;</span><span class="n">gradientEnergyFvPatchScalarField</span><span class="o">&gt;</span><span class="p">(</span><span class="n">hBf</span><span class="p">[</span><span class="n">patchi</span><span class="p">]))</span>
        <span class="p">{</span>
            <span class="n">refCast</span><span class="o">&lt;</span><span class="n">gradientEnergyFvPatchScalarField</span><span class="o">&gt;</span><span class="p">(</span><span class="n">hBf</span><span class="p">[</span><span class="n">patchi</span><span class="p">]).</span><span class="n">gradient</span><span class="p">()</span> <span class="o">=</span> <span class="n">hBf</span><span class="p">[</span><span class="n">patchi</span><span class="p">].</span><span class="n">fvPatchField</span><span class="o">::</span><span class="n">snGrad</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">isA</span><span class="o">&lt;</span><span class="n">mixedEnergyFvPatchScalarField</span><span class="o">&gt;</span><span class="p">(</span><span class="n">hBf</span><span class="p">[</span><span class="n">patchi</span><span class="p">]))</span>
        <span class="p">{</span>
            <span class="n">refCast</span><span class="o">&lt;</span><span class="n">mixedEnergyFvPatchScalarField</span><span class="o">&gt;</span><span class="p">(</span><span class="n">hBf</span><span class="p">[</span><span class="n">patchi</span><span class="p">]).</span><span class="n">refGrad</span><span class="p">()</span> <span class="o">=</span> <span class="n">hBf</span><span class="p">[</span><span class="n">patchi</span><span class="p">].</span><span class="n">fvPatchField</span><span class="o">::</span><span class="n">snGrad</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="c1">// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">heThermo</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">fvMesh</span><span class="o">&amp;</span> <span class="n">mesh</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">word</span><span class="o">&amp;</span> <span class="n">phaseName</span>
<span class="p">)</span>
<span class="o">:</span>
    <span class="n">BasicThermo</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">phaseName</span><span class="p">),</span>
    <span class="n">MixtureType</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">phaseName</span><span class="p">),</span>

    <span class="n">he_</span>
    <span class="p">(</span>
        <span class="n">IOobject</span>
        <span class="p">(</span>
            <span class="n">BasicThermo</span><span class="o">::</span><span class="n">phasePropertyName</span>
            <span class="p">(</span>
                <span class="n">MixtureType</span><span class="o">::</span><span class="n">thermoType</span><span class="o">::</span><span class="n">heName</span><span class="p">(),</span>
                <span class="n">phaseName</span>
            <span class="p">),</span>
            <span class="n">mesh</span><span class="p">.</span><span class="n">time</span><span class="p">().</span><span class="n">timeName</span><span class="p">(),</span>
            <span class="n">mesh</span><span class="p">,</span>
            <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_READ</span><span class="p">,</span>
            <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_WRITE</span>
        <span class="p">),</span>
        <span class="n">volScalarFieldProperty</span>
        <span class="p">(</span>
            <span class="s">&quot;he&quot;</span><span class="p">,</span>
            <span class="n">dimEnergy</span><span class="o">/</span><span class="n">dimMass</span><span class="p">,</span>
            <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">cellThermoMixture</span><span class="p">,</span>
            <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">patchFaceThermoMixture</span><span class="p">,</span>
            <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">thermoMixtureType</span><span class="o">::</span><span class="n">HE</span><span class="p">,</span>
            <span class="n">this</span><span class="o">-&gt;</span><span class="n">p_</span><span class="p">,</span>
            <span class="n">this</span><span class="o">-&gt;</span><span class="n">T_</span>
        <span class="p">),</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">heBoundaryTypes</span><span class="p">(),</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">heBoundaryBaseTypes</span><span class="p">()</span>
    <span class="p">),</span>

    <span class="n">Cp_</span>
    <span class="p">(</span>
        <span class="n">IOobject</span>
        <span class="p">(</span>
            <span class="n">BasicThermo</span><span class="o">::</span><span class="n">phasePropertyName</span><span class="p">(</span><span class="s">&quot;Cp&quot;</span><span class="p">,</span> <span class="n">phaseName</span><span class="p">),</span>
            <span class="n">mesh</span><span class="p">.</span><span class="n">time</span><span class="p">().</span><span class="n">timeName</span><span class="p">(),</span>
            <span class="n">mesh</span>
        <span class="p">),</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">dimensionedScalar</span><span class="p">(</span><span class="n">dimEnergy</span><span class="o">/</span><span class="n">dimMass</span><span class="o">/</span><span class="n">dimTemperature</span><span class="p">,</span> <span class="n">Zero</span><span class="p">)</span>
    <span class="p">),</span>

    <span class="n">Cv_</span>
    <span class="p">(</span>
        <span class="n">IOobject</span>
        <span class="p">(</span>
            <span class="n">BasicThermo</span><span class="o">::</span><span class="n">phasePropertyName</span><span class="p">(</span><span class="s">&quot;Cv&quot;</span><span class="p">,</span> <span class="n">phaseName</span><span class="p">),</span>
            <span class="n">mesh</span><span class="p">.</span><span class="n">time</span><span class="p">().</span><span class="n">timeName</span><span class="p">(),</span>
            <span class="n">mesh</span>
        <span class="p">),</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">dimensionedScalar</span><span class="p">(</span><span class="n">dimEnergy</span><span class="o">/</span><span class="n">dimMass</span><span class="o">/</span><span class="n">dimTemperature</span><span class="p">,</span> <span class="n">Zero</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">{</span>
    <span class="n">heBoundaryCorrection</span><span class="p">(</span><span class="n">he_</span><span class="p">);</span>
<span class="p">}</span>


<span class="c1">// * * * * * * * * * * * * * * * * Destructor  * * * * * * * * * * * * * * * //</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::~</span><span class="n">heThermo</span><span class="p">()</span>
<span class="p">{}</span>


<span class="c1">// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">he</span>    <span class="c1">// 焓或者内能</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">T</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">volScalarFieldProperty</span>
    <span class="p">(</span>
        <span class="s">&quot;he&quot;</span><span class="p">,</span>
        <span class="n">dimEnergy</span><span class="o">/</span><span class="n">dimMass</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">cellThermoMixture</span><span class="p">,</span>         <span class="c1">// mixture定义</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">patchFaceThermoMixture</span><span class="p">,</span>    <span class="c1">// mixture定义</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">thermoMixtureType</span><span class="o">::</span><span class="n">HE</span><span class="p">,</span>     <span class="c1">// energy定义</span>
        <span class="n">p</span><span class="p">,</span>
        <span class="n">T</span>
    <span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">scalarField</span><span class="o">&gt;</span> <span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">he</span>    <span class="c1">// 焓或者内能</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">T</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">labelList</span><span class="o">&amp;</span> <span class="n">cells</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">cellSetProperty</span>
    <span class="p">(</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">cellThermoMixture</span><span class="p">,</span>        <span class="c1">// mixture定义</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">thermoMixtureType</span><span class="o">::</span><span class="n">HE</span><span class="p">,</span>    <span class="c1">// energy定义</span>
        <span class="n">cells</span><span class="p">,</span>
        <span class="n">cellSetScalarList</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">p_</span><span class="p">,</span> <span class="n">cells</span><span class="p">),</span>
        <span class="n">T</span>
    <span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">scalarField</span><span class="o">&gt;</span> <span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">he</span>    <span class="c1">// 焓或者内能</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">T</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">label</span> <span class="n">patchi</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">patchFieldProperty</span>
    <span class="p">(</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">patchFaceThermoMixture</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">thermoMixtureType</span><span class="o">::</span><span class="n">HE</span><span class="p">,</span>
        <span class="n">patchi</span><span class="p">,</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">p_</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">],</span>
        <span class="n">T</span>
    <span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">volScalarField</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">hs</span><span class="p">()</span> <span class="k">const</span>    <span class="c1">// 显焓</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">volScalarFieldProperty</span>
    <span class="p">(</span>
        <span class="s">&quot;hs&quot;</span><span class="p">,</span>
        <span class="n">dimEnergy</span><span class="o">/</span><span class="n">dimMass</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">cellThermoMixture</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">patchFaceThermoMixture</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">thermoMixtureType</span><span class="o">::</span><span class="n">Hs</span><span class="p">,</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">p_</span><span class="p">,</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">T_</span>
    <span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">hs</span>    <span class="c1">// 显焓</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">T</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">volScalarFieldProperty</span>
    <span class="p">(</span>
        <span class="s">&quot;hs&quot;</span><span class="p">,</span>
        <span class="n">dimEnergy</span><span class="o">/</span><span class="n">dimMass</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">cellThermoMixture</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">patchFaceThermoMixture</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">thermoMixtureType</span><span class="o">::</span><span class="n">Hs</span><span class="p">,</span>
        <span class="n">p</span><span class="p">,</span>
        <span class="n">T</span>
    <span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">scalarField</span><span class="o">&gt;</span> <span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">hs</span>    <span class="c1">// 显焓</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">T</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">labelList</span><span class="o">&amp;</span> <span class="n">cells</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">cellSetProperty</span>
    <span class="p">(</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">cellThermoMixture</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">thermoMixtureType</span><span class="o">::</span><span class="n">Hs</span><span class="p">,</span>
        <span class="n">cells</span><span class="p">,</span>
        <span class="n">cellSetScalarList</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">p_</span><span class="p">,</span> <span class="n">cells</span><span class="p">),</span>
        <span class="n">T</span>
    <span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">scalarField</span><span class="o">&gt;</span> <span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">hs</span>    <span class="c1">// 显焓</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">T</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">label</span> <span class="n">patchi</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">patchFieldProperty</span>
    <span class="p">(</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">patchFaceThermoMixture</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">thermoMixtureType</span><span class="o">::</span><span class="n">Hs</span><span class="p">,</span>
        <span class="n">patchi</span><span class="p">,</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">p_</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">],</span>
        <span class="n">T</span>
    <span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">volScalarField</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">ha</span><span class="p">()</span> <span class="k">const</span>    <span class="c1">// 绝对焓</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">volScalarFieldProperty</span>
    <span class="p">(</span>
        <span class="s">&quot;ha&quot;</span><span class="p">,</span>
        <span class="n">dimEnergy</span><span class="o">/</span><span class="n">dimMass</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">cellThermoMixture</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">patchFaceThermoMixture</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">thermoMixtureType</span><span class="o">::</span><span class="n">Ha</span><span class="p">,</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">p_</span><span class="p">,</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">T_</span>
    <span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">ha</span>    <span class="c1">// 绝对焓</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">T</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">volScalarFieldProperty</span>
    <span class="p">(</span>
        <span class="s">&quot;ha&quot;</span><span class="p">,</span>
        <span class="n">dimEnergy</span><span class="o">/</span><span class="n">dimMass</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">cellThermoMixture</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">patchFaceThermoMixture</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">thermoMixtureType</span><span class="o">::</span><span class="n">Ha</span><span class="p">,</span>
        <span class="n">p</span><span class="p">,</span>
        <span class="n">T</span>
    <span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">scalarField</span><span class="o">&gt;</span> <span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">ha</span>    <span class="c1">// 绝对焓</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">T</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">labelList</span><span class="o">&amp;</span> <span class="n">cells</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">cellSetProperty</span>
    <span class="p">(</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">cellThermoMixture</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">thermoMixtureType</span><span class="o">::</span><span class="n">Ha</span><span class="p">,</span>
        <span class="n">cells</span><span class="p">,</span>
        <span class="n">cellSetScalarList</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">p_</span><span class="p">,</span> <span class="n">cells</span><span class="p">),</span>
        <span class="n">T</span>
    <span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">scalarField</span><span class="o">&gt;</span> <span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">ha</span>    <span class="c1">// 绝对焓</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">T</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">label</span> <span class="n">patchi</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">patchFieldProperty</span>
    <span class="p">(</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">patchFaceThermoMixture</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">thermoMixtureType</span><span class="o">::</span><span class="n">Ha</span><span class="p">,</span>
        <span class="n">patchi</span><span class="p">,</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">p_</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">],</span>
        <span class="n">T</span>
    <span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">volScalarField</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">hc</span><span class="p">()</span> <span class="k">const</span>    <span class="c1">// 生成焓</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">volScalarFieldProperty</span>
    <span class="p">(</span>
        <span class="s">&quot;hc&quot;</span><span class="p">,</span>
        <span class="n">dimEnergy</span><span class="o">/</span><span class="n">dimMass</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">cellThermoMixture</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">patchFaceThermoMixture</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">thermoMixtureType</span><span class="o">::</span><span class="n">Hf</span>
    <span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">scalarField</span><span class="o">&gt;</span> <span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">Cp</span>    <span class="c1">// 定压比热容</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">T</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">label</span> <span class="n">patchi</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">patchFieldProperty</span>
    <span class="p">(</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">patchFaceThermoMixture</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">thermoMixtureType</span><span class="o">::</span><span class="n">Cp</span><span class="p">,</span>
        <span class="n">patchi</span><span class="p">,</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">p_</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">],</span>
        <span class="n">T</span>
    <span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">scalarField</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">Cv</span>    <span class="c1">// 定体比热容</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">T</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">label</span> <span class="n">patchi</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">patchFieldProperty</span>
    <span class="p">(</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">patchFaceThermoMixture</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">thermoMixtureType</span><span class="o">::</span><span class="n">Cv</span><span class="p">,</span>
        <span class="n">patchi</span><span class="p">,</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">p_</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">],</span>
        <span class="n">T</span>
    <span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">scalarField</span><span class="o">&gt;</span> <span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">gamma</span>    <span class="c1">// 比热容比</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">T</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">label</span> <span class="n">patchi</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">patchFieldProperty</span>
    <span class="p">(</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">patchFaceThermoMixture</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">thermoMixtureType</span><span class="o">::</span><span class="n">gamma</span><span class="p">,</span>
        <span class="n">patchi</span><span class="p">,</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">p_</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">],</span>
        <span class="n">T</span>
    <span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">volScalarField</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">gamma</span><span class="p">()</span> <span class="k">const</span>    <span class="c1">// 比热容比</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">volScalarField</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="s">&quot;gamma&quot;</span><span class="p">,</span> <span class="n">Cp_</span><span class="o">/</span><span class="n">Cv_</span><span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">scalarField</span><span class="o">&gt;</span> <span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">Cpv</span>    <span class="c1">// 定压比热容或定体比热容</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">T</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">label</span> <span class="n">patchi</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">thermoType</span><span class="o">::</span><span class="n">enthalpy</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Cp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">patchi</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Cv</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">patchi</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">volScalarField</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">Cpv</span><span class="p">()</span> <span class="k">const</span>    <span class="c1">// 定压比热容或定体比热容</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">thermoType</span><span class="o">::</span><span class="n">enthalpy</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Cp_</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Cv_</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">THE</span>    <span class="c1">// 由焓或内能得到的温度</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">h</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">T0</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">volScalarFieldProperty</span>
    <span class="p">(</span>
        <span class="s">&quot;T&quot;</span><span class="p">,</span>
        <span class="n">dimTemperature</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">cellThermoMixture</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">patchFaceThermoMixture</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">thermoMixtureType</span><span class="o">::</span><span class="n">THE</span><span class="p">,</span>
        <span class="n">h</span><span class="p">,</span>
        <span class="n">p</span><span class="p">,</span>
        <span class="n">T0</span>
    <span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">scalarField</span><span class="o">&gt;</span> <span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">THE</span>    <span class="c1">// 由焓或内能得到的温度</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">h</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">T0</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">labelList</span><span class="o">&amp;</span> <span class="n">cells</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">cellSetProperty</span>
    <span class="p">(</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">cellThermoMixture</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">thermoMixtureType</span><span class="o">::</span><span class="n">THE</span><span class="p">,</span>
        <span class="n">cells</span><span class="p">,</span>
        <span class="n">h</span><span class="p">,</span>
        <span class="n">cellSetScalarList</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">p_</span><span class="p">,</span> <span class="n">cells</span><span class="p">),</span>
        <span class="n">T0</span>
    <span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">scalarField</span><span class="o">&gt;</span> <span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">THE</span>    <span class="c1">// 由焓或内能得到的温度</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">h</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">T0</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">label</span> <span class="n">patchi</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">patchFieldProperty</span>
    <span class="p">(</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">patchFaceThermoMixture</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">thermoMixtureType</span><span class="o">::</span><span class="n">THE</span><span class="p">,</span>
        <span class="n">patchi</span><span class="p">,</span>
        <span class="n">h</span><span class="p">,</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">p_</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">],</span>
        <span class="n">T0</span>
    <span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">volScalarField</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">W</span><span class="p">()</span> <span class="k">const</span>    <span class="c1">// 分子量</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">volScalarFieldProperty</span>
    <span class="p">(</span>
        <span class="s">&quot;W&quot;</span><span class="p">,</span>
        <span class="n">dimMass</span><span class="o">/</span><span class="n">dimMoles</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">cellThermoMixture</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">patchFaceThermoMixture</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">thermoMixtureType</span><span class="o">::</span><span class="n">W</span>
    <span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">scalarField</span><span class="o">&gt;</span> <span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">W</span>    <span class="c1">// 分子量</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">label</span> <span class="n">patchi</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">patchFieldProperty</span>
    <span class="p">(</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">patchFaceThermoMixture</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">thermoMixtureType</span><span class="o">::</span><span class="n">W</span><span class="p">,</span>
        <span class="n">patchi</span>
    <span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">volScalarField</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">alphahe</span><span class="p">()</span> <span class="k">const</span>    <span class="c1">// 混合物能量的热扩散率</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">thermoType</span><span class="o">::</span><span class="n">enthalpy</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">volScalarField</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="s">&quot;alphahe&quot;</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">kappa_</span><span class="o">/</span><span class="n">Cp_</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">volScalarField</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="s">&quot;alphahe&quot;</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">kappa_</span><span class="o">/</span><span class="n">Cv_</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">scalarField</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">alphahe</span><span class="p">(</span><span class="k">const</span> <span class="n">label</span> <span class="n">patchi</span><span class="p">)</span> <span class="k">const</span>    <span class="c1">// 混合物能量的热扩散率</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">thermoType</span><span class="o">::</span><span class="n">enthalpy</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">kappa_</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">]</span><span class="o">/</span><span class="n">Cp_</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">kappa_</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">]</span><span class="o">/</span><span class="n">Cv_</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">volScalarField</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">kappaEff</span>    <span class="c1">// 混合物的有效湍流热导率</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">alphat</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">volScalarField</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="s">&quot;kappaEff&quot;</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">kappa_</span> <span class="o">+</span> <span class="n">Cp_</span><span class="o">*</span><span class="n">alphat</span><span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">scalarField</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">kappaEff</span>    <span class="c1">// 混合物的有效湍流热导率</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">alphat</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">label</span> <span class="n">patchi</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">kappa_</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">]</span> <span class="o">+</span> <span class="n">Cp</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">T_</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">],</span> <span class="n">patchi</span><span class="p">)</span><span class="o">*</span><span class="n">alphat</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">volScalarField</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">alphaEff</span>    <span class="c1">// 混合物的有效湍流热扩散系数</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">alphat</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">thermoType</span><span class="o">::</span><span class="n">enthalpy</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">volScalarField</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="s">&quot;alphaEff&quot;</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">kappa_</span><span class="o">/</span><span class="n">Cp_</span> <span class="o">+</span> <span class="n">alphat</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">volScalarField</span><span class="o">::</span><span class="n">New</span>
        <span class="p">(</span>
            <span class="s">&quot;alphaEff&quot;</span><span class="p">,</span>
            <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">kappa_</span> <span class="o">+</span> <span class="n">Cp_</span><span class="o">*</span><span class="n">alphat</span><span class="p">)</span><span class="o">/</span><span class="n">Cv_</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">scalarField</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">alphaEff</span>    <span class="c1">// 混合物的有效湍流热扩散系数</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">alphat</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">label</span> <span class="n">patchi</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">MixtureType</span><span class="o">::</span><span class="n">thermoType</span><span class="o">::</span><span class="n">enthalpy</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">kappa_</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">]</span><span class="o">/</span><span class="n">Cp_</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">]</span> <span class="o">+</span> <span class="n">alphat</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">kappa_</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">]</span> <span class="o">+</span> <span class="n">Cp_</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">]</span><span class="o">*</span><span class="n">alphat</span><span class="p">)</span><span class="o">/</span><span class="n">Cv_</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">Foam</span><span class="o">::</span><span class="n">heThermo</span><span class="o">&lt;</span><span class="n">BasicThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">read</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">BasicThermo</span><span class="o">::</span><span class="n">read</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">MixtureType</span><span class="o">::</span><span class="n">read</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>使用上述的构建模板，heThermo建立了如下的场：</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">符号</th>
<th class="head">含义</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>he</td>
<td>焓/内能</td>
</tr>
<tr class="row-odd"><td>Cp</td>
<td>定压比热容</td>
</tr>
<tr class="row-even"><td>Cv</td>
<td>定体比热容</td>
</tr>
<tr class="row-odd"><td>hs</td>
<td>显焓</td>
</tr>
<tr class="row-even"><td>ha</td>
<td>绝对焓</td>
</tr>
<tr class="row-odd"><td>hc</td>
<td>生成焓</td>
</tr>
<tr class="row-even"><td>THE</td>
<td>由焓/内能得到的温度</td>
</tr>
<tr class="row-odd"><td>gamma</td>
<td>比热容比，为 <span class="math notranslate nohighlight">\(c_{p}/c_{v}\)</span></td>
</tr>
<tr class="row-even"><td>Cpv</td>
<td>在恒压/恒容条件下的比热容，当使用焓时为 <span class="math notranslate nohighlight">\(c_{p}\)</span> ；当使用内能时为 <span class="math notranslate nohighlight">\(c_{v}\)</span></td>
</tr>
<tr class="row-odd"><td>W</td>
<td>分子量</td>
</tr>
<tr class="row-even"><td>alphahe</td>
<td>混合物能量的热扩散率，当使用焓时为 <span class="math notranslate nohighlight">\(\kappa/c_{p}\)</span> ；当使用内能时为 <span class="math notranslate nohighlight">\(\kappa/c_{v}\)</span></td>
</tr>
<tr class="row-odd"><td>kappaEff</td>
<td>混合物的有效热湍导率，为 <span class="math notranslate nohighlight">\(\kappa + c_{p}\alpha_{t}\)</span></td>
</tr>
<tr class="row-even"><td>alphaEff</td>
<td>混合物能量的有效湍流热扩散系数，当使用焓时为 <span class="math notranslate nohighlight">\(\kappa/c_{p} + \alpha_{t}\)</span> ；当使用内能时为 <span class="math notranslate nohighlight">\((\kappa + c_{p}\alpha_{t})/c_{v}\)</span></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="psithermo">
<h4>psiThermo<a class="headerlink" href="#psithermo" title="永久链接至标题">¶</a></h4>
<p>进入src/thermophysicalModels/basic/psiThermo/psiThermo.C文件，可以看到如下代码：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">psiThermo</span><span class="o">::</span><span class="n">correctRho</span><span class="p">(</span><span class="k">const</span> <span class="n">Foam</span><span class="o">::</span><span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">deltaRho</span><span class="p">)</span>
<span class="p">{}</span>

<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">Foam</span><span class="o">::</span><span class="n">psiThermo</span><span class="o">::</span><span class="n">implementation</span><span class="o">::</span><span class="n">rho</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">()</span><span class="o">*</span><span class="n">psi_</span><span class="p">;</span>    <span class="c1">// 利用可压缩性计算密度场的方式为 p*psi</span>
<span class="p">}</span>

<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">scalarField</span><span class="o">&gt;</span> <span class="n">Foam</span><span class="o">::</span><span class="n">psiThermo</span><span class="o">::</span><span class="n">implementation</span><span class="o">::</span><span class="n">rho</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">label</span> <span class="n">patchi</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">().</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">]</span><span class="o">*</span><span class="n">psi_</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">];</span>    <span class="c1">// 边界处的密度场计算方式</span>
<span class="p">}</span>

<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">Foam</span><span class="o">::</span><span class="n">psiThermo</span><span class="o">::</span><span class="n">implementation</span><span class="o">::</span><span class="n">rho0</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">().</span><span class="n">oldTime</span><span class="p">()</span><span class="o">*</span><span class="n">psi_</span><span class="p">.</span><span class="n">oldTime</span><span class="p">();</span>    <span class="c1">// 上一个时间步的密度场</span>
<span class="p">}</span>

<span class="k">const</span> <span class="n">Foam</span><span class="o">::</span><span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">Foam</span><span class="o">::</span><span class="n">psiThermo</span><span class="o">::</span><span class="n">implementation</span><span class="o">::</span><span class="n">psi</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">psi_</span><span class="p">;</span>    <span class="c1">// 可压缩性场</span>
<span class="p">}</span>

<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">Foam</span><span class="o">::</span><span class="n">psiThermo</span><span class="o">::</span><span class="n">implementation</span><span class="o">::</span><span class="n">mu</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">mu_</span><span class="p">;</span>    <span class="c1">// 动力粘度场</span>
<span class="p">}</span>

<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">scalarField</span><span class="o">&gt;</span> <span class="n">Foam</span><span class="o">::</span><span class="n">psiThermo</span><span class="o">::</span><span class="n">implementation</span><span class="o">::</span><span class="n">mu</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">label</span> <span class="n">patchi</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">mu_</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">];</span>    <span class="c1">// 边界处的动力粘度场</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="type">
<h3>type<a class="headerlink" href="#type" title="永久链接至标题">¶</a></h3>
<p>type关键词用来指定具体的热物理模型库：</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="83%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">热物理模型库</th>
<th class="head">使用场景</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>hePsiThermo</td>
<td>调用fluidThermo，fluidReactionThermo以及psiThermo的求解器需指定</td>
</tr>
<tr class="row-odd"><td>heRhoThermo</td>
<td>调用fluidThermo，fluidReactionThermo以及multiphaseMixtureThermo的求解器需指定</td>
</tr>
<tr class="row-even"><td>heheuPsiThermo</td>
<td>调用psiuReactionThermo的求解器需指定</td>
</tr>
</tbody>
</table>
<div class="section" id="hepsithermo">
<h4>hePsiThermo<a class="headerlink" href="#hepsithermo" title="永久链接至标题">¶</a></h4>
<p>这是一个基于压缩性的混合物能量类，它决定了使用hePsiThermo的求解器中thermo.correct()函数所做的内容：</p>
<div class="literal-block-wrapper docutils container" id="id47">
<div class="code-block-caption"><span class="caption-text">src/thermophysicalModels/basic/psiThermo/hePsiThermo.C</span><a class="headerlink" href="#id47" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicPsiThermo</span><span class="p">,</span> <span class="n">class</span> <span class="n">MixtureType</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">hePsiThermo</span><span class="o">&lt;</span><span class="n">BasicPsiThermo</span><span class="p">,</span> <span class="n">MixtureType</span><span class="o">&gt;::</span><span class="n">calculate</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">hCells</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">he_</span><span class="p">;</span>    <span class="c1">// 焓或内能</span>
    <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">pCells</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">p_</span><span class="p">;</span>     <span class="c1">// 压强</span>

    <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">TCells</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">T_</span><span class="p">.</span><span class="n">primitiveFieldRef</span><span class="p">();</span>            <span class="c1">// 温度</span>
    <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">CpCells</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">Cp_</span><span class="p">.</span><span class="n">primitiveFieldRef</span><span class="p">();</span>          <span class="c1">// 定压比热容</span>
    <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">CvCells</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">Cv_</span><span class="p">.</span><span class="n">primitiveFieldRef</span><span class="p">();</span>          <span class="c1">// 定体比热容</span>
    <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">psiCells</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">psi_</span><span class="p">.</span><span class="n">primitiveFieldRef</span><span class="p">();</span>        <span class="c1">// 可压缩性</span>
    <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">muCells</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">mu_</span><span class="p">.</span><span class="n">primitiveFieldRef</span><span class="p">();</span>          <span class="c1">// 动力粘度</span>
    <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">kappaCells</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">kappa_</span><span class="p">.</span><span class="n">primitiveFieldRef</span><span class="p">();</span>    <span class="c1">// 热导率</span>

    <span class="n">forAll</span><span class="p">(</span><span class="n">TCells</span><span class="p">,</span> <span class="n">celli</span><span class="p">)</span>    <span class="c1">// 在温度场内的网格单元内的计算</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="kr">typename</span> <span class="n">MixtureType</span><span class="o">::</span><span class="n">thermoMixtureType</span><span class="o">&amp;</span> <span class="n">thermoMixture</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">cellThermoMixture</span><span class="p">(</span><span class="n">celli</span><span class="p">);</span>
        <span class="k">const</span> <span class="kr">typename</span> <span class="n">MixtureType</span><span class="o">::</span><span class="n">transportMixtureType</span><span class="o">&amp;</span> <span class="n">transportMixture</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">cellTransportMixture</span><span class="p">(</span><span class="n">celli</span><span class="p">,</span> <span class="n">thermoMixture</span><span class="p">);</span>

        <span class="n">TCells</span><span class="p">[</span><span class="n">celli</span><span class="p">]</span> <span class="o">=</span> <span class="n">thermoMixture</span><span class="p">.</span><span class="n">THE</span><span class="p">(</span><span class="n">hCells</span><span class="p">[</span><span class="n">celli</span><span class="p">],</span> <span class="n">pCells</span><span class="p">[</span><span class="n">celli</span><span class="p">],</span> <span class="n">TCells</span><span class="p">[</span><span class="n">celli</span><span class="p">]);</span>  <span class="c1">// 由焓或内能计算温度T，该函数定义在thermoI.H文件中</span>
        <span class="n">CpCells</span><span class="p">[</span><span class="n">celli</span><span class="p">]</span> <span class="o">=</span> <span class="n">thermoMixture</span><span class="p">.</span><span class="n">Cp</span><span class="p">(</span><span class="n">pCells</span><span class="p">[</span><span class="n">celli</span><span class="p">],</span> <span class="n">TCells</span><span class="p">[</span><span class="n">celli</span><span class="p">]);</span>                 <span class="c1">// 根据thermo设置方式计算定压比热容Cp</span>
        <span class="n">CvCells</span><span class="p">[</span><span class="n">celli</span><span class="p">]</span> <span class="o">=</span> <span class="n">thermoMixture</span><span class="p">.</span><span class="n">Cv</span><span class="p">(</span><span class="n">pCells</span><span class="p">[</span><span class="n">celli</span><span class="p">],</span> <span class="n">TCells</span><span class="p">[</span><span class="n">celli</span><span class="p">]);</span>                 <span class="c1">// 根据thermo设置方式计算定体比热容Cv</span>
        <span class="n">psiCells</span><span class="p">[</span><span class="n">celli</span><span class="p">]</span> <span class="o">=</span> <span class="n">thermoMixture</span><span class="p">.</span><span class="n">psi</span><span class="p">(</span><span class="n">pCells</span><span class="p">[</span><span class="n">celli</span><span class="p">],</span> <span class="n">TCells</span><span class="p">[</span><span class="n">celli</span><span class="p">]);</span>               <span class="c1">// 根据thermo设置方式计算可压缩性psi</span>
        <span class="n">muCells</span><span class="p">[</span><span class="n">celli</span><span class="p">]</span> <span class="o">=</span> <span class="n">transportMixture</span><span class="p">.</span><span class="n">mu</span><span class="p">(</span><span class="n">pCells</span><span class="p">[</span><span class="n">celli</span><span class="p">],</span> <span class="n">TCells</span><span class="p">[</span><span class="n">celli</span><span class="p">]);</span>              <span class="c1">// 根据transport设置方式计算动力粘度mu</span>
        <span class="n">kappaCells</span><span class="p">[</span><span class="n">celli</span><span class="p">]</span> <span class="o">=</span> <span class="n">transportMixture</span><span class="p">.</span><span class="n">kappa</span><span class="p">(</span><span class="n">pCells</span><span class="p">[</span><span class="n">celli</span><span class="p">],</span> <span class="n">TCells</span><span class="p">[</span><span class="n">celli</span><span class="p">]);</span>        <span class="c1">// 根据transport设置方式计算热导率kappa</span>
    <span class="p">}</span>

    <span class="n">volScalarField</span><span class="o">::</span><span class="n">Boundary</span><span class="o">&amp;</span> <span class="n">pBf</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">p_</span><span class="p">.</span><span class="n">boundaryFieldRef</span><span class="p">();</span>            <span class="c1">// 边界处的压强</span>
    <span class="n">volScalarField</span><span class="o">::</span><span class="n">Boundary</span><span class="o">&amp;</span> <span class="n">TBf</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">T_</span><span class="p">.</span><span class="n">boundaryFieldRef</span><span class="p">();</span>            <span class="c1">// 边界处的温度</span>
    <span class="n">volScalarField</span><span class="o">::</span><span class="n">Boundary</span><span class="o">&amp;</span> <span class="n">CpBf</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">Cp_</span><span class="p">.</span><span class="n">boundaryFieldRef</span><span class="p">();</span>          <span class="c1">// 边界处的定压比热容</span>
    <span class="n">volScalarField</span><span class="o">::</span><span class="n">Boundary</span><span class="o">&amp;</span> <span class="n">CvBf</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">Cv_</span><span class="p">.</span><span class="n">boundaryFieldRef</span><span class="p">();</span>          <span class="c1">// 边界处的定体比热容</span>
    <span class="n">volScalarField</span><span class="o">::</span><span class="n">Boundary</span><span class="o">&amp;</span> <span class="n">psiBf</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">psi_</span><span class="p">.</span><span class="n">boundaryFieldRef</span><span class="p">();</span>        <span class="c1">// 边界处的可压缩性</span>
    <span class="n">volScalarField</span><span class="o">::</span><span class="n">Boundary</span><span class="o">&amp;</span> <span class="n">heBf</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">he</span><span class="p">().</span><span class="n">boundaryFieldRef</span><span class="p">();</span>         <span class="c1">// 边界处的焓或内能</span>
    <span class="n">volScalarField</span><span class="o">::</span><span class="n">Boundary</span><span class="o">&amp;</span> <span class="n">muBf</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">mu_</span><span class="p">.</span><span class="n">boundaryFieldRef</span><span class="p">();</span>          <span class="c1">// 边界处的动力粘度</span>
    <span class="n">volScalarField</span><span class="o">::</span><span class="n">Boundary</span><span class="o">&amp;</span> <span class="n">kappaBf</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">kappa_</span><span class="p">.</span><span class="n">boundaryFieldRef</span><span class="p">();</span>    <span class="c1">// 边界处的热导率</span>

    <span class="n">forAll</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">T_</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">(),</span> <span class="n">patchi</span><span class="p">)</span>    <span class="c1">// 在温度场的边界处的计算</span>
    <span class="p">{</span>
        <span class="n">fvPatchScalarField</span><span class="o">&amp;</span> <span class="n">pp</span> <span class="o">=</span> <span class="n">pBf</span><span class="p">[</span><span class="n">patchi</span><span class="p">];</span>            <span class="c1">// 边界处的压强</span>
        <span class="n">fvPatchScalarField</span><span class="o">&amp;</span> <span class="n">pT</span> <span class="o">=</span> <span class="n">TBf</span><span class="p">[</span><span class="n">patchi</span><span class="p">];</span>            <span class="c1">// 边界处的温度</span>
        <span class="n">fvPatchScalarField</span><span class="o">&amp;</span> <span class="n">pCp</span> <span class="o">=</span> <span class="n">CpBf</span><span class="p">[</span><span class="n">patchi</span><span class="p">];</span>          <span class="c1">// 边界处的定压比热容</span>
        <span class="n">fvPatchScalarField</span><span class="o">&amp;</span> <span class="n">pCv</span> <span class="o">=</span> <span class="n">CvBf</span><span class="p">[</span><span class="n">patchi</span><span class="p">];</span>          <span class="c1">// 边界处的定体比热容</span>
        <span class="n">fvPatchScalarField</span><span class="o">&amp;</span> <span class="n">ppsi</span> <span class="o">=</span> <span class="n">psiBf</span><span class="p">[</span><span class="n">patchi</span><span class="p">];</span>        <span class="c1">// 边界处的可压缩性</span>
        <span class="n">fvPatchScalarField</span><span class="o">&amp;</span> <span class="n">phe</span> <span class="o">=</span> <span class="n">heBf</span><span class="p">[</span><span class="n">patchi</span><span class="p">];</span>          <span class="c1">// 边界处的焓或内能</span>
        <span class="n">fvPatchScalarField</span><span class="o">&amp;</span> <span class="n">pmu</span> <span class="o">=</span> <span class="n">muBf</span><span class="p">[</span><span class="n">patchi</span><span class="p">];</span>          <span class="c1">// 边界处的动力粘度</span>
        <span class="n">fvPatchScalarField</span><span class="o">&amp;</span> <span class="n">pkappa</span> <span class="o">=</span> <span class="n">kappaBf</span><span class="p">[</span><span class="n">patchi</span><span class="p">];</span>    <span class="c1">// 边界处的热导率</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">pT</span><span class="p">.</span><span class="n">fixesValue</span><span class="p">())</span>    <span class="c1">// 如果边界处的温度设置为了固定值</span>
        <span class="p">{</span>
            <span class="n">forAll</span><span class="p">(</span><span class="n">pT</span><span class="p">,</span> <span class="n">facei</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">const</span> <span class="kr">typename</span> <span class="n">MixtureType</span><span class="o">::</span><span class="n">thermoMixtureType</span><span class="o">&amp;</span> <span class="n">thermoMixture</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">patchFaceThermoMixture</span><span class="p">(</span><span class="n">patchi</span><span class="p">,</span> <span class="n">facei</span><span class="p">);</span>
                <span class="k">const</span> <span class="kr">typename</span> <span class="n">MixtureType</span><span class="o">::</span><span class="n">transportMixtureType</span><span class="o">&amp;</span> <span class="n">transportMixture</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">patchFaceTransportMixture</span><span class="p">(</span><span class="n">patchi</span><span class="p">,</span> <span class="n">facei</span><span class="p">,</span> <span class="n">thermoMixture</span><span class="p">);</span>

                <span class="n">phe</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="o">=</span> <span class="n">thermoMixture</span><span class="p">.</span><span class="n">HE</span><span class="p">(</span><span class="n">pp</span><span class="p">[</span><span class="n">facei</span><span class="p">],</span> <span class="n">pT</span><span class="p">[</span><span class="n">facei</span><span class="p">]);</span>             <span class="c1">// 根据thermo的设置方式计算边界处的焓或内能</span>
                <span class="n">pCp</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="o">=</span> <span class="n">thermoMixture</span><span class="p">.</span><span class="n">Cp</span><span class="p">(</span><span class="n">pp</span><span class="p">[</span><span class="n">facei</span><span class="p">],</span> <span class="n">pT</span><span class="p">[</span><span class="n">facei</span><span class="p">]);</span>             <span class="c1">// 根据thermo的设置方式计算边界处的定压比热容</span>
                <span class="n">pCv</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="o">=</span> <span class="n">thermoMixture</span><span class="p">.</span><span class="n">Cv</span><span class="p">(</span><span class="n">pp</span><span class="p">[</span><span class="n">facei</span><span class="p">],</span> <span class="n">pT</span><span class="p">[</span><span class="n">facei</span><span class="p">]);</span>             <span class="c1">// 根据thermo的设置方式计算边界处的定体比热容</span>
                <span class="n">ppsi</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="o">=</span> <span class="n">thermoMixture</span><span class="p">.</span><span class="n">psi</span><span class="p">(</span><span class="n">pp</span><span class="p">[</span><span class="n">facei</span><span class="p">],</span> <span class="n">pT</span><span class="p">[</span><span class="n">facei</span><span class="p">]);</span>           <span class="c1">// 根据thermo的设置方式计算边界处的可压缩性</span>
                <span class="n">pmu</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="o">=</span> <span class="n">transportMixture</span><span class="p">.</span><span class="n">mu</span><span class="p">(</span><span class="n">pp</span><span class="p">[</span><span class="n">facei</span><span class="p">],</span> <span class="n">pT</span><span class="p">[</span><span class="n">facei</span><span class="p">]);</span>          <span class="c1">// 根据tansport的设置方式计算边界处的动力粘度</span>
                <span class="n">pkappa</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="o">=</span> <span class="n">transportMixture</span><span class="p">.</span><span class="n">kappa</span><span class="p">(</span><span class="n">pp</span><span class="p">[</span><span class="n">facei</span><span class="p">],</span> <span class="n">pT</span><span class="p">[</span><span class="n">facei</span><span class="p">]);</span>    <span class="c1">// 根据transport的设置方式计算边界处的热导率</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span>    <span class="c1">// 如果边界处的温度没有设置为固定值</span>
        <span class="p">{</span>
            <span class="n">forAll</span><span class="p">(</span><span class="n">pT</span><span class="p">,</span> <span class="n">facei</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">const</span> <span class="kr">typename</span> <span class="n">MixtureType</span><span class="o">::</span><span class="n">thermoMixtureType</span><span class="o">&amp;</span> <span class="n">thermoMixture</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">patchFaceThermoMixture</span><span class="p">(</span><span class="n">patchi</span><span class="p">,</span> <span class="n">facei</span><span class="p">);</span>

                <span class="k">const</span> <span class="kr">typename</span> <span class="n">MixtureType</span><span class="o">::</span><span class="n">transportMixtureType</span><span class="o">&amp;</span> <span class="n">transportMixture</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">patchFaceTransportMixture</span><span class="p">(</span><span class="n">patchi</span><span class="p">,</span> <span class="n">facei</span><span class="p">,</span> <span class="n">thermoMixture</span><span class="p">);</span>

                <span class="n">pT</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="o">=</span> <span class="n">thermoMixture</span><span class="p">.</span><span class="n">THE</span><span class="p">(</span><span class="n">phe</span><span class="p">[</span><span class="n">facei</span><span class="p">],</span> <span class="n">pp</span><span class="p">[</span><span class="n">facei</span><span class="p">],</span> <span class="n">pT</span><span class="p">[</span><span class="n">facei</span><span class="p">]);</span>    <span class="c1">// 根据thermo的设置方式计算边界处的由焓或内能得到的温度</span>
                <span class="n">pCp</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="o">=</span> <span class="n">thermoMixture</span><span class="p">.</span><span class="n">Cp</span><span class="p">(</span><span class="n">pp</span><span class="p">[</span><span class="n">facei</span><span class="p">],</span> <span class="n">pT</span><span class="p">[</span><span class="n">facei</span><span class="p">]);</span>                <span class="c1">// 根据thermo的设置方式计算边界处的定压比热容</span>
                <span class="n">pCv</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="o">=</span> <span class="n">thermoMixture</span><span class="p">.</span><span class="n">Cv</span><span class="p">(</span><span class="n">pp</span><span class="p">[</span><span class="n">facei</span><span class="p">],</span> <span class="n">pT</span><span class="p">[</span><span class="n">facei</span><span class="p">]);</span>                <span class="c1">// 根据thermo的设置方式计算边界处的定体比热容</span>
                <span class="n">ppsi</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="o">=</span> <span class="n">thermoMixture</span><span class="p">.</span><span class="n">psi</span><span class="p">(</span><span class="n">pp</span><span class="p">[</span><span class="n">facei</span><span class="p">],</span> <span class="n">pT</span><span class="p">[</span><span class="n">facei</span><span class="p">]);</span>              <span class="c1">// 根据thermo的设置方式计算边界处的可压缩性</span>
                <span class="n">pmu</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="o">=</span> <span class="n">transportMixture</span><span class="p">.</span><span class="n">mu</span><span class="p">(</span><span class="n">pp</span><span class="p">[</span><span class="n">facei</span><span class="p">],</span> <span class="n">pT</span><span class="p">[</span><span class="n">facei</span><span class="p">]);</span>             <span class="c1">// 根据tansport的设置方式计算边界处的动力粘度</span>
                <span class="n">pkappa</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="o">=</span> <span class="n">transportMixture</span><span class="p">.</span><span class="n">kappa</span><span class="p">(</span><span class="n">pp</span><span class="p">[</span><span class="n">facei</span><span class="p">],</span> <span class="n">pT</span><span class="p">[</span><span class="n">facei</span><span class="p">]);</span>       <span class="c1">// 根据transport的设置方式计算边界处的热导率</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="mixture">
<h3>mixture<a class="headerlink" href="#mixture" title="永久链接至标题">¶</a></h3>
<p>mixture关键词指定混合组分。无反应的热物理模型库通常使用pureMixture，也即固定组分。当指定pureMixture的时候，相关的热物理模型系数在mixture子字典中指定。</p>
<div class="section" id="puremixture">
<h4>pureMixture<a class="headerlink" href="#puremixture" title="永久链接至标题">¶</a></h4>
<div class="literal-block-wrapper docutils container" id="id48">
<div class="code-block-caption"><span class="caption-text">src/thermophysicalModels/basic/mixtures/pureMixture/pureMixture.C</span><a class="headerlink" href="#id48" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">ThermoType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">pureMixture</span><span class="o">&lt;</span><span class="n">ThermoType</span><span class="o">&gt;::</span><span class="n">pureMixture</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">dictionary</span><span class="o">&amp;</span> <span class="n">thermoDict</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">fvMesh</span><span class="o">&amp;</span> <span class="n">mesh</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">word</span><span class="o">&amp;</span> <span class="n">phaseName</span>
<span class="p">)</span>
<span class="o">:</span>
    <span class="n">basicMixture</span><span class="p">(</span><span class="n">thermoDict</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">phaseName</span><span class="p">),</span>
    <span class="n">mixture_</span><span class="p">(</span><span class="n">thermoDict</span><span class="p">.</span><span class="n">subDict</span><span class="p">(</span><span class="s">&quot;mixture&quot;</span><span class="p">))</span>
<span class="p">{}</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">ThermoType</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">pureMixture</span><span class="o">&lt;</span><span class="n">ThermoType</span><span class="o">&gt;::</span><span class="n">read</span><span class="p">(</span><span class="k">const</span> <span class="n">dictionary</span><span class="o">&amp;</span> <span class="n">thermoDict</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">mixture_</span> <span class="o">=</span> <span class="n">ThermoType</span><span class="p">(</span><span class="n">thermoDict</span><span class="p">.</span><span class="n">subDict</span><span class="p">(</span><span class="s">&quot;mixture&quot;</span><span class="p">));</span>    <span class="c1">// 读取thermoType字典中mixture关键词的设置</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="transport">
<h3>transport<a class="headerlink" href="#transport" title="永久链接至标题">¶</a></h3>
<p>transport传递模型需要计算动力粘度 <span class="math notranslate nohighlight">\(\mu\)</span> 、热导率 <span class="math notranslate nohighlight">\(\kappa\)</span> 、扩散率(用于内能方程或焓方程中) <span class="math notranslate nohighlight">\(\alpha\)</span> 。可选的transport模型有：</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">transport模型</th>
<th class="head">含义</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>const</td>
<td>粘度 <span class="math notranslate nohighlight">\(\mu\)</span> 为常数，普朗特数由 <span class="math notranslate nohighlight">\(P_{r} = C_{p}\mu / \kappa\)</span> 来计算，需要指定 <span class="math notranslate nohighlight">\(\mu\)</span> 和 <span class="math notranslate nohighlight">\(P_{r}\)</span></td>
</tr>
<tr class="row-odd"><td>sutherland</td>
<td>通过温度 <span class="math notranslate nohighlight">\(T\)</span> 和两个系数 <span class="math notranslate nohighlight">\(A_{s},T_{s}\)</span> 的函数来计算粘度 <span class="math notranslate nohighlight">\(\mu\)</span> ，即 <span class="math notranslate nohighlight">\(\mu = \frac{A_{s}\sqrt{T}}{1+T_{s}/T}\)</span> ，需要指定 <span class="math notranslate nohighlight">\(A_{s}\)</span> 和 <span class="math notranslate nohighlight">\(T_{s}\)</span></td>
</tr>
<tr class="row-even"><td>polynomial</td>
<td>从一个可以指定任意阶数的函数通过温度 <span class="math notranslate nohighlight">\(T\)</span> 来计算粘度 <span class="math notranslate nohighlight">\(\mu\)</span> 和热导率 <span class="math notranslate nohighlight">\(\varepsilon\)</span> ，即 <span class="math notranslate nohighlight">\(\mu = \sum\limits_{i=0}^{N-1}a_{i}T^{i}\)</span></td>
</tr>
<tr class="row-odd"><td>logPolynomial</td>
<td>从任意阶数依据 <span class="math notranslate nohighlight">\(\ln(T)\)</span> 来计算 <span class="math notranslate nohighlight">\(\ln(\mu)\)</span> 和 <span class="math notranslate nohighlight">\(\ln(k)\)</span> ，即 <span class="math notranslate nohighlight">\(\ln(\mu)=\sum\limits_{i=0}^{N-1}a_{i}(\ln T)^{i}\)</span></td>
</tr>
<tr class="row-even"><td>icoTabulated</td>
<td>使用粘度和热导率的非均匀列表数据作为温度函数</td>
</tr>
<tr class="row-odd"><td>WLF</td>
<td>计算 <span class="math notranslate nohighlight">\(\ln(\mu)\)</span> 和 <span class="math notranslate nohighlight">\(\ln(\kappa)\)</span> 作为 <span class="math notranslate nohighlight">\(\ln(T)\)</span> 的函数由任意阶N的多项式通过指数来计算 <span class="math notranslate nohighlight">\(\mu,\kappa\)</span> ，即 <span class="math notranslate nohighlight">\(\ln(\mu)=\sum\limits_{i=0}^{N-1}a_{i}[\ln(T)]^{i}\)</span></td>
</tr>
</tbody>
</table>
<div class="section" id="const">
<h4>const<a class="headerlink" href="#const" title="永久链接至标题">¶</a></h4>
<div class="literal-block-wrapper docutils container" id="id49">
<div class="code-block-caption"><span class="caption-text">src/thermophysicalModels/specie/transport/const/constTransport.C</span><a class="headerlink" href="#id49" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">constTransport</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="o">&gt;::</span><span class="n">constTransport</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">Ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">os</span>  <span class="o">&lt;&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">os</span>  <span class="o">&lt;&lt;</span> <span class="n">token</span><span class="o">::</span><span class="n">BEGIN_BLOCK</span>  <span class="o">&lt;&lt;</span> <span class="n">incrIndent</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span><span class="p">;</span>

    <span class="n">Thermo</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>

    <span class="n">dictionary</span> <span class="nf">dict</span><span class="p">(</span><span class="s">&quot;transport&quot;</span><span class="p">);</span>
    <span class="n">dict</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s">&quot;mu&quot;</span><span class="p">,</span> <span class="n">mu_</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">constPr_</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">dict</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s">&quot;Pr&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">rPr_</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">dict</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s">&quot;kappa&quot;</span><span class="p">,</span> <span class="n">kappa_</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">os</span>  <span class="o">&lt;&lt;</span> <span class="n">indent</span> <span class="o">&lt;&lt;</span> <span class="n">dict</span><span class="p">.</span><span class="n">dictName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">dict</span><span class="p">;</span>

    <span class="n">os</span>  <span class="o">&lt;&lt;</span> <span class="n">decrIndent</span> <span class="o">&lt;&lt;</span> <span class="n">token</span><span class="o">::</span><span class="n">END_BLOCK</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>上面的代码表明，设置为const时将会查看transport字典中的mu关键词，并会检查是否存在Pr关键词，如果存在该关键词，则读取Pr关键词的值来计算普朗特数的倒数rPr；如果不存在该关键词，则会读取kappa关键词。</p>
<div class="literal-block-wrapper docutils container" id="id50">
<div class="code-block-caption"><span class="caption-text">src/thermophysicalModels/specie/transport/const/constTransportI.H</span><a class="headerlink" href="#id50" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span> <span class="n">Foam</span><span class="o">::</span><span class="n">constTransport</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="o">&gt;::</span><span class="n">mu</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">mu_</span><span class="p">;</span>    <span class="c1">// 直接返回mu值</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span> <span class="n">Foam</span><span class="o">::</span><span class="n">constTransport</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="o">&gt;::</span><span class="n">kappa</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">constPr_</span> <span class="o">?</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">Cp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span><span class="o">*</span><span class="n">mu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span><span class="o">*</span><span class="nl">rPr_</span> <span class="p">:</span> <span class="n">kappa_</span><span class="p">;</span>    <span class="c1">// 判断是否设置Pr关键词计算kappa</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">constTransport</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="o">&gt;::</span><span class="n">operator</span><span class="o">+=</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">constTransport</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="o">&gt;&amp;</span> <span class="n">st</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">scalar</span> <span class="n">Y1</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">Y</span><span class="p">();</span>

    <span class="n">Thermo</span><span class="o">::</span><span class="n">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">st</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">mag</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">Y</span><span class="p">())</span> <span class="o">&gt;</span> <span class="n">small</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span>
        <span class="p">(</span>
            <span class="n">constTransport</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="o">&gt;::</span><span class="n">debug</span>
         <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">constPr_</span> <span class="o">!=</span> <span class="n">st</span><span class="p">.</span><span class="n">constPr_</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">FatalErrorInFunction</span>
                <span class="o">&lt;&lt;</span> <span class="s">&quot;Constant &quot;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">constPr_</span> <span class="o">?</span> <span class="s">&quot;Pr&quot;</span> <span class="o">:</span> <span class="s">&quot;kappa&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; for &quot;</span>
                <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="o">?</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span> <span class="o">:</span> <span class="s">&quot;others&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; but &quot;</span>
                <span class="o">&lt;&lt;</span> <span class="s">&quot;constant &quot;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">constPr_</span> <span class="o">?</span> <span class="s">&quot;Pr&quot;</span> <span class="o">:</span> <span class="s">&quot;kappa&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; for &quot;</span>
                <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">name</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="o">?</span> <span class="n">st</span><span class="p">.</span><span class="n">name</span><span class="p">()</span> <span class="o">:</span> <span class="s">&quot;others&quot;</span><span class="p">)</span>
                <span class="o">&lt;&lt;</span> <span class="n">exit</span><span class="p">(</span><span class="n">FatalError</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">Y1</span> <span class="o">/=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">Y</span><span class="p">();</span>                 <span class="c1">// 第一组分的质量分数</span>
        <span class="n">scalar</span> <span class="n">Y2</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">Y</span><span class="p">()</span><span class="o">/</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">Y</span><span class="p">();</span>    <span class="c1">// 第二组分的质量分数</span>

        <span class="n">mu_</span> <span class="o">=</span> <span class="n">Y1</span><span class="o">*</span><span class="n">mu_</span> <span class="o">+</span> <span class="n">Y2</span><span class="o">*</span><span class="n">st</span><span class="p">.</span><span class="n">mu_</span><span class="p">;</span>
        <span class="n">rPr_</span> <span class="o">=</span> <span class="n">constPr_</span> <span class="o">?</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">Y1</span><span class="o">/</span><span class="n">rPr_</span> <span class="o">+</span> <span class="n">Y2</span><span class="o">/</span><span class="n">st</span><span class="p">.</span><span class="n">rPr_</span><span class="p">)</span> <span class="o">:</span> <span class="n">NaN</span><span class="p">;</span>
        <span class="n">kappa_</span> <span class="o">=</span> <span class="n">constPr_</span> <span class="o">?</span> <span class="nl">NaN</span> <span class="p">:</span> <span class="n">Y1</span><span class="o">*</span><span class="n">kappa_</span> <span class="o">+</span> <span class="n">Y2</span><span class="o">*</span><span class="n">st</span><span class="p">.</span><span class="n">kappa_</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>从上面的代码可知，设置为const时，单组分的热传导率的计算方式为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\kappa =
\left \{ \begin{array}{l}
\frac{c_{p}\mu}{\text{Pr}} ,\quad \text{if Pr exists} \\
\kappa_{0},  \quad \text{if Pr not exists}
\end{array} \right .
\end{align}\end{split}\]</div>
<p>双组分的动力粘度计算方式为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\mu = Y_{1}\mu_{1} + Y_{2}\mu_{2}
\end{align}\]</div>
<p>如果设置了Pr值，那么Pr值的倒数的计算方式为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{1}{\mathrm{Pr}} = \frac{1}{Y_{1}\mathrm{Pr} + Y_{2}\mathrm{Pr}}
\end{align}\]</div>
<p>如果没有设置Pr值，而是设置了kappa值，则双组分的热传导率的计算方式为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\kappa = Y_{1}\kappa_{1} + Y_{2}\kappa_{2}
\end{align}\]</div>
</div>
</div>
<div class="section" id="thermo">
<h3>thermo<a class="headerlink" href="#thermo" title="永久链接至标题">¶</a></h3>
<p>thermo热力模型参数和比热容 <span class="math notranslate nohighlight">\(C_{p}\)</span> 有关，别的相关特性可以从比热容计算而来。可选的模型有：</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">thermo模型</th>
<th class="head">含义</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>hConst</td>
<td>指定 <span class="math notranslate nohighlight">\(C_{p}\)</span> 以及 <span class="math notranslate nohighlight">\(H_{f}\)</span> 为常量</td>
</tr>
<tr class="row-odd"><td>eConst</td>
<td>指定 <span class="math notranslate nohighlight">\(C_{\nu}\)</span> 以及 <span class="math notranslate nohighlight">\(H_{f}\)</span> 为常量</td>
</tr>
<tr class="row-even"><td>eIcoTabulated</td>
<td>通过插值 <span class="math notranslate nohighlight">\((T,C_{p})\)</span> 键值对的非均匀数据列表计算 <span class="math notranslate nohighlight">\(C_{\nu}\)</span></td>
</tr>
<tr class="row-odd"><td>hIcoTabulated</td>
<td>通过插值 <span class="math notranslate nohighlight">\((T,C_{p})\)</span> 键值对的均匀数据列表计算 <span class="math notranslate nohighlight">\(C_{\nu}\)</span></td>
</tr>
<tr class="row-even"><td>ePolynomial</td>
<td>通过任意N阶多项式计算 <span class="math notranslate nohighlight">\(C_{\nu}\)</span> 作为温度的函数，即 <span class="math notranslate nohighlight">\(C_{\nu}=\sum\limits_{i=0}^{N-1}a_{i}T^{i}\)</span></td>
</tr>
<tr class="row-odd"><td>hPower</td>
<td>将 <span class="math notranslate nohighlight">\(C_{p}\)</span> 作为温度的指数来计算，即 <span class="math notranslate nohighlight">\(C_{p}=c_{0}\left ( \frac{T}{T_{\text{ref}}}\right )^{n_{0}}\)</span></td>
</tr>
<tr class="row-even"><td>ePower</td>
<td>将 <span class="math notranslate nohighlight">\(C_{\nu}\)</span> 作为温度的指数来计算，即 <span class="math notranslate nohighlight">\(C_{\nu}=c_{0}\left ( \frac{T}{T_{\text{ref}}}\right )^{n_{0}}\)</span></td>
</tr>
<tr class="row-odd"><td>janaf</td>
<td>从JANAF热力学表来选择参数，以温度的函数来计算</td>
</tr>
</tbody>
</table>
<p>thermo能够调用的各物理量计算函数如下所示：</p>
<div class="literal-block-wrapper docutils container" id="id51">
<div class="code-block-caption"><span class="caption-text">src/thermophysicalModels/specie/thermo/thermo/thermoI.H</span><a class="headerlink" href="#id51" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="p">,</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">bool</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">species</span><span class="o">::</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">enthalpy</span><span class="p">()</span>    <span class="c1">// 返回一个bool值，标识是否要使用焓作为能量。</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">Type</span><span class="o">&lt;</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;&gt;::</span><span class="n">enthalpy</span><span class="p">();</span>    <span class="c1">// 具体执行内容由energy的设置决定</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="p">,</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">word</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">species</span><span class="o">::</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">heName</span><span class="p">()</span>    <span class="c1">// 返回所设定的energyName名称</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">Type</span><span class="o">&lt;</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;&gt;::</span><span class="n">energyName</span><span class="p">();</span>    <span class="c1">// 具体执行内容由energy的设置决定</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="p">,</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">species</span><span class="o">::</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">Cpv</span><span class="p">(</span><span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span><span class="p">)</span> <span class="k">const</span>    <span class="c1">// 定压比热容或定体比热容</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">Type</span><span class="o">&lt;</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;&gt;::</span><span class="n">Cpv</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="p">,</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">species</span><span class="o">::</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">gamma</span><span class="p">(</span><span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span><span class="p">)</span> <span class="k">const</span>    <span class="c1">// 比热容比</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">Cp</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">Cp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Cp</span><span class="o">/</span><span class="p">(</span><span class="n">Cp</span> <span class="o">-</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">CpMCv</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">));</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="p">,</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">species</span><span class="o">::</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">HE</span><span class="p">(</span><span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span><span class="p">)</span> <span class="k">const</span>    <span class="c1">// 焓或内能</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">Type</span><span class="o">&lt;</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;&gt;::</span><span class="n">HE</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="p">,</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">species</span><span class="o">::</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">G</span><span class="p">(</span><span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span><span class="p">)</span> <span class="k">const</span>    <span class="c1">// 吉布斯自由能</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">Ha</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span> <span class="o">-</span> <span class="n">T</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">S</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="p">,</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">species</span><span class="o">::</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span><span class="p">)</span> <span class="k">const</span>    <span class="c1">// 亥姆霍兹自由能</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">Ea</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span> <span class="o">-</span> <span class="n">T</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">S</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="p">,</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">species</span><span class="o">::</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">cp</span><span class="p">(</span><span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span><span class="p">)</span> <span class="k">const</span>    <span class="c1">// 乘以摩尔质量的定压比热容</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">Cp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">W</span><span class="p">();</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="p">,</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">species</span><span class="o">::</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">ha</span><span class="p">(</span><span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span><span class="p">)</span> <span class="k">const</span>    <span class="c1">// 乘以摩尔质量的绝对焓</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">Ha</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">W</span><span class="p">();</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="p">,</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">species</span><span class="o">::</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">hs</span><span class="p">(</span><span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span><span class="p">)</span> <span class="k">const</span>    <span class="c1">// 乘以摩尔质量的显焓</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">Hs</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">W</span><span class="p">();</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="p">,</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">species</span><span class="o">::</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">hc</span><span class="p">()</span> <span class="k">const</span>    <span class="c1">// 乘以摩尔质量的生成焓</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">Hf</span><span class="p">()</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">W</span><span class="p">();</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="p">,</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">species</span><span class="o">::</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">s</span><span class="p">(</span><span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span><span class="p">)</span> <span class="k">const</span>    <span class="c1">// 乘以摩尔质量的熵</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">S</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">W</span><span class="p">();</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="p">,</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">species</span><span class="o">::</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">he</span><span class="p">(</span><span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span><span class="p">)</span> <span class="k">const</span>    <span class="c1">// 乘以摩尔质量的焓或内能</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">HE</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">W</span><span class="p">();</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="p">,</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">species</span><span class="o">::</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">cv</span><span class="p">(</span><span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span><span class="p">)</span> <span class="k">const</span>    <span class="c1">// 乘以摩尔质量的定体比热容</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">Cv</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">W</span><span class="p">();</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="p">,</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">species</span><span class="o">::</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">es</span><span class="p">(</span><span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span><span class="p">)</span> <span class="k">const</span>    <span class="c1">// Sensible internal energy</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">Es</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">W</span><span class="p">();</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="p">,</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">species</span><span class="o">::</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">ea</span><span class="p">(</span><span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span><span class="p">)</span> <span class="k">const</span>    <span class="c1">// Absolute internal energy</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">Ea</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">W</span><span class="p">();</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="p">,</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">species</span><span class="o">::</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">g</span><span class="p">(</span><span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span><span class="p">)</span> <span class="k">const</span>    <span class="c1">// 乘以摩尔质量的吉布斯自由能</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">G</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">W</span><span class="p">();</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="p">,</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">species</span><span class="o">::</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">a</span><span class="p">(</span><span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span><span class="p">)</span> <span class="k">const</span>    <span class="c1">// 乘以摩尔质量的亥姆霍兹自由能</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">W</span><span class="p">();</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="p">,</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">species</span><span class="o">::</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">K</span><span class="p">(</span><span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span><span class="p">)</span> <span class="k">const</span>    <span class="c1">// Equilibrium constant [] i.t.o fugacities</span>
<span class="p">{</span>
    <span class="n">scalar</span> <span class="n">arg</span> <span class="o">=</span> <span class="o">-</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">Y</span><span class="p">()</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">Gstd</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">RR</span><span class="o">*</span><span class="n">T</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">arg</span> <span class="o">&lt;</span> <span class="mi">600</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">rootVGreat</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="p">,</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">species</span><span class="o">::</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">Kp</span><span class="p">(</span><span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span><span class="p">)</span> <span class="k">const</span>    <span class="c1">// Equilibrium constant [] i.t.o. partial pressures</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">K</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="p">,</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">species</span><span class="o">::</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">Kc</span><span class="p">(</span><span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span><span class="p">)</span> <span class="k">const</span>    <span class="c1">// Equilibrium constant i.t.o. molar concentration</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">nm</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">Y</span><span class="p">()</span><span class="o">/</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">W</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">nm</span><span class="p">,</span> <span class="n">small</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Kp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Kp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span><span class="o">*</span><span class="n">pow</span><span class="p">(</span><span class="n">Pstd</span><span class="o">/</span><span class="p">(</span><span class="n">RR</span><span class="o">*</span><span class="n">T</span><span class="p">),</span> <span class="n">nm</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="p">,</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span> <span class="n">Foam</span><span class="o">::</span><span class="n">species</span><span class="o">::</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">Kx</span>    <span class="c1">// Equilibrium constant [] i.t.o. mole-fractions</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">nm</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">Y</span><span class="p">()</span><span class="o">/</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">W</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">nm</span><span class="p">,</span> <span class="n">small</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Kp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Kp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span><span class="o">*</span><span class="n">pow</span><span class="p">(</span><span class="n">Pstd</span><span class="o">/</span><span class="n">p</span><span class="p">,</span> <span class="n">nm</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="p">,</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span> <span class="n">Foam</span><span class="o">::</span><span class="n">species</span><span class="o">::</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">Kn</span>    <span class="c1">// Equilibrium constant [] i.t.o. number of moles</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">n</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">nm</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">Y</span><span class="p">()</span><span class="o">/</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">W</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">nm</span><span class="p">,</span> <span class="n">small</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Kp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Kp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span><span class="o">*</span><span class="n">pow</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">Pstd</span><span class="o">/</span><span class="n">p</span><span class="p">,</span> <span class="n">nm</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>



<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="p">,</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">ThermoType</span><span class="p">,</span> <span class="n">class</span> <span class="n">FType</span><span class="p">,</span> <span class="n">class</span> <span class="n">dFdTType</span><span class="p">,</span> <span class="n">class</span> <span class="n">LimitType</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span> <span class="n">Foam</span><span class="o">::</span><span class="n">species</span><span class="o">::</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">T</span>    <span class="c1">// 计算温度</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">ThermoType</span><span class="o">&amp;</span> <span class="n">thermo</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">f</span><span class="p">,</span>     <span class="c1">// 混合物的能量</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span>     <span class="c1">// 混合物的压强</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">T0</span><span class="p">,</span>    <span class="c1">// 温度的初始猜测值</span>
    <span class="n">FType</span> <span class="n">F</span><span class="p">,</span>            <span class="c1">// 温度表示的能量函数</span>
    <span class="n">dFdTType</span> <span class="n">dFdT</span><span class="p">,</span>      <span class="c1">// 温度表示的能量函数对温度的导函数</span>
    <span class="n">LimitType</span> <span class="n">limit</span><span class="p">,</span>    <span class="c1">// 温度范围限制</span>
    <span class="k">const</span> <span class="kt">bool</span> <span class="n">diagnostics</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">T0</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">FatalErrorInFunction</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;Negative initial temperature T0: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">T0</span>
            <span class="o">&lt;&lt;</span> <span class="n">abort</span><span class="p">(</span><span class="n">FatalError</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">scalar</span> <span class="n">Test</span> <span class="o">=</span> <span class="n">T0</span><span class="p">;</span>
    <span class="n">scalar</span> <span class="n">Tnew</span> <span class="o">=</span> <span class="n">T0</span><span class="p">;</span>
    <span class="n">scalar</span> <span class="n">Ttol</span> <span class="o">=</span> <span class="n">T0</span><span class="o">*</span><span class="n">tol_</span><span class="p">;</span>
    <span class="kt">int</span>    <span class="n">iter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">diagnostics</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="n">IOstream</span><span class="o">::</span><span class="n">defaultPrecision</span><span class="p">()</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span>

        <span class="n">InfoInFunction</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;Energy -&gt; temperature conversion failed to converge:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">Pout</span><span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="n">width</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;iter&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="n">width</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Test&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="n">width</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;e/h&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="n">width</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Cv/p&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="n">width</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Tnew&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">do</span>    <span class="c1">// 通过欧拉迭代法求解温度场</span>
    <span class="p">{</span>
        <span class="n">Test</span> <span class="o">=</span> <span class="n">Tnew</span><span class="p">;</span>
        <span class="n">Tnew</span> <span class="o">=</span> <span class="p">(</span><span class="n">thermo</span><span class="p">.</span><span class="o">*</span><span class="n">limit</span><span class="p">)(</span><span class="n">Test</span> <span class="o">-</span> <span class="p">((</span><span class="n">thermo</span><span class="p">.</span><span class="o">*</span><span class="n">F</span><span class="p">)(</span><span class="n">p</span><span class="p">,</span> <span class="n">Test</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">thermo</span><span class="p">.</span><span class="o">*</span><span class="n">dFdT</span><span class="p">)(</span><span class="n">p</span><span class="p">,</span> <span class="n">Test</span><span class="p">));</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">diagnostics</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="n">IOstream</span><span class="o">::</span><span class="n">defaultPrecision</span><span class="p">()</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span>

            <span class="n">Pout</span><span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="n">width</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">iter</span>
                <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="n">width</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">Test</span>
                <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="n">width</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">thermo</span><span class="p">.</span><span class="o">*</span><span class="n">F</span><span class="p">)(</span><span class="n">p</span><span class="p">,</span> <span class="n">Test</span><span class="p">))</span>
                <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="n">width</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">thermo</span><span class="p">.</span><span class="o">*</span><span class="n">dFdT</span><span class="p">)(</span><span class="n">p</span><span class="p">,</span> <span class="n">Test</span><span class="p">))</span>
                <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="n">width</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">Tnew</span>
                <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">++</span> <span class="o">&gt;</span> <span class="n">maxIter_</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">diagnostics</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">T</span><span class="p">(</span><span class="n">thermo</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">T0</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">dFdT</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="n">FatalErrorInFunction</span>
                <span class="o">&lt;&lt;</span> <span class="s">&quot;Maximum number of iterations exceeded: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">maxIter_</span>
                <span class="o">&lt;&lt;</span> <span class="n">abort</span><span class="p">(</span><span class="n">FatalError</span><span class="p">);</span>
        <span class="p">}</span>

    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">mag</span><span class="p">(</span><span class="n">Tnew</span> <span class="o">-</span> <span class="n">Test</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">Ttol</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">Tnew</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="p">,</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span> <span class="n">Foam</span><span class="o">::</span><span class="n">species</span><span class="o">::</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">THE</span>    <span class="c1">// 由焓或内能计算温度</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">he</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">T0</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">Type</span><span class="o">&lt;</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;&gt;::</span><span class="n">THE</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="n">he</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">T0</span><span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="p">,</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span> <span class="n">Foam</span><span class="o">::</span><span class="n">species</span><span class="o">::</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">THs</span>    <span class="c1">// 通过显焓计算温度</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">hs</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">T0</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">T</span>
    <span class="p">(</span>
        <span class="o">*</span><span class="n">this</span><span class="p">,</span>
        <span class="n">hs</span><span class="p">,</span>
        <span class="n">p</span><span class="p">,</span>
        <span class="n">T0</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">Hs</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">Cp</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">limit</span>
    <span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="p">,</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span> <span class="n">Foam</span><span class="o">::</span><span class="n">species</span><span class="o">::</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">THa</span>    <span class="c1">// 由绝对焓计算温度</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">ha</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">T0</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">T</span>
    <span class="p">(</span>
        <span class="o">*</span><span class="n">this</span><span class="p">,</span>
        <span class="n">ha</span><span class="p">,</span>
        <span class="n">p</span><span class="p">,</span>
        <span class="n">T0</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">Ha</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">Cp</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">limit</span>
    <span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="p">,</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span> <span class="n">Foam</span><span class="o">::</span><span class="n">species</span><span class="o">::</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">TEs</span>    <span class="c1">// Temperature from sensible internal energy</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">es</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">T0</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">T</span>
    <span class="p">(</span>
        <span class="o">*</span><span class="n">this</span><span class="p">,</span>
        <span class="n">es</span><span class="p">,</span>
        <span class="n">p</span><span class="p">,</span>
        <span class="n">T0</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">Es</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">Cv</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">limit</span>
    <span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="p">,</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span> <span class="n">Foam</span><span class="o">::</span><span class="n">species</span><span class="o">::</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">TEa</span>    <span class="c1">// Temperature from absolute internal energy</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">ea</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">T0</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">T</span>
    <span class="p">(</span>
        <span class="o">*</span><span class="n">this</span><span class="p">,</span>
        <span class="n">ea</span><span class="p">,</span>
        <span class="n">p</span><span class="p">,</span>
        <span class="n">T0</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">Ea</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">Cv</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">limit</span>
    <span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="p">,</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">species</span><span class="o">::</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">dKcdTbyKc</span>    <span class="c1">// Derivative of B (according to Niemeyer et al.) w.r.t. temperature</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">dKcdTbyKc</span> <span class="o">=</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">S</span><span class="p">(</span><span class="n">Pstd</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">Gstd</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="o">/</span><span class="n">T</span><span class="p">)</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">Y</span><span class="p">()</span><span class="o">/</span><span class="p">(</span><span class="n">RR</span><span class="o">*</span><span class="n">T</span><span class="p">);</span>

    <span class="k">const</span> <span class="n">scalar</span> <span class="n">nm</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">Y</span><span class="p">()</span><span class="o">/</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">W</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">nm</span><span class="p">,</span> <span class="n">small</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">dKcdTbyKc</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">dKcdTbyKc</span> <span class="o">-</span> <span class="n">nm</span><span class="o">/</span><span class="n">T</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="p">,</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">species</span><span class="o">::</span><span class="n">thermo</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">dcpdT</span><span class="p">(</span><span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span><span class="p">)</span> <span class="k">const</span>    <span class="c1">// Derivative of cp w.r.t. temperature</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">dCpdT</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">W</span><span class="p">();;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="hconst">
<h4>hConst<a class="headerlink" href="#hconst" title="永久链接至标题">¶</a></h4>
<p>这是一个基于焓的热力学包，它在恒压条件下使用恒定热容，满足：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
h = c_{p}(T - T_{\text{ref}}) + H_{s_{\text{ref}}}
\end{align}\]</div>
<p>设置为hConst时将会读取thermodynamics字典中的Cp和Hf关键词；如果存在Tref关键词也会读取，否则默认值使用Tstd；如果存在Hsref关键词也会读取，否则默认值使用0。</p>
<div class="literal-block-wrapper docutils container" id="id52">
<div class="code-block-caption"><span class="caption-text">src/thermophysicalModels/specie/thermo/hConst/hConstThermo.C</span><a class="headerlink" href="#id52" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">EquationOfState</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">hConstThermo</span><span class="o">&lt;</span><span class="n">EquationOfState</span><span class="o">&gt;::</span><span class="n">hConstThermo</span><span class="p">(</span><span class="k">const</span> <span class="n">dictionary</span><span class="o">&amp;</span> <span class="n">dict</span><span class="p">)</span>
<span class="o">:</span>
    <span class="n">EquationOfState</span><span class="p">(</span><span class="n">dict</span><span class="p">),</span>
    <span class="n">Cp_</span><span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">subDict</span><span class="p">(</span><span class="s">&quot;thermodynamics&quot;</span><span class="p">).</span><span class="n">lookup</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;Cp&quot;</span><span class="p">)),</span>    <span class="c1">// 定压比热容</span>
    <span class="n">Hf_</span><span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">subDict</span><span class="p">(</span><span class="s">&quot;thermodynamics&quot;</span><span class="p">).</span><span class="n">lookup</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;Hf&quot;</span><span class="p">)),</span>    <span class="c1">// 生成热（生成焓）</span>
    <span class="n">Tref_</span><span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">subDict</span><span class="p">(</span><span class="s">&quot;thermodynamics&quot;</span><span class="p">).</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;Tref&quot;</span><span class="p">,</span> <span class="n">Tstd</span><span class="p">)),</span>    <span class="c1">// 线性化的参考温度</span>
    <span class="n">Hsref_</span><span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">subDict</span><span class="p">(</span><span class="s">&quot;thermodynamics&quot;</span><span class="p">).</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;Hsref&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>    <span class="c1">// 参考显焓，围绕它进行线性化</span>
<span class="p">{}</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">EquationOfState</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">hConstThermo</span><span class="o">&lt;</span><span class="n">EquationOfState</span><span class="o">&gt;::</span><span class="n">write</span><span class="p">(</span><span class="n">Ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">EquationOfState</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>

    <span class="n">dictionary</span> <span class="nf">dict</span><span class="p">(</span><span class="s">&quot;thermodynamics&quot;</span><span class="p">);</span>
    <span class="n">dict</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s">&quot;Cp&quot;</span><span class="p">,</span> <span class="n">Cp_</span><span class="p">);</span>
    <span class="n">dict</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s">&quot;Hf&quot;</span><span class="p">,</span> <span class="n">Hf_</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Tref_</span> <span class="o">!=</span> <span class="n">Tstd</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">dict</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s">&quot;Tref&quot;</span><span class="p">,</span> <span class="n">Tref_</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Hsref_</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">dict</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s">&quot;Hsref&quot;</span><span class="p">,</span> <span class="n">Hsref_</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">os</span>  <span class="o">&lt;&lt;</span> <span class="n">indent</span> <span class="o">&lt;&lt;</span> <span class="n">dict</span><span class="p">.</span><span class="n">dictName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">dict</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>在将thermo设置为hConst之后，可以通过thermo调用的函数所执行的内容如下所示：</p>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="18%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">函数作用</th>
<th class="head">函数形式</th>
<th class="head">返回内容</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>限制温度</td>
<td><code class="code docutils literal notranslate"><span class="pre">limit(T)</span></code></td>
<td><code class="code docutils literal notranslate"><span class="pre">T</span></code></td>
</tr>
<tr class="row-odd"><td>计算定压比热容</td>
<td><code class="code docutils literal notranslate"><span class="pre">Cp(p,T)</span></code></td>
<td><code class="code docutils literal notranslate"><span class="pre">Cp_</span> <span class="pre">+</span> <span class="pre">EquationOfState::Cp(p,</span> <span class="pre">T)</span></code></td>
</tr>
<tr class="row-even"><td>计算显焓</td>
<td><code class="code docutils literal notranslate"><span class="pre">Hs(p,T)</span></code></td>
<td><code class="code docutils literal notranslate"><span class="pre">Cp_*(T</span> <span class="pre">-</span> <span class="pre">Tref_)</span> <span class="pre">+</span> <span class="pre">Hsref_</span> <span class="pre">+</span> <span class="pre">EquationOfState::H(p,</span> <span class="pre">T)</span></code></td>
</tr>
<tr class="row-odd"><td>计算绝对焓</td>
<td><code class="code docutils literal notranslate"><span class="pre">Ha(p,T)</span></code></td>
<td><code class="code docutils literal notranslate"><span class="pre">Hs(p,</span> <span class="pre">T)</span> <span class="pre">+</span> <span class="pre">Hf()</span></code></td>
</tr>
<tr class="row-even"><td>计算生成焓</td>
<td><code class="code docutils literal notranslate"><span class="pre">Hf()</span></code></td>
<td><code class="code docutils literal notranslate"><span class="pre">Hf_</span></code></td>
</tr>
<tr class="row-odd"><td>计算熵</td>
<td><code class="code docutils literal notranslate"><span class="pre">S(p,T)</span></code></td>
<td><code class="code docutils literal notranslate"><span class="pre">Cp_*log(T/Tstd)</span> <span class="pre">+</span> <span class="pre">EquationOfState::Sp(p,</span> <span class="pre">T)</span></code></td>
</tr>
<tr class="row-even"><td>计算标准吉布斯自由能</td>
<td><code class="code docutils literal notranslate"><span class="pre">Gstd(T)</span></code></td>
<td><code class="code docutils literal notranslate"><span class="pre">Cp_*(T</span> <span class="pre">-</span> <span class="pre">Tref_)</span> <span class="pre">+</span> <span class="pre">Hsref_</span> <span class="pre">+</span> <span class="pre">Hf()</span> <span class="pre">-</span> <span class="pre">Cp_*T*log(T/Tstd)</span></code></td>
</tr>
<tr class="row-odd"><td>计算定压比热容对温度的导数</td>
<td><code class="code docutils literal notranslate"><span class="pre">dCpdT(p,T)</span></code></td>
<td><code class="code docutils literal notranslate"><span class="pre">0</span></code></td>
</tr>
</tbody>
</table>
<div class="literal-block-wrapper docutils container" id="id53">
<div class="code-block-caption"><span class="caption-text">src/thermophysicalModels/specie/thermo/hConst/hConstThermoI.H</span><a class="headerlink" href="#id53" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">EquationOfState</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span> <span class="n">Foam</span><span class="o">::</span><span class="n">hConstThermo</span><span class="o">&lt;</span><span class="n">EquationOfState</span><span class="o">&gt;::</span><span class="n">limit</span>    <span class="c1">// 将温度限制在从Tlow到Thigh的范围内</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">T</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">EquationOfState</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span> <span class="n">Foam</span><span class="o">::</span><span class="n">hConstThermo</span><span class="o">&lt;</span><span class="n">EquationOfState</span><span class="o">&gt;::</span><span class="n">Cp</span>    <span class="c1">// 定压比热容</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">Cp_</span> <span class="o">+</span> <span class="n">EquationOfState</span><span class="o">::</span><span class="n">Cp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>    <span class="c1">// 其中EquationOfState::Cp表示由于状态方程而产生的定压比热容的贡献</span>
<span class="p">}</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">EquationOfState</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span> <span class="n">Foam</span><span class="o">::</span><span class="n">hConstThermo</span><span class="o">&lt;</span><span class="n">EquationOfState</span><span class="o">&gt;::</span><span class="n">Hs</span>    <span class="c1">// 显焓</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">Cp_</span><span class="o">*</span><span class="p">(</span><span class="n">T</span> <span class="o">-</span> <span class="n">Tref_</span><span class="p">)</span> <span class="o">+</span> <span class="n">Hsref_</span> <span class="o">+</span> <span class="n">EquationOfState</span><span class="o">::</span><span class="n">H</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>    <span class="c1">// 其中EquationOfState::H表示由于状态方程而产生的焓的贡献</span>
<span class="p">}</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">EquationOfState</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span> <span class="n">Foam</span><span class="o">::</span><span class="n">hConstThermo</span><span class="o">&lt;</span><span class="n">EquationOfState</span><span class="o">&gt;::</span><span class="n">Ha</span>    <span class="c1">// 绝对焓</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">Hs</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="n">Hf</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">EquationOfState</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span> <span class="n">Foam</span><span class="o">::</span><span class="n">hConstThermo</span><span class="o">&lt;</span><span class="n">EquationOfState</span><span class="o">&gt;::</span><span class="n">Hf</span><span class="p">()</span> <span class="k">const</span>    <span class="c1">// 生成焓</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">Hf_</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">EquationOfState</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span> <span class="n">Foam</span><span class="o">::</span><span class="n">hConstThermo</span><span class="o">&lt;</span><span class="n">EquationOfState</span><span class="o">&gt;::</span><span class="n">S</span>    <span class="c1">// 熵</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">Cp_</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">Tstd</span><span class="p">)</span> <span class="o">+</span> <span class="n">EquationOfState</span><span class="o">::</span><span class="n">Sp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>    <span class="c1">// 其中EquationOfState::Sp表示由于状态方程而产生的熵对Cp/T积分的贡献</span>
<span class="p">}</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">EquationOfState</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span> <span class="n">Foam</span><span class="o">::</span><span class="n">hConstThermo</span><span class="o">&lt;</span><span class="n">EquationOfState</span><span class="o">&gt;::</span><span class="n">Gstd</span>    <span class="c1">// 混合物在标准态下的吉布斯自由能</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">Cp_</span><span class="o">*</span><span class="p">(</span><span class="n">T</span> <span class="o">-</span> <span class="n">Tref_</span><span class="p">)</span> <span class="o">+</span> <span class="n">Hsref_</span> <span class="o">+</span> <span class="n">Hf</span><span class="p">()</span> <span class="o">-</span> <span class="n">Cp_</span><span class="o">*</span><span class="n">T</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">Tstd</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">EquationOfState</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span> <span class="n">Foam</span><span class="o">::</span><span class="n">hConstThermo</span><span class="o">&lt;</span><span class="n">EquationOfState</span><span class="o">&gt;::</span><span class="n">dCpdT</span>    <span class="c1">// 定压比热容关于温度的导数</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="equationofstate">
<h3>equationOfState<a class="headerlink" href="#equationofstate" title="永久链接至标题">¶</a></h3>
<p>状态方程equationOfState可选的有：</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="86%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">状态方程</th>
<th class="head">含义</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>rhoConst</td>
<td>密度为常量</td>
</tr>
<tr class="row-odd"><td>perfectGas</td>
<td>理想气体，即 <span class="math notranslate nohighlight">\(\rho=\frac{1}{RT}p\)</span></td>
</tr>
<tr class="row-even"><td>incompressiblePerfectGas</td>
<td>不可压缩理想气体，即 <span class="math notranslate nohighlight">\(\rho=\frac{1}{RT}p_{\text{ref}}\)</span> ，其中 <span class="math notranslate nohighlight">\(p_{\text{ref}}\)</span> 为参考压力</td>
</tr>
<tr class="row-odd"><td>perfectFluid</td>
<td>理想液体，即 <span class="math notranslate nohighlight">\(\rho=\frac{1}{RT}p+\rho_{0}\)</span> ，其中 <span class="math notranslate nohighlight">\(p_{0}\)</span> 为 <span class="math notranslate nohighlight">\(T=0\)</span> 下的密度</td>
</tr>
<tr class="row-even"><td>linear</td>
<td>线性状态方程，即 <span class="math notranslate nohighlight">\(\rho=\varphi p+\rho_{0}\)</span> ，其中 <span class="math notranslate nohighlight">\(\varphi\)</span> 为可压缩性</td>
</tr>
<tr class="row-odd"><td>adiabaticPerfectFluid</td>
<td>绝热理想气体，即 <span class="math notranslate nohighlight">\(\rho=\rho_{0}\left ( \frac{p+B}{p_{0}B}\right ) ^{1/\gamma}\)</span> ，其中 <span class="math notranslate nohighlight">\(\rho_{0},p_{0}\)</span> 为参考密度和参考压力， <span class="math notranslate nohighlight">\(B\)</span> 为模型常数</td>
</tr>
<tr class="row-even"><td>Boussinesq</td>
<td>布辛涅司克近似，即 <span class="math notranslate nohighlight">\(\rho=\rho_{0}\big(1-\beta(T-T_{0})\big)\)</span> ，其中 <span class="math notranslate nohighlight">\(\beta\)</span> 表示体膨胀率， <span class="math notranslate nohighlight">\(\rho_{0}\)</span> 表示参考温度 <span class="math notranslate nohighlight">\(T_{0}\)</span> 下的参考密度</td>
</tr>
<tr class="row-odd"><td>PengRobinsonGas</td>
<td>彭-罗宾森状态方程，即 <span class="math notranslate nohighlight">\(\rho=\frac{1}{zRT}p\)</span> ，其中 <span class="math notranslate nohighlight">\(z=z(p,T)\)</span></td>
</tr>
<tr class="row-even"><td>icoPolynomial</td>
<td>不可压缩多项式状态方程 <span class="math notranslate nohighlight">\(\rho=\sum\limits_{i=0}^{N-1}a_{i}T^{i}\)</span> ，其中 <span class="math notranslate nohighlight">\(\varphi\)</span> 为可压缩性</td>
</tr>
<tr class="row-odd"><td>icoTabulated</td>
<td>提供不可压缩流体 <span class="math notranslate nohighlight">\((T,\rho)\)</span> 键值对的数据列表</td>
</tr>
<tr class="row-even"><td>rhoTabulated</td>
<td>可压缩流体的统一表格数据，计算 <span class="math notranslate nohighlight">\(\rho\)</span> 作为 <span class="math notranslate nohighlight">\(T\)</span> 和 <span class="math notranslate nohighlight">\(T\)</span> 的函数</td>
</tr>
<tr class="row-odd"><td>rPolynomial</td>
<td>液体或固体的倒数多项式状态方程，即 <span class="math notranslate nohighlight">\(\frac{1}{\rho}=C_{0}+C_{1}T+C_{2}T^{2}-C_{3}p-C_{4}pT\)</span> ，其中的 <span class="math notranslate nohighlight">\(C_{i}\)</span> 为系数</td>
</tr>
</tbody>
</table>
<div class="section" id="perfectgas">
<h4>perfectGas<a class="headerlink" href="#perfectgas" title="永久链接至标题">¶</a></h4>
<p>理想气体状态方程，所使用的气体常数 <span class="math notranslate nohighlight">\(R\)</span> 直接从specie或者混合物的分子量得到，所以不需要额外设定：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\rho = \frac{p}{RT}
\end{align}\]</div>
<p>当equationOfState设置为perfectGas之后，通过它可以调用的函数如下所示：</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="27%" />
<col width="42%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">函数作用</th>
<th class="head">函数形式</th>
<th class="head">返回内容</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>计算密度场</td>
<td><code class="code docutils literal notranslate"><span class="pre">rho(p,T)</span></code></td>
<td><code class="code docutils literal notranslate"><span class="pre">p/(this-&gt;R()*T)</span></code></td>
</tr>
<tr class="row-odd"><td>计算对焓的贡献</td>
<td><code class="code docutils literal notranslate"><span class="pre">H(p,T)</span></code></td>
<td><code class="code docutils literal notranslate"><span class="pre">0</span></code></td>
</tr>
<tr class="row-even"><td>计算对定压比热容的贡献</td>
<td><code class="code docutils literal notranslate"><span class="pre">Cp(p,T)</span></code></td>
<td><code class="code docutils literal notranslate"><span class="pre">0</span></code></td>
</tr>
<tr class="row-odd"><td>计算对能量的贡献</td>
<td><code class="code docutils literal notranslate"><span class="pre">E(p,T)</span></code></td>
<td><code class="code docutils literal notranslate"><span class="pre">0</span></code></td>
</tr>
<tr class="row-even"><td>计算对定体比热容的贡献</td>
<td><code class="code docutils literal notranslate"><span class="pre">Cv(p,T)</span></code></td>
<td><code class="code docutils literal notranslate"><span class="pre">0</span></code></td>
</tr>
<tr class="row-odd"><td>计算熵对Cp/T积分的贡献</td>
<td><code class="code docutils literal notranslate"><span class="pre">Sp(p,T)</span></code></td>
<td><code class="code docutils literal notranslate"><span class="pre">-this-&gt;R()*log(p/Pstd)</span></code></td>
</tr>
<tr class="row-even"><td>计算熵对Cv/T积分的贡献</td>
<td><code class="code docutils literal notranslate"><span class="pre">Sv(p,T)</span></code></td>
<td><code class="code docutils literal notranslate"><span class="pre">0</span></code></td>
</tr>
<tr class="row-odd"><td>计算可压缩性场</td>
<td><code class="code docutils literal notranslate"><span class="pre">psi(p,T)</span></code></td>
<td><code class="code docutils literal notranslate"><span class="pre">1.0/(this-&gt;R()*T)</span></code></td>
</tr>
<tr class="row-even"><td>计算压缩因子</td>
<td><code class="code docutils literal notranslate"><span class="pre">Z(p,T)</span></code></td>
<td><code class="code docutils literal notranslate"><span class="pre">1</span></code></td>
</tr>
<tr class="row-odd"><td>计算Cp与Cv的差</td>
<td><code class="code docutils literal notranslate"><span class="pre">CpMCv(p,T)</span></code></td>
<td><code class="code docutils literal notranslate"><span class="pre">this-&gt;R()</span></code></td>
</tr>
<tr class="row-even"><td>计算热膨胀的体积系数</td>
<td><code class="code docutils literal notranslate"><span class="pre">alphav(p,T)</span></code></td>
<td><code class="code docutils literal notranslate"><span class="pre">1/T</span></code></td>
</tr>
</tbody>
</table>
<div class="literal-block-wrapper docutils container" id="id54">
<div class="code-block-caption"><span class="caption-text">src/thermophysicalModels/specie/equationOfState/perfectGas/perfectGasI.H</span><a class="headerlink" href="#id54" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Specie</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span> <span class="n">Foam</span><span class="o">::</span><span class="n">perfectGas</span><span class="o">&lt;</span><span class="n">Specie</span><span class="o">&gt;::</span><span class="n">rho</span><span class="p">(</span><span class="n">scalar</span> <span class="n">p</span><span class="p">,</span> <span class="n">scalar</span> <span class="n">T</span><span class="p">)</span> <span class="k">const</span>    <span class="c1">// 密度场</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">/</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">()</span><span class="o">*</span><span class="n">T</span><span class="p">);</span>    <span class="c1">// 通过理想气体方程求解密度</span>
<span class="p">}</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Specie</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span> <span class="n">Foam</span><span class="o">::</span><span class="n">perfectGas</span><span class="o">&lt;</span><span class="n">Specie</span><span class="o">&gt;::</span><span class="n">H</span><span class="p">(</span><span class="n">scalar</span> <span class="n">p</span><span class="p">,</span> <span class="n">scalar</span> <span class="n">T</span><span class="p">)</span> <span class="k">const</span>    <span class="c1">// 焓的贡献</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Specie</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span> <span class="n">Foam</span><span class="o">::</span><span class="n">perfectGas</span><span class="o">&lt;</span><span class="n">Specie</span><span class="o">&gt;::</span><span class="n">Cp</span><span class="p">(</span><span class="n">scalar</span> <span class="n">p</span><span class="p">,</span> <span class="n">scalar</span> <span class="n">T</span><span class="p">)</span> <span class="k">const</span>    <span class="c1">// 定压比热容的贡献</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Specie</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span> <span class="n">Foam</span><span class="o">::</span><span class="n">perfectGas</span><span class="o">&lt;</span><span class="n">Specie</span><span class="o">&gt;::</span><span class="n">E</span><span class="p">(</span><span class="n">scalar</span> <span class="n">p</span><span class="p">,</span> <span class="n">scalar</span> <span class="n">T</span><span class="p">)</span> <span class="k">const</span>    <span class="c1">// 能量贡献</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Specie</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span> <span class="n">Foam</span><span class="o">::</span><span class="n">perfectGas</span><span class="o">&lt;</span><span class="n">Specie</span><span class="o">&gt;::</span><span class="n">Cv</span><span class="p">(</span><span class="n">scalar</span> <span class="n">p</span><span class="p">,</span> <span class="n">scalar</span> <span class="n">T</span><span class="p">)</span> <span class="k">const</span>    <span class="c1">// 定体比热容贡献</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Specie</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span> <span class="n">Foam</span><span class="o">::</span><span class="n">perfectGas</span><span class="o">&lt;</span><span class="n">Specie</span><span class="o">&gt;::</span><span class="n">Sp</span><span class="p">(</span><span class="n">scalar</span> <span class="n">p</span><span class="p">,</span> <span class="n">scalar</span> <span class="n">T</span><span class="p">)</span> <span class="k">const</span>    <span class="c1">// 熵对Cp/T积分的贡献</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">()</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">p</span><span class="o">/</span><span class="n">Pstd</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Specie</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span> <span class="n">Foam</span><span class="o">::</span><span class="n">perfectGas</span><span class="o">&lt;</span><span class="n">Specie</span><span class="o">&gt;::</span><span class="n">Sv</span><span class="p">(</span><span class="n">scalar</span> <span class="n">p</span><span class="p">,</span> <span class="n">scalar</span> <span class="n">T</span><span class="p">)</span> <span class="k">const</span>    <span class="c1">// 熵对Cv/T积分的贡献</span>
<span class="p">{</span>
    <span class="n">NotImplemented</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Specie</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span> <span class="n">Foam</span><span class="o">::</span><span class="n">perfectGas</span><span class="o">&lt;</span><span class="n">Specie</span><span class="o">&gt;::</span><span class="n">psi</span><span class="p">(</span><span class="n">scalar</span> <span class="n">p</span><span class="p">,</span> <span class="n">scalar</span> <span class="n">T</span><span class="p">)</span> <span class="k">const</span>    <span class="c1">// 可压缩性场</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">()</span><span class="o">*</span><span class="n">T</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Specie</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span> <span class="n">Foam</span><span class="o">::</span><span class="n">perfectGas</span><span class="o">&lt;</span><span class="n">Specie</span><span class="o">&gt;::</span><span class="n">Z</span><span class="p">(</span><span class="n">scalar</span> <span class="n">p</span><span class="p">,</span> <span class="n">scalar</span> <span class="n">T</span><span class="p">)</span> <span class="k">const</span>    <span class="c1">// 压缩因子</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Specie</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span> <span class="n">Foam</span><span class="o">::</span><span class="n">perfectGas</span><span class="o">&lt;</span><span class="n">Specie</span><span class="o">&gt;::</span><span class="n">CpMCv</span><span class="p">(</span><span class="n">scalar</span> <span class="n">p</span><span class="p">,</span> <span class="n">scalar</span> <span class="n">T</span><span class="p">)</span> <span class="k">const</span>    <span class="c1">// Cp与Cv的差</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">R</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Specie</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span> <span class="n">Foam</span><span class="o">::</span><span class="n">perfectGas</span><span class="o">&lt;</span><span class="n">Specie</span><span class="o">&gt;::</span><span class="n">alphav</span><span class="p">(</span><span class="n">scalar</span> <span class="n">p</span><span class="p">,</span> <span class="n">scalar</span> <span class="n">T</span><span class="p">)</span> <span class="k">const</span>    <span class="c1">// 热膨胀的体积系数</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="n">T</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="specie">
<h3>specie<a class="headerlink" href="#specie" title="永久链接至标题">¶</a></h3>
<p>这是热物理性质类型的基类。组分的量只有一种选择specie，后续需要进一步输入下面的信息：</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="82%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">specie组分信息</th>
<th class="head">含义</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>nMoles</td>
<td>摩尔数。仅仅在使用反应组分均一混合回归变量燃烧模型的时候起作用，否则其为1</td>
</tr>
<tr class="row-odd"><td>molWeight</td>
<td>摩尔质量g/mol</td>
</tr>
</tbody>
</table>
<div class="literal-block-wrapper docutils container" id="id55">
<div class="code-block-caption"><span class="caption-text">src/thermophysicalModels/specie/specie/specie.C</span><a class="headerlink" href="#id55" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Foam</span><span class="o">::</span><span class="n">specie</span><span class="o">::</span><span class="n">specie</span><span class="p">(</span><span class="k">const</span> <span class="n">dictionary</span><span class="o">&amp;</span> <span class="n">dict</span><span class="p">)</span>
<span class="o">:</span>
    <span class="n">name_</span><span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">dictName</span><span class="p">()),</span>
    <span class="n">Y_</span><span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">subDict</span><span class="p">(</span><span class="s">&quot;specie&quot;</span><span class="p">).</span><span class="n">lookupOrDefault</span><span class="p">(</span><span class="s">&quot;massFraction&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)),</span>    <span class="c1">// 质量分数</span>
    <span class="n">molWeight_</span><span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">subDict</span><span class="p">(</span><span class="s">&quot;specie&quot;</span><span class="p">).</span><span class="n">lookup</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;molWeight&quot;</span><span class="p">))</span>      <span class="c1">// 摩尔质量</span>
<span class="p">{}</span>

<span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">specie</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">Ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">dictionary</span> <span class="n">dict</span><span class="p">(</span><span class="s">&quot;specie&quot;</span><span class="p">);</span>    <span class="c1">// 查找specie字典</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Y_</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>    <span class="c1">// 如果质量分数不等于1</span>
    <span class="p">{</span>
        <span class="n">dict</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s">&quot;massFraction&quot;</span><span class="p">,</span> <span class="n">Y_</span><span class="p">);</span>    <span class="c1">// 则需要进一步读取massFraction关键词获取所设置的质量分数</span>
    <span class="p">}</span>
    <span class="n">dict</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s">&quot;molWeight&quot;</span><span class="p">,</span> <span class="n">molWeight_</span><span class="p">);</span>    <span class="c1">// 读取molWeight关键词获取摩尔质量</span>
    <span class="n">os</span>  <span class="o">&lt;&lt;</span> <span class="n">indent</span> <span class="o">&lt;&lt;</span> <span class="n">dict</span><span class="p">.</span><span class="n">dictName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">dict</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id56">
<div class="code-block-caption"><span class="caption-text">src/thermophysicalModels/specie/specie/specieI.H</span><a class="headerlink" href="#id56" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kr">inline</span> <span class="k">const</span> <span class="n">word</span><span class="o">&amp;</span> <span class="n">specie</span><span class="o">::</span><span class="n">name</span><span class="p">()</span> <span class="k">const</span>    <span class="c1">// 组分名称</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">name_</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="n">scalar</span> <span class="n">specie</span><span class="o">::</span><span class="n">W</span><span class="p">()</span> <span class="k">const</span>    <span class="c1">// 摩尔质量</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">molWeight_</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="n">scalar</span> <span class="n">specie</span><span class="o">::</span><span class="n">Y</span><span class="p">()</span> <span class="k">const</span>    <span class="c1">// 组分的质量分数</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">Y_</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="n">scalar</span> <span class="n">specie</span><span class="o">::</span><span class="n">R</span><span class="p">()</span> <span class="k">const</span>    <span class="c1">// 个别气体常数</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">RR</span><span class="o">/</span><span class="n">molWeight_</span><span class="p">;</span>    <span class="c1">// 通过气体常数除以该组分的摩尔质量得到</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="energy">
<h3>energy<a class="headerlink" href="#energy" title="永久链接至标题">¶</a></h3>
<p>可以对能量方程求解的变量进行指定，其可为内能 <span class="math notranslate nohighlight">\(e\)</span> 也可以为焓 <span class="math notranslate nohighlight">\(h\)</span> ，并可以选择是否包含热源 <span class="math notranslate nohighlight">\(\Delta h_{f}\)</span> 。其可以通过指定energy关键字来实现：</p>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">能量方程变量</th>
<th class="head">含义</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>sensibleEnthalpy</td>
<td>利用焓值求解温度</td>
</tr>
<tr class="row-odd"><td>sensibleInternalEnergy</td>
<td>利用内能求解温度</td>
</tr>
<tr class="row-even"><td>absoluteEnthalpy</td>
<td>使用绝对焓表示包含热源的情况</td>
</tr>
<tr class="row-odd"><td>absoluteInternalEnergy</td>
<td>使用绝对内能求解温度</td>
</tr>
</tbody>
</table>
<div class="section" id="sensibleenthalpy">
<h4>sensibleEnthalpy<a class="headerlink" href="#sensibleenthalpy" title="永久链接至标题">¶</a></h4>
<p>这是一个热力学映射类，以使用关于显式焓的函数。</p>
<div class="literal-block-wrapper docutils container" id="id57">
<div class="code-block-caption"><span class="caption-text">src/thermophysicalModels/specie/thermo/sensibleEnthalpy/sensibleEnthalpy.H</span><a class="headerlink" href="#id57" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">enthalpy</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>    <span class="c1">// 使用焓</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">word</span> <span class="nf">energyName</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;h&quot;</span><span class="p">;</span>    <span class="c1">// 将energyName设置为焓h</span>
<span class="p">}</span>

<span class="c1">// Heat capacity at constant pressure [J/kg/K]</span>
<span class="n">scalar</span> <span class="n">Cpv</span>    <span class="c1">// 定压比热容</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">Thermo</span><span class="o">&amp;</span> <span class="n">thermo</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">thermo</span><span class="p">.</span><span class="n">Cp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Sensible enthalpy [J/kg]</span>
<span class="n">scalar</span> <span class="n">HE</span>    <span class="c1">// 显内能</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">Thermo</span><span class="o">&amp;</span> <span class="n">thermo</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">thermo</span><span class="p">.</span><span class="n">Hs</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//- Temperature from sensible enthalpy given an initial temperature T0</span>
<span class="n">scalar</span> <span class="n">THE</span>    <span class="c1">// 在给定初始温度T0的条件下，由显内能得到的温度</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">Thermo</span><span class="o">&amp;</span> <span class="n">thermo</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">h</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">T0</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">thermo</span><span class="p">.</span><span class="n">THs</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">T0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="sensibleinternalenergy">
<h4>sensibleInternalEnergy<a class="headerlink" href="#sensibleinternalenergy" title="永久链接至标题">¶</a></h4>
<p>这是一个热力学映射类，以使用关于显式内能的函数。</p>
<div class="literal-block-wrapper docutils container" id="id58">
<div class="code-block-caption"><span class="caption-text">src/thermophysicalModels/specie/thermo/sensibleInternalEnergy/sensibleInternalEnergy.H</span><a class="headerlink" href="#id58" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">enthalpy</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>    <span class="c1">// 不使用焓</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">word</span> <span class="nf">energyName</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;e&quot;</span><span class="p">;</span>    <span class="c1">// 将energyName设置为内能e</span>
<span class="p">}</span>

<span class="c1">//- Heat capacity at constant volume [J/kg/K]</span>
<span class="n">scalar</span> <span class="n">Cpv</span>    <span class="c1">// 定体比热容</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">Thermo</span><span class="o">&amp;</span> <span class="n">thermo</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">thermo</span><span class="p">.</span><span class="n">Cv</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>    <span class="c1">// 调用thermo设置模式的函数或者使用HtoEthermo.H文件中定义的函数</span>
<span class="p">}</span>

<span class="c1">//- Sensible internal energy [J/kg]</span>
<span class="n">scalar</span> <span class="n">HE</span>    <span class="c1">// 显内能</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">Thermo</span><span class="o">&amp;</span> <span class="n">thermo</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">thermo</span><span class="p">.</span><span class="n">Es</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>    <span class="c1">// 调用thermo设置模式的函数或者使用HtoEthermo.H文件中定义的函数</span>
<span class="p">}</span>

<span class="c1">//- Temperature from sensible internal energy given an initial temperature T0</span>
<span class="n">scalar</span> <span class="n">THE</span>    <span class="c1">// 在给定初始温度T0的条件下，由显内能得到的温度</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">Thermo</span><span class="o">&amp;</span> <span class="n">thermo</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">e</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">T0</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">thermo</span><span class="p">.</span><span class="n">TEs</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">T0</span><span class="p">);</span>    <span class="c1">// 调用thermo模块模板函数</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="absoluteenthalpy">
<h4>absoluteEnthalpy<a class="headerlink" href="#absoluteenthalpy" title="永久链接至标题">¶</a></h4>
<p>这是一个热力学映射类，以使用关于绝对焓的函数。</p>
<div class="literal-block-wrapper docutils container" id="id59">
<div class="code-block-caption"><span class="caption-text">src/thermophysicalModels/specie/thermo/absoluteEnthalpy/absoluteEnthalpy.H</span><a class="headerlink" href="#id59" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">enthalpy</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>    <span class="c1">// 使用焓</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">word</span> <span class="nf">energyName</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;ha&quot;</span><span class="p">;</span>    <span class="c1">// 将energyName设置为绝对焓he</span>
<span class="p">}</span>

<span class="c1">// Heat capacity at constant pressure [J/kg/K]</span>
<span class="n">scalar</span> <span class="n">Cpv</span>    <span class="c1">// 定压比热容</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">Thermo</span><span class="o">&amp;</span> <span class="n">thermo</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">thermo</span><span class="p">.</span><span class="n">Cp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Absolute enthalpy [J/kg]</span>
<span class="n">scalar</span> <span class="n">HE</span>    <span class="c1">// 绝对焓</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">Thermo</span><span class="o">&amp;</span> <span class="n">thermo</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">thermo</span><span class="p">.</span><span class="n">Ha</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//- Temperature from absolute enthalpy given an initial temperature T0</span>
<span class="n">scalar</span> <span class="n">THE</span>    <span class="c1">// 给定初始温度T0，由绝对焓得到的温度</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">Thermo</span><span class="o">&amp;</span> <span class="n">thermo</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">h</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">T0</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">thermo</span><span class="p">.</span><span class="n">THa</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">T0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="absoluteinternalenergy">
<h4>absoluteInternalEnergy<a class="headerlink" href="#absoluteinternalenergy" title="永久链接至标题">¶</a></h4>
<p>这是一个热力学映射类，以使用关于绝对内能的函数。</p>
<div class="literal-block-wrapper docutils container" id="id60">
<div class="code-block-caption"><span class="caption-text">src/thermophysicalModels/specie/thermo/absoluteInternalEnergy/absoluteInternalEnergy.H</span><a class="headerlink" href="#id60" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">enthalpy</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>    <span class="c1">// 不使用焓</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">word</span> <span class="nf">energyName</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;ea&quot;</span><span class="p">;</span>    <span class="c1">// 设置energyName为绝对内能ea</span>
<span class="p">}</span>

<span class="c1">// Heat capacity at constant volume [J/kg/K]</span>
<span class="n">scalar</span> <span class="n">Cpv</span>    <span class="c1">// 定体比热容</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">Thermo</span><span class="o">&amp;</span> <span class="n">thermo</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">thermo</span><span class="p">.</span><span class="n">Cv</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Absolute internal energy [J/kg]</span>
<span class="n">scalar</span> <span class="n">HE</span>    <span class="c1">// 绝对内能</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">Thermo</span><span class="o">&amp;</span> <span class="n">thermo</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">T</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">thermo</span><span class="p">.</span><span class="n">Ea</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//- Temperature from absolute internal energy given an initial temperature T0</span>
<span class="n">scalar</span> <span class="n">THE</span>    <span class="c1">// 给定初始温度T0，由绝对内能得到的温度</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">Thermo</span><span class="o">&amp;</span> <span class="n">thermo</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">e</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">T0</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">thermo</span><span class="p">.</span><span class="n">TEa</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">T0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="thermophysicaltransport">
<h2>ThermophysicalTransport<a class="headerlink" href="#thermophysicaltransport" title="永久链接至标题">¶</a></h2>
<p>ThermophysicalTransport模块中包含湍流影响的热物理量，例如热通量、有效热扩散系数等，在求解器中将会通过thermophysicalTransport-&gt;的形式来调用对应的函数。在构建其函数的过程中继承了heThermo.C文件中的函数，并利用thermo()来调用其中的函数来计算对应物理量。</p>
<p>eddyDiffusivity是用于单相RAS或LES湍流流动的基于温度梯度热通量的涡流扩散模型。需要通过RAS/LES子字典中model关键词进行设置。热通量源通过一种隐式能量对温度梯度的修正来构建，在收敛的时候能量修正为零。</p>
<div class="literal-block-wrapper docutils container" id="id61">
<div class="code-block-caption"><span class="caption-text">src/ThermophysicalTransportModels/turbulence/eddyDiffusivity/eddyDiffusivity.H</span><a class="headerlink" href="#id61" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">//- Turbulent thermal diffusivity for enthalpy [kg/m/s]</span>
<span class="n">virtual</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">alphat</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">alphat_</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//- Turbulent thermal diffusivity for enthalpy for a patch [kg/m/s]</span>
<span class="n">virtual</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">scalarField</span><span class="o">&gt;</span> <span class="n">alphat</span><span class="p">(</span><span class="k">const</span> <span class="n">label</span> <span class="n">patchi</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">alphat</span><span class="p">()().</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">//- Effective thermal turbulent diffusivity for temperature of mixture [W/m/K]</span>
<span class="n">virtual</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">kappaEff</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">thermo</span><span class="p">().</span><span class="n">kappaEff</span><span class="p">(</span><span class="n">alphat</span><span class="p">());</span>
<span class="p">}</span>

<span class="c1">//- Effective thermal turbulent diffusivity for temperature of mixture for patch [W/m/K]</span>
<span class="n">virtual</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">scalarField</span><span class="o">&gt;</span> <span class="n">kappaEff</span><span class="p">(</span><span class="k">const</span> <span class="n">label</span> <span class="n">patchi</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">thermo</span><span class="p">().</span><span class="n">kappaEff</span>
    <span class="p">(</span>
        <span class="n">alphat</span><span class="p">(</span><span class="n">patchi</span><span class="p">),</span>
        <span class="n">patchi</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="c1">//- Effective thermal turbulent diffusivity of mixture [kg/m/s]</span>
<span class="n">virtual</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">alphaEff</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">thermo</span><span class="p">().</span><span class="n">alphaEff</span><span class="p">(</span><span class="n">alphat</span><span class="p">());</span>
<span class="p">}</span>

<span class="c1">//- Effective thermal turbulent diffusivity of mixture for patch [kg/m/s]</span>
<span class="n">virtual</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">scalarField</span><span class="o">&gt;</span> <span class="n">alphaEff</span><span class="p">(</span><span class="k">const</span> <span class="n">label</span> <span class="n">patchi</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">thermo</span><span class="p">().</span><span class="n">alphaEff</span>
    <span class="p">(</span>
        <span class="n">alphat</span><span class="p">(</span><span class="n">patchi</span><span class="p">),</span>
        <span class="n">patchi</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id62">
<div class="code-block-caption"><span class="caption-text">src/ThermophysicalTransportModels/turbulence/eddyDiffusivity/eddyDiffusivity.C</span><a class="headerlink" href="#id62" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">TurbulenceThermophysicalTransportModel</span><span class="o">&gt;</span>
<span class="n">tmp</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="o">&gt;</span>
<span class="n">eddyDiffusivity</span><span class="o">&lt;</span><span class="n">TurbulenceThermophysicalTransportModel</span><span class="o">&gt;::</span><span class="n">q</span><span class="p">()</span> <span class="k">const</span>    <span class="c1">// 热通量</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">surfaceScalarField</span><span class="o">::</span><span class="n">New</span>
    <span class="p">(</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">groupName</span>
        <span class="p">(</span>
            <span class="s">&quot;q&quot;</span><span class="p">,</span>
            <span class="n">this</span><span class="o">-&gt;</span><span class="n">momentumTransport</span><span class="p">().</span><span class="n">alphaRhoPhi</span><span class="p">().</span><span class="n">group</span><span class="p">()</span>
        <span class="p">),</span>
       <span class="o">-</span><span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">kappaEff</span><span class="p">())</span>
       <span class="o">*</span><span class="n">fvc</span><span class="o">::</span><span class="n">snGrad</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">thermo</span><span class="p">().</span><span class="n">T</span><span class="p">())</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">TurbulenceThermophysicalTransportModel</span><span class="o">&gt;</span>
<span class="n">tmp</span><span class="o">&lt;</span><span class="n">fvScalarMatrix</span><span class="o">&gt;</span>
<span class="n">eddyDiffusivity</span><span class="o">&lt;</span><span class="n">TurbulenceThermophysicalTransportModel</span><span class="o">&gt;::</span><span class="n">divq</span>    <span class="c1">// 热通量的散度</span>
<span class="p">(</span>
    <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">he</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="c1">// Return heat flux source as an implicit energy correction to the temperature gradient flux</span>
    <span class="k">return</span>
        <span class="o">-</span><span class="n">correction</span><span class="p">(</span><span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">alphaEff</span><span class="p">(),</span> <span class="n">he</span><span class="p">))</span>
        <span class="o">-</span><span class="n">fvc</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">kappaEff</span><span class="p">(),</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">thermo</span><span class="p">().</span><span class="n">T</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>其中函数correction()的定义为</p>
<div class="literal-block-wrapper docutils container" id="id63">
<div class="code-block-caption"><span class="caption-text">src/finiteVolume/fvMatrices/fvMatrix/fvMatrix.C</span><a class="headerlink" href="#id63" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span> <span class="n">Foam</span><span class="o">::</span><span class="n">correction</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&amp;</span> <span class="n">A</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span> <span class="n">tAcorr</span> <span class="o">=</span> <span class="n">A</span> <span class="o">-</span> <span class="p">(</span><span class="n">A</span> <span class="o">&amp;</span> <span class="n">A</span><span class="p">.</span><span class="n">psi</span><span class="p">());</span>

    <span class="c1">// Delete the faceFluxCorrection from the correction matrix as it does not have a clear meaning or purpose</span>
    <span class="n">deleteDemandDrivenData</span><span class="p">(</span><span class="n">tAcorr</span><span class="p">.</span><span class="n">ref</span><span class="p">().</span><span class="n">faceFluxCorrectionPtr</span><span class="p">());</span>

    <span class="k">return</span> <span class="n">tAcorr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">关于correction()函数的讨论见 <a class="reference external" href="https://www.cfd-online.com/Forums/openfoam-programming-development/152356-foam-correction-function.html">Foam::correction() function</a> 。一个帮助理解该函数作用的例子是：correction(fvm::ddt(p)) 表示 d(p)/d(t) - d(pold)/d(t) 。</p>
</div>
<p>unityLewisEddyDiffusivity是用于RAS或LES模型的基于能量梯度热通量模型的涡流扩散模型，物质的通量在计算时假定具有统一的Lewis数。它是RAS/LES默认采用的模型，或者也可以子字典中的model关键词进行设置。</p>
<div class="literal-block-wrapper docutils container" id="id64">
<div class="code-block-caption"><span class="caption-text">src/ThermophysicalTransportModels/turbulence/unityLewisEddyDiffusivity/unityLewisEddyDiffusivity.H</span><a class="headerlink" href="#id64" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">virtual</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">alphat</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">alphat_</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//- Turbulent thermal diffusivity for enthalpy for a patch [kg/m/s]</span>
<span class="n">virtual</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">scalarField</span><span class="o">&gt;</span> <span class="n">alphat</span><span class="p">(</span><span class="k">const</span> <span class="n">label</span> <span class="n">patchi</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">alphat</span><span class="p">()().</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">//- Effective thermal turbulent diffusivity for temperature of mixture [W/m/K]</span>
<span class="n">virtual</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">kappaEff</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">thermo</span><span class="p">().</span><span class="n">kappaEff</span><span class="p">(</span><span class="n">alphat</span><span class="p">());</span>
<span class="p">}</span>

<span class="c1">//- Effective thermal turbulent diffusivity for temperature of mixture for patch [W/m/K]</span>
<span class="n">virtual</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">scalarField</span><span class="o">&gt;</span> <span class="n">kappaEff</span><span class="p">(</span><span class="k">const</span> <span class="n">label</span> <span class="n">patchi</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">thermo</span><span class="p">().</span><span class="n">kappaEff</span>
    <span class="p">(</span>
        <span class="n">alphat</span><span class="p">(</span><span class="n">patchi</span><span class="p">),</span>
        <span class="n">patchi</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="c1">//- Effective thermal turbulent diffusivity of mixture [kg/m/s]</span>
<span class="n">virtual</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">alphaEff</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">thermo</span><span class="p">().</span><span class="n">alphaEff</span><span class="p">(</span><span class="n">alphat</span><span class="p">());</span>
<span class="p">}</span>

<span class="c1">//- Effective thermal turbulent diffusivity of mixture for patch [kg/m/s]</span>
<span class="n">virtual</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">scalarField</span><span class="o">&gt;</span> <span class="n">alphaEff</span><span class="p">(</span><span class="k">const</span> <span class="n">label</span> <span class="n">patchi</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">thermo</span><span class="p">().</span><span class="n">alphaEff</span>
    <span class="p">(</span>
        <span class="n">alphat</span><span class="p">(</span><span class="n">patchi</span><span class="p">),</span>
        <span class="n">patchi</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="c1">//- Effective mass diffusion coefficient for a given specie mass-fraction [kg/m/s]</span>
<span class="n">virtual</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">DEff</span><span class="p">(</span><span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">Yi</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">volScalarField</span><span class="o">::</span><span class="n">New</span>
    <span class="p">(</span>
        <span class="s">&quot;DEff&quot;</span><span class="p">,</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">thermo</span><span class="p">().</span><span class="n">kappa</span><span class="p">()</span><span class="o">/</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">thermo</span><span class="p">().</span><span class="n">Cp</span><span class="p">()</span> <span class="o">+</span> <span class="n">alphat</span><span class="p">()</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="c1">//- Effective mass diffusion coefficient for a given specie mass-fraction for patch [kg/m/s]</span>
<span class="n">virtual</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">scalarField</span><span class="o">&gt;</span> <span class="n">DEff</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">Yi</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">label</span> <span class="n">patchi</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">thermo</span><span class="p">().</span><span class="n">kappa</span><span class="p">().</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">]</span>
       <span class="o">/</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">thermo</span><span class="p">().</span><span class="n">Cp</span><span class="p">().</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">]</span>
      <span class="o">+</span> <span class="n">alphat</span><span class="p">(</span><span class="n">patchi</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id65">
<div class="code-block-caption"><span class="caption-text">src/ThermophysicalTransportModels/turbulence/unityLewisEddyDiffusivity/unityLewisEddyDiffusivity.C</span><a class="headerlink" href="#id65" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">TurbulenceThermophysicalTransportModel</span><span class="o">&gt;</span>
<span class="n">tmp</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="o">&gt;</span>
<span class="n">unityLewisEddyDiffusivity</span><span class="o">&lt;</span><span class="n">TurbulenceThermophysicalTransportModel</span><span class="o">&gt;::</span><span class="n">q</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">surfaceScalarField</span><span class="o">::</span><span class="n">New</span>
    <span class="p">(</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">groupName</span>
        <span class="p">(</span>
            <span class="s">&quot;q&quot;</span><span class="p">,</span>
            <span class="n">this</span><span class="o">-&gt;</span><span class="n">momentumTransport</span><span class="p">().</span><span class="n">alphaRhoPhi</span><span class="p">().</span><span class="n">group</span><span class="p">()</span>
        <span class="p">),</span>
       <span class="o">-</span><span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">alphaEff</span><span class="p">()</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">alpha</span><span class="p">())</span>
       <span class="o">*</span><span class="n">fvc</span><span class="o">::</span><span class="n">snGrad</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">thermo</span><span class="p">().</span><span class="n">he</span><span class="p">())</span>
    <span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">TurbulenceThermophysicalTransportModel</span><span class="o">&gt;</span>
<span class="n">tmp</span><span class="o">&lt;</span><span class="n">fvScalarMatrix</span><span class="o">&gt;</span>
<span class="n">unityLewisEddyDiffusivity</span><span class="o">&lt;</span><span class="n">TurbulenceThermophysicalTransportModel</span><span class="o">&gt;::</span><span class="n">divq</span>
<span class="p">(</span>
    <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">he</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">alphaEff</span><span class="p">(),</span> <span class="n">he</span><span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">TurbulenceThermophysicalTransportModel</span><span class="o">&gt;</span>
<span class="n">tmp</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="o">&gt;</span>
<span class="n">unityLewisEddyDiffusivity</span><span class="o">&lt;</span><span class="n">TurbulenceThermophysicalTransportModel</span><span class="o">&gt;::</span><span class="n">j</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">Yi</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">surfaceScalarField</span><span class="o">::</span><span class="n">New</span>
    <span class="p">(</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">groupName</span>
        <span class="p">(</span>
            <span class="s">&quot;j(&quot;</span> <span class="o">+</span> <span class="n">Yi</span><span class="p">.</span><span class="n">name</span><span class="p">()</span> <span class="o">+</span> <span class="sc">&#39;)&#39;</span><span class="p">,</span>
            <span class="n">this</span><span class="o">-&gt;</span><span class="n">momentumTransport</span><span class="p">().</span><span class="n">alphaRhoPhi</span><span class="p">().</span><span class="n">group</span><span class="p">()</span>
        <span class="p">),</span>
       <span class="o">-</span><span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">DEff</span><span class="p">(</span><span class="n">Yi</span><span class="p">)</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">alpha</span><span class="p">())</span><span class="o">*</span><span class="n">fvc</span><span class="o">::</span><span class="n">snGrad</span><span class="p">(</span><span class="n">Yi</span><span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">TurbulenceThermophysicalTransportModel</span><span class="o">&gt;</span>
<span class="n">tmp</span><span class="o">&lt;</span><span class="n">fvScalarMatrix</span><span class="o">&gt;</span>
<span class="n">unityLewisEddyDiffusivity</span><span class="o">&lt;</span><span class="n">TurbulenceThermophysicalTransportModel</span><span class="o">&gt;::</span><span class="n">divj</span>
<span class="p">(</span>
    <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">Yi</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">DEff</span><span class="p">(</span><span class="n">Yi</span><span class="p">),</span> <span class="n">Yi</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>Non-unity-Lewis-Eddy-diffusivity based temperature gradient heat flux model for RAS or LES of turbulent flow. Allows independent specification of turbulent Prandtl and Schmidt numbers.  Unity laminar Lewis number is assumed. The heat flux source is implemented as an implicit energy correction to the temperature gradient based flux source.  At convergence the energy correction is 0.</p>
<div class="literal-block-wrapper docutils container" id="id66">
<div class="code-block-caption"><span class="caption-text">src/ThermophysicalTransportModels/turbulence/nonUnityLewisEddyDiffusivity/nonUnityLewisEddyDiffusivity.H</span><a class="headerlink" href="#id66" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">//- Effective mass diffusion coefficient for a given specie mass-fraction [kg/m/s]</span>
<span class="n">virtual</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">DEff</span><span class="p">(</span><span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">Yi</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">volScalarField</span><span class="o">::</span><span class="n">New</span>
    <span class="p">(</span>
        <span class="s">&quot;DEff&quot;</span><span class="p">,</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">thermo</span><span class="p">().</span><span class="n">alphaEff</span><span class="p">((</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">Prt_</span><span class="o">/</span><span class="n">Sct_</span><span class="p">)</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">alphat</span><span class="p">())</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="c1">//- Effective mass diffusion coefficient for a given specie mass-fraction for patch [kg/m/s]</span>
<span class="n">virtual</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">scalarField</span><span class="o">&gt;</span> <span class="n">DEff</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">Yi</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">label</span> <span class="n">patchi</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">thermo</span><span class="p">().</span><span class="n">alphaEff</span>
    <span class="p">(</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">Prt_</span><span class="p">.</span><span class="n">value</span><span class="p">()</span><span class="o">/</span><span class="n">Sct_</span><span class="p">.</span><span class="n">value</span><span class="p">()</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">alphat</span><span class="p">(</span><span class="n">patchi</span><span class="p">),</span>
        <span class="n">patchi</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id67">
<div class="code-block-caption"><span class="caption-text">src/ThermophysicalTransportModels/turbulence/nonUnityLewisEddyDiffusivity/nonUnityLewisEddyDiffusivity.C</span><a class="headerlink" href="#id67" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">TurbulenceThermophysicalTransportModel</span><span class="o">&gt;</span>
<span class="n">tmp</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="o">&gt;</span>
<span class="n">nonUnityLewisEddyDiffusivity</span><span class="o">&lt;</span><span class="n">TurbulenceThermophysicalTransportModel</span><span class="o">&gt;::</span><span class="n">q</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="o">&gt;</span> <span class="n">tmpq</span>
    <span class="p">(</span>
        <span class="n">surfaceScalarField</span><span class="o">::</span><span class="n">New</span>
        <span class="p">(</span>
            <span class="n">IOobject</span><span class="o">::</span><span class="n">groupName</span>
            <span class="p">(</span>
                <span class="s">&quot;q&quot;</span><span class="p">,</span>
                <span class="n">this</span><span class="o">-&gt;</span><span class="n">momentumTransport</span><span class="p">().</span><span class="n">alphaRhoPhi</span><span class="p">().</span><span class="n">group</span><span class="p">()</span>
            <span class="p">),</span>
           <span class="o">-</span><span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">kappaEff</span><span class="p">())</span>
           <span class="o">*</span><span class="n">fvc</span><span class="o">::</span><span class="n">snGrad</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">thermo</span><span class="p">().</span><span class="n">T</span><span class="p">())</span>
        <span class="p">)</span>
    <span class="p">);</span>

    <span class="k">const</span> <span class="n">basicSpecieMixture</span><span class="o">&amp;</span> <span class="n">composition</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">thermo</span><span class="p">().</span><span class="n">composition</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">PtrList</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;&amp;</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">composition</span><span class="p">.</span><span class="n">Y</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">Y</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">surfaceScalarField</span> <span class="n">hGradY</span>
        <span class="p">(</span>
            <span class="n">surfaceScalarField</span><span class="o">::</span><span class="n">New</span>
            <span class="p">(</span>
                <span class="s">&quot;hGradY&quot;</span><span class="p">,</span>
                <span class="n">Y</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">mesh</span><span class="p">(),</span>
                <span class="n">dimensionedScalar</span><span class="p">(</span><span class="n">dimEnergy</span><span class="o">/</span><span class="n">dimMass</span><span class="o">/</span><span class="n">dimLength</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">);</span>

        <span class="n">forAll</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">const</span> <span class="n">volScalarField</span> <span class="n">hi</span>
            <span class="p">(</span>
                <span class="n">composition</span><span class="p">.</span><span class="n">Hs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">thermo</span><span class="p">().</span><span class="n">p</span><span class="p">(),</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">thermo</span><span class="p">().</span><span class="n">T</span><span class="p">())</span>
            <span class="p">);</span>

            <span class="n">hGradY</span> <span class="o">+=</span> <span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">hi</span><span class="p">)</span><span class="o">*</span><span class="n">fvc</span><span class="o">::</span><span class="n">snGrad</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>

        <span class="n">tmpq</span><span class="p">.</span><span class="n">ref</span><span class="p">()</span> <span class="o">-=</span>
            <span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span>
            <span class="p">(</span>
                <span class="n">this</span><span class="o">-&gt;</span><span class="n">alpha</span><span class="p">()</span>
               <span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">thermo</span><span class="p">().</span><span class="n">alphaEff</span><span class="p">((</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">Prt_</span><span class="o">/</span><span class="n">Sct_</span><span class="p">)</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">alphat</span><span class="p">())</span>
            <span class="p">)</span><span class="o">*</span><span class="n">hGradY</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">tmpq</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">TurbulenceThermophysicalTransportModel</span><span class="o">&gt;</span>
<span class="n">tmp</span><span class="o">&lt;</span><span class="n">fvScalarMatrix</span><span class="o">&gt;</span>
<span class="n">nonUnityLewisEddyDiffusivity</span><span class="o">&lt;</span><span class="n">TurbulenceThermophysicalTransportModel</span><span class="o">&gt;::</span><span class="n">divq</span>
<span class="p">(</span>
    <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">he</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">fvScalarMatrix</span><span class="o">&gt;</span> <span class="n">tmpDivq</span>
    <span class="p">(</span>
        <span class="n">fvm</span><span class="o">::</span><span class="n">Su</span>
        <span class="p">(</span>
            <span class="o">-</span><span class="n">fvc</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">kappaEff</span><span class="p">(),</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">thermo</span><span class="p">().</span><span class="n">T</span><span class="p">()),</span>
            <span class="n">he</span>
        <span class="p">)</span>
    <span class="p">);</span>

    <span class="k">const</span> <span class="n">basicSpecieMixture</span><span class="o">&amp;</span> <span class="n">composition</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">thermo</span><span class="p">().</span><span class="n">composition</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">PtrList</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;&amp;</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">composition</span><span class="p">.</span><span class="n">Y</span><span class="p">();</span>

    <span class="n">tmpDivq</span><span class="p">.</span><span class="n">ref</span><span class="p">()</span> <span class="o">-=</span>
        <span class="n">correction</span><span class="p">(</span><span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">alphaEff</span><span class="p">(),</span> <span class="n">he</span><span class="p">));</span>

    <span class="n">surfaceScalarField</span> <span class="nf">hGradY</span>
    <span class="p">(</span>
        <span class="n">surfaceScalarField</span><span class="o">::</span><span class="n">New</span>
        <span class="p">(</span>
            <span class="s">&quot;hGradY&quot;</span><span class="p">,</span>
            <span class="n">he</span><span class="p">.</span><span class="n">mesh</span><span class="p">(),</span>
            <span class="n">dimensionedScalar</span><span class="p">(</span><span class="n">he</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()</span><span class="o">/</span><span class="n">dimLength</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">);</span>

    <span class="n">forAll</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">volScalarField</span> <span class="n">hi</span>
        <span class="p">(</span>
            <span class="n">composition</span><span class="p">.</span><span class="n">Hs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">thermo</span><span class="p">().</span><span class="n">p</span><span class="p">(),</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">thermo</span><span class="p">().</span><span class="n">T</span><span class="p">())</span>
        <span class="p">);</span>

        <span class="n">hGradY</span> <span class="o">+=</span> <span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">hi</span><span class="p">)</span><span class="o">*</span><span class="n">fvc</span><span class="o">::</span><span class="n">snGrad</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="n">tmpDivq</span><span class="p">.</span><span class="n">ref</span><span class="p">()</span> <span class="o">-=</span>
        <span class="n">fvc</span><span class="o">::</span><span class="n">div</span>
        <span class="p">(</span>
            <span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span>
            <span class="p">(</span>
                <span class="n">this</span><span class="o">-&gt;</span><span class="n">alpha</span><span class="p">()</span>
               <span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">thermo</span><span class="p">().</span><span class="n">alphaEff</span><span class="p">((</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">Prt_</span><span class="o">/</span><span class="n">Sct_</span><span class="p">)</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">alphat</span><span class="p">())</span>
            <span class="p">)</span><span class="o">*</span><span class="n">hGradY</span><span class="o">*</span><span class="n">he</span><span class="p">.</span><span class="n">mesh</span><span class="p">().</span><span class="n">magSf</span><span class="p">()</span>
        <span class="p">);</span>

    <span class="k">return</span> <span class="n">tmpDivq</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>Multi-component Fickian and eddy-diffusivity turbulent based temperature gradient heat flux model for RAS or LES of turbulent flow with optional Soret thermal diffusion of species. The mixture diffusion coefficients are specified as Function2&lt;scalar&gt;s of pressure and temperature but independent of composition. The heat flux source is implemented as an implicit energy correction to the temperature gradient based flux source.  At convergence the energy correction is 0.</p>
<div class="literal-block-wrapper docutils container" id="id68">
<div class="code-block-caption"><span class="caption-text">src/ThermophysicalTransportModels/turbulence/FickianEddyDiffusivity/FickianEddyDiffusivity.C</span><a class="headerlink" href="#id68" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">TurbulenceThermophysicalTransportModel</span><span class="o">&gt;</span>
<span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span>
<span class="n">FickianEddyDiffusivity</span><span class="o">&lt;</span><span class="n">TurbulenceThermophysicalTransportModel</span><span class="o">&gt;::</span><span class="n">DEff</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">Yi</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">volScalarField</span><span class="o">::</span><span class="n">New</span>
    <span class="p">(</span>
        <span class="s">&quot;DEff&quot;</span><span class="p">,</span>
        <span class="n">Fickian</span>
        <span class="o">&lt;</span>
            <span class="n">unityLewisEddyDiffusivity</span><span class="o">&lt;</span><span class="n">TurbulenceThermophysicalTransportModel</span><span class="o">&gt;</span>
        <span class="o">&gt;::</span><span class="n">DEff</span><span class="p">(</span><span class="n">Yi</span><span class="p">)</span>
      <span class="o">+</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">Prt_</span><span class="o">/</span><span class="n">Sct_</span><span class="p">)</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">alphat</span><span class="p">()</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">TurbulenceThermophysicalTransportModel</span><span class="o">&gt;</span>
<span class="n">tmp</span><span class="o">&lt;</span><span class="n">scalarField</span><span class="o">&gt;</span>
<span class="n">FickianEddyDiffusivity</span><span class="o">&lt;</span><span class="n">TurbulenceThermophysicalTransportModel</span><span class="o">&gt;::</span><span class="n">DEff</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">Yi</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">label</span> <span class="n">patchi</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span>
        <span class="n">Fickian</span>
        <span class="o">&lt;</span>
            <span class="n">unityLewisEddyDiffusivity</span><span class="o">&lt;</span><span class="n">TurbulenceThermophysicalTransportModel</span><span class="o">&gt;</span>
        <span class="o">&gt;::</span><span class="n">DEff</span><span class="p">(</span><span class="n">Yi</span><span class="p">,</span> <span class="n">patchi</span><span class="p">)</span>
      <span class="o">+</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">Prt_</span><span class="p">.</span><span class="n">value</span><span class="p">()</span><span class="o">/</span><span class="n">Sct_</span><span class="p">.</span><span class="n">value</span><span class="p">()</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">alphat</span><span class="p">(</span><span class="n">patchi</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id7">
<h2>场设置<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<p>常用的场文件名称及其意义如下所示：</p>
<table border="1" class="docutils">
<colgroup>
<col width="5%" />
<col width="44%" />
<col width="52%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">文件名</th>
<th class="head">含义</th>
<th class="head">量纲</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>U</td>
<td>速度</td>
<td><span class="math notranslate nohighlight">\(\mathrm{m\cdot s^{-1}}\)</span></td>
</tr>
<tr class="row-odd"><td>U_0</td>
<td>前一个时间步长的速度(需要重新启动更高阶时间步长的格式时建立)</td>
<td><span class="math notranslate nohighlight">\(\mathrm{m\cdot s^{-1}}\)</span></td>
</tr>
<tr class="row-even"><td>phi</td>
<td>流量</td>
<td>对于不可压缩流为 <span class="math notranslate nohighlight">\(\mathrm{m^{3}\cdot s^{-1}}\)</span> ；对于可压缩流为 <span class="math notranslate nohighlight">\(\mathrm{kg\cdot s^{-1}}\)</span></td>
</tr>
<tr class="row-odd"><td rowspan="2">p</td>
<td rowspan="2"><p class="first">压力。对于不可压缩求解器，这个场实际上是由恒定流体密度归一化的压力，</p>
<p class="last">如果要得到真实的压力则需要在后期处理中乘以流体的密度。对于可压缩解算器，p是真实压力。</p>
</td>
<td rowspan="2"><p class="first">对于不可压缩流为 <span class="math notranslate nohighlight">\(\mathrm{m^{3}\cdot s^{-1}}\)</span> ；</p>
<p class="last">对于可压缩流为 <span class="math notranslate nohighlight">\(\mathrm{kg\cdot s^{-1}}\)</span></p>
</td>
</tr>
<tr class="row-even"></tr>
<tr class="row-odd"><td>epsilon</td>
<td>湍流耗散率</td>
<td><span class="math notranslate nohighlight">\(\mathrm{m^{2}\cdot s^{-3}}\)</span></td>
</tr>
<tr class="row-even"><td>k</td>
<td>湍流动能</td>
<td><span class="math notranslate nohighlight">\(\mathrm{m^{2}\cdot s^{-2}}\)</span></td>
</tr>
<tr class="row-odd"><td>rho</td>
<td>密度</td>
<td><span class="math notranslate nohighlight">\(\mathrm{kg\cdot m^{-3}}\)</span></td>
</tr>
<tr class="row-even"><td>alpha</td>
<td>分散相体积分数</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>Theta</td>
<td>颗粒温度</td>
<td><span class="math notranslate nohighlight">\(\mathrm{m^{2}\cdot s^{-2}}\)</span></td>
</tr>
<tr class="row-even"><td rowspan="2">rDeltaT</td>
<td rowspan="2"><p class="first">时间步长的倒数。对于改变局部时间步长的求解器，这表示局部时间步长。</p>
<p class="last">这对于调试尤其有用。rDeltaT的高值可能表明需要在一个区域内进一步细化网格。</p>
</td>
<td rowspan="2"><span class="math notranslate nohighlight">\(\mathrm{s^{-1}}\)</span></td>
</tr>
<tr class="row-odd"></tr>
</tbody>
</table>
</div>
<div class="section" id="id8">
<h2>边界条件<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<p>边界上的某个场值，或者梯度值，其计算方法可以用如下通式表示：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; \phi_{f} = A_{1} \phi_{c} + B_{1} \\
&amp; \nabla \phi_{f} = A_{2} \phi_{c} + B_{2}
\end{align}\end{split}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\phi_{c}\)</span> 表示 <span class="math notranslate nohighlight">\(\phi\)</span> 在邻近边界的网格中心的值，四个系数 <span class="math notranslate nohighlight">\(A_{1},B_{1},A_{2},B_{2}\)</span> 分别通过 <code class="code docutils literal notranslate"><span class="pre">valueInternalCoeffs</span></code> 、 <code class="code docutils literal notranslate"><span class="pre">valueBoundaryCoeffs</span></code> 、 <code class="code docutils literal notranslate"><span class="pre">gradientInternalCoeffs</span></code> 、 <code class="code docutils literal notranslate"><span class="pre">gradientBoundaryCoeffs</span></code> 来表示。</p>
<p><code class="code docutils literal notranslate"><span class="pre">updateCoeffs()</span></code> 主要用来显式地计算并更新变量在边界上的值，当边界上的值是通过某个依赖于外部参数的公式来计算，并且值会随着迭代的进行而不断改变时，则需要用 <code class="code docutils literal notranslate"><span class="pre">updateCoeffs()</span></code> 。有些边界条件，比如最基本的 <code class="code docutils literal notranslate"><span class="pre">zeroGradient()</span></code> ，不需要外部的参数，只需要每一次将临近网格的值赋给边界就可以了，这时就可以用 <code class="code docutils literal notranslate"><span class="pre">evaluate()</span></code> 。</p>
<p>而有些边界条件继承于transform边界，里面额外定义了通过snGrad()和snGradTransformDiag()确定系数的方式，查看src/finiteVolume/fields/fvPatchFields/basic/transform中的transformFvPatchField.C可以看到它们之间的关系：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">transformFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">valueInternalCoeffs</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">scalarField</span><span class="o">&gt;&amp;</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">pTraits</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">one</span> <span class="o">-</span> <span class="n">snGradTransformDiag</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">pTraits&lt;Type&gt;::one</span></code> 表示的是全一向量。上面的代码说明transform边界设定的系数 <span class="math notranslate nohighlight">\(A_{1}\)</span> 表达式为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
A_{1} = (1, 1,1) - \text{snGradTransformDiag} =
\begin{bmatrix}
1 - \text{snGradTransformDiag}_{x} \\
1 - \text{snGradTransformDiag}_{y} \\
1 - \text{snGradTransformDiag}_{z}
\end{bmatrix}
\end{align}\end{split}\]</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">transformFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">valueBoundaryCoeffs</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">scalarField</span><span class="o">&gt;&amp;</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span>
        <span class="o">*</span><span class="n">this</span>
      <span class="o">-</span> <span class="n">cmptMultiply</span>
        <span class="p">(</span>
            <span class="n">valueInternalCoeffs</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">weights</span><span class="p">()),</span>
            <span class="n">this</span><span class="o">-&gt;</span><span class="n">patchInternalField</span><span class="p">()</span>
        <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">cmptMultiply</span></code> 表示的是按位相乘。上面的代码说明transform边界设定的系数 <span class="math notranslate nohighlight">\(B_{1}\)</span> 表达式为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
B_{1} = \vec{\phi}_{p} - [(1, 1, 1) - \text{snGradTransformDiag}] * \vec{\phi}_{c} =
\begin{bmatrix}
\phi_{px} - (1 - \text{snGradTransformDiag}_{x})\cdot \phi_{cx} \\
\phi_{py} - (1 - \text{snGradTransformDiag}_{y})\cdot \phi_{cy} \\
\phi_{pz} - (1 - \text{snGradTransformDiag}_{z})\cdot \phi_{cz}
\end{bmatrix}
\end{align}\end{split}\]</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">transformFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">gradientInternalCoeffs</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">deltaCoeffs</span><span class="p">()</span><span class="o">*</span><span class="n">snGradTransformDiag</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>其中 <code class="code docutils literal notranslate"><span class="pre">this-&gt;patch().deltaCoeffs()</span></code> 可以认为返回的是 <span class="math notranslate nohighlight">\(1/d\)</span> 。上面的代码说明transform边界条件设定的系数 <span class="math notranslate nohighlight">\(A_{2}\)</span> 表达式为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
A_{2} = - \frac{1}{d} \times \text{snGradTransformDiag} =
\begin{bmatrix}
- \frac{1}{d} \times \text{snGradTransformDiag}_{x} \\
- \frac{1}{d} \times \text{snGradTransformDiag}_{y} \\
- \frac{1}{d} \times \text{snGradTransformDiag}_{z}
\end{bmatrix}
\end{align}\end{split}\]</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">transformFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">gradientBoundaryCoeffs</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span>
        <span class="n">snGrad</span><span class="p">()</span>
      <span class="o">-</span> <span class="n">cmptMultiply</span><span class="p">(</span><span class="n">gradientInternalCoeffs</span><span class="p">(),</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">patchInternalField</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码说明transform边界条件设定的系数 <span class="math notranslate nohighlight">\(B_{2}\)</span> 表达式为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
B_{2} = \text{snGrad} - \big( -(\frac{1}{d}) \times \text{snGradTransformDiag} \big) \cdot \vec{\phi}_{c} =
\begin{bmatrix}
\text{snGrad}_{x} + \frac{1}{d} \times \text{snGradTransformDiag}_{x} \times \phi_{cx} \\
\text{snGrad}_{y} + \frac{1}{d} \times \text{snGradTransformDiag}_{y} \times \phi_{cy} \\
\text{snGrad}_{z} + \frac{1}{d} \times \text{snGradTransformDiag}_{z} \times \phi_{cz}
\end{bmatrix}
\end{align}\end{split}\]</div>
<p>部分派生类在定义自己的snGrad()和snGradTransformDiag()会涉及到 <code class="code docutils literal notranslate"><span class="pre">transform</span></code> 函数和 <code class="code docutils literal notranslate"><span class="pre">transformFieldMask</span></code> 。参考 <a class="reference external" href="http://xiaopingqiu.github.io/2016/04/02/Boundary-conditions-in-OpenFOAM3/">OpenFOAM 中的边界条件（三）</a> transform 函数的作用为：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kr">inline</span> <span class="n">scalar</span> <span class="nf">transform</span><span class="p">(</span><span class="n">constsymmTensor</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">scalar</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Cmpt</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">Cmpt</span><span class="o">&gt;</span> <span class="n">transform</span><span class="p">(</span><span class="k">const</span> <span class="n">symmTensor</span><span class="o">&amp;</span> <span class="n">stt</span><span class="p">,</span> <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">Cmpt</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">stt</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>而与transformFieldMask有关的下述代码经过测试返回的是 <code class="code docutils literal notranslate"><span class="pre">diag</span></code> 本身：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">transformFieldMask</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pow</span><span class="o">&lt;</span><span class="n">vector</span><span class="p">,</span> <span class="n">pTraits</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">rank</span><span class="o">&gt;</span><span class="p">(</span><span class="n">diag</span><span class="p">))</span>
</pre></div>
</div>
<div class="section" id="id10">
<h3>通用边界条件<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<div class="section" id="fixedvalue">
<h4>fixedValue<a class="headerlink" href="#fixedvalue" title="永久链接至标题">¶</a></h4>
<p>fixedValue边界条件对边界值和梯度值的计算方式如下：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
x_{p} &amp; = a \\
\nabla x_{p} &amp; = \frac{a - x_{c}}{d}
\end{align}\end{split}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(a\)</span> 是自己通过value关键词设定的值， <span class="math notranslate nohighlight">\(d\)</span> 是面心与面所属网格中心的距离。于是四个参数的设置应当如下：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; A_{1} = 0, &amp;&amp; B_{1}=a \\
&amp; A_{2} = -\frac{1}{d} , &amp;&amp; B_{2} = \frac{a}{d}
\end{align}\end{split}\]</div>
<p>可以通过位于src/finiteVolume/fields/fvPatchFields/basic/fixedValue的fixedValueFvPatchField.C文件查看其内容：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">fixedValueFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">write</span><span class="p">(</span><span class="n">Ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">fvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">write</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">this</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码说明fixedValue边界条件需要读取value关键词的值，来赋值给 <code class="code docutils literal notranslate"><span class="pre">*this</span></code></p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">fixedValueFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">valueInternalCoeffs</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">scalarField</span><span class="o">&gt;&amp;</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
    <span class="p">(</span>
        <span class="n">new</span> <span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">(),</span> <span class="n">Zero</span><span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码是将valueInternalCoeffs也就是 <span class="math notranslate nohighlight">\(A_{1}\)</span> 直接设置成了零，其中 <code class="code docutils literal notranslate"><span class="pre">Zero</span></code> 是OpenFOAM自行定义的可变维度零。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">fixedValueFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">valueBoundaryCoeffs</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">scalarField</span><span class="o">&gt;&amp;</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码是将valueBoundaryCoeffs也就是 <span class="math notranslate nohighlight">\(B_{1}\)</span> 设置为value关键词的值，<code class="code docutils literal notranslate"><span class="pre">*this</span></code> 表示类本身也即当前边界上的值。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">fixedValueFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">gradientInternalCoeffs</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">pTraits</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">one</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">deltaCoeffs</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码是将gradientInternalCoeffs也就是 <span class="math notranslate nohighlight">\(A_{2}\)</span> 设置为 <span class="math notranslate nohighlight">\(-1/d\)</span> 。其中 <code class="code docutils literal notranslate"><span class="pre">pTraits&lt;Type&gt;::one</span></code> 返回的是可变维度的一；可以近似认为 <code class="code docutils literal notranslate"><span class="pre">this-&gt;patch().deltaCoeffs()</span></code> 返回的是 <span class="math notranslate nohighlight">\(1/d\)</span> ，严格来说应该是两个网格中心的距离往接触面法向的投影的倒数。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">fixedValueFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">gradientBoundaryCoeffs</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">deltaCoeffs</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码是将gradientBoundaryCoeffs也就是 <span class="math notranslate nohighlight">\(B_{2}\)</span> 设置为 <span class="math notranslate nohighlight">\(1/d \times \text{value}\)</span> 。</p>
</div>
<div class="section" id="zerogradient">
<h4>zeroGradient<a class="headerlink" href="#zerogradient" title="永久链接至标题">¶</a></h4>
<p>zeroGradient对边界的值和梯度值的计算方式如下：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
x_{p} &amp;= x_{c} \\
\nabla x_{p} &amp;= 0
\end{align}\end{split}\]</div>
<p>于是可知四个参数的设置应当如下：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; A_{1}=1, &amp;&amp; B_{1}=0 \\
&amp; A_{2}=0, &amp;&amp; B_{2}=0
\end{align}\end{split}\]</div>
<p>位于src/finiteVolume/fields/fvPatchFields/basic/zeroGradient的zeroGradientFvPatchField.C如下所示：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">zeroGradientFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">valueInternalCoeffs</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">scalarField</span><span class="o">&gt;&amp;</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
    <span class="p">(</span>
        <span class="n">new</span> <span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">(),</span> <span class="n">pTraits</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">one</span><span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码说明zeroGradient边界条件将valueInternalCoeffs也就是 <span class="math notranslate nohighlight">\(A_{1}\)</span> 设置为 <span class="math notranslate nohighlight">\(1\)</span> 。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">zeroGradientFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">valueBoundaryCoeffs</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">scalarField</span><span class="o">&gt;&amp;</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
    <span class="p">(</span>
        <span class="n">new</span> <span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">(),</span> <span class="n">Zero</span><span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码说明zeroGradient边界条件将valueBoundaryCoeffs也就是 <span class="math notranslate nohighlight">\(B_{1}\)</span> 设置为 <span class="math notranslate nohighlight">\(0\)</span> 。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">zeroGradientFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">gradientInternalCoeffs</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
    <span class="p">(</span>
        <span class="n">new</span> <span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">(),</span> <span class="n">Zero</span><span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码说明zeroGradient边界条件将gradientInternalCoeffs也就是 <span class="math notranslate nohighlight">\(A_{2}\)</span> 设置为 <span class="math notranslate nohighlight">\(0\)</span> 。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">zeroGradientFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">gradientBoundaryCoeffs</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
    <span class="p">(</span>
        <span class="n">new</span> <span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">(),</span> <span class="n">Zero</span><span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码说明zeroGradient边界条件将gradientBoundaryCoeffs也就是 <span class="math notranslate nohighlight">\(B_{2}\)</span> 设置为 <span class="math notranslate nohighlight">\(0\)</span> 。</p>
</div>
<div class="section" id="fixedgradient">
<h4>fixedGradient<a class="headerlink" href="#fixedgradient" title="永久链接至标题">¶</a></h4>
<p>fixedGradient对边界的值和梯度值的计算方式如下：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
x_{p} &amp;= x_{c} + a\cdot d \\
\nabla x_{p} &amp;= a
\end{align}\end{split}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(a\)</span> 是自行通过gradient关键词设定的固定梯度值， <span class="math notranslate nohighlight">\(d\)</span> 是面心与面所属网格中心的距离。于是可知四个参数的设置应当如下：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; A_{1}=1, &amp;&amp; B_{1}=a \cdot d \\
&amp; A_{2}=0, &amp;&amp; B_{2}=a
\end{align}\end{split}\]</div>
<p>位于src/finiteVolume/fields/fvPatchFields/basic/fixedGradient的fixedGradientFvPatchField.C如下所示：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">fixedGradientFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">write</span><span class="p">(</span><span class="n">Ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">fvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">write</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;gradient&quot;</span><span class="p">,</span> <span class="n">gradient_</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码说明fixedGradient边界条件需要读取字典中gradient关键词赋值给 <code class="code docutils literal notranslate"><span class="pre">gradient_</span></code> 变量。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">fixedGradientFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">evaluate</span><span class="p">(</span><span class="k">const</span> <span class="n">Pstream</span><span class="o">::</span><span class="n">commsTypes</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">updated</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">updateCoeffs</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">operator</span><span class="o">=</span>
    <span class="p">(</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">patchInternalField</span><span class="p">()</span> <span class="o">+</span> <span class="n">gradient_</span><span class="o">/</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">deltaCoeffs</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="n">fvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">evaluate</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码定义了evaluate操作的内容为 <span class="math notranslate nohighlight">\(x_{c} + \frac{a}{(1/d)}\)</span> ，其中 <code class="code docutils literal notranslate"><span class="pre">this-&gt;patchInternalField()</span></code> 返回 <span class="math notranslate nohighlight">\(x_{c}\)</span> ， <code class="code docutils literal notranslate"><span class="pre">this-&gt;patch().deltaCoeffs()</span></code> 返回 <span class="math notranslate nohighlight">\(1/d\)</span> 。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">fixedGradientFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">valueInternalCoeffs</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">scalarField</span><span class="o">&gt;&amp;</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">new</span> <span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">(),</span> <span class="n">pTraits</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">one</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码说明fixedGradient边界条件设定了valueInternalCoeffs也就是 <span class="math notranslate nohighlight">\(A_{1}\)</span> 的值为 <span class="math notranslate nohighlight">\(1\)</span> 。其中 <code class="code docutils literal notranslate"><span class="pre">pTraits&lt;Type&gt;::one</span></code> 返回的是 <span class="math notranslate nohighlight">\(1\)</span> 。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">fixedGradientFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">valueBoundaryCoeffs</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">scalarField</span><span class="o">&gt;&amp;</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">gradient</span><span class="p">()</span><span class="o">/</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">deltaCoeffs</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码说明fixedGradient边界条件设定了valueBoundaryCoeffs也就是 <span class="math notranslate nohighlight">\(B_{1}\)</span> 的值为 <span class="math notranslate nohighlight">\(\frac{a}{(1/d)}\)</span> 。其中 <code class="code docutils literal notranslate"><span class="pre">gradient()</span></code> 返回的是已经映射到场上的 <code class="code docutils literal notranslate"><span class="pre">gradient_</span></code> 变量，即 <span class="math notranslate nohighlight">\(a\)</span> ； <code class="code docutils literal notranslate"><span class="pre">this-&gt;patch().deltaCoeffs()</span></code> 返回的是 <span class="math notranslate nohighlight">\(1/d\)</span> 。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">fixedGradientFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">gradientInternalCoeffs</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
    <span class="p">(</span>
        <span class="n">new</span> <span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">(),</span> <span class="n">Zero</span><span class="p">)</span>    <span class="c1">// 设定A2的值为 0</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码说明fixedGradient边界条件设定了gradientInternalCoeffs也就是 <span class="math notranslate nohighlight">\(A_{2}\)</span> 的值为 <span class="math notranslate nohighlight">\(0\)</span> 。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">fixedGradientFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">gradientBoundaryCoeffs</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">gradient</span><span class="p">();</span>    <span class="c1">// 设定B2的值为已经映射到场上的gradient_变量，即a</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码说明fixedGradient边界条件设定了gradientBoundaryCoeffs也就是 <span class="math notranslate nohighlight">\(B_{2}\)</span> 的值为已经映射到场上的 <code class="code docutils literal notranslate"><span class="pre">gradient_</span></code> 变量，即 <span class="math notranslate nohighlight">\(a\)</span> 。</p>
</div>
<div class="section" id="mixed">
<h4>mixed<a class="headerlink" href="#mixed" title="永久链接至标题">¶</a></h4>
<p>mixed边界条件对边界的值和梯度值的计算方式如下：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
x_{p} &amp;= [(1-\text{valueFraction})x_{c} + \text{valueFraction}\cdot \text{refValue}] + (1-\text{valueFraction}) \cdot \text{refGradient} \cdot d \\
\nabla x_{p} &amp;= \text{valueFraction}\cdot\frac{\text{refValue} - x_{c}}{d} + (1-\text{valueFraction}) \cdot \text{refGradient}
\end{align}\end{split}\]</div>
<p>其中refValue是自行通过refValue关键词设定的参考值，refGradient是自行通过refGradient关键词设定的参考梯度，valueFraction是自行通过valueFraction关键词设定的权重值， <span class="math notranslate nohighlight">\(d\)</span> 是面心与面所属网格中心的距离。于是可知四个参数的设置应当如下：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; A_{1}=1-\text{valueFraction}, &amp;&amp; B_{1}=\text{valueFraction}\cdot \text{refValue} + (1-\text{valueFraction})\cdot \text{refGradient}\cdot d \\
&amp; A_{2}=\frac{-\text{valueFraction}}{d}, &amp;&amp; B_{2}=\frac{\text{valueFraction}\cdot \text{refValue}}{d} +(1-\text{valueFraction}) \cdot \text{refGradient}
\end{align}\end{split}\]</div>
<p>位于src/finiteVolume/fields/fvPatchFields/basic/mixed的mixedFvPatchField.C如下所示：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">mixedFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">write</span><span class="p">(</span><span class="n">Ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">fvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">write</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;refValue&quot;</span><span class="p">,</span> <span class="n">refValue_</span><span class="p">);</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;refGradient&quot;</span><span class="p">,</span> <span class="n">refGrad_</span><span class="p">);</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;valueFraction&quot;</span><span class="p">,</span> <span class="n">valueFraction_</span><span class="p">);</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">this</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码说明mixed边界条件需要分别读取字典中的refValue、refGradient、valueFraction和value关键词的值，来赋给 <code class="code docutils literal notranslate"><span class="pre">refValue_</span></code> 、 <code class="code docutils literal notranslate"><span class="pre">refGrad_</span></code> 、 <code class="code docutils literal notranslate"><span class="pre">valueFraction_</span></code> 和 <code class="code docutils literal notranslate"><span class="pre">*this</span></code> 变量。其中value关键词是由于C++特性导致的，其实并不是必须的。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">mixedFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">evaluate</span><span class="p">(</span><span class="k">const</span> <span class="n">Pstream</span><span class="o">::</span><span class="n">commsTypes</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">updated</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">updateCoeffs</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">operator</span><span class="o">=</span>    <span class="c1">// 定义evaluate操作内容为 w*a + (1-w)*(x_c + b/(1/d) )</span>
    <span class="p">(</span>
        <span class="n">valueFraction_</span><span class="o">*</span><span class="n">refValue_</span>
      <span class="o">+</span>
        <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">valueFraction_</span><span class="p">)</span><span class="o">*</span>
        <span class="p">(</span>
            <span class="n">this</span><span class="o">-&gt;</span><span class="n">patchInternalField</span><span class="p">()</span>
          <span class="o">+</span> <span class="n">refGrad_</span><span class="o">/</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">deltaCoeffs</span><span class="p">()</span>
        <span class="p">)</span>
    <span class="p">);</span>

    <span class="n">fvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">evaluate</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码定义了mixed边界条件的evaluate操作内容为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\text{valueFraction} \times \text{refValue}
+ (1.0 - \text{valueFraction}) \times
(x_{c} + \frac{\text{refGrad}}{(1/d)})
\end{align}\]</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">mixedFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">valueInternalCoeffs</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">scalarField</span><span class="o">&gt;&amp;</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">Type</span><span class="p">(</span><span class="n">pTraits</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">one</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">valueFraction_</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码表明mixed边界条件设定valueInternalCoeffs也就是 <span class="math notranslate nohighlight">\(A_{1}\)</span> 的值为 <span class="math notranslate nohighlight">\((1 - \text{valueFraction})\)</span> 。其中 <code class="code docutils literal notranslate"><span class="pre">pTraits&lt;Type&gt;::one</span></code> 作用是调整维度。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">mixedFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">valueBoundaryCoeffs</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">scalarField</span><span class="o">&gt;&amp;</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span>
         <span class="n">valueFraction_</span><span class="o">*</span><span class="n">refValue_</span>                                        <span class="c1">// 设定B1的值为 w*a + (1-w)*b/(1/d)</span>
       <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">valueFraction_</span><span class="p">)</span><span class="o">*</span><span class="n">refGrad_</span><span class="o">/</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">deltaCoeffs</span><span class="p">();</span>    <span class="c1">// this-&gt;patch().deltaCoeffs()返回的是 1/d</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码表明mixed边界条件设定valueBoundaryCoeffs也就是 <span class="math notranslate nohighlight">\(B_{1}\)</span> 的值为 <span class="math notranslate nohighlight">\(\text{valueFraction} \times \text{refValue} + (1.0 - \text{valueFraction}) \times \frac{\text{refGrad}}{(1/d)}\)</span> 。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">mixedFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">gradientInternalCoeffs</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">Type</span><span class="p">(</span><span class="n">pTraits</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">one</span><span class="p">)</span><span class="o">*</span><span class="n">valueFraction_</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">deltaCoeffs</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码表明mixed边界条件设定gradientInternalCoeffs也就是 <span class="math notranslate nohighlight">\(A_{2}\)</span> 的值为 <span class="math notranslate nohighlight">\(- \text{valueFraction} \times (1/d)\)</span> 。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">mixedFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">gradientBoundaryCoeffs</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span>
        <span class="n">valueFraction_</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">deltaCoeffs</span><span class="p">()</span><span class="o">*</span><span class="n">refValue_</span>    <span class="c1">// 设定B2的值为 w*(1/d)*a + (1-w)*b</span>
      <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">valueFraction_</span><span class="p">)</span><span class="o">*</span><span class="n">refGrad_</span><span class="p">;</span>                        <span class="c1">// this-&gt;patch().deltaCoeffs()返回的是 1/d</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码表明mixed边界条件设定gradientBoundaryCoeffs也就是 <span class="math notranslate nohighlight">\(B_{2}\)</span> 的值为 <span class="math notranslate nohighlight">\(\text{valueFraction} \times (1/d) \times \text{refValue} + (1.0 - \text{valueFraction}) \times \text{refGrad}\)</span> 。</p>
</div>
<div class="section" id="directionmixed">
<h4>directionMixed<a class="headerlink" href="#directionmixed" title="永久链接至标题">¶</a></h4>
<p>该类是所有方向混合类型边界条件的基类。该类继承于transform边界条件，通过定义其自身的snGrad()和snGradTransformDiag()函数返回内容来实现。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">directionMixedFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">write</span><span class="p">(</span><span class="n">Ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">transformFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">write</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;refValue&quot;</span><span class="p">,</span> <span class="n">refValue_</span><span class="p">);</span>               <span class="c1">// 读取字典中的关键词refValue赋值给refValue_变量</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;refGradient&quot;</span><span class="p">,</span> <span class="n">refGrad_</span><span class="p">);</span>             <span class="c1">// 读取字典中的关键词refGradient赋值给refGrad_变量</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;valueFraction&quot;</span><span class="p">,</span> <span class="n">valueFraction_</span><span class="p">);</span>     <span class="c1">// 读取字典中的关键词valueFraction赋值给valueFraction_变量</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">this</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码表明，directionMixed需要读取关键词refValue、refGradient、valueFraction的赋值。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">directionMixedFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">snGrad</span><span class="p">()</span> <span class="k">const</span>    <span class="c1">// 定义snGrad函数操作内容</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="n">pif</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">patchInternalField</span><span class="p">());</span>    <span class="c1">// pif用来代表内部场x_c</span>

    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span> <span class="n">normalValue</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">valueFraction_</span><span class="p">,</span> <span class="n">refValue_</span><span class="p">);</span>    <span class="c1">// 定义normalValue的值，通过transform函数来计算</span>

    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span> <span class="n">gradValue</span> <span class="o">=</span> <span class="n">pif</span> <span class="o">+</span> <span class="n">refGrad_</span><span class="o">/</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">deltaCoeffs</span><span class="p">();</span>    <span class="c1">// 定义gradValue的值为 x_c + refGrad / (1/d)</span>

    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span> <span class="n">transformGradValue</span> <span class="o">=</span>    <span class="c1">// 定义transformGradValue的值，通过transform函数来计算。其中I是单位矩阵</span>
        <span class="n">transform</span><span class="p">(</span><span class="n">I</span> <span class="o">-</span> <span class="n">valueFraction_</span><span class="p">,</span> <span class="n">gradValue</span><span class="p">);</span>

    <span class="k">return</span>
        <span class="p">(</span><span class="n">normalValue</span> <span class="o">+</span> <span class="n">transformGradValue</span> <span class="o">-</span> <span class="n">pif</span><span class="p">)</span><span class="o">*</span>    <span class="c1">// 定义snGrad函数返回结果为 (normalValue + transformGradValue - x_c) * (1/d)</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">deltaCoeffs</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码表明，在directionMixed边界条件中，snGrad的具体定义内容为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\text{snGrad} &amp;=
\frac{1}{d}\Big( \text{valueFraction} \cdot \text{refValue} + (\mathbf{I} - \text{valueFraction}) \cdot (\vec{\phi}_{c} + \text{refGrad}\cdot d) - \vec{\phi}_{c}\Big) \\
&amp; = \frac{1}{d}
\begin{bmatrix}
\text{valueFraction} \times (\text{refValue} -  \phi_{cx}) + (1 - \text{valueFraction}) \times \text{refGrad}\times d) \\
\text{valueFraction} \times (\text{refValue} -  \phi_{cy}) + (1 - \text{valueFraction}) \times \text{refGrad}\times d) \\
\text{valueFraction} \times (\text{refValue} -  \phi_{cz}) + (1 - \text{valueFraction}) \times \text{refGrad}\times d)
\end{bmatrix}
\end{align}\end{split}\]</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">directionMixedFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">snGradTransformDiag</span><span class="p">()</span> <span class="k">const</span>    <span class="c1">// 定义snGradTransformDiag函数的操作内容</span>
<span class="p">{</span>
    <span class="n">vectorField</span> <span class="n">diag</span><span class="p">(</span><span class="n">valueFraction_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>    <span class="c1">// 定义向量场diag</span>

    <span class="n">diag</span><span class="p">.</span><span class="n">replace</span>
    <span class="p">(</span>
        <span class="n">vector</span><span class="o">::</span><span class="n">X</span><span class="p">,</span>
        <span class="n">sqrt</span><span class="p">(</span><span class="n">mag</span><span class="p">(</span><span class="n">valueFraction_</span><span class="p">.</span><span class="n">component</span><span class="p">(</span><span class="n">symmTensor</span><span class="o">::</span><span class="n">XX</span><span class="p">)))</span>    <span class="c1">// 将diag向量的x分量替换为 \sqrt{ |valueFraction_xx| }</span>
    <span class="p">);</span>
    <span class="n">diag</span><span class="p">.</span><span class="n">replace</span>
    <span class="p">(</span>
        <span class="n">vector</span><span class="o">::</span><span class="n">Y</span><span class="p">,</span>
        <span class="n">sqrt</span><span class="p">(</span><span class="n">mag</span><span class="p">(</span><span class="n">valueFraction_</span><span class="p">.</span><span class="n">component</span><span class="p">(</span><span class="n">symmTensor</span><span class="o">::</span><span class="n">YY</span><span class="p">)))</span>    <span class="c1">// 将diag向量的y分量替换为 \sqrt{ |valueFraction_yy| }</span>
    <span class="p">);</span>
    <span class="n">diag</span><span class="p">.</span><span class="n">replace</span>
    <span class="p">(</span>
        <span class="n">vector</span><span class="o">::</span><span class="n">Z</span><span class="p">,</span>
        <span class="n">sqrt</span><span class="p">(</span><span class="n">mag</span><span class="p">(</span><span class="n">valueFraction_</span><span class="p">.</span><span class="n">component</span><span class="p">(</span><span class="n">symmTensor</span><span class="o">::</span><span class="n">ZZ</span><span class="p">)))</span>    <span class="c1">// 将diag向量的z分量替换为 \sqrt{ |valueFraction_zz| }</span>
    <span class="p">);</span>

    <span class="k">return</span> <span class="n">transformFieldMask</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pow</span><span class="o">&lt;</span><span class="n">vector</span><span class="p">,</span> <span class="n">pTraits</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">rank</span><span class="o">&gt;</span><span class="p">(</span><span class="n">diag</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码表明，在directionMixed边界条件中，snGradTransformDiag的具体定义内容为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\text{snGradTransformDiag} =
\begin{bmatrix}
\sqrt{|\text{valueFraction}|} \\
\sqrt{|\text{valueFraction}|} \\
\sqrt{|\text{valueFraction}|}
\end{bmatrix}
\end{align}\end{split}\]</div>
<p>因此在directionMixed边界条件中，四个系数的具体定义分别为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
A_{1} =
\begin{bmatrix}
1 - \sqrt{|\text{valueFraction}|} \\
1 - \sqrt{|\text{valueFraction}|} \\
1 - \sqrt{|\text{valueFraction}|}
\end{bmatrix}
\end{align}\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
B_{1} =
\begin{bmatrix}
\phi_{px} - (1 - \sqrt{|\text{valueFraction}|}) \times \phi_{cx} \\
\phi_{py} - (1 - \sqrt{|\text{valueFraction}|}) \times \phi_{cy} \\
\phi_{pz} - (1 - \sqrt{|\text{valueFraction}|}) \times \phi_{cz}
\end{bmatrix}
\end{align}\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
A_{2} = -\frac{1}{d}
\begin{bmatrix}
\sqrt{|\text{valueFraction}|} \\
\sqrt{|\text{valueFraction}|} \\
\sqrt{|\text{valueFraction}|}
\end{bmatrix}
\end{align}\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
B_{2} =
\begin{bmatrix}
\frac{1}{d}\times  \text{valueFraction} \times \text{refValue} + \frac{1}{d}\times (\sqrt{|\text{valueFraction}|} - \text{valueFraction} ) \times \phi_{cx} + (1 - \text{valueFraction}) \times \text{refGrad} \\
\frac{1}{d}\times  \text{valueFraction} \times \text{refValue} + \frac{1}{d}\times (\sqrt{|\text{valueFraction}|} - \text{valueFraction} ) \times \phi_{cy} + (1 - \text{valueFraction}) \times \text{refGrad} \\
\frac{1}{d}\times  \text{valueFraction} \times \text{refValue} + \frac{1}{d}\times (\sqrt{|\text{valueFraction}|} - \text{valueFraction} ) \times \phi_{cz} + (1 - \text{valueFraction}) \times \text{refGrad}
\end{bmatrix}
\end{align}\end{split}\]</div>
</div>
<div class="section" id="basicsymmetry">
<h4>basicSymmetry<a class="headerlink" href="#basicsymmetry" title="永久链接至标题">¶</a></h4>
<p>对于标量，该边界条件等价于zeroGradient。对于矢量的情况，边界上的值等于其临近网格中心的值的切向分量，满足：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\vec{\phi}_{p} = \vec{\phi}_{c} - (\vec{\phi}_{c} \cdot \vec{n}) \cdot \vec{n} = [\vec{\phi}_{c} + (I - 2\vec{n} \otimes \vec{n}) \cdot \vec{\phi}_{c}] \times \frac{1}{2}
\end{align}\]</div>
<p>各系数在OpenFOAM中的矩阵表示如下：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
A_{1} =  \begin{bmatrix} 1-|n_{x}| \\ 1-|n_{y}| \\ 1-|n_{z}| \end{bmatrix}
\end{align}\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
B_{1} =  \begin{bmatrix} \phi_{px} \\ \phi_{py} \\ \phi_{pz} \end{bmatrix}
       - \begin{bmatrix} (1-|n_{x}|)\phi_{cx} \\ (1-|n_{y}|)\phi_{cy} \\ (1-|n_{z}|)\phi_{cz} \end{bmatrix}
\end{align}\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
A_{2} = -\frac{1}{d}\begin{bmatrix} |n_{x}| \\ |n_{y}| \\ |n_{z}| \end{bmatrix}
\end{align}\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
B_{2} = -\frac{1}{d}
        \begin{bmatrix}
        n_{x}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z}) \\
        n_{y}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z}) \\
        n_{z}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z})
        \end{bmatrix}
        + \frac{1}{d}
        \begin{bmatrix}
        |n_{x}|\phi_{cx} \\
        |n_{y}|\phi_{cy} \\
        |n_{z}|\phi_{cz}
        \end{bmatrix}
\end{align}\end{split}\]</div>
<p>位于src/finiteVolume/fields/fvPatchFields/basic/basicSymmetry的basicSymmetryFvPatchField.C中定义系数的相关内容如下所示：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">basicSymmetryFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">snGrad</span><span class="p">()</span> <span class="k">const</span>    <span class="c1">// 定义snGrad的具体操作内容</span>
<span class="p">{</span>
    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">vectorField</span><span class="o">&gt;</span> <span class="n">nHat</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">nf</span><span class="p">();</span>    <span class="c1">// 用nHat表示面法向量</span>

    <span class="k">const</span> <span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="n">iF</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">patchInternalField</span><span class="p">());</span>    <span class="c1">// 用iF表示 \vec{\phi}_{c}</span>

    <span class="k">return</span>
    <span class="cm">/*  snGrad的操作定义为 ((I - 2\vec{n} \otimes \vec{n}) \cdot \vec{\phi}_{c} - \vec{\phi}_{c} )\times \frac{1}{2d}</span>
<span class="cm">        分量形式为</span>
<span class="cm">        \text{snGrad}_{x} = -\frac{1}{d}n_{x}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z}),</span>
<span class="cm">        \text{snGrad}_{y} = -\frac{1}{d}n_{y}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z}),</span>
<span class="cm">        \text{snGrad}_{z} = -\frac{1}{d}n_{z}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z})</span>
<span class="cm">    */</span>
        <span class="p">(</span><span class="n">transform</span><span class="p">(</span><span class="n">I</span> <span class="o">-</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">sqr</span><span class="p">(</span><span class="n">nHat</span><span class="p">),</span> <span class="n">iF</span><span class="p">)</span> <span class="o">-</span> <span class="n">iF</span><span class="p">)</span>
       <span class="o">*</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">deltaCoeffs</span><span class="p">()</span><span class="o">/</span><span class="mf">2.0</span><span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">basicSymmetryFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">evaluate</span><span class="p">(</span><span class="k">const</span> <span class="n">Pstream</span><span class="o">::</span><span class="n">commsTypes</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">updated</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">updateCoeffs</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">vectorField</span><span class="o">&gt;</span> <span class="n">nHat</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">nf</span><span class="p">();</span>    <span class="c1">// 用nHat表示面法向量</span>

    <span class="k">const</span> <span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="n">iF</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">patchInternalField</span><span class="p">());</span>    <span class="c1">// 用iF表示 \vec{\phi}_{c}</span>

    <span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">operator</span><span class="o">=</span>
    <span class="p">(</span>
    <span class="cm">/*  定义evaluate操作内容为 \frac{1}{2}(\vec{\phi}_{c} + (I - 2\vec{n} \otimes \vec{n}) \cdot \vec{\phi}_{c})</span>
<span class="cm">        分量形式为</span>
<span class="cm">        \phi_{cx} - n_{x}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z}),</span>
<span class="cm">        \phi_{cy} - n_{y}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z}),</span>
<span class="cm">        \phi_{cz} - n_{z}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z})</span>
<span class="cm">    */</span>
        <span class="p">(</span><span class="n">iF</span> <span class="o">+</span> <span class="n">transform</span><span class="p">(</span><span class="n">I</span> <span class="o">-</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">sqr</span><span class="p">(</span><span class="n">nHat</span><span class="p">),</span> <span class="n">iF</span><span class="p">))</span><span class="o">/</span><span class="mf">2.0</span>
    <span class="p">);</span>

    <span class="n">transformFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">evaluate</span><span class="p">();</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">basicSymmetryFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">snGradTransformDiag</span><span class="p">()</span> <span class="k">const</span>    <span class="c1">// 定义snGradTransformDiag具体操作内容</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">vectorField</span> <span class="n">nHat</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">nf</span><span class="p">());</span>    <span class="c1">// 用nHat表示面法向量</span>

    <span class="n">vectorField</span> <span class="nf">diag</span><span class="p">(</span><span class="n">nHat</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>    <span class="c1">// 定义向量 diag = (|n_{x}|, |n_{y}|, |n_{z}|)</span>

    <span class="n">diag</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="n">vector</span><span class="o">::</span><span class="n">X</span><span class="p">,</span> <span class="n">mag</span><span class="p">(</span><span class="n">nHat</span><span class="p">.</span><span class="n">component</span><span class="p">(</span><span class="n">vector</span><span class="o">::</span><span class="n">X</span><span class="p">)));</span>
    <span class="n">diag</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="n">vector</span><span class="o">::</span><span class="n">Y</span><span class="p">,</span> <span class="n">mag</span><span class="p">(</span><span class="n">nHat</span><span class="p">.</span><span class="n">component</span><span class="p">(</span><span class="n">vector</span><span class="o">::</span><span class="n">Y</span><span class="p">)));</span>
    <span class="n">diag</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="n">vector</span><span class="o">::</span><span class="n">Z</span><span class="p">,</span> <span class="n">mag</span><span class="p">(</span><span class="n">nHat</span><span class="p">.</span><span class="n">component</span><span class="p">(</span><span class="n">vector</span><span class="o">::</span><span class="n">Z</span><span class="p">)));</span>

    <span class="k">return</span> <span class="n">transformFieldMask</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pow</span><span class="o">&lt;</span><span class="n">vector</span><span class="p">,</span> <span class="n">pTraits</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">rank</span><span class="o">&gt;</span><span class="p">(</span><span class="n">diag</span><span class="p">));</span>    <span class="c1">// snGradTransformDiag返回 diag = (|n_{x}|, |n_{y}|, |n_{z}|)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="inletoutlet">
<h4>inletOutlet<a class="headerlink" href="#inletoutlet" title="永久链接至标题">¶</a></h4>
<p>inletOutlet边界条件是一个一般性的出流条件，同时给定了特定的入流条件。对于入流，该条件相当于fixedValue；对于出流，该条件相当于zeroGradient。该条件继承于mixed边界条件，通过设置不同的refValue、refGrad和valueFraction来实现。</p>
<p>位于src/finiteVolume/fields/fvPatchFields/derived/inletOutlet的inletOutletFvPatchField.C如下所示：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">inletOutletFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">inletOutletFvPatchField</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">fvPatch</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">DimensionedField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">iF</span>
<span class="p">)</span>
<span class="o">:</span>
    <span class="n">mixedFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">iF</span><span class="p">),</span>    <span class="c1">// 继承于mixed边界条件</span>
    <span class="n">phiName_</span><span class="p">(</span><span class="s">&quot;phi&quot;</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">this</span><span class="o">-&gt;</span><span class="n">refValue</span><span class="p">()</span> <span class="o">=</span> <span class="n">Zero</span><span class="p">;</span>        <span class="c1">// 初始化refValue的值为0</span>
    <span class="n">this</span><span class="o">-&gt;</span><span class="n">refGrad</span><span class="p">()</span> <span class="o">=</span> <span class="n">Zero</span><span class="p">;</span>         <span class="c1">// 初始化refGrad的值为0</span>
    <span class="n">this</span><span class="o">-&gt;</span><span class="n">valueFraction</span><span class="p">()</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>    <span class="c1">// 初始化valueFraction的值为0.0</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码表明inletOutlet边界条件继承于mixed边界条件，并且先将refValue、refGradient、valueFraction的值初始化为了 <span class="math notranslate nohighlight">\(0\)</span> 。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">inletOutletFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">inletOutletFvPatchField</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">fvPatch</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">DimensionedField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">iF</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">dictionary</span><span class="o">&amp;</span> <span class="n">dict</span>
<span class="p">)</span>
<span class="o">:</span>
    <span class="n">mixedFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">iF</span><span class="p">),</span>
    <span class="n">phiName_</span><span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;phi&quot;</span><span class="p">,</span> <span class="s">&quot;phi&quot;</span><span class="p">))</span>    <span class="c1">// 读取子字典中phi关键词的值赋给phiName_变量，默认就是phi</span>
<span class="p">{</span>
    <span class="n">this</span><span class="o">-&gt;</span><span class="n">refValue</span><span class="p">()</span> <span class="o">=</span> <span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;inletValue&quot;</span><span class="p">,</span> <span class="n">dict</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">found</span><span class="p">(</span><span class="s">&quot;value&quot;</span><span class="p">))</span>    <span class="c1">// 如果子字典中存在value关键词的赋值</span>
    <span class="p">{</span>
        <span class="n">fvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">operator</span><span class="o">=</span>
        <span class="p">(</span>
            <span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="n">dict</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>    <span class="c1">// 将边界的值初始化为value的值</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">fvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">refValue</span><span class="p">());</span>    <span class="c1">// 如果不存在value关键词则将边界的值初始化为refValue的值</span>
    <span class="p">}</span>

    <span class="n">this</span><span class="o">-&gt;</span><span class="n">refGrad</span><span class="p">()</span> <span class="o">=</span> <span class="n">Zero</span><span class="p">;</span>         <span class="c1">// 设置refGradient的值为0</span>
    <span class="n">this</span><span class="o">-&gt;</span><span class="n">valueFraction</span><span class="p">()</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>    <span class="c1">// 设置valueFraction的值为0</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码对边界上的情况进行了初始化。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">inletOutletFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">updateCoeffs</span><span class="p">()</span>    <span class="c1">// 通过updateCoeffs函数来修改mixed边界条件的参数来实现</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">updated</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">Field</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;&amp;</span> <span class="n">phip</span> <span class="o">=</span>    <span class="c1">// 定义phip为通量场的值</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">template</span> <span class="n">lookupPatchField</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="p">,</span> <span class="n">scalar</span><span class="o">&gt;</span>
        <span class="p">(</span>
            <span class="n">phiName_</span>
        <span class="p">);</span>

    <span class="n">this</span><span class="o">-&gt;</span><span class="n">valueFraction</span><span class="p">()</span> <span class="o">=</span> <span class="n">neg</span><span class="p">(</span><span class="n">phip</span><span class="p">);</span>    <span class="c1">// 设置valueFraction的值为 neg(phip)</span>

    <span class="n">mixedFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">updateCoeffs</span><span class="p">();</span>    <span class="c1">// 更新mixed边界条件的参数</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码表明intletOutlet边界条件根据通量场phi的大小来设置valueFraction的值，设置方式为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\text{valueFraction} =
\left\{\begin{array}{l}
1, \quad \phi &lt; 0, \\
0, \quad \phi \ge 0
\end{array}\right .
\end{align}\end{split}\]</div>
<p>其中 <code class="code docutils literal notranslate"><span class="pre">neg(phip)</span></code> 表示当phip小于零时取1，当phip大于等于零时取0，具体定义可以查看src/OpenFOAM/lnInclude/Scalar.H文件。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">inletOutletFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">write</span><span class="p">(</span><span class="n">Ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">fvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">write</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">phiName_</span> <span class="o">!=</span> <span class="s">&quot;phi&quot;</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;phi&quot;</span><span class="p">,</span> <span class="n">phiName_</span><span class="p">);</span>    <span class="c1">// 遇到不是默认的phi的情况时则读取phi关键词赋给的名字</span>
    <span class="p">}</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;inletValue&quot;</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">refValue</span><span class="p">());</span>    <span class="c1">// 读取子字典的inletValue的值赋给refValue</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">this</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码表明inletOutlet边界条件将会读取字典里inletValue的值赋给refValue，同时会读取value关键词。</p>
<p>inletOutlet边界条件的一般设置方式如下所示：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">patchName</span>
<span class="p">{</span>
    <span class="n">type</span>            <span class="n">inletOutlet</span><span class="p">;</span>
    <span class="n">phi</span>             <span class="n">phi</span><span class="p">;</span>
    <span class="n">inletValue</span>      <span class="n">uniform</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">value</span>           <span class="n">uniform</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="freestream">
<h4>freestream<a class="headerlink" href="#freestream" title="永久链接至标题">¶</a></h4>
<p>这个边界条件提供了一个自由流条件。它是由inletOutlet条件衍生而来的混合条件，其中操作模式根据通量的符号在固定(自由流)值和零梯度之间切换。该边界条件继承于inletOutlet边界条件。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&amp;</span> <span class="n">freestreamValue</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">refValue</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&amp;</span> <span class="n">freestreamValue</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">refValue</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码表明freestreamValue和refValue是等价的。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">freestreamFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">freestreamFvPatchField</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">fvPatch</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">DimensionedField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">iF</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">dictionary</span><span class="o">&amp;</span> <span class="n">dict</span>
<span class="p">)</span>
<span class="o">:</span>
    <span class="n">inletOutletFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">iF</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">this</span><span class="o">-&gt;</span><span class="n">phiName_</span> <span class="o">=</span> <span class="n">dict</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;phi&quot;</span><span class="p">,</span><span class="s">&quot;phi&quot;</span><span class="p">);</span>    <span class="c1">// 查找通量场phi</span>

    <span class="n">freestreamValue</span><span class="p">()</span> <span class="o">=</span> <span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;freestreamValue&quot;</span><span class="p">,</span> <span class="n">dict</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>    <span class="c1">// 读取freestreamValue的值赋给freestreamValue</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">found</span><span class="p">(</span><span class="s">&quot;value&quot;</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">fvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">operator</span><span class="o">=</span>
        <span class="p">(</span>
            <span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="n">dict</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>    <span class="c1">// 如果有value关键词则初始化边界值为value的值</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">fvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">freestreamValue</span><span class="p">());</span>    <span class="c1">// 否则初始化边界值为freestreamValue的值</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码表明freestream继承于inletOutlet边界条件，上面进行了边界情况的初始化，其余操作均与inletOutlet边界条件相同。可以认为freestreamValue和inletValue的作用是等价的。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">freestreamFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">write</span><span class="p">(</span><span class="n">Ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">fvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">write</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">phiName_</span> <span class="o">!=</span> <span class="s">&quot;phi&quot;</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;phi&quot;</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">phiName_</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;freestreamValue&quot;</span><span class="p">,</span> <span class="n">freestreamValue</span><span class="p">());</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">this</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>freestream边界条件的一般设置方式如下所示：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">patchName</span>
<span class="p">{</span>
    <span class="n">type</span>            <span class="n">freestream</span><span class="p">;</span>
    <span class="n">freestreamValue</span> <span class="nf">uniform</span> <span class="p">(</span><span class="mi">300</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id11">
<h3>速度边界条件<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h3>
<div class="section" id="noslip">
<h4>noSlip<a class="headerlink" href="#noslip" title="永久链接至标题">¶</a></h4>
<p>这个边界条件使壁面处的速度固定为零。它继承于fixedValue边界条件。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Foam</span><span class="o">::</span><span class="n">noSlipFvPatchVectorField</span><span class="o">::</span><span class="n">noSlipFvPatchVectorField</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">fvPatch</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">DimensionedField</span><span class="o">&lt;</span><span class="n">vector</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">iF</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">dictionary</span><span class="o">&amp;</span> <span class="n">dict</span>
<span class="p">)</span>
<span class="o">:</span>
    <span class="n">fixedValueFvPatchVectorField</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">iF</span><span class="p">,</span> <span class="n">dict</span><span class="p">,</span> <span class="nb">false</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">operator</span><span class="o">==</span><span class="p">(</span><span class="n">Zero</span><span class="p">);</span>    <span class="c1">// 继承fixedValue边界条件，设定为固定值 0</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="partialslip">
<h4>partialSlip<a class="headerlink" href="#partialslip" title="永久链接至标题">¶</a></h4>
<p>对于partialSlip边界，流体在边界法向上的速度为零，边界切向上的速度沿法向成梯度下降，满足：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\vec{\phi}_{p} = (1 - \text{valueFraction})[\vec{\phi}_{c} - (\vec{\phi}_{c} \cdot \vec{n}) \cdot \vec{n}]
               = (1 - \text{valueFraction})(I - \vec{n} \otimes \vec{n}) \cdot \vec{\phi}_{c}
\end{align}\]</div>
<p>其中valueFraction为自行定义的衰减系数。各系数的表达式如下：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
A_{1} = \begin{bmatrix}
        (1 - \text{valueFraction})(1 - |n_{x}|) \\
        (1 - \text{valueFraction})(1 - |n_{y}|) \\
        (1 - \text{valueFraction})(1 - |n_{z}|) \\
        \end{bmatrix}
\end{align}\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
B_{1} = \begin{bmatrix}
        \phi_{px} \\
        \phi_{py} \\
        \phi_{pz}
        \end{bmatrix}
      - \begin{bmatrix}
        (1 - \text{valueFraction})(1 - |n_{x}|)\phi_{cx} \\
        (1 - \text{valueFraction})(1 - |n_{y}|)\phi_{cy} \\
        (1 - \text{valueFraction})(1 - |n_{z}|)\phi_{cz} \\
        \end{bmatrix}
\end{align}\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
A_{2} = -\frac{1}{d}
        \begin{bmatrix}
        \text{valueFraction} + (1 - \text{valueFraction})|n_{x}| \\
        \text{valueFraction} + (1 - \text{valueFraction})|n_{y}| \\
        \text{valueFraction} + (1 - \text{valueFraction})|n_{z}|
        \end{bmatrix}
\end{align}\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
B_{2} = \frac{1}{d}
        \begin{bmatrix}
        (1 - \text{valueFraction})\big( n_{x} - n_{x}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z}) \big) - \phi_{cx} \\
        (1 - \text{valueFraction})\big( n_{y} - n_{y}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z}) \big) - \phi_{cy} \\
        (1 - \text{valueFraction})\big( n_{z} - n_{z}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z}) \big) - \phi_{cz}
        \end{bmatrix}
      + \frac{1}{d}
        \begin{bmatrix}
        \big( \text{valueFraction} + (1 - \text{valueFraction})|n_{x}| \big) \phi_{cx} \\
        \big( \text{valueFraction} + (1 - \text{valueFraction})|n_{y}| \big) \phi_{cy} \\
        \big( \text{valueFraction} + (1 - \text{valueFraction})|n_{z}| \big) \phi_{cz}
        \end{bmatrix}
\end{align}\end{split}\]</div>
<p>位于src/finiteVolume/fields/fvPatchFields/derived/partialSlip的partialSlipFvPatchField.C中定义系数的相关内容如下所示：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">partialSlipFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">snGrad</span><span class="p">()</span> <span class="k">const</span>    <span class="c1">// 定义snGrad函数的操作内容</span>
<span class="p">{</span>
    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">vectorField</span><span class="o">&gt;</span> <span class="n">nHat</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">nf</span><span class="p">();</span>    <span class="c1">// 用nHat来表示面法向量</span>
    <span class="k">const</span> <span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="n">pif</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">patchInternalField</span><span class="p">());</span>    <span class="c1">// 用pif来表示内部场的值 \vec{\phi}_{c}</span>

    <span class="k">return</span>
    <span class="cm">/*  snGrad函数的操作内容为 [ (1 - \text{valueFraction}) \times ( I-\vec{n} \otimes \vec{n} ) \cdot \vec{\phi}_{c} - \vec{\phi}_{c} ] * (1/d)</span>
<span class="cm">        分量形式为</span>
<span class="cm">        \text{snGrad}_{x} = [ (1 - \text{valueFraction}) \times (n_{x} - n_{x}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z})) - \phi_{cx} ] \times (1/d),</span>
<span class="cm">        \text{snGrad}_{y} = [ (1 - \text{valueFraction}) \times (n_{y} - n_{y}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z})) - \phi_{cy} ] \times (1/d),</span>
<span class="cm">        \text{snGrad}_{z} = [ (1 - \text{valueFraction}) \times (n_{z} - n_{z}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z})) - \phi_{cz} ] \times (1/d)</span>
<span class="cm">    */</span>
    <span class="p">(</span>
        <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">valueFraction_</span><span class="p">)</span><span class="o">*</span><span class="n">transform</span><span class="p">(</span><span class="n">I</span> <span class="o">-</span> <span class="n">sqr</span><span class="p">(</span><span class="n">nHat</span><span class="p">),</span> <span class="n">pif</span><span class="p">)</span> <span class="o">-</span> <span class="n">pif</span>
    <span class="p">)</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">deltaCoeffs</span><span class="p">();</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">partialSlipFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">evaluate</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">Pstream</span><span class="o">::</span><span class="n">commsTypes</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">updated</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">updateCoeffs</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">vectorField</span><span class="o">&gt;</span> <span class="n">nHat</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">nf</span><span class="p">();</span>

    <span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">operator</span><span class="o">=</span>    <span class="c1">// 定义evaluate的具体操作内容</span>
    <span class="p">(</span>
    <span class="cm">/*</span>
<span class="cm">        (1 - \text{valueFraction}) \times [( I-\vec{n} \otimes \vec{n} ) \cdot \vec{\phi}_{c}]</span>
<span class="cm">    */</span>
        <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">valueFraction_</span><span class="p">)</span>
       <span class="o">*</span><span class="n">transform</span><span class="p">(</span><span class="n">I</span> <span class="o">-</span> <span class="n">sqr</span><span class="p">(</span><span class="n">nHat</span><span class="p">),</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">patchInternalField</span><span class="p">())</span>
    <span class="p">);</span>

    <span class="n">transformFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">evaluate</span><span class="p">();</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">partialSlipFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">snGradTransformDiag</span><span class="p">()</span> <span class="k">const</span>    <span class="c1">// 定义snGradTransformDiag函数的操作内容</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">vectorField</span> <span class="n">nHat</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">nf</span><span class="p">());</span>    <span class="c1">// 用nHat来表示面法向量</span>
    <span class="n">vectorField</span> <span class="nf">diag</span><span class="p">(</span><span class="n">nHat</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>    <span class="c1">// 定义一个矢量场diag</span>

    <span class="n">diag</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="n">vector</span><span class="o">::</span><span class="n">X</span><span class="p">,</span> <span class="n">mag</span><span class="p">(</span><span class="n">nHat</span><span class="p">.</span><span class="n">component</span><span class="p">(</span><span class="n">vector</span><span class="o">::</span><span class="n">X</span><span class="p">)));</span>    <span class="c1">// 替换对角矩阵x分量值为 |n_x|</span>
    <span class="n">diag</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="n">vector</span><span class="o">::</span><span class="n">Y</span><span class="p">,</span> <span class="n">mag</span><span class="p">(</span><span class="n">nHat</span><span class="p">.</span><span class="n">component</span><span class="p">(</span><span class="n">vector</span><span class="o">::</span><span class="n">Y</span><span class="p">)));</span>    <span class="c1">// 替换对角矩阵y分量值为 |n_y|</span>
    <span class="n">diag</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="n">vector</span><span class="o">::</span><span class="n">Z</span><span class="p">,</span> <span class="n">mag</span><span class="p">(</span><span class="n">nHat</span><span class="p">.</span><span class="n">component</span><span class="p">(</span><span class="n">vector</span><span class="o">::</span><span class="n">Z</span><span class="p">)));</span>    <span class="c1">// 替换对角矩阵z分量值为 |n_z|</span>
    <span class="cm">/* 也即该向量场为 diag = ( |n_x| , |n_y| , |n_z|) */</span>
    <span class="k">return</span>
    <span class="cm">/*  snGradTransformDiag函数的操作内容为 valueFraction * (1, 1, 1) + (1 - valueFraction) * diag</span>
<span class="cm">        分量形式为</span>
<span class="cm">        \text{snGradTransformDiag}_{x} = \text{valueFraction} + (1 - \text{valueFraction}) \times |n_{x}|,</span>
<span class="cm">        \text{snGradTransformDiag}_{y} = \text{valueFraction} + (1 - \text{valueFraction}) \times |n_{y}|,</span>
<span class="cm">        \text{snGradTransformDiag}_{z} = \text{valueFraction} + (1 - \text{valueFraction}) \times |n_{z}|</span>
<span class="cm">    */</span>
        <span class="n">valueFraction_</span><span class="o">*</span><span class="n">pTraits</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">one</span>
      <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">valueFraction_</span><span class="p">)</span>
       <span class="o">*</span><span class="n">transformFieldMask</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pow</span><span class="o">&lt;</span><span class="n">vector</span><span class="p">,</span> <span class="n">pTraits</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">rank</span><span class="o">&gt;</span><span class="p">(</span><span class="n">diag</span><span class="p">));</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">partialSlipFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">write</span><span class="p">(</span><span class="n">Ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">transformFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">write</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;valueFraction&quot;</span><span class="p">,</span> <span class="n">valueFraction_</span><span class="p">);</span>    <span class="c1">// 读取子字典中的valueFraction关键词赋值给valueFraction_变量</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="slip">
<h4>slip<a class="headerlink" href="#slip" title="永久链接至标题">¶</a></h4>
<p>这个边界条件提供了一个滑移约束。一般用于无粘性流体的情况。该边界条件继承于basicSymmetry边界条件。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">slipFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">slipFvPatchField</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">fvPatch</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">DimensionedField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">iF</span>
<span class="p">)</span>
<span class="o">:</span>
   <span class="n">basicSymmetryFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">iF</span><span class="p">)</span>    <span class="c1">// noSlip边界等价于basicSymmetry边界的效果，即法向为零，切向保持</span>
<span class="p">{}</span>
</pre></div>
</div>
<p>下面是使用该边界条件的一般设置方式：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">patchName</span>
<span class="p">{</span>
    <span class="n">type</span>            <span class="n">slip</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="freestreamvelocity">
<h4>freestreamVelocity<a class="headerlink" href="#freestreamvelocity" title="永久链接至标题">¶</a></h4>
<p>该边界条件为速度提供了自由流条件。这是一种使用速度方向在正常入口的固定值和正常出口流量的零梯度之间连续混合的进出口条件。该边界条件继承于mixed边界条件。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">vectorField</span><span class="o">&amp;</span> <span class="n">freestreamValue</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">refValue</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">vectorField</span><span class="o">&amp;</span> <span class="n">freestreamValue</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">refValue</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码表明freestreamValue等价与refValue。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">freestreamVelocityFvPatchVectorField</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">Ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">fvPatchVectorField</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;freestreamValue&quot;</span><span class="p">,</span> <span class="n">freestreamValue</span><span class="p">());</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">this</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码表明freestreamVelocity边界条件将会读取设置中freestreamValue和value关键词的赋值。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Foam</span><span class="o">::</span><span class="n">freestreamVelocityFvPatchVectorField</span><span class="o">::</span><span class="n">freestreamVelocityFvPatchVectorField</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">fvPatch</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">DimensionedField</span><span class="o">&lt;</span><span class="n">vector</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">iF</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">dictionary</span><span class="o">&amp;</span> <span class="n">dict</span>
<span class="p">)</span>
<span class="o">:</span>
    <span class="n">mixedFvPatchVectorField</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">iF</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">freestreamValue</span><span class="p">()</span> <span class="o">=</span> <span class="n">vectorField</span><span class="p">(</span><span class="s">&quot;freestreamValue&quot;</span><span class="p">,</span> <span class="n">dict</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>    <span class="c1">// 读取freestreamValue的值赋给freestreamValue变量</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">found</span><span class="p">(</span><span class="s">&quot;value&quot;</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">fvPatchVectorField</span><span class="o">::</span><span class="n">operator</span><span class="o">=</span>
        <span class="p">(</span>
            <span class="n">vectorField</span><span class="p">(</span><span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="n">dict</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>    <span class="c1">// 如果有value关键词则初始化边界值为value的值</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">fvPatchVectorField</span><span class="o">::</span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">freestreamValue</span><span class="p">());</span>    <span class="c1">// 否则初始化边界值为freestreamValue的值</span>
    <span class="p">}</span>

    <span class="n">refGrad</span><span class="p">()</span> <span class="o">=</span> <span class="n">Zero</span><span class="p">;</span>       <span class="c1">// 初始化refGradient的值为0</span>
    <span class="n">valueFraction</span><span class="p">()</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>    <span class="c1">// 初始化valueFraction的值为1</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码表明freestreamVelocity继承于mixed边界条件，并进行了边界情况的初始化，并初始化refGradient的值为 <span class="math notranslate nohighlight">\(0\)</span> ，初始化valueFraction的值为 <span class="math notranslate nohighlight">\(1\)</span> 。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">freestreamVelocityFvPatchVectorField</span><span class="o">::</span><span class="n">updateCoeffs</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">updated</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">Field</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&gt;</span> <span class="n">Up</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">patchInternalField</span><span class="p">()</span> <span class="o">+</span> <span class="o">*</span><span class="n">this</span><span class="p">));</span>    <span class="c1">// 定义Up，通过内部速度场和value的设置进行计算</span>
    <span class="k">const</span> <span class="n">Field</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;</span> <span class="n">magUp</span><span class="p">(</span><span class="n">mag</span><span class="p">(</span><span class="n">Up</span><span class="p">));</span>    <span class="c1">// 定义magUp为Up的模长大小</span>

    <span class="k">const</span> <span class="n">Field</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&gt;</span> <span class="n">nf</span><span class="p">(</span><span class="n">patch</span><span class="p">().</span><span class="n">nf</span><span class="p">());</span>    <span class="c1">// 定义nf为网格面单位法向量</span>

    <span class="n">Field</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;&amp;</span> <span class="n">vf</span> <span class="o">=</span> <span class="n">valueFraction</span><span class="p">();</span>    <span class="c1">// 定义vf为valueFraction的值</span>

    <span class="n">forAll</span><span class="p">(</span><span class="n">vf</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">magUp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">vSmall</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">vf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">Up</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">nf</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="n">magUp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>    <span class="c1">// 当Up的模长大小不是小量时valueFraction的设置方法</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">vf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>    <span class="c1">// 当Up的模长为小量时设置valueFraction为0.5</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">mixedFvPatchField</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&gt;::</span><span class="n">updateCoeffs</span><span class="p">();</span>    <span class="c1">// 更新mixed边界条件的参数</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码给出了valueFraction的设置方式：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\text{valueFraction} =
\left \{\begin{array}{l}
0.5 - 0.5 \times \frac{0.5\times (\mathbf{U}_{c} + \text{value}) \cdot \mathbf{n}}{|0.5\times (\mathbf{U}_{c} + \text{value})|} , \quad |0.5\times (\mathbf{U}_{c} + \text{value})| &gt; \text{vSmall} \\
0.5, \qquad\qquad\qquad\qquad\qquad\quad  |0.5\times (\mathbf{U}_{c} + \text{value})| \le \text{vSmall}
\end{array}\right .
\end{align}\end{split}\]</div>
</div>
<div class="section" id="pressureinletvelocity">
<h4>pressureInletVelocity<a class="headerlink" href="#pressureinletvelocity" title="永久链接至标题">¶</a></h4>
<p>这个速度入口边界条件适用于指定压力的边界面。流入速度由与边界面法线方向的通量得到。该边界条件继承于fixedValue边界条件，并且一般需要压力场配合使用totalPressure边界条件。</p>
<p>进入src/finiteVolume/fields/fvPatchFields/derived/pressureInletVelocity/pressureInletVelocityFvPatchVectorField.C文件，可以看到如下代码：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">pressureInletVelocityFvPatchVectorField</span><span class="o">::</span><span class="n">updateCoeffs</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">updated</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">phi</span> <span class="o">=</span>
        <span class="n">db</span><span class="p">().</span><span class="n">lookupObject</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="o">&gt;</span><span class="p">(</span><span class="n">phiName_</span><span class="p">);</span>

    <span class="k">const</span> <span class="n">fvsPatchField</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;&amp;</span> <span class="n">phip</span> <span class="o">=</span>    <span class="c1">// 边界面的通量场</span>
        <span class="n">patch</span><span class="p">().</span><span class="n">patchField</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="p">,</span> <span class="n">scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">phi</span><span class="p">);</span>

    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">vectorField</span><span class="o">&gt;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">patch</span><span class="p">().</span><span class="n">nf</span><span class="p">();</span>    <span class="c1">// 边界面的单位面法向量</span>
    <span class="k">const</span> <span class="n">Field</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;&amp;</span> <span class="n">magS</span> <span class="o">=</span> <span class="n">patch</span><span class="p">().</span><span class="n">magSf</span><span class="p">();</span>    <span class="c1">// 边界面的面积</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">phi</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()</span> <span class="o">==</span> <span class="n">dimFlux</span><span class="p">)</span>    <span class="c1">// 不可压缩流的情况，通量为体积通量</span>
    <span class="p">{</span>
        <span class="n">operator</span><span class="o">==</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">phip</span><span class="o">/</span><span class="n">magS</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">phi</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()</span> <span class="o">==</span> <span class="n">dimMassFlux</span><span class="p">)</span>    <span class="c1">// 可压缩流的情况，通量为质量通量</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">fvPatchField</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;&amp;</span> <span class="n">rhop</span> <span class="o">=</span>    <span class="c1">// 边界面的密度场</span>
            <span class="n">patch</span><span class="p">().</span><span class="n">lookupPatchField</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="p">,</span> <span class="n">scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rhoName_</span><span class="p">);</span>

        <span class="n">operator</span><span class="o">==</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">phip</span><span class="o">/</span><span class="p">(</span><span class="n">rhop</span><span class="o">*</span><span class="n">magS</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">FatalErrorInFunction</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;dimensions of phi are not correct&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">    on patch &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">name</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot; of field &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">internalField</span><span class="p">().</span><span class="n">name</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot; in file &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">internalField</span><span class="p">().</span><span class="n">objectPath</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="n">exit</span><span class="p">(</span><span class="n">FatalError</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">fixedValueFvPatchVectorField</span><span class="o">::</span><span class="n">updateCoeffs</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码表明，pressureInletVelocity所设置的边界速度计算方式为：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\mathbf{U} =
\left \{ \begin{array}{l}
\frac{\phi\mathbf{n}}{|\mathbf{S}_{f}|} ,\quad   ~\text{if}~\phi~\text{is volume flux}  \\
\frac{\phi\mathbf{n}}{\rho|\mathbf{S}_{f}|},\quad \text{if}~\phi~\text{is mass flux}
\end{array} \right .
\end{align}\end{split}\]</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">pressureInletVelocityFvPatchVectorField</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">Ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">fvPatchVectorField</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
    <span class="n">writeEntryIfDifferent</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;phi&quot;</span><span class="p">,</span> <span class="s">&quot;phi&quot;</span><span class="p">,</span> <span class="n">phiName_</span><span class="p">);</span>
    <span class="n">writeEntryIfDifferent</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;rho&quot;</span><span class="p">,</span> <span class="s">&quot;rho&quot;</span><span class="p">,</span> <span class="n">rhoName_</span><span class="p">);</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">this</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>下面是pressureInletVelocity边界条件的一般设置方式：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">patchName</span>
<span class="p">{</span>
    <span class="n">type</span>            <span class="n">pressureInletVelocity</span><span class="p">;</span>
    <span class="n">phi</span>             <span class="n">phi</span><span class="p">;</span>
    <span class="n">rho</span>             <span class="n">rho</span><span class="p">;</span>    <span class="c1">// 可压缩流</span>
    <span class="n">value</span>           <span class="n">uniform</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">如果预期可能会出现回流现象，则应该设置为pressureInletOutletVelocity边界条件。</p>
</div>
</div>
<div class="section" id="pressureinletuniformvelocity">
<h4>pressureInletUniformVelocity<a class="headerlink" href="#pressureinletuniformvelocity" title="永久链接至标题">¶</a></h4>
<p>该速度入口边界条件适用于指定了压力的边界面。通过求边界面上通量的平均值来得到均一的入流速度，然后将其应用到边界面的法线方向。该边界条件继承于pressureInletUniformVelocity边界条件。</p>
<p>进入src/finiteVolume/fields/fvPatchFields/derived/pressureInletUniformVelocity/pressureInletUniformVelocityFvPatchVectorField.C文件，可以看到如下代码：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">pressureInletUniformVelocityFvPatchVectorField</span><span class="o">::</span><span class="n">updateCoeffs</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">updated</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">pressureInletVelocityFvPatchVectorField</span><span class="o">::</span><span class="n">updateCoeffs</span><span class="p">();</span>

    <span class="n">operator</span><span class="o">==</span><span class="p">(</span><span class="n">patch</span><span class="p">().</span><span class="n">nf</span><span class="p">()</span><span class="o">*</span><span class="n">gSum</span><span class="p">(</span><span class="n">patch</span><span class="p">().</span><span class="n">Sf</span><span class="p">()</span> <span class="o">&amp;</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span><span class="o">/</span><span class="n">gSum</span><span class="p">(</span><span class="n">patch</span><span class="p">().</span><span class="n">magSf</span><span class="p">()));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>由上面的代码可知，pressureInletUniformVelocity设置的边界速度计算方式为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\mathbf{U} = \frac{\mathbf{n} \sum\limits_{\text{global}}(\mathbf{S}_{f}\cdot \mathbf{U}_{p})}{\sum\limits_{\text{global}}|\mathbf{S}_{f}|}
\end{align}\]</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">pressureInletVelocityFvPatchVectorField</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">Ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">fvPatchVectorField</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
    <span class="n">writeEntryIfDifferent</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;phi&quot;</span><span class="p">,</span> <span class="s">&quot;phi&quot;</span><span class="p">,</span> <span class="n">phiName_</span><span class="p">);</span>    <span class="c1">// 读取通量场的名字</span>
    <span class="n">writeEntryIfDifferent</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;rho&quot;</span><span class="p">,</span> <span class="s">&quot;rho&quot;</span><span class="p">,</span> <span class="n">rhoName_</span><span class="p">);</span>    <span class="c1">// 读取密度场的名字</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">this</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>下面是pressureInletVelocity边界条件的一般设置方式：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">patchName</span>
<span class="p">{</span>
    <span class="n">type</span>            <span class="n">pressureInletVelocity</span><span class="p">;</span>
    <span class="n">phi</span>             <span class="n">phi</span><span class="p">;</span>
    <span class="n">rho</span>             <span class="n">rho</span><span class="p">;</span>    <span class="c1">// 可压缩流</span>
    <span class="n">value</span>           <span class="n">uniform</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="pressuredirectedinletvelocity">
<h4>pressureDirectedInletVelocity<a class="headerlink" href="#pressuredirectedinletvelocity" title="永久链接至标题">¶</a></h4>
<p>这个速度入口边界条件适用于指定压力的补丁。流入速度由指定进口方向“方向”的通量得到。该边界条件继承于fixedValue边界条件。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">pressureDirectedInletVelocityFvPatchVectorField</span><span class="o">::</span><span class="n">updateCoeffs</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">updated</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">phi</span> <span class="o">=</span>
        <span class="n">db</span><span class="p">().</span><span class="n">lookupObject</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="o">&gt;</span><span class="p">(</span><span class="n">phiName_</span><span class="p">);</span>

    <span class="k">const</span> <span class="n">fvsPatchField</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;&amp;</span> <span class="n">phip</span> <span class="o">=</span>    <span class="c1">// 获取通量场</span>
        <span class="n">patch</span><span class="p">().</span><span class="n">patchField</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="p">,</span> <span class="n">scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">phi</span><span class="p">);</span>

    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">vectorField</span><span class="o">&gt;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">patch</span><span class="p">().</span><span class="n">nf</span><span class="p">();</span>    <span class="c1">// 边界面的法向量</span>
    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">scalarField</span><span class="o">&gt;</span> <span class="n">ndmagS</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="n">inletDir_</span><span class="p">)</span><span class="o">*</span><span class="n">patch</span><span class="p">().</span><span class="n">magSf</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">phi</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()</span> <span class="o">==</span> <span class="n">dimFlux</span><span class="p">)</span>    <span class="c1">// 不可压缩流的情况，通量为体积通量</span>
    <span class="p">{</span>
        <span class="n">operator</span><span class="o">==</span><span class="p">(</span><span class="n">inletDir_</span><span class="o">*</span><span class="n">phip</span><span class="o">/</span><span class="n">ndmagS</span><span class="p">);</span>    <span class="c1">// 计算边界值</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">phi</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()</span> <span class="o">==</span> <span class="n">dimMassFlux</span><span class="p">)</span>    <span class="c1">// 可压缩流的情况，通量为质量通量</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">fvPatchField</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;&amp;</span> <span class="n">rhop</span> <span class="o">=</span>    <span class="c1">// 获取密度场</span>
            <span class="n">patch</span><span class="p">().</span><span class="n">lookupPatchField</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="p">,</span> <span class="n">scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rhoName_</span><span class="p">);</span>

        <span class="n">operator</span><span class="o">==</span><span class="p">(</span><span class="n">inletDir_</span><span class="o">*</span><span class="n">phip</span><span class="o">/</span><span class="p">(</span><span class="n">rhop</span><span class="o">*</span><span class="n">ndmagS</span><span class="p">));</span>    <span class="c1">// 计算边界值</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">FatalErrorInFunction</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;dimensions of phi are not correct&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">    on patch &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">name</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot; of field &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">internalField</span><span class="p">().</span><span class="n">name</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot; in file &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">internalField</span><span class="p">().</span><span class="n">objectPath</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="n">exit</span><span class="p">(</span><span class="n">FatalError</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">fixedValueFvPatchVectorField</span><span class="o">::</span><span class="n">updateCoeffs</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码表明，pressureDirectedInletVelocity所设置的边界处的速度计算方式为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\mathbf{U} =
\left \{ \begin{array}{l}
\mathbf{V}_{\text{dir}}\frac{\phi}{(\mathbf{n} \cdot \mathbf{V}_{\text{dir}})|\mathbf{S}_{f}|} , \quad \text{if}~\phi~\text{is volume flux}   \\
\mathbf{V}_{\text{dir}}\frac{\phi}{\rho (\mathbf{n} \cdot \mathbf{V}_{\text{dir}})|\mathbf{S}_{f}| } ,\quad \text{if}~\phi~\text{is mass flux}
\end{array} \right .
\end{align}\end{split}\]</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">pressureDirectedInletVelocityFvPatchVectorField</span><span class="o">::</span><span class="n">write</span>
<span class="p">(</span>
    <span class="n">Ostream</span><span class="o">&amp;</span> <span class="n">os</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">fvPatchVectorField</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
    <span class="n">writeEntryIfDifferent</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;phi&quot;</span><span class="p">,</span> <span class="s">&quot;phi&quot;</span><span class="p">,</span> <span class="n">phiName_</span><span class="p">);</span>
    <span class="n">writeEntryIfDifferent</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;rho&quot;</span><span class="p">,</span> <span class="s">&quot;rho&quot;</span><span class="p">,</span> <span class="n">rhoName_</span><span class="p">);</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;inletDirection&quot;</span><span class="p">,</span> <span class="n">inletDir_</span><span class="p">);</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">this</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>下面是pressureDirectedInletVelocity边界条件的一般设置方式：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">patchName</span>
<span class="p">{</span>
    <span class="n">type</span>            <span class="n">pressureDirectedInletVelocity</span><span class="p">;</span>
    <span class="n">phi</span>             <span class="n">phi</span><span class="p">;</span>
    <span class="n">rho</span>             <span class="n">rho</span><span class="p">;</span>    <span class="c1">// 可压缩流</span>
    <span class="n">inletDirection</span>  <span class="nf">uniform</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">value</span>           <span class="n">uniform</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="pressureinletoutletvelocity">
<h4>pressureInletOutletVelocity<a class="headerlink" href="#pressureinletoutletvelocity" title="永久链接至标题">¶</a></h4>
<p>这是一个速度入口/出口边界条件，其中需要压力场配合使用fixedValue、totalPressure、entrainmentPressure等边界条件。该边界条件继承于directioniMixed边界，对于出流等价于zeroGradient边界条件；对于入流将会为法向分量设置为zeroGradient而为切向分量设置为fixedValue。外部切向速度可以被任意指定，如果没有设置则视为零。</p>
<p>进入src/finiteVolume/fields/fvPatchFields/derived/pressureInletOutletVelocityFvPatchVectorField.C文件，可以看到如下代码：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Foam</span><span class="o">::</span><span class="n">pressureInletOutletVelocityFvPatchVectorField</span><span class="o">::</span>
<span class="n">pressureInletOutletVelocityFvPatchVectorField</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">fvPatch</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">DimensionedField</span><span class="o">&lt;</span><span class="n">vector</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">iF</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">dictionary</span><span class="o">&amp;</span> <span class="n">dict</span>
<span class="p">)</span>
<span class="o">:</span>
    <span class="n">directionMixedFvPatchVectorField</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">iF</span><span class="p">),</span>    <span class="c1">// 继承于directionMixed边界条件</span>
    <span class="n">phiName_</span><span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;phi&quot;</span><span class="p">,</span> <span class="s">&quot;phi&quot;</span><span class="p">))</span>    <span class="c1">// 读取phi关键词设置，默认为通量场名称为phi</span>
<span class="p">{</span>
    <span class="n">fvPatchVectorField</span><span class="o">::</span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">vectorField</span><span class="p">(</span><span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="n">dict</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>    <span class="c1">// 读取value关键词赋值进行初始化</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">found</span><span class="p">(</span><span class="s">&quot;tangentialVelocity&quot;</span><span class="p">))</span>    <span class="c1">// 如果设置了tangentialVelocity关键词则读取赋值</span>
    <span class="p">{</span>
        <span class="n">tangentialVelocity_</span> <span class="o">=</span>
            <span class="n">Function1</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&gt;::</span><span class="n">New</span><span class="p">(</span><span class="s">&quot;tangentialVelocity&quot;</span><span class="p">,</span> <span class="n">dict</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">refValue</span><span class="p">()</span> <span class="o">=</span> <span class="n">Zero</span><span class="p">;</span>         <span class="c1">// 初始化refValue为零</span>
    <span class="n">refGrad</span><span class="p">()</span> <span class="o">=</span> <span class="n">Zero</span><span class="p">;</span>          <span class="c1">// 初始化refGrad为零</span>
    <span class="n">valueFraction</span><span class="p">()</span> <span class="o">=</span> <span class="n">Zero</span><span class="p">;</span>    <span class="c1">// 初始化valueFraction为零</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">pressureInletOutletVelocityFvPatchVectorField</span><span class="o">::</span><span class="n">updateCoeffs</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">updated</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">tangentialVelocity_</span><span class="p">.</span><span class="n">valid</span><span class="p">())</span>    <span class="c1">// 如果设置了tangentialVelocity的值</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">scalar</span> <span class="n">t</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">().</span><span class="n">time</span><span class="p">().</span><span class="n">userTimeValue</span><span class="p">();</span>    <span class="c1">// 获取时间t</span>
        <span class="k">const</span> <span class="n">vector</span> <span class="n">tangentialVelocity</span> <span class="o">=</span> <span class="n">tangentialVelocity_</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>    <span class="c1">// 获取在时间t时候tangentialVelocity的值</span>
        <span class="k">const</span> <span class="n">vectorField</span> <span class="nf">n</span><span class="p">(</span><span class="n">patch</span><span class="p">().</span><span class="n">nf</span><span class="p">());</span>    <span class="c1">// 边界面的单位面法向量</span>
        <span class="n">refValue</span><span class="p">()</span> <span class="o">=</span> <span class="n">tangentialVelocity</span> <span class="o">-</span> <span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="n">tangentialVelocity</span><span class="p">);</span>    <span class="c1">// 计算refValue</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">fvsPatchField</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;&amp;</span> <span class="n">phip</span> <span class="o">=</span>    <span class="c1">// 边界面的通量场</span>
        <span class="n">patch</span><span class="p">().</span><span class="n">lookupPatchField</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="p">,</span> <span class="n">scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">phiName_</span><span class="p">);</span>

    <span class="n">valueFraction</span><span class="p">()</span> <span class="o">=</span> <span class="n">neg</span><span class="p">(</span><span class="n">phip</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">I</span> <span class="o">-</span> <span class="n">sqr</span><span class="p">(</span><span class="n">patch</span><span class="p">().</span><span class="n">nf</span><span class="p">()));</span>    <span class="c1">// 计算valueFraction</span>

    <span class="n">directionMixedFvPatchVectorField</span><span class="o">::</span><span class="n">updateCoeffs</span><span class="p">();</span>
    <span class="n">directionMixedFvPatchVectorField</span><span class="o">::</span><span class="n">evaluate</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码表明，在pressureInletOutletVelocity边界条件中，在没有设置tangentialVelocity关键词的时候，refValue和refGrad的值被默认设置为了零，而valueFraction的计算方式为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\text{valueFraction} =
\left \{ \begin{array}{l}
\mathbf{0}, \quad \phi \ge 0 \\
\mathbf{I} - \mathbf{n}^{2} =
\begin{bmatrix}
1 - n_{x}^{2} \\
1 - n_{y}^{2} \\
1 - n_{z}^{2}
\end{bmatrix}
, \quad \phi &lt; 0
\end{array} \right .
\end{align}\end{split}\]</div>
<p>如果设置了tangentialVelocity关键词，那么refValue将不再是零，其计算方式为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\text{refValue} = \mathbf{U_{\text{tan}}}(t) - \big(\mathbf{n} \cdot \mathbf{U_{\text{tan}}}(t)\big)\mathbf{n}
\end{align}\]</div>
<p>下面是pressureInletOutletVelocity边界条件的一般设置方式：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">patchName</span>
<span class="p">{</span>
    <span class="n">type</span>            <span class="n">pressureInletOutletVelocity</span><span class="p">;</span>
    <span class="n">phi</span>             <span class="n">phi</span><span class="p">;</span>
    <span class="n">tangentialVelocity</span> <span class="p">(</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">value</span>           <span class="n">uniform</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="pressuredirectedinletoutletvelocity">
<h4>pressureDirectedInletOutletVelocity<a class="headerlink" href="#pressuredirectedinletoutletvelocity" title="永久链接至标题">¶</a></h4>
<p>该速度入口/出口边界条件应用于指定了压力的边界。对于出流，该边界条件等价于zeroGradient(由通量定义)；对于入流，速度由指定进口方向的通量得到。该边界条件继承于mixed边界条件。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Foam</span><span class="o">::</span><span class="n">pressureDirectedInletOutletVelocityFvPatchVectorField</span><span class="o">::</span>
<span class="n">pressureDirectedInletOutletVelocityFvPatchVectorField</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">fvPatch</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">DimensionedField</span><span class="o">&lt;</span><span class="n">vector</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">iF</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">dictionary</span><span class="o">&amp;</span> <span class="n">dict</span>
<span class="p">)</span>
<span class="o">:</span>
    <span class="n">mixedFvPatchVectorField</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">iF</span><span class="p">),</span>    <span class="c1">// 继承于mixed边界条件</span>
    <span class="n">phiName_</span><span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;phi&quot;</span><span class="p">,</span> <span class="s">&quot;phi&quot;</span><span class="p">)),</span>    <span class="c1">// 读取通量场名称，默认为phi</span>
    <span class="n">rhoName_</span><span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;rho&quot;</span><span class="p">,</span> <span class="s">&quot;rho&quot;</span><span class="p">)),</span>    <span class="c1">// 读取密度场名称，默认为rho</span>
    <span class="n">inletDir_</span><span class="p">(</span><span class="s">&quot;inletDirection&quot;</span><span class="p">,</span> <span class="n">dict</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>    <span class="c1">// 读取指定的进口速度</span>
<span class="p">{</span>
    <span class="n">fvPatchVectorField</span><span class="o">::</span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">vectorField</span><span class="p">(</span><span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="n">dict</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>    <span class="c1">// 读取value关键词进行初始化</span>
    <span class="n">refValue</span><span class="p">()</span> <span class="o">=</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>    <span class="c1">// 初始化refValue为当前值</span>
    <span class="n">refGrad</span><span class="p">()</span> <span class="o">=</span> <span class="n">Zero</span><span class="p">;</span>    <span class="c1">// 初始化refGrad为零</span>
    <span class="n">valueFraction</span><span class="p">()</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>    <span class="c1">// 初始化valueFraction为零</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">pressureDirectedInletOutletVelocityFvPatchVectorField</span><span class="o">::</span><span class="n">updateCoeffs</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">updated</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">phi</span> <span class="o">=</span>
        <span class="n">db</span><span class="p">().</span><span class="n">lookupObject</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="o">&gt;</span><span class="p">(</span><span class="n">phiName_</span><span class="p">);</span>

    <span class="k">const</span> <span class="n">fvsPatchField</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;&amp;</span> <span class="n">phip</span> <span class="o">=</span>    <span class="c1">// 获取通量场</span>
        <span class="n">patch</span><span class="p">().</span><span class="n">patchField</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="p">,</span> <span class="n">scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">phi</span><span class="p">);</span>

    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">vectorField</span><span class="o">&gt;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">patch</span><span class="p">().</span><span class="n">nf</span><span class="p">();</span>    <span class="c1">// 获取边界面单位面法向量</span>
    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">scalarField</span><span class="o">&gt;</span> <span class="n">ndmagS</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="n">inletDir_</span><span class="p">)</span><span class="o">*</span><span class="n">patch</span><span class="p">().</span><span class="n">magSf</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">phi</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()</span> <span class="o">==</span> <span class="n">dimFlux</span><span class="p">)</span>    <span class="c1">// 不可压缩流体，通量为体积通量</span>
    <span class="p">{</span>
        <span class="n">refValue</span><span class="p">()</span> <span class="o">=</span> <span class="n">inletDir_</span><span class="o">*</span><span class="n">phip</span><span class="o">/</span><span class="n">ndmagS</span><span class="p">;</span>    <span class="c1">// 计算refValue</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">phi</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()</span> <span class="o">==</span> <span class="n">dimMassFlux</span><span class="p">)</span>    <span class="c1">// 可压缩流体，通量为质量通量</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">fvPatchField</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;&amp;</span> <span class="n">rhop</span> <span class="o">=</span>    <span class="c1">// 获取密度场</span>
            <span class="n">patch</span><span class="p">().</span><span class="n">lookupPatchField</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="p">,</span> <span class="n">scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rhoName_</span><span class="p">);</span>

        <span class="n">refValue</span><span class="p">()</span> <span class="o">=</span> <span class="n">inletDir_</span><span class="o">*</span><span class="n">phip</span><span class="o">/</span><span class="p">(</span><span class="n">rhop</span><span class="o">*</span><span class="n">ndmagS</span><span class="p">);</span>    <span class="c1">// 计算refValue</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">FatalErrorInFunction</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;dimensions of phi are not correct&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">    on patch &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">name</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot; of field &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">internalField</span><span class="p">().</span><span class="n">name</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot; in file &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">internalField</span><span class="p">().</span><span class="n">objectPath</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="n">exit</span><span class="p">(</span><span class="n">FatalError</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">valueFraction</span><span class="p">()</span> <span class="o">=</span> <span class="n">neg</span><span class="p">(</span><span class="n">phip</span><span class="p">);</span>    <span class="c1">// 根据通量正负号设置valueFraction</span>

    <span class="n">mixedFvPatchVectorField</span><span class="o">::</span><span class="n">updateCoeffs</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码表明，refGrad默认被设置为零；valueFraction在入流的时候为设置为 <span class="math notranslate nohighlight">\(1\)</span> ，在出流的时候设置为 <span class="math notranslate nohighlight">\(0\)</span> ；refValue的计算方式为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\text{refValue} =
\left \{ \begin{array}{l}
\mathbf{V}_{\text{dir}}\frac{\phi}{(\mathbf{n}_{f} \cdot \mathbf{V}_{\text{dir}})|\mathbf{S}_{f}|} , \quad \text{if}~\phi~\text{is volume flux} \\
\mathbf{V}_{\text{dir}}\frac{\phi}{\rho (\mathbf{n}_{f} \cdot \mathbf{V}_{\text{dir}})|\mathbf{S}_{f}|} , \quad \text{if}~\phi~\text{is mass flux}
\end{array} \right .
\end{align}\end{split}\]</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">pressureDirectedInletOutletVelocityFvPatchVectorField</span><span class="o">::</span><span class="n">write</span>
<span class="p">(</span>
    <span class="n">Ostream</span><span class="o">&amp;</span> <span class="n">os</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">fvPatchVectorField</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
    <span class="n">writeEntryIfDifferent</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;phi&quot;</span><span class="p">,</span> <span class="s">&quot;phi&quot;</span><span class="p">,</span> <span class="n">phiName_</span><span class="p">);</span>
    <span class="n">writeEntryIfDifferent</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;rho&quot;</span><span class="p">,</span> <span class="s">&quot;rho&quot;</span><span class="p">,</span> <span class="n">rhoName_</span><span class="p">);</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;inletDirection&quot;</span><span class="p">,</span> <span class="n">inletDir_</span><span class="p">);</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">this</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>下面是pressureDirectedInletOutletVelocity边界条件的一般设置方式：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">patchName</span>
<span class="p">{</span>
    <span class="n">type</span>            <span class="n">pressureDirectedInletOutletVelocity</span><span class="p">;</span>
    <span class="n">phi</span>             <span class="n">phi</span><span class="p">;</span>
    <span class="n">rho</span>             <span class="n">rho</span><span class="p">;</span>    <span class="c1">// 可压缩流</span>
    <span class="n">inletDirection</span>  <span class="nf">uniform</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">);</span>    <span class="c1">// 入流方向</span>
    <span class="n">value</span>           <span class="n">uniform</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id12">
<h3>压强边界条件<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h3>
<div class="section" id="pressure">
<h4>pressure<a class="headerlink" href="#pressure" title="永久链接至标题">¶</a></h4>
<p>静压边界条件。用作静态压力边界条件的基类，强迫替代压力变量，例如p_rgh。该边界条件继承于fixedValue边界条件。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Foam</span><span class="o">::</span><span class="n">pressureFvPatchScalarField</span><span class="o">::</span><span class="n">pressureFvPatchScalarField</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">fvPatch</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">DimensionedField</span><span class="o">&lt;</span><span class="n">scalar</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">iF</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">dictionary</span><span class="o">&amp;</span> <span class="n">dict</span>
<span class="p">)</span>
<span class="o">:</span>
    <span class="n">fixedValueFvPatchScalarField</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">iF</span><span class="p">,</span> <span class="n">dict</span><span class="p">,</span> <span class="nb">false</span><span class="p">),</span>
    <span class="n">p_</span><span class="p">(</span><span class="s">&quot;p&quot;</span><span class="p">,</span> <span class="n">dict</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">found</span><span class="p">(</span><span class="s">&quot;value&quot;</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">fvPatchScalarField</span><span class="o">::</span><span class="n">operator</span><span class="o">=</span>
        <span class="p">(</span>
            <span class="n">scalarField</span><span class="p">(</span><span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="n">dict</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">fvPatchField</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;::</span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">p_</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">pressureFvPatchScalarField</span><span class="o">::</span><span class="n">updateCoeffs</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">updated</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">operator</span><span class="o">==</span><span class="p">(</span><span class="n">p_</span><span class="p">);</span>

    <span class="n">fixedValueFvPatchScalarField</span><span class="o">::</span><span class="n">updateCoeffs</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">pressureFvPatchScalarField</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">Ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">fvPatchScalarField</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;p&quot;</span><span class="p">,</span> <span class="n">p_</span><span class="p">);</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">this</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="freestreampressure">
<h4>freestreamPressure<a class="headerlink" href="#freestreampressure" title="永久链接至标题">¶</a></h4>
<p>该边界条件为压力提供了自由流动条件。这是一种出口-进口条件，使用速度方向在正常入口的零梯度和正常出口流量的固定值之间连续混合。该边界条件继承于mixed边界条件，通过利用速度设置valueFraction的值来实现。</p>
<p>进入src/finiteVolume/fields/fvPatchFields/derived/freestreamPressure/freestreamPressureFvPatchScalarField.H文件中，可以看到下面定义了一个成员函数：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">freestreamValue</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">refValue</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">freestreamValue</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">refValue</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码表明freestreamValue等价于mixed边界条件里面的refValue。</p>
<p>进入src/finiteVolume/fields/fvPatchFields/derived/freestreamPressure/freestreamPressureFvPatchScalarField.C文件中，可以看到相关参数设置方式：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Foam</span><span class="o">::</span><span class="n">freestreamPressureFvPatchScalarField</span><span class="o">::</span>
<span class="n">freestreamPressureFvPatchScalarField</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">fvPatch</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">DimensionedField</span><span class="o">&lt;</span><span class="n">scalar</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">iF</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">dictionary</span><span class="o">&amp;</span> <span class="n">dict</span>
<span class="p">)</span>
<span class="o">:</span>
    <span class="n">mixedFvPatchScalarField</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">iF</span><span class="p">),</span>
    <span class="n">UName_</span><span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;U&quot;</span><span class="p">,</span> <span class="s">&quot;U&quot;</span><span class="p">)),</span>
    <span class="n">supersonic_</span>
    <span class="p">(</span>
        <span class="n">dict</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">Switch</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;supersonic&quot;</span><span class="p">,</span> <span class="nb">false</span><span class="p">)</span>    <span class="c1">// 读取字典关键词supersonic的赋值，默认是false</span>
    <span class="p">)</span>
<span class="p">{</span>
    <span class="n">freestreamValue</span><span class="p">()</span> <span class="o">=</span> <span class="n">scalarField</span><span class="p">(</span><span class="s">&quot;freestreamValue&quot;</span><span class="p">,</span> <span class="n">dict</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">found</span><span class="p">(</span><span class="s">&quot;value&quot;</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">fvPatchScalarField</span><span class="o">::</span><span class="n">operator</span><span class="o">=</span>
        <span class="p">(</span>
            <span class="n">scalarField</span><span class="p">(</span><span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="n">dict</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>    <span class="c1">// 如果字典中有value关键词就先将边界的值初始化为value的值</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">fvPatchScalarField</span><span class="o">::</span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">freestreamValue</span><span class="p">());</span>    <span class="c1">// 如果没有value关键词就将边界初始化为freestreamValue的值</span>
    <span class="p">}</span>

    <span class="n">refGrad</span><span class="p">()</span> <span class="o">=</span> <span class="n">Zero</span><span class="p">;</span>       <span class="c1">// 初始化refGradient的值为0</span>
    <span class="n">valueFraction</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="c1">// 初始化valueFraction的值为0</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码表明freestreamPreassure边界条件继承于mixed边界条件，并且refGradient的值被设置为了 <span class="math notranslate nohighlight">\(0\)</span> ，而refValue则设置为了freestreamValue的值。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">freestreamPressureFvPatchScalarField</span><span class="o">::</span><span class="n">updateCoeffs</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">updated</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">Field</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&gt;&amp;</span> <span class="n">Up</span> <span class="o">=</span>    <span class="c1">// 定义Up为当前的速度场</span>
        <span class="n">patch</span><span class="p">().</span><span class="n">template</span> <span class="n">lookupPatchField</span><span class="o">&lt;</span><span class="n">volVectorField</span><span class="p">,</span> <span class="n">vector</span><span class="o">&gt;</span>
        <span class="p">(</span>
            <span class="n">UName_</span>
        <span class="p">);</span>

    <span class="k">const</span> <span class="n">Field</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;</span> <span class="n">magUp</span><span class="p">(</span><span class="n">mag</span><span class="p">(</span><span class="n">Up</span><span class="p">));</span>    <span class="c1">// 定义magUp为当前速度场的模长大小</span>

    <span class="k">const</span> <span class="n">Field</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&gt;</span> <span class="n">nf</span><span class="p">(</span><span class="n">patch</span><span class="p">().</span><span class="n">nf</span><span class="p">());</span>    <span class="c1">// 定义nf为网格面单位法向量</span>

    <span class="n">Field</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;&amp;</span> <span class="n">vf</span> <span class="o">=</span> <span class="n">valueFraction</span><span class="p">();</span>    <span class="c1">// 定义vf为valueFraction的值</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">supersonic_</span><span class="p">)</span>    <span class="c1">// 如果设置supersonic为true</span>
    <span class="p">{</span>
        <span class="n">forAll</span><span class="p">(</span><span class="n">vf</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">magUp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">vSmall</span><span class="p">)</span>    <span class="c1">// 如果速度场大小不是一个小量</span>
            <span class="p">{</span>
                <span class="n">vf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">Up</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">nf</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="n">magUp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>    <span class="c1">// 设置valueFraction的值</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">vf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>    <span class="c1">// 如果速度场大小是一个小量则取valueFraction = 0.5</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span>    <span class="c1">// 如果设置supersonic为false</span>
    <span class="p">{</span>
        <span class="n">forAll</span><span class="p">(</span><span class="n">vf</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">magUp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">vSmall</span><span class="p">)</span>    <span class="c1">// 如果速度场大小不是一个小量</span>
            <span class="p">{</span>
                <span class="n">vf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">Up</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">nf</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="n">magUp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>    <span class="c1">// 设置valueFraction的值</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">vf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>    <span class="c1">// 如果速度场大小是一个小量则取valueFraction = 0.5</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">mixedFvPatchField</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;::</span><span class="n">updateCoeffs</span><span class="p">();</span>    <span class="c1">// 更新mixed边界条件参数设置</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码表明，当设置supersonic为true时，valueFraction的计算方式为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\text{valueFraction} =
\left\{\begin{array}{l}
0.5 - 0.5\times \frac{\mathbf{U} \cdot \mathbf{n}}{|\mathbf{U}|}, \quad |\mathbf{U}| &gt; \text{vSmall} \\
0.5 , \qquad\qquad\qquad ~~ |\mathbf{U}| \le \text{vSmall}
\end{array}\right .
\end{align}\end{split}\]</div>
<p>当设置supersonic为false时，valueFraction的计算方式为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\text{valueFraction} =
\left\{\begin{array}{l}
0.5 + 0.5\times \frac{\mathbf{U} \cdot \mathbf{n}}{|\mathbf{U}|}, \quad |\mathbf{U}| &gt; \text{vSmall} \\
0.5 , \qquad\qquad\qquad ~~ |\mathbf{U}| \le \text{vSmall}
\end{array}\right .
\end{align}\end{split}\]</div>
<p>于是，freestreamPressure边界条件的四个参数的具体计算方式为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; A_{1} = 1 - \text{valueFraction}, &amp;&amp; B_{1} = \text{valueFraction} \times \text{freestreamValue} \\
&amp; A_{2} = \frac{-\text{valueFraction}}{d}, &amp;&amp; B_{2} = \frac{\text{valueFraction} \times \text{freestreamValue}}{d}
\end{align}\end{split}\]</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">freestreamPressureFvPatchScalarField</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">Ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">fvPatchScalarField</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
    <span class="n">writeEntryIfDifferent</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;U&quot;</span><span class="p">,</span> <span class="s">&quot;U&quot;</span><span class="p">,</span> <span class="n">UName_</span><span class="p">);</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;freestreamValue&quot;</span><span class="p">,</span> <span class="n">freestreamValue</span><span class="p">());</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;supersonic&quot;</span><span class="p">,</span> <span class="n">supersonic_</span><span class="p">);</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">this</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码说明freestreamPressure将会读取速度场的名称，并且查找边界设置的freestreamValue、supersonic和value三个关键词。下面是使用freestreamPressure边界条件的一般设置方式：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">patchName</span>
<span class="p">{</span>
    <span class="n">type</span>               <span class="n">freestreamPressure</span><span class="p">;</span>
    <span class="n">U</span>                  <span class="n">U</span><span class="p">;</span>
    <span class="n">freestreamValue</span>    <span class="n">uniform</span> <span class="mf">1e5</span><span class="p">;</span>
    <span class="n">supersonic</span>         <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="dynamicpressure">
<h4>dynamicPressure<a class="headerlink" href="#dynamicpressure" title="永久链接至标题">¶</a></h4>
<p>这个边界条件提供了一个动态压力条件。它从参考压力中减去动能项得到边界上固定的值。它构成了总压力和夹带压力条件的基类。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">dynamicPressureFvPatchScalarField</span><span class="o">::</span><span class="n">updateCoeffs</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">p0p</span><span class="p">,</span>    <span class="c1">// 静压</span>
    <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">K0mKp</span>   <span class="c1">// 单位动能</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">updated</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">internalField</span><span class="p">().</span><span class="n">dimensions</span><span class="p">()</span> <span class="o">==</span> <span class="n">dimPressure</span><span class="p">)</span>    <span class="c1">// 如果内部场单位是Pa，即可压缩流情况</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">psiName_</span> <span class="o">==</span> <span class="s">&quot;none&quot;</span><span class="p">)</span>    <span class="c1">// 变密度和低速可压缩流的情况</span>
        <span class="p">{</span>
            <span class="c1">// Variable density and low-speed compressible flow</span>

            <span class="k">const</span> <span class="n">fvPatchField</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;&amp;</span> <span class="n">rho</span> <span class="o">=</span>    <span class="c1">// 定义密度场</span>
                <span class="n">patch</span><span class="p">().</span><span class="n">lookupPatchField</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="p">,</span> <span class="n">scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rhoName_</span><span class="p">);</span>

            <span class="n">operator</span><span class="o">==</span><span class="p">(</span><span class="n">p0p</span> <span class="o">+</span> <span class="n">rho</span><span class="o">*</span><span class="n">K0mKp</span><span class="p">);</span>    <span class="c1">// 计算值设置为fixedValue</span>
        <span class="p">}</span>
        <span class="k">else</span>    <span class="c1">// 高速可压缩流的情况</span>
        <span class="p">{</span>
            <span class="c1">// High-speed compressible flow</span>

            <span class="k">const</span> <span class="n">fvPatchField</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;&amp;</span> <span class="n">psip</span> <span class="o">=</span>    <span class="c1">// 定义可压缩性场</span>
                <span class="n">patch</span><span class="p">().</span><span class="n">lookupPatchField</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="p">,</span> <span class="n">scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">psiName_</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">gamma_</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>    <span class="c1">// 比热容比大于1的情况</span>
            <span class="p">{</span>
                <span class="k">const</span> <span class="n">scalar</span> <span class="n">gM1ByG</span> <span class="o">=</span> <span class="p">(</span><span class="n">gamma_</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">gamma_</span><span class="p">;</span>

                <span class="n">operator</span><span class="o">==</span>
                <span class="p">(</span>
                    <span class="n">p0p</span><span class="o">/</span><span class="n">pow</span><span class="p">(</span><span class="n">scalar</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">psip</span><span class="o">*</span><span class="n">gM1ByG</span><span class="o">*</span><span class="n">K0mKp</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">gM1ByG</span><span class="p">)</span>
                <span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span>    <span class="c1">// 比热容小于等于1的情况</span>
            <span class="p">{</span>
                <span class="n">operator</span><span class="o">==</span><span class="p">(</span><span class="n">p0p</span><span class="o">/</span><span class="p">(</span><span class="n">scalar</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">psip</span><span class="o">*</span><span class="n">K0mKp</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">internalField</span><span class="p">().</span><span class="n">dimensions</span><span class="p">()</span> <span class="o">==</span> <span class="n">dimPressure</span><span class="o">/</span><span class="n">dimDensity</span><span class="p">)</span>    <span class="c1">// 不可压缩流情况</span>
    <span class="p">{</span>
        <span class="c1">// Incompressible flow</span>

        <span class="n">operator</span><span class="o">==</span><span class="p">(</span><span class="n">p0p</span> <span class="o">+</span> <span class="n">K0mKp</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">FatalErrorInFunction</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot; Incorrect pressure dimensions &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">internalField</span><span class="p">().</span><span class="n">dimensions</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="n">nl</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;    Should be &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">dimPressure</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot; for compressible/variable density flow&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;    or &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">dimPressure</span><span class="o">/</span><span class="n">dimDensity</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot; for incompressible flow,&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;    on patch &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">name</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot; of field &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">internalField</span><span class="p">().</span><span class="n">name</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot; in file &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">internalField</span><span class="p">().</span><span class="n">objectPath</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="n">exit</span><span class="p">(</span><span class="n">FatalError</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">fixedValueFvPatchScalarField</span><span class="o">::</span><span class="n">updateCoeffs</span><span class="p">();</span>    <span class="c1">// 调用fixedValue边界条件的updateCoeffs</span>
<span class="p">}</span>
</pre></div>
</div>
<p>从上面的代码可以看到，dynamicPressure边界条件实际上是通过某些方式计算得到压强值以fixedValue的方式进行边界设置的。对于变密度和低速可压缩流的情况，需要设置psi场的名为none，且计算方式为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
p = p_{0} + \rho \cdot K
\end{align}\]</div>
<p>对于高速可压缩流的情况，需要给定psi场的名，且计算方式为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
p =
\left \{ \begin{array}{l}
\frac{p_{0}}{\Big(1 - \psi \cdot \frac{\gamma - 1}{\gamma} \cdot K \Big)^{\frac{\gamma}{\gamma -1}}} , \quad \gamma &gt; 1 \\
\frac{p_{0}}{1 - \psi \cdot K} , \qquad\qquad\quad  \gamma \le 1
\end{array} \right.
\end{align}\end{split}\]</div>
<p>对于不可压缩流的情况，计算方式为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
p = p_{0} + K
\end{align}\]</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Foam</span><span class="o">::</span><span class="n">dynamicPressureFvPatchScalarField</span><span class="o">::</span><span class="n">dynamicPressureFvPatchScalarField</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">fvPatch</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">DimensionedField</span><span class="o">&lt;</span><span class="n">scalar</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">iF</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">dictionary</span><span class="o">&amp;</span> <span class="n">dict</span>
<span class="p">)</span>
<span class="o">:</span>
    <span class="n">fixedValueFvPatchScalarField</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">iF</span><span class="p">,</span> <span class="n">dict</span><span class="p">,</span> <span class="nb">false</span><span class="p">),</span>
    <span class="n">rhoName_</span><span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;rho&quot;</span><span class="p">,</span> <span class="s">&quot;rho&quot;</span><span class="p">)),</span>
    <span class="n">psiName_</span><span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;psi&quot;</span><span class="p">,</span> <span class="s">&quot;none&quot;</span><span class="p">)),</span>
    <span class="n">gamma_</span><span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;gamma&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
    <span class="n">p0_</span><span class="p">(</span><span class="s">&quot;p0&quot;</span><span class="p">,</span> <span class="n">dict</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">found</span><span class="p">(</span><span class="s">&quot;value&quot;</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">fvPatchField</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;::</span><span class="n">operator</span><span class="o">=</span>
        <span class="p">(</span>
            <span class="n">scalarField</span><span class="p">(</span><span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="n">dict</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">fvPatchField</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;::</span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">p0_</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>从上面的代码可知，初始化时会将psi的名设置为none，gamma的值初始化为 <span class="math notranslate nohighlight">\(1\)</span> 。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">dynamicPressureFvPatchScalarField</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">Ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">fvPatchScalarField</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;rho&quot;</span><span class="p">,</span> <span class="n">rhoName_</span><span class="p">);</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;psi&quot;</span><span class="p">,</span> <span class="n">psiName_</span><span class="p">);</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;gamma&quot;</span><span class="p">,</span> <span class="n">gamma_</span><span class="p">);</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;p0&quot;</span><span class="p">,</span> <span class="n">p0_</span><span class="p">);</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">this</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="totalpressure">
<h4>totalPressure<a class="headerlink" href="#totalpressure" title="永久链接至标题">¶</a></h4>
<p>基于恒定总压假设的流入、流出和夹带压力边界条件。对于流出，贴片压力设置为外部静压。对于流入，贴片压力是根据贴片速度和外部静压p0和外部速度U0来评估的，外部速度U0是根据贴片速度边界条件(如果使用该边界条件)中的可选tangentialVelocity入口查找的，否则U0被假设为零，外部总压力等于外部静压。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">totalPressureFvPatchScalarField</span><span class="o">::</span><span class="n">updateCoeffs</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 获取通量场，用来表明方向，后续根据其正负号来运算</span>
    <span class="k">const</span> <span class="n">fvsPatchField</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;&amp;</span> <span class="n">phip</span> <span class="o">=</span> <span class="n">patch</span><span class="p">().</span><span class="n">lookupPatchField</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="p">,</span> <span class="n">scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">phiName_</span><span class="p">);</span>

    <span class="c1">// 获取速度场</span>
    <span class="k">const</span> <span class="n">fvPatchField</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&gt;&amp;</span> <span class="n">Up</span> <span class="o">=</span> <span class="n">patch</span><span class="p">().</span><span class="n">lookupPatchField</span><span class="o">&lt;</span><span class="n">volVectorField</span><span class="p">,</span> <span class="n">vector</span><span class="o">&gt;</span><span class="p">(</span><span class="n">UName_</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">isA</span><span class="o">&lt;</span><span class="n">pressureInletOutletVelocityFvPatchVectorField</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Up</span><span class="p">))</span>    <span class="c1">// 如果速度场的边界条件设为了pressureInletOutletVelocity</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">pressureInletOutletVelocityFvPatchVectorField</span><span class="o">&amp;</span> <span class="n">Upiov</span> <span class="o">=</span>
            <span class="n">refCast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">pressureInletOutletVelocityFvPatchVectorField</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Up</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">Upiov</span><span class="p">.</span><span class="n">tangentialVelocity</span><span class="p">().</span><span class="n">valid</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">const</span> <span class="n">scalar</span> <span class="n">t</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">().</span><span class="n">time</span><span class="p">().</span><span class="n">userTimeValue</span><span class="p">();</span>

            <span class="n">dynamicPressureFvPatchScalarField</span><span class="o">::</span><span class="n">updateCoeffs</span>
            <span class="p">(</span>
                <span class="n">p0_</span><span class="p">,</span>
                <span class="mf">0.5</span><span class="o">*</span><span class="n">neg</span><span class="p">(</span><span class="n">phip</span><span class="p">)</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">Upiov</span><span class="p">.</span><span class="n">tangentialVelocity</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
              <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">neg</span><span class="p">(</span><span class="n">phip</span><span class="p">)</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">Up</span><span class="p">)</span>
            <span class="p">);</span>

            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">dynamicPressureFvPatchScalarField</span><span class="o">::</span><span class="n">updateCoeffs</span>
    <span class="p">(</span>
        <span class="n">p0_</span><span class="p">,</span>
        <span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">neg</span><span class="p">(</span><span class="n">phip</span><span class="p">)</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">Up</span><span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>可以看到totalPressure边界条件继承于dynamicPressure边界条件，就是通过字典关键词p0来设置dynamicPressure中p0p的值，并且确定了单位动能的计算方式为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
K =
\left \{ \begin{array}{l}
0, \quad \phi \ge 0 \\
-\frac{1}{2}|\mathbf{U}|^{2} ,\quad \phi &lt; 0
\end{array} \right .
\end{align}\end{split}\]</div>
<p>而当速度边界条件设置为pressureInletOutletVelocity时，单位动能的计算方式则有所不同：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
K =
\left \{ \begin{array}{l}
0, \quad \phi \ge 0 \\
\frac{1}{2}|\mathbf{U}_{\text{tan}}(t)|^{2} - \frac{1}{2}|\mathbf{U}|^{2}, \quad \phi &lt; 0
\end{array} \right .
\end{align}\end{split}\]</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">totalPressureFvPatchScalarField</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">Ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">dynamicPressureFvPatchScalarField</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
    <span class="n">writeEntryIfDifferent</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;U&quot;</span><span class="p">,</span> <span class="s">&quot;U&quot;</span><span class="p">,</span> <span class="n">UName_</span><span class="p">);</span>
    <span class="n">writeEntryIfDifferent</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;phi&quot;</span><span class="p">,</span> <span class="s">&quot;phi&quot;</span><span class="p">,</span> <span class="n">phiName_</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>下面是totalPressure的一般设置方式：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">patchName</span>
<span class="p">{</span>
    <span class="n">type</span>            <span class="n">totalPressure</span><span class="p">;</span>
    <span class="n">rho</span>             <span class="n">rho</span><span class="p">;</span>              <span class="c1">// 可压缩流</span>
    <span class="n">psi</span>             <span class="n">none</span><span class="p">;</span>             <span class="c1">// 低速可压缩流</span>
    <span class="n">gamma</span>           <span class="mf">1.4</span>               <span class="c1">// 可压缩流</span>
    <span class="n">U</span>               <span class="n">U</span><span class="p">;</span>
    <span class="n">phi</span>             <span class="n">phi</span><span class="p">;</span>
    <span class="n">p0</span>              <span class="n">uniform</span> <span class="mf">1e5</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id13">
<h3>温度边界条件<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h3>
<div class="section" id="totaltemperature">
<h4>totalTemperature<a class="headerlink" href="#totaltemperature" title="永久链接至标题">¶</a></h4>
<p>这个边界条件提供了一个总温度条件。该边界条件继承于fixedValue边界条件。</p>
<p>进入src/finiteVolume/fields/fvPatchFields/derived/totalTemperature/totalTemperatureFvPatchScalarField.C文件，可以看到如下代码：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Foam</span><span class="o">::</span><span class="n">totalTemperatureFvPatchScalarField</span><span class="o">::</span><span class="n">totalTemperatureFvPatchScalarField</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">fvPatch</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">DimensionedField</span><span class="o">&lt;</span><span class="n">scalar</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">iF</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">dictionary</span><span class="o">&amp;</span> <span class="n">dict</span>
<span class="p">)</span>
<span class="o">:</span>
    <span class="n">fixedValueFvPatchScalarField</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">iF</span><span class="p">,</span> <span class="n">dict</span><span class="p">,</span> <span class="nb">false</span><span class="p">),</span>
    <span class="n">UName_</span><span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;U&quot;</span><span class="p">,</span> <span class="s">&quot;U&quot;</span><span class="p">)),</span>                 <span class="c1">// 读取速度场名称，默认为U</span>
    <span class="n">phiName_</span><span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;phi&quot;</span><span class="p">,</span> <span class="s">&quot;phi&quot;</span><span class="p">)),</span>           <span class="c1">// 读取通量场名称，默认为phi</span>
    <span class="n">psiName_</span><span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;psi&quot;</span><span class="p">,</span> <span class="s">&quot;thermo:psi&quot;</span><span class="p">)),</span>    <span class="c1">// 读取可压缩性场名称，默认为thermo:psi</span>
    <span class="n">gamma_</span><span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">lookup</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;gamma&quot;</span><span class="p">)),</span>                         <span class="c1">// 读取比热容比的赋值</span>
    <span class="n">T0_</span><span class="p">(</span><span class="s">&quot;T0&quot;</span><span class="p">,</span> <span class="n">dict</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>                                     <span class="c1">// 读取参考温度的赋值</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">found</span><span class="p">(</span><span class="s">&quot;value&quot;</span><span class="p">))</span>    <span class="c1">// 如果有value关键词则用value关键词的赋值进行初始化</span>
    <span class="p">{</span>
        <span class="n">fvPatchField</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;::</span><span class="n">operator</span><span class="o">=</span>
        <span class="p">(</span>
            <span class="n">scalarField</span><span class="p">(</span><span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="n">dict</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">fvPatchField</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;::</span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">T0_</span><span class="p">);</span>    <span class="c1">// 否则使用T0的值进行初始化</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">totalTemperatureFvPatchScalarField</span><span class="o">::</span><span class="n">updateCoeffs</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">updated</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">fvPatchVectorField</span><span class="o">&amp;</span> <span class="n">Up</span> <span class="o">=</span> <span class="n">patch</span><span class="p">().</span><span class="n">lookupPatchField</span><span class="o">&lt;</span><span class="n">volVectorField</span><span class="p">,</span> <span class="n">vector</span><span class="o">&gt;</span><span class="p">(</span><span class="n">UName_</span><span class="p">);</span>    <span class="c1">// 获取速度场</span>
    <span class="k">const</span> <span class="n">fvsPatchField</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;&amp;</span> <span class="n">phip</span> <span class="o">=</span> <span class="n">patch</span><span class="p">().</span><span class="n">lookupPatchField</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="p">,</span> <span class="n">scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">phiName_</span><span class="p">);</span>    <span class="c1">// 获取通量场</span>
    <span class="k">const</span> <span class="n">fvPatchField</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;&amp;</span> <span class="n">psip</span> <span class="o">=</span> <span class="n">patch</span><span class="p">().</span><span class="n">lookupPatchField</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="p">,</span> <span class="n">scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">psiName_</span><span class="p">);</span>    <span class="c1">// 获取可压缩性场</span>
    <span class="n">scalar</span> <span class="n">gM1ByG</span> <span class="o">=</span> <span class="p">(</span><span class="n">gamma_</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span><span class="o">/</span><span class="n">gamma_</span><span class="p">;</span>

    <span class="n">operator</span><span class="o">==</span>
    <span class="p">(</span>
        <span class="n">T0_</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">psip</span><span class="o">*</span><span class="n">gM1ByG</span><span class="o">*</span><span class="n">neg</span><span class="p">(</span><span class="n">phip</span><span class="p">)</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">Up</span><span class="p">))</span>    <span class="c1">// 计算边界处的赋值</span>
    <span class="p">);</span>

    <span class="n">fixedValueFvPatchScalarField</span><span class="o">::</span><span class="n">updateCoeffs</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码表明，totalTemperature边界条件的边界温度计算方式为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
T =
\left \{ \begin{array}{l}
T_{0}, \quad \phi \ge 0 \\
\frac{T_{0}}{1 + \frac{1}{2}\psi \frac{\gamma - 1}{\gamma}|\mathbf{U}|^{2}}, \quad \phi &lt;0
\end{array} \right .
\end{align}\end{split}\]</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">totalTemperatureFvPatchScalarField</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">Ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">fvPatchScalarField</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
    <span class="n">writeEntryIfDifferent</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;U&quot;</span><span class="p">,</span> <span class="s">&quot;U&quot;</span><span class="p">,</span> <span class="n">UName_</span><span class="p">);</span>
    <span class="n">writeEntryIfDifferent</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;phi&quot;</span><span class="p">,</span> <span class="s">&quot;phi&quot;</span><span class="p">,</span> <span class="n">phiName_</span><span class="p">);</span>
    <span class="n">writeEntryIfDifferent</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;psi&quot;</span><span class="p">,</span> <span class="s">&quot;thermo:psi&quot;</span><span class="p">,</span> <span class="n">psiName_</span><span class="p">);</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;gamma&quot;</span><span class="p">,</span> <span class="n">gamma_</span><span class="p">);</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;T0&quot;</span><span class="p">,</span> <span class="n">T0_</span><span class="p">);</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">this</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id14">
<h3>无反射边界条件<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h3>
<div class="section" id="advective">
<h4>advective<a class="headerlink" href="#advective" title="永久链接至标题">¶</a></h4>
<p>可以参考 <a class="reference external" href="https://blog.csdn.net/weixin_39124457/article/details/120152679">OpenFOAM无反射边界条件源码学习</a></p>
<p>该边界条件提供了一个平流流出条件，基于求解边界处的DDt(W, field) = 0，其中W为波速，field为应用该边界条件的场。该边界条件支持标准时间格式(Euler, backward, CrankNicolson, localEuler)。此外，还提供了一种可选机制，通过指定松弛长度尺度lInf和远场值fieldInf，将边界处的值放松到指定的远场值。出口的流/波速度(w)由虚函数advectionSpeed()提供，该函数的默认实现需要通量场的名称(phi)，如果给出的是质量通量而不是体积通量则还需要密度(rho)。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">出口的流/波速度可以通过从这个类中派生一个专门的BC并覆盖advectionSpeed()来改变，例如在waveTransmissiveFvPatchField中，advectionSpeed()计算并返回流速度加上声波速度，从而创建一个声波传输边界条件。</p>
</div>
<p>边界处无反射在物理意义上可以认为是该物理量在边界处的物质导数为零，即由当地时间变化所引起的变化率与由流体通过边界流出引起的变化率的和恒为零：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{D\phi}{Dt} = \frac{\partial \phi}{\partial t} + \mathbf{U} \cdot \nabla \phi
\approx \frac{\partial \phi}{\partial t} + U_{n}\cdot \frac{\partial \phi}{\partial \mathbf{n}} = 0
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\phi\)</span> 就是需要无反射处理的流场变量。在后续， <span class="math notranslate nohighlight">\(\frac{\partial \phi}{\partial t}\)</span> 项需要根据时间离散格式进行不同的处理， <span class="math notranslate nohighlight">\(U_{n}\)</span> 则通过advectionSpeed()函数计算。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">advectiveFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">advectiveFvPatchField</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">fvPatch</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">DimensionedField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">iF</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">dictionary</span><span class="o">&amp;</span> <span class="n">dict</span>
<span class="p">)</span>
<span class="o">:</span>
    <span class="n">mixedFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">iF</span><span class="p">),</span>    <span class="c1">// 继承于mixed边界条件</span>
    <span class="n">phiName_</span><span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;phi&quot;</span><span class="p">,</span> <span class="s">&quot;phi&quot;</span><span class="p">)),</span>    <span class="c1">// 获取通量场的名称</span>
    <span class="n">rhoName_</span><span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;rho&quot;</span><span class="p">,</span> <span class="s">&quot;rho&quot;</span><span class="p">)),</span>    <span class="c1">// 获取密度场的名称</span>
    <span class="n">fieldInf_</span><span class="p">(</span><span class="n">Zero</span><span class="p">),</span>    <span class="c1">// 远场值初始化为零</span>
    <span class="n">lInf_</span><span class="p">(</span><span class="o">-</span><span class="n">great</span><span class="p">)</span>       <span class="c1">// 松弛长度尺度初始化为-great</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">found</span><span class="p">(</span><span class="s">&quot;value&quot;</span><span class="p">))</span>    <span class="c1">// 如果设置了value</span>
    <span class="p">{</span>
        <span class="n">fvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">operator</span><span class="o">=</span>
        <span class="p">(</span>
            <span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="n">dict</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>    <span class="c1">// 则用value初始化边界值</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">fvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">patchInternalField</span><span class="p">());</span>   <span class="c1">// 否则使用内部场的值初始化</span>
    <span class="p">}</span>

    <span class="n">this</span><span class="o">-&gt;</span><span class="n">refValue</span><span class="p">()</span> <span class="o">=</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>       <span class="c1">// refValue初始化为边界的当前值</span>
    <span class="n">this</span><span class="o">-&gt;</span><span class="n">refGrad</span><span class="p">()</span> <span class="o">=</span> <span class="n">Zero</span><span class="p">;</span>         <span class="c1">// refGrad初始化为零</span>
    <span class="n">this</span><span class="o">-&gt;</span><span class="n">valueFraction</span><span class="p">()</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>    <span class="c1">// valueFraction初始化为零</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">readIfPresent</span><span class="p">(</span><span class="s">&quot;lInf&quot;</span><span class="p">,</span> <span class="n">lInf_</span><span class="p">))</span>    <span class="c1">// 如果设置了松弛长度尺度则读取</span>
    <span class="p">{</span>
        <span class="n">dict</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="s">&quot;fieldInf&quot;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">fieldInf_</span><span class="p">;</span>    <span class="c1">// 并进一步读取远场值</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">lInf_</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">)</span>    <span class="c1">// 如果松弛长度尺度为负数则报错</span>
        <span class="p">{</span>
            <span class="n">FatalIOErrorInFunction</span>
            <span class="p">(</span>
                <span class="n">dict</span>
            <span class="p">)</span>   <span class="o">&lt;&lt;</span> <span class="s">&quot;unphysical lInf specified (lInf &lt; 0)&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span>
                <span class="o">&lt;&lt;</span> <span class="s">&quot;    on patch &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">name</span><span class="p">()</span>
                <span class="o">&lt;&lt;</span> <span class="s">&quot; of field &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">internalField</span><span class="p">().</span><span class="n">name</span><span class="p">()</span>
                <span class="o">&lt;&lt;</span> <span class="s">&quot; in file &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">internalField</span><span class="p">().</span><span class="n">objectPath</span><span class="p">()</span>
                <span class="o">&lt;&lt;</span> <span class="n">exit</span><span class="p">(</span><span class="n">FatalIOError</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码表明，refGrad被初始化为零，并且后续也没有修改。如果在字典中设置了松弛长度尺度lInf，那么它必须大于等于0，否则将会报错；而且只有设置了lInf之后才会进一步读取远场值fieldInf。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">scalarField</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">advectiveFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">advectionSpeed</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">phi</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">().</span><span class="n">objectRegistry</span><span class="o">::</span><span class="n">template</span> <span class="n">lookupObject</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="o">&gt;</span><span class="p">(</span><span class="n">phiName_</span><span class="p">);</span>
    <span class="c1">// 获取通量场</span>
    <span class="k">const</span> <span class="n">fvsPatchField</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;&amp;</span> <span class="n">phip</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">template</span> <span class="n">lookupPatchField</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="p">,</span> <span class="n">scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">phiName_</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">phi</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()</span> <span class="o">==</span> <span class="n">dimMassFlux</span><span class="p">)</span>    <span class="c1">// 可压缩流的情况，通量为质量通量</span>
    <span class="p">{</span>
        <span class="c1">// 获取密度场</span>
        <span class="k">const</span> <span class="n">fvPatchScalarField</span><span class="o">&amp;</span> <span class="n">rhop</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">template</span> <span class="n">lookupPatchField</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="p">,</span> <span class="n">scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rhoName_</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">phip</span><span class="o">/</span><span class="p">(</span><span class="n">rhop</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">magSf</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">phip</span><span class="o">/</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">magSf</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码定义了advectionSpeed()函数返回的内容，返回值为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
w =
\left\{\begin{array}{l}
\frac{\phi}{|\mathbf{S}_{f}|} ,\quad \text{if}~\phi~\text{is volume flux}  \\
\frac{\phi}{\rho |\mathbf{S}_{f}|} ,\quad \text{if}~\phi~\text{is mass flux}
\end{array}\right .
\end{align}\end{split}\]</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">advectiveFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">updateCoeffs</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">updated</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">fvMesh</span><span class="o">&amp;</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">internalField</span><span class="p">().</span><span class="n">mesh</span><span class="p">();</span>

    <span class="n">word</span> <span class="nf">ddtScheme</span>
    <span class="p">(</span>
        <span class="n">mesh</span><span class="p">.</span><span class="n">schemes</span><span class="p">().</span><span class="n">ddt</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">internalField</span><span class="p">().</span><span class="n">name</span><span class="p">())</span>
    <span class="p">);</span>
    <span class="n">scalar</span> <span class="n">deltaT</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">().</span><span class="n">time</span><span class="p">().</span><span class="n">deltaTValue</span><span class="p">();</span>    <span class="c1">// 获取时间步长</span>

    <span class="k">const</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">field</span> <span class="o">=</span>    <span class="c1">// 获取内部场</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">().</span><span class="n">objectRegistry</span><span class="o">::</span><span class="n">template</span>
        <span class="n">lookupObject</span><span class="o">&lt;</span><span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&gt;</span>
        <span class="p">(</span>
            <span class="n">this</span><span class="o">-&gt;</span><span class="n">internalField</span><span class="p">().</span><span class="n">name</span><span class="p">()</span>
        <span class="p">);</span>

    <span class="c1">// Calculate the advection speed of the field wave</span>
    <span class="c1">// If the wave is incoming set the speed to 0.</span>
    <span class="k">const</span> <span class="n">scalarField</span> <span class="nf">w</span><span class="p">(</span><span class="n">Foam</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">advectionSpeed</span><span class="p">(),</span> <span class="n">scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">)));</span>    <span class="c1">// 计算advectionSpeed，如果是入流则取0</span>

    <span class="c1">// Calculate the field wave coefficient alpha (See notes)</span>
    <span class="k">const</span> <span class="n">scalarField</span> <span class="nf">alpha</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">deltaT</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">deltaCoeffs</span><span class="p">());</span>    <span class="c1">// 计算场波系数alpha</span>

    <span class="n">label</span> <span class="n">patchi</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">index</span><span class="p">();</span>

    <span class="c1">// Non-reflecting outflow boundary</span>
    <span class="c1">// If lInf_ defined setup relaxation to the value fieldInf_.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lInf_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>    <span class="c1">// 如果松弛长度尺度大于0</span>
    <span class="p">{</span>
        <span class="c1">// Calculate the field relaxation coefficient k (See notes)</span>
        <span class="k">const</span> <span class="n">scalarField</span> <span class="n">k</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">deltaT</span><span class="o">/</span><span class="n">lInf_</span><span class="p">);</span>    <span class="c1">// 计算场松弛系数k</span>

        <span class="k">if</span>    <span class="c1">// 如果时间离散格式设置的是Euler或CrankNicolson格式</span>
        <span class="p">(</span>
            <span class="n">ddtScheme</span> <span class="o">==</span> <span class="n">fv</span><span class="o">::</span><span class="n">EulerDdtScheme</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;::</span><span class="n">typeName</span>
         <span class="o">||</span> <span class="n">ddtScheme</span> <span class="o">==</span> <span class="n">fv</span><span class="o">::</span><span class="n">CrankNicolsonDdtScheme</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;::</span><span class="n">typeName</span>
        <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">this</span><span class="o">-&gt;</span><span class="n">refValue</span><span class="p">()</span> <span class="o">=</span> <span class="p">(</span><span class="n">field</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">]</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">fieldInf_</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">k</span><span class="p">);</span>    <span class="c1">// 计算refValue</span>

            <span class="n">this</span><span class="o">-&gt;</span><span class="n">valueFraction</span><span class="p">()</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">k</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">+</span> <span class="n">k</span><span class="p">);</span>    <span class="c1">// 计算valueFraction</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ddtScheme</span> <span class="o">==</span> <span class="n">fv</span><span class="o">::</span><span class="n">backwardDdtScheme</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;::</span><span class="n">typeName</span><span class="p">)</span>    <span class="c1">// 如果时间离散格式设置的是backward格式</span>
        <span class="p">{</span>
            <span class="n">this</span><span class="o">-&gt;</span><span class="n">refValue</span><span class="p">()</span> <span class="o">=</span>    <span class="c1">// 计算refValue</span>
            <span class="p">(</span>
                <span class="mf">2.0</span><span class="o">*</span><span class="n">field</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">]</span>
              <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">field</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">oldTime</span><span class="p">().</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">]</span>
              <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">fieldInf_</span>
            <span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.5</span> <span class="o">+</span> <span class="n">k</span><span class="p">);</span>

            <span class="n">this</span><span class="o">-&gt;</span><span class="n">valueFraction</span><span class="p">()</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">+</span> <span class="n">k</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.5</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">+</span> <span class="n">k</span><span class="p">);</span>    <span class="c1">// 计算valueFraction</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span>    <span class="c1">// 如果时间离散格式设置的是localEuler格式</span>
        <span class="p">(</span>
            <span class="n">ddtScheme</span> <span class="o">==</span> <span class="n">fv</span><span class="o">::</span><span class="n">localEulerDdtScheme</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;::</span><span class="n">typeName</span>
        <span class="p">)</span>
        <span class="p">{</span>
            <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">rDeltaT</span> <span class="o">=</span> <span class="n">fv</span><span class="o">::</span><span class="n">localEulerDdt</span><span class="o">::</span><span class="n">localRDeltaT</span><span class="p">(</span><span class="n">mesh</span><span class="p">);</span>

            <span class="c1">// Calculate the field wave coefficient alpha (See notes)</span>
            <span class="k">const</span> <span class="n">scalarField</span> <span class="n">alpha</span>    <span class="c1">// 更新场波系数alpha</span>
            <span class="p">(</span>
                <span class="n">w</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">deltaCoeffs</span><span class="p">()</span><span class="o">/</span><span class="n">rDeltaT</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">]</span>
            <span class="p">);</span>

            <span class="c1">// Calculate the field relaxation coefficient k (See notes)</span>
            <span class="k">const</span> <span class="n">scalarField</span> <span class="nf">k</span><span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="p">(</span><span class="n">rDeltaT</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">]</span><span class="o">*</span><span class="n">lInf_</span><span class="p">));</span>    <span class="c1">// 更新场松弛系数k</span>

            <span class="n">this</span><span class="o">-&gt;</span><span class="n">refValue</span><span class="p">()</span> <span class="o">=</span> <span class="p">(</span><span class="n">field</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">]</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">fieldInf_</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">k</span><span class="p">);</span>    <span class="c1">// 计算refValue</span>

            <span class="n">this</span><span class="o">-&gt;</span><span class="n">valueFraction</span><span class="p">()</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">k</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">+</span> <span class="n">k</span><span class="p">);</span>    <span class="c1">// 计算valueFraction</span>
        <span class="p">}</span>
        <span class="k">else</span>    <span class="c1">// 当设置的时间离散格式不是Euler,CrankNicolson,backward,localEuler中的其中一种时将报错</span>
        <span class="p">{</span>
            <span class="n">FatalErrorInFunction</span>
                <span class="o">&lt;&lt;</span> <span class="n">ddtScheme</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span>
                <span class="o">&lt;&lt;</span> <span class="s">&quot;    on patch &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">name</span><span class="p">()</span>
                <span class="o">&lt;&lt;</span> <span class="s">&quot; of field &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">internalField</span><span class="p">().</span><span class="n">name</span><span class="p">()</span>
                <span class="o">&lt;&lt;</span> <span class="s">&quot; in file &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">internalField</span><span class="p">().</span><span class="n">objectPath</span><span class="p">()</span>
                <span class="o">&lt;&lt;</span> <span class="n">exit</span><span class="p">(</span><span class="n">FatalError</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span>    <span class="c1">// 如果松弛长度尺度等于0</span>
    <span class="p">{</span>
        <span class="k">if</span>    <span class="c1">// 如果时间离散格式设置的是Euler或CrankNicolson格式</span>
        <span class="p">(</span>
            <span class="n">ddtScheme</span> <span class="o">==</span> <span class="n">fv</span><span class="o">::</span><span class="n">EulerDdtScheme</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;::</span><span class="n">typeName</span>
         <span class="o">||</span> <span class="n">ddtScheme</span> <span class="o">==</span> <span class="n">fv</span><span class="o">::</span><span class="n">CrankNicolsonDdtScheme</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;::</span><span class="n">typeName</span>
        <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">this</span><span class="o">-&gt;</span><span class="n">refValue</span><span class="p">()</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">];</span>    <span class="c1">// 计算refValue</span>

            <span class="n">this</span><span class="o">-&gt;</span><span class="n">valueFraction</span><span class="p">()</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">alpha</span><span class="p">);</span>    <span class="c1">// 计算valueFraction</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ddtScheme</span> <span class="o">==</span> <span class="n">fv</span><span class="o">::</span><span class="n">backwardDdtScheme</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;::</span><span class="n">typeName</span><span class="p">)</span>    <span class="c1">// 如果时间离散格式设置的是backward格式</span>
        <span class="p">{</span>
            <span class="n">this</span><span class="o">-&gt;</span><span class="n">refValue</span><span class="p">()</span> <span class="o">=</span>    <span class="c1">// 计算refValue</span>
            <span class="p">(</span>
                <span class="mf">2.0</span><span class="o">*</span><span class="n">field</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">]</span>
              <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">field</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">oldTime</span><span class="p">().</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">]</span>
            <span class="p">)</span><span class="o">/</span><span class="mf">1.5</span><span class="p">;</span>

            <span class="n">this</span><span class="o">-&gt;</span><span class="n">valueFraction</span><span class="p">()</span> <span class="o">=</span> <span class="mf">1.5</span><span class="o">/</span><span class="p">(</span><span class="mf">1.5</span> <span class="o">+</span> <span class="n">alpha</span><span class="p">);</span>    <span class="c1">// 计算valueFraction</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span>    <span class="c1">// 如果时间离散格式设置的是localEuler格式</span>
        <span class="p">(</span>
            <span class="n">ddtScheme</span> <span class="o">==</span> <span class="n">fv</span><span class="o">::</span><span class="n">localEulerDdtScheme</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;::</span><span class="n">typeName</span>
        <span class="p">)</span>
        <span class="p">{</span>
            <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">rDeltaT</span> <span class="o">=</span> <span class="n">fv</span><span class="o">::</span><span class="n">localEulerDdt</span><span class="o">::</span><span class="n">localRDeltaT</span><span class="p">(</span><span class="n">mesh</span><span class="p">);</span>

            <span class="c1">// Calculate the field wave coefficient alpha (See notes)</span>
            <span class="k">const</span> <span class="n">scalarField</span> <span class="n">alpha</span>    <span class="c1">// 更新场波系数alpha</span>
            <span class="p">(</span>
                <span class="n">w</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">deltaCoeffs</span><span class="p">()</span><span class="o">/</span><span class="n">rDeltaT</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">]</span>
            <span class="p">);</span>

            <span class="n">this</span><span class="o">-&gt;</span><span class="n">refValue</span><span class="p">()</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">];</span>    <span class="c1">// 计算refValue</span>

            <span class="n">this</span><span class="o">-&gt;</span><span class="n">valueFraction</span><span class="p">()</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">alpha</span><span class="p">);</span>    <span class="c1">// 计算valueFraction</span>
        <span class="p">}</span>
        <span class="k">else</span>    <span class="c1">// 当设置的时间离散格式不是Euler,CrankNicolson,backward,localEuler中的其中一种时将报错</span>
        <span class="p">{</span>
            <span class="n">FatalErrorInFunction</span>
                <span class="o">&lt;&lt;</span> <span class="n">ddtScheme</span>
                <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">    on patch &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">name</span><span class="p">()</span>
                <span class="o">&lt;&lt;</span> <span class="s">&quot; of field &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">internalField</span><span class="p">().</span><span class="n">name</span><span class="p">()</span>
                <span class="o">&lt;&lt;</span> <span class="s">&quot; in file &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">internalField</span><span class="p">().</span><span class="n">objectPath</span><span class="p">()</span>
                <span class="o">&lt;&lt;</span> <span class="n">exit</span><span class="p">(</span><span class="n">FatalError</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">mixedFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">updateCoeffs</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码表明，advective边界条件设置的边界值与松弛长度尺度的设置以及时间离散格式的设置有关。当松弛长度尺度lInf设置为0时，refValue设置方式如下：</p>
<ol class="arabic simple">
<li>如果时间离散格式为Euler或CrankNicolson或localEuler，则</li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{align}
\text{refValue} = \phi_{p_{\text{old}}}
\end{align}\]</div>
<ol class="arabic simple" start="2">
<li>如果时间离散格式为backward，则</li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{align}
\text{refValue} = \frac{2}{3}\times (2\phi_{p_{\text{old}}} - \frac{1}{2}\phi_{p_{\text{oldold}}})
\end{align}\]</div>
<p>当松弛长度尺度lInf设置为0时，valueFraction的设置方式如下：</p>
<ol class="arabic simple">
<li>如果时间离散格式为Euler或CrankNicolson，则</li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{align}
\text{valueFraction} = \frac{1}{1 + \alpha} = \frac{1}{1 + w\Delta t \times \frac{1}{d}}
\end{align}\]</div>
<ol class="arabic simple" start="2">
<li>如果时间离散格式为backward，则</li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{align}
\text{valueFraction} = \frac{1.5}{1.5 + \alpha} = \frac{1.5}{1.5 + w\Delta t \times \frac{1}{d}}
\end{align}\]</div>
<ol class="arabic simple" start="3">
<li>如果时间离散格式为localEuler，则</li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{align}
\text{valueFraction} = \frac{1}{1 + \alpha'} = \frac{1}{1 + (w\times\frac{1}{d})/ \text{rDeltaT}}
\end{align}\]</div>
<p>当松弛长度尺度lInf设置为大于零的时候，refValue的设置方式如下：</p>
<ol class="arabic simple">
<li>如果时间离散格式为Euler或CrankNicolson，则</li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{align}
\text{refValue} = \frac{\phi_{p_{\text{old}}} + k \times \text{fieldInf}}{1 + k}
= \frac{\phi_{p_{\text{old}}} + \frac{w\Delta t}{\text{lInf}}\times \text{fieldInf}}{1 + \frac{w\Delta t}{\text{lInf}}}
\end{align}\]</div>
<ol class="arabic simple" start="2">
<li>如果时间离散格式为backward，则</li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{align}
\text{refValue} = \frac{2\phi_{p_{\text{old}}} - 0.5\phi_{p_{\text{oldold}}} + k\times \text{fieldInf}}{1.5 + k}
= \frac{2\phi_{p_{\text{old}}} - 0.5\phi_{p_{\text{oldold}}} + \frac{w\Delta t}{\text{lInf}}\times \text{fieldInf}}{1.5 + \frac{w\Delta t}{\text{lInf}}}
\end{align}\]</div>
<ol class="arabic simple" start="3">
<li>如果时间离散格式为localEuler，则</li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{align}
\text{refValue} = \frac{\phi_{p_{\text{old}}} + k' \times \text{fieldInf}}{1 + k'}
= \frac{\phi_{p_{\text{old}} + \frac{w}{\text{rDeltaT} \times \text{lInf}}\times \text{fieldInf}}}{1 + \frac{w}{\text{rDeltaT} \times \text{lInf}}}
\end{align}\]</div>
<p>当松弛长度尺度lInf设置为大于零的时候，valueFraction的设置方式如下：</p>
<ol class="arabic simple">
<li>如果时间离散格式为Euler或CrankNicolson，则</li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{align}
\text{valueFraction} = \frac{1 + k}{1 + \alpha + k}
= \frac{1 + \frac{w\Delta t}{\text{lInf}}}{1 + \frac{w\Delta t}{d} + \frac{w\Delta t}{\text{lInf}}}
\end{align}\]</div>
<ol class="arabic simple" start="2">
<li>如果时间离散格式为backward，则</li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{align}
\text{valueFraction} = \frac{1.5 + k}{1.5 + \alpha + k}
= \frac{1.5 + \frac{w\Delta t}{\text{lInf}}}{1.5 + \frac{w\Delta t}{d} + \frac{w\Delta t}{\text{lInf}}}
\end{align}\]</div>
<ol class="arabic simple" start="3">
<li>如果时间离散格式为localEuler，则</li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{align}
\text{valueFraction} = \frac{1 + k'}{1 + \alpha' + k'}
= \frac{1 + \frac{w}{\text{rDeltaT} \times \text{lInf}}}{1 + \frac{w}{d\times \text{rDeltaT}} + \frac{w}{\text{rDeltaT}\times \text{lInf}}}
\end{align}\]</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>下面以Euler格式以及lInf设置为0的情况为例，说明各个系数为何设置成如上形式：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\partial \phi}{\partial t} + U_{n}\cdot \frac{\partial \phi}{\partial \mathbf{n}}
= \frac{\phi_{p} - \phi_{\text{old}}}{\Delta t} + w \times \frac{\phi_{p} - \phi_{c}}{d}
\end{align}\]</div>
<p>于是可以得到</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\phi_{p} = \frac{\frac{1}{\Delta t}\phi_{\text{old}}}{\frac{1}{\Delta t} + w\times \frac{1}{d}}
+ \frac{w\times \frac{1}{d} \phi_{c}}{\frac{1}{\Delta t} + w \times \frac{1}{d}}
= \Big( 1 - \frac{1}{1 + w\Delta t\times \frac{1}{d}} \Big)\phi_{c}
+ \frac{1}{1 + w\Delta t \times \frac{1}{d}}\phi_{\text{old}}
\end{align}\]</div>
<p class="last">据此可以得到refValue、refGrad和valueFraction的表达式。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>对于lInf设置大于零的情况，以Euler格式为例，用上述方法进行整理可以得到其求解的方程为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\partial \phi}{\partial t}
+ U_{n}\cdot \frac{\partial \phi}{\partial \mathbf{n}}
= \frac{\phi_{p} - \phi_{p_{\text{old}}}}{\Delta t}
+ w\times \Big( \frac{\phi_{p} - \phi_{c}}{d} + \frac{\phi_{p} - \text{fieldInf}}{\text{lInf}}  \Big)
= 0
\end{align}\]</div>
<p class="last">由此可知，lInf可以理解为当前边界面与设想远场位置的距离。</p>
</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">advectiveFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">write</span><span class="p">(</span><span class="n">Ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">fvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">write</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>

    <span class="n">writeEntryIfDifferent</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;phi&quot;</span><span class="p">,</span> <span class="s">&quot;phi&quot;</span><span class="p">,</span> <span class="n">phiName_</span><span class="p">);</span>
    <span class="n">writeEntryIfDifferent</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;rho&quot;</span><span class="p">,</span> <span class="s">&quot;rho&quot;</span><span class="p">,</span> <span class="n">rhoName_</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">lInf_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;fieldInf&quot;</span><span class="p">,</span> <span class="n">fieldInf_</span><span class="p">);</span>
        <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;lInf&quot;</span><span class="p">,</span> <span class="n">lInf_</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">this</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>下面是advective边界条件一般的设置方式：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">patchName</span>
<span class="p">{</span>
    <span class="n">type</span>            <span class="n">advective</span><span class="p">;</span>
    <span class="n">phi</span>             <span class="n">phi</span><span class="p">;</span>
    <span class="n">rho</span>             <span class="n">rho</span><span class="p">;</span>     <span class="c1">// 可压缩流的情况</span>
    <span class="n">lInf</span>            <span class="mi">1</span><span class="p">;</span>       <span class="c1">// 松弛长度尺度</span>
    <span class="n">fieldInf</span>        <span class="mi">2902</span><span class="p">;</span>    <span class="c1">// 远场值</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="wavetransmissive">
<h4>waveTransmissive<a class="headerlink" href="#wavetransmissive" title="永久链接至标题">¶</a></h4>
<p>该边界条件通过求解边界处DDt(W, field) = 0提供了一个波透射流出条件，W为波速，field为应用该边界条件的场。该边界条件继承于advective边界条件，不过求解的方程改为了</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{D\phi}{Dt} \approx \frac{\partial \phi}{\partial t} + (U_{n} + c) \cdot \frac{\partial \phi}{\partial \mathbf{n}} = 0
\end{align}\]</div>
<p>所以waveTransmissive边界条件就是设置了自己的advectionSpeed()函数，其中添加了音速。</p>
<p>进入src/finiteVolume/fields/fvPatchFields/derived/waveTransmissive/waveTransmissiveFvPatchField.C文件，可以看到如下代码：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">scalarField</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">waveTransmissiveFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">advectionSpeed</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="c1">// Lookup the velocity and compressibility of the patch</span>
    <span class="k">const</span> <span class="n">fvPatchField</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;&amp;</span> <span class="n">psip</span> <span class="o">=</span>    <span class="c1">// 获取可压缩性场</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">template</span>
            <span class="n">lookupPatchField</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="p">,</span> <span class="n">scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">psiName_</span><span class="p">);</span>

    <span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">phi</span> <span class="o">=</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">().</span><span class="n">template</span> <span class="n">lookupObject</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="o">&gt;</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">phiName_</span><span class="p">);</span>

    <span class="n">scalarField</span> <span class="n">phip</span>    <span class="c1">// 获取通量场</span>
    <span class="p">(</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">template</span>
            <span class="n">lookupPatchField</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="p">,</span> <span class="n">scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">phiName_</span><span class="p">)</span>
    <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">phi</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()</span> <span class="o">==</span> <span class="n">dimMassFlux</span><span class="p">)</span>    <span class="c1">// 可压缩流的情况，通量为质量通量</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">fvPatchScalarField</span><span class="o">&amp;</span> <span class="n">rhop</span> <span class="o">=</span>    <span class="c1">// 获取密度场</span>
            <span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">template</span>
                <span class="n">lookupPatchField</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="p">,</span> <span class="n">scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rhoName_</span><span class="p">);</span>

        <span class="n">phip</span> <span class="o">/=</span> <span class="n">rhop</span><span class="p">;</span>    <span class="c1">// 提前将通量除以密度，统一为体积通量</span>
    <span class="p">}</span>

    <span class="c1">// Calculate the speed of the field wave w</span>
    <span class="c1">// by summing the component of the velocity normal to the boundary</span>
    <span class="c1">// and the speed of sound (sqrt(gamma_/psi)).</span>
    <span class="k">return</span> <span class="n">phip</span><span class="o">/</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">().</span><span class="n">magSf</span><span class="p">()</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">gamma_</span><span class="o">/</span><span class="n">psip</span><span class="p">);</span>    <span class="c1">// 求解波速度w</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码表明，在waveTransmissive边界条件中，advectionSpeed()返回的波速度被修改为了</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
w =
\left \{ \begin{array}{l}
\frac{\phi}{|\mathbf{S}_{f}|} + \sqrt{\frac{\gamma}{\psi}}
,\quad \text{if}~\phi~\text{is volume flux} \\
\frac{\phi}{\rho |\mathbf{S}_{f}|} + \sqrt{\frac{\gamma}{\psi}}
,\quad \text{if}~\phi~\text{is mass flux}
\end{array} \right .
\end{align}\end{split}\]</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">waveTransmissiveFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">write</span><span class="p">(</span><span class="n">Ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">fvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">write</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>

    <span class="n">writeEntryIfDifferent</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;phi&quot;</span><span class="p">,</span> <span class="s">&quot;phi&quot;</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">phiName_</span><span class="p">);</span>
    <span class="n">writeEntryIfDifferent</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;rho&quot;</span><span class="p">,</span> <span class="s">&quot;rho&quot;</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">rhoName_</span><span class="p">);</span>
    <span class="n">writeEntryIfDifferent</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;psi&quot;</span><span class="p">,</span> <span class="s">&quot;thermo:psi&quot;</span><span class="p">,</span> <span class="n">psiName_</span><span class="p">);</span>

    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;gamma&quot;</span><span class="p">,</span> <span class="n">gamma_</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">lInf_</span> <span class="o">&gt;</span> <span class="n">small</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;fieldInf&quot;</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">fieldInf_</span><span class="p">);</span>
        <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;lInf&quot;</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">lInf_</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">this</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>下面是waveTransmissive边界条件的一般设置方式：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">patchName</span>
<span class="p">{</span>
    <span class="n">type</span>            <span class="n">waveTransmissive</span><span class="p">;</span>
    <span class="n">phi</span>             <span class="n">phi</span><span class="p">;</span>
    <span class="n">psi</span>             <span class="n">psi</span><span class="p">;</span>
    <span class="n">gamma</span>           <span class="mf">1.4</span><span class="p">;</span>
    <span class="n">lInf</span>            <span class="mi">1</span><span class="p">;</span>
    <span class="n">fieldInf</span>        <span class="mi">2900</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id16">
<h3>自定义边界条件<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h3>
<div class="section" id="codedfixedvalue">
<h4>codedFixedValue<a class="headerlink" href="#codedfixedvalue" title="永久链接至标题">¶</a></h4>
<p>下面是在射流外设置一个线性分布的速度场的例子：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">AirInlet</span>
    <span class="p">{</span>
        <span class="n">type</span>        <span class="n">codedFixedValue</span><span class="p">;</span>
        <span class="n">value</span>       <span class="nf">uniform</span> <span class="p">(</span><span class="mi">0</span> <span class="mi">0</span> <span class="mf">6.10</span><span class="p">);</span>

        <span class="n">name</span>    <span class="n">linearVelocity</span><span class="p">;</span>
        <span class="n">code</span>
        <span class="cp">#{</span>
            <span class="k">const</span> <span class="n">vectorField</span><span class="o">&amp;</span> <span class="n">Cf</span> <span class="o">=</span> <span class="n">patch</span><span class="p">().</span><span class="n">Cf</span><span class="p">();</span>   <span class="c1">//center of the patch</span>
            <span class="n">vectorField</span><span class="o">&amp;</span> <span class="n">field</span> <span class="o">=</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>             <span class="c1">//the target velocity field</span>

            <span class="k">const</span> <span class="n">scalar</span> <span class="n">Umax</span> <span class="o">=</span> <span class="mf">6.1</span><span class="p">;</span>
            <span class="k">const</span> <span class="n">scalar</span> <span class="n">r1</span> <span class="o">=</span> <span class="mf">0.02</span><span class="p">;</span>                 <span class="c1">//radius of the hot coflow</span>
            <span class="k">const</span> <span class="n">scalar</span> <span class="n">r2</span> <span class="o">=</span> <span class="mf">0.06</span><span class="p">;</span>                 <span class="c1">//radius of the domain</span>

            <span class="n">forAll</span><span class="p">(</span><span class="n">Cf</span><span class="p">,</span> <span class="n">faceI</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">const</span> <span class="n">scalar</span> <span class="n">x</span> <span class="o">=</span> <span class="n">Cf</span><span class="p">[</span><span class="n">faceI</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
                <span class="k">const</span> <span class="n">scalar</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Cf</span><span class="p">[</span><span class="n">faceI</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
                <span class="k">const</span> <span class="n">scalar</span> <span class="n">R</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="p">);</span>

                <span class="k">if</span><span class="p">(</span><span class="n">R</span><span class="o">&gt;</span><span class="n">r1</span><span class="p">){</span>
                    <span class="n">field</span><span class="p">[</span><span class="n">faceI</span><span class="p">]</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">Umax</span><span class="o">*</span><span class="p">(</span><span class="n">r2</span><span class="o">-</span><span class="n">R</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">r2</span><span class="o">-</span><span class="n">r1</span><span class="p">));</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="cp">#};</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>另外一个应用案例：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">code</span>
<span class="cp">#{</span>
    <span class="k">const</span> <span class="n">fvPatch</span><span class="o">&amp;</span> <span class="n">boundaryPatch</span> <span class="o">=</span> <span class="n">patch</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">vectorField</span><span class="o">&amp;</span> <span class="n">Cf</span> <span class="o">=</span> <span class="n">boundaryPatch</span><span class="p">.</span><span class="n">Cf</span><span class="p">();</span>
    <span class="n">vectorField</span><span class="o">&amp;</span> <span class="n">field</span> <span class="o">=</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">scalar</span> <span class="n">pi</span> <span class="o">=</span> <span class="n">constant</span><span class="o">::</span><span class="n">mathematical</span><span class="o">::</span><span class="n">pi</span><span class="p">;</span>
    <span class="n">scalar</span> <span class="n">x0</span><span class="o">=</span><span class="mf">0.654157</span><span class="p">,</span> <span class="n">z0</span><span class="o">=</span><span class="mf">0.115013</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mf">0.004554</span><span class="p">;</span>
    <span class="n">scalar</span> <span class="n">umax</span><span class="o">=</span><span class="mf">26.6</span><span class="p">,</span>   <span class="n">fjet</span><span class="o">=</span><span class="mf">138.5</span><span class="p">;</span>
    <span class="n">scalar</span> <span class="n">theta</span> <span class="o">=</span> <span class="mf">18.31163</span><span class="o">/</span><span class="n">pi</span><span class="p">;</span>

    <span class="n">forAll</span><span class="p">(</span><span class="n">Cf</span><span class="p">,</span> <span class="n">faceI</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">scalar</span> <span class="n">x</span>  <span class="o">=</span> <span class="n">Cf</span><span class="p">[</span><span class="n">faceI</span><span class="p">].</span><span class="n">x</span><span class="p">();</span>
        <span class="n">scalar</span> <span class="n">z</span>  <span class="o">=</span> <span class="n">Cf</span><span class="p">[</span><span class="n">faceI</span><span class="p">].</span><span class="n">z</span><span class="p">();</span>
        <span class="n">scalar</span> <span class="n">t</span>  <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">().</span><span class="n">time</span><span class="p">().</span><span class="n">value</span><span class="p">();</span>

        <span class="n">scalar</span> <span class="n">kesi</span>  <span class="o">=</span> <span class="n">pow</span><span class="p">(</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">z</span><span class="o">-</span><span class="n">z0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">z</span><span class="o">-</span><span class="n">z0</span><span class="p">),</span><span class="mf">0.5</span><span class="p">);</span>
        <span class="n">scalar</span> <span class="n">ujmag</span> <span class="o">=</span> <span class="mi">6</span><span class="o">*</span><span class="n">umax</span><span class="o">*</span><span class="p">(</span> <span class="p">(</span><span class="n">kesi</span><span class="o">/</span><span class="n">d</span><span class="p">)</span><span class="o">-</span><span class="n">pow</span><span class="p">(</span><span class="n">kesi</span><span class="o">/</span><span class="n">d</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">fjet</span><span class="o">*</span><span class="n">t</span><span class="p">);</span>
        <span class="n">scalar</span> <span class="n">ujet</span>  <span class="o">=</span> <span class="n">ujmag</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">);</span>
        <span class="n">scalar</span> <span class="n">vjet</span>  <span class="o">=</span> <span class="n">ujmag</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">);</span>

        <span class="n">field</span><span class="p">[</span><span class="n">faceI</span><span class="p">]</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">ujet</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">vjet</span><span class="p">);</span>
    <span class="p">}</span>
<span class="cp">#};</span>
</pre></div>
</div>
<p>更多的案例：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">inlet</span>
<span class="p">{</span>
    <span class="n">type</span>            <span class="n">codedFixedValue</span><span class="p">;</span>
    <span class="n">value</span>           <span class="n">uniform</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">name</span>            <span class="n">codeinlet_air</span><span class="p">;</span>

    <span class="n">code</span>
    <span class="cp">#{</span>
        <span class="k">const</span> <span class="n">vectorField</span><span class="o">&amp;</span> <span class="n">Cf</span> <span class="o">=</span> <span class="n">patch</span><span class="p">().</span><span class="n">Cf</span><span class="p">();</span>

        <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">field</span> <span class="o">=</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>

        <span class="n">scalar</span> <span class="n">D</span> <span class="o">=</span> <span class="mf">0.0252</span><span class="p">;</span>
        <span class="n">scalar</span> <span class="n">ymax</span> <span class="o">=</span> <span class="mf">5.82</span><span class="o">*</span><span class="n">D</span><span class="p">;</span>

        <span class="n">forAll</span><span class="p">(</span><span class="n">Cf</span><span class="p">,</span><span class="n">faceI</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">Cf</span><span class="p">[</span><span class="n">faceI</span><span class="p">].</span><span class="n">y</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">ymax</span> <span class="p">)</span>
               <span class="p">{</span>
                 <span class="n">field</span><span class="p">[</span><span class="n">faceI</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
               <span class="p">}</span>
        <span class="p">}</span>

    <span class="cp">#};</span>

<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">inlet</span>
<span class="p">{</span>
    <span class="n">type</span>            <span class="n">codedFixedValue</span><span class="p">;</span>
    <span class="n">value</span>           <span class="nf">uniform</span> <span class="p">(</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">//default value</span>
    <span class="n">name</span>            <span class="n">powvelocity</span><span class="p">;</span>      <span class="c1">//name of new BC type</span>

    <span class="n">code</span>
    <span class="cp">#{</span>
        <span class="k">const</span> <span class="n">fvPatch</span> <span class="o">&amp;</span><span class="n">boundaryPatch</span> <span class="o">=</span> <span class="n">patch</span><span class="p">();</span>
        <span class="k">const</span> <span class="n">fvBoundaryMesh</span> <span class="o">&amp;</span><span class="n">boundaryMesh</span> <span class="o">=</span> <span class="n">boundaryPatch</span><span class="p">.</span><span class="n">boundaryMesh</span><span class="p">();</span>
        <span class="k">const</span> <span class="n">fvMesh</span> <span class="o">&amp;</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">boundaryMesh</span><span class="p">.</span><span class="n">mesh</span><span class="p">();</span>
        <span class="k">const</span> <span class="n">fvPatchField</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">U</span> <span class="o">=</span> <span class="n">boundaryPatch</span><span class="p">.</span><span class="n">lookupPatchField</span><span class="o">&lt;</span><span class="n">volVectorField</span><span class="p">,</span> <span class="n">vector</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;U&quot;</span><span class="p">);</span>

        <span class="k">const</span> <span class="n">vectorField</span> <span class="n">FC</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">Cf</span><span class="p">();</span>
        <span class="k">const</span> <span class="n">scalarField</span> <span class="n">y</span> <span class="o">=</span> <span class="n">FC</span><span class="o">&amp;</span><span class="n">vector</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>

        <span class="n">vectorField</span> <span class="nf">U1</span> <span class="p">(</span><span class="n">U</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">Zero</span><span class="p">);</span>
        <span class="c1">// const scalar pi = M_PI;</span>
        <span class="k">const</span> <span class="n">scalar</span> <span class="n">U_0</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
        <span class="k">const</span> <span class="n">scalar</span> <span class="n">D</span> <span class="o">=</span> <span class="mf">0.03</span><span class="p">;</span>

        <span class="n">forAll</span><span class="p">(</span><span class="n">boundaryPatch</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">U1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">U_0</span><span class="o">*</span><span class="p">(</span><span class="n">pow</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">D</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">7</span><span class="p">)),</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">operator</span><span class="o">==</span><span class="p">(</span><span class="n">U1</span><span class="p">);</span>
    <span class="cp">#};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如需要设置随时间变化的边界条件，可采用如下方法得到OF运行时间：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">scalar</span> <span class="n">t</span>  <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">().</span><span class="n">time</span><span class="p">().</span><span class="n">value</span><span class="p">();</span>
</pre></div>
</div>
<p>添加下面的语句来解决 <code class="code docutils literal notranslate"><span class="pre">error:</span> <span class="pre">‘mesh’</span> <span class="pre">was</span> <span class="pre">not</span> <span class="pre">declared</span> <span class="pre">in</span> <span class="pre">this</span> <span class="pre">scope</span></code> 的问题：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>codeOptions
#{
-I$(LIB_SRC)/meshTools/lnInclude
#};
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id17">
<h2>壁面函数<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h2>
<div class="section" id="id18">
<h3>壁面函数的推导<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h3>
<p>首先要了解近壁区域的性质才能了解什么时候能够使用壁面函数。引入两个无量纲数：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
y^{+} = \frac{yu_{\tau}}{\nu}, \quad  u_{\tau} = \sqrt{\frac{\tau_{w}}{\rho}} , \quad u^{+} = \frac{u}{u_{\tau}}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(u_{\tau}\)</span> 为摩擦速度，它可以后续用来定义无量纲速度； <span class="math notranslate nohighlight">\(\tau_{w}\)</span> 为壁面切应力， <span class="math notranslate nohighlight">\(y\)</span> 为距离壁面的距离， <span class="math notranslate nohighlight">\(y^{+}\)</span> 是一个无量纲数， <span class="math notranslate nohighlight">\(u^{+}\)</span> 为无量纲速度。第一层网格的 <span class="math notranslate nohighlight">\(y^{+}\)</span> 值非常重要，因为它将决定其所在的近壁区域类型。</p>
<p>近壁区域可以分为三个类型，它们可以通过 <span class="math notranslate nohighlight">\(y^{+}\)</span> 和 <span class="math notranslate nohighlight">\(u^{+}\)</span> 的关系来进行区分：</p>
<ol class="arabic simple">
<li><strong>粘性底层</strong> （ <span class="math notranslate nohighlight">\(y^{+} &lt; 5\)</span> ）：在粘性底层中，流体主要受粘性的影响，所以在这个区域可以假设剪切力等于壁面剪切应力 <span class="math notranslate nohighlight">\(\tau_{w}\)</span> 。在粘性底层中粘性力决定了流动方式并且速度分布式线性的，满足</li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{align}
u ^{+} = y^{+}
\end{align}\]</div>
<ol class="arabic simple" start="2">
<li><strong>对数分布区</strong> （ <span class="math notranslate nohighlight">\(30 &lt; y^{+} &lt; 200\)</span> ）：在对数分布区湍流应力起主导作用，速度分布变化按照关于壁面距离 <span class="math notranslate nohighlight">\(y\)</span> 的对数方式进行分布，满足</li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{align}
u^{+} = \frac{1}{\kappa}\ln(E y^{+})
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\kappa\)</span> 为卡门常数，取 <span class="math notranslate nohighlight">\(\kappa=0.41\)</span> ，对于光滑壁面取 <span class="math notranslate nohighlight">\(E = 9.8\)</span> 。</p>
<ol class="arabic simple" start="3">
<li><strong>缓冲区</strong> ：粘性和湍流应力的作用尺度相似，因此在这部分区域速度分布非常复杂而无法良好定义，因此原始壁面函数需要壁面第一层网格中心位于这个区域。但是，一些改良的壁面函数能够允许第一层网格中心位于缓冲区。在OpenFOAM中，缓冲层被分为两部分，一部分认为是粘性底层满足线性关系，另一部分认为满足对数分布规律。</li>
</ol>
<p>壁面函数的推导过程将会涉及到 <span class="math notranslate nohighlight">\(\varepsilon, f, k, \nu, \overline{v^{2}}\)</span> 和 <span class="math notranslate nohighlight">\(\omega\)</span> ，不过具体应用时都会取它们的无量纲形式，即</p>
<div class="math notranslate nohighlight">
\[\begin{align}
u^{+} = \frac{u}{u_{\tau}} ,\quad
k^{+}=\frac{k}{u_{\tau}^{2}} ,\quad
\varepsilon^{+} = \frac{\varepsilon \nu}{u_{\tau}^{4}} ,\quad
\overline{v^{2}}^{+} = \frac{\overline{v^{2}}}{u_{\tau}^{2}} ,\quad
f^{+} = \frac{f \nu}{u_{\tau}^{2}} ,\quad
\omega^{+} = \frac{\nu \omega}{u_{\tau}^{2}}
\end{align}\]</div>
<p>下面将讨论两类湍流模型，第一个是 <span class="math notranslate nohighlight">\(v^{2}-f\)</span> 湍流模型，需要 <span class="math notranslate nohighlight">\(k, \varepsilon, v^{2}, f\)</span> 壁面函数；第二个是 <span class="math notranslate nohighlight">\(k-\omega\)</span> 湍流模型，需要 <span class="math notranslate nohighlight">\(\omega\)</span> 壁面函数。</p>
<p>在粘性底层， <span class="math notranslate nohighlight">\(v^{2}-f\)</span> 湍流模型方程组可以简化为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
- \varepsilon^{+}
+ \frac{\mathrm{d}^{2}k^{+}}{\mathrm{d}(y^{+})^{2}}
= 0
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
- \frac{C_{\varepsilon 2}}{6}(\varepsilon^{+})^{1.5}
+ \frac{\mathrm{d}^{2}\varepsilon^{+}}{\mathrm{d}(y^{+})^{2}}
= 0
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
- N \frac{\varepsilon^{+} (\overline{v^{2}})^{+}}{k^{+}}
+ k^{+}f^{+}
+ \frac{\mathrm{d}^{2}(\overline{v^{2}})^{+}}{\mathrm{d}(y^{+})^{2}}
= 0
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{2}{3}(C_{f1} - 1)
- (N - C_{f1})\frac{(\overline{v^{2}})^{+}}{k^{+}}
- \frac{6}{(\varepsilon^{+})^{0.5}}f^{+}
+ \frac{C_{\eta}^{2} C_{L}^{2} 6}{\varepsilon^{+}}\frac{\mathrm{d}^{2}f^{+}}{\mathrm{d}(y^{+})^{2}}
= 0
\end{align}\]</div>
<p>根据上面的方程组可以得到 <span class="math notranslate nohighlight">\(\varepsilon^{+}\)</span> 的表达式为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\varepsilon^{+} = \frac{14400}{C_{\varepsilon2}^{2}}\frac{1}{(y^{+} + C)^{4}}
\end{align}\]</div>
<p>根据边界条件 <span class="math notranslate nohighlight">\(k^{+}(0)=0\)</span> ， <span class="math notranslate nohighlight">\(\frac{\mathrm{d}k^{+}}{\mathrm{d}y^{+}}(0) = 0\)</span> ，可以使用 <span class="math notranslate nohighlight">\(\varepsilon^{+}\)</span> 的结果进行积分得到 <span class="math notranslate nohighlight">\(k^{+}\)</span> 的表达式为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
k^{+} = \frac{2400}{C_{\varepsilon2}^{2}} \times \Big( \frac{1}{(y^{+} + C)^{4}} + \frac{2y^{+}}{C^{3}} - \frac{1}{C^{2}} \Big)
\end{align}\]</div>
<p>假定 <span class="math notranslate nohighlight">\(k^{+}\)</span> 满足一个二次函数关系 <span class="math notranslate nohighlight">\(k^{+} = C_{k}(y^{+})^{2}\)</span> ，将其代入到湍流方程组中可以得到一个关于 <span class="math notranslate nohighlight">\(\varepsilon^{+}\)</span> 的特别条件：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\varepsilon^{+} = 2 \frac{k^{+}}{(y^{+})^{2}}
\end{align}\]</div>
<p><span class="math notranslate nohighlight">\(f^{+}\)</span> 的边界条件的推导可以通过假设 <span class="math notranslate nohighlight">\((\overline{v^{2}})^{+} = C_{V^{2}}(y^{+})^{4}\)</span> ，将其代入到 <span class="math notranslate nohighlight">\(v^{2}-f\)</span> 模型方程组就可以得到</p>
<div class="math notranslate nohighlight">
\[\begin{align}
f^{+} = \frac{-4(6-N)(\overline{v^{2}})^{+}}{\varepsilon^{+}(y^{+})^{4}}
\end{align}\]</div>
<p>在对数分布区，可以假设扩散项非常小，得到</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\kappa y^{+} \frac{\mathrm{d}k^{+}}{\mathrm{d}y^{+}} = C_{k}
\end{align}\]</div>
<p>用相同的方式可以推导出 <span class="math notranslate nohighlight">\(\overline{v^{2}}^{+}\)</span> ， <span class="math notranslate nohighlight">\(\varepsilon^{+}\)</span> 和 <span class="math notranslate nohighlight">\(f^{+}\)</span> ：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\overline{v^{2}}^{+} = \frac{C_{V^{2}}}{\kappa}\log (y^{+}) + B_{V^{2}}
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
\varepsilon^{+} = \frac{1}{\kappa y^{+}}
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
f^{+} = N \frac{\overline{v^{2}}^{+}}{(k^{+})^{2}}\varepsilon^{+}
\end{align}\]</div>
<p>在上述推导过程中涉及到一些常数，这些常数的赋值在OpenFOAM中一般为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
C_{k} = -0.416 ,\quad
B_{k} = 8.366 ,\quad
C_{V^{2}} = 0.193 ,\quad
B_{V^{2}} = -0.940
\end{align}\]</div>
<p>与 <span class="math notranslate nohighlight">\(v^{2}-f\)</span> 模型类似， <span class="math notranslate nohighlight">\(k-\omega\)</span> 模型方程组也可以简化来得到 <span class="math notranslate nohighlight">\(\omega\)</span> 在粘性底层和对数分布区的行为。在粘性底层，标准 <span class="math notranslate nohighlight">\(k-\omega\)</span> 方程组可以简化为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
C_{\mu} \omega^{+}k^{+} + \frac{\mathrm{d}^{2}k^{+}}{\mathrm{d}(y^{+})^{2}} = 0
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
- \beta_{1} (\omega^{+})^{2} + \frac{\mathrm{d}^{2}\omega^{+}}{\mathrm{d}(y^{+})^{2}} = 0
\end{align}\]</div>
<p>根据上面两个方程， <span class="math notranslate nohighlight">\(\omega^{+}\)</span> 的奇异解为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\omega ^{+} = \frac{6}{\beta_{1}(y^{+})^{2}}
\end{align}\]</div>
<p>在对数分布区， <span class="math notranslate nohighlight">\(\omega^{+}\)</span> 的表达式则为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\omega ^{+} = \frac{1}{\kappa\sqrt{C_{\mu}} y^{+}}
\end{align}\]</div>
<p>在过渡区 <span class="math notranslate nohighlight">\(\omega^{+}\)</span> 通常根据粘性底层和对数分布律的组合来得到，即</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\omega^{+} = \sqrt{[\omega^{+}_{\text{vis}}]^{2} + [\omega^{+}_{\text{log}}]^{2}}
\end{align}\]</div>
</div>
<div class="section" id="id19">
<h3>壁面函数代码解读<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h3>
<p>壁面函数作为一种边界条件继承于FvPatchField类，它们提供Dirichlet和Neumann边界条件，继承于fixedValue和zeroGradient边界条件。它们的实现将会涉及到upateCoeffs()和evaluate()功能。另外，OpenFOAM还使用了yPlusLam这个量来表示粘性底层与对数分布区的交界位置，对于一些提供了两种计算模式的壁面函数，则会在类的最开始计算yPlusLam。同时，壁面函数的计算过程也可以分为两类，一类是计算第一层网格面上的值，另一类则是计算临近壁面的网格中心的值。</p>
<p>OpenFOAM的壁面函数定义在src/MomentumTransportModels/momentumTransportModels/derivedFvPatchFields/wallFunctions当中，总共有6大类壁面函数，而各类细分后总共有12种壁面函数：</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">壁面函数</th>
<th class="head">用途</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>kqRWallFunction</td>
<td>用于高雷诺数，属于zeroGradient条件</td>
</tr>
<tr class="row-odd"><td>kLowReWallFunction</td>
<td>用于高和低雷诺数，条件根据 <span class="math notranslate nohighlight">\(y^{+}\)</span> 的情况</td>
</tr>
<tr class="row-even"><td>epsilonWallFunction</td>
<td>用于高雷诺数</td>
</tr>
<tr class="row-odd"><td>epsilonLowReWallFunction</td>
<td>用于高和低雷诺数，条件根据 <span class="math notranslate nohighlight">\(y^{+}\)</span> 的情况</td>
</tr>
<tr class="row-even"><td>V2WallFunction</td>
<td>用于高和低雷诺数，条件根据 <span class="math notranslate nohighlight">\(y^{+}\)</span> 的情况</td>
</tr>
<tr class="row-odd"><td>fWallFunction</td>
<td>用于高和低雷诺数，条件根据 <span class="math notranslate nohighlight">\(y^{+}\)</span> 的情况</td>
</tr>
<tr class="row-even"><td>omegaWallFunction</td>
<td>用于高和低雷诺数，条件基于粘性底层和对数分布律的混合</td>
</tr>
<tr class="row-odd"><td>nutWallFunction</td>
<td>抽象类，不提供特定的 <span class="math notranslate nohighlight">\(\nu_{t}\)</span></td>
</tr>
<tr class="row-even"><td>nutLowReWallFunction</td>
<td>用于低雷诺数，条件是zero</td>
</tr>
<tr class="row-odd"><td>nutUWallFunction</td>
<td>条件基于速度</td>
</tr>
<tr class="row-even"><td>nutkWallFunction</td>
<td>条件基于kinematic</td>
</tr>
<tr class="row-odd"><td>nutUSpaldingWallFunction</td>
<td>用于整个区域</td>
</tr>
</tbody>
</table>
<p>在壁面函数的构建过程中，会使用到src/MomentumTransportModels/momentumTransportModels/momentumTransportModel.H中定义的调用函数来获取所需物理量。</p>
<div class="section" id="nutwallfunction">
<h4>nutWallFunction<a class="headerlink" href="#nutwallfunction" title="永久链接至标题">¶</a></h4>
<p>该边界条件是一个抽象类，提供了基于湍流动能湍流运动粘度条件。不少其他壁面函数会继承这里面定义的一些调用函数。</p>
<p>在nutWallFunctionFvPatchScalarField.H文件中可以看到声明的变量的含义及相关的调用函数：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="nl">protected</span><span class="p">:</span>

    <span class="c1">// Protected data</span>

        <span class="c1">//- Cmu coefficient</span>
        <span class="n">scalar</span> <span class="n">Cmu_</span><span class="p">;</span>    <span class="c1">// 系数Cmu</span>

        <span class="c1">//- Von Karman constant</span>
        <span class="n">scalar</span> <span class="n">kappa_</span><span class="p">;</span>    <span class="c1">// 卡门常数kappa</span>

        <span class="c1">//- E coefficient</span>
        <span class="n">scalar</span> <span class="n">E_</span><span class="p">;</span>    <span class="c1">// 粗糙系数E</span>

        <span class="c1">//- Y+ at the edge of the laminar sublayer</span>
        <span class="n">scalar</span> <span class="n">yPlusLam_</span><span class="p">;</span>    <span class="c1">// 粘性底层极限位置的y+值</span>


    <span class="c1">// Protected Member Functions</span>

        <span class="c1">//- Check the type of the patch</span>
        <span class="n">virtual</span> <span class="kt">void</span> <span class="nf">checkType</span><span class="p">();</span>

        <span class="c1">//- Calculate the turbulence viscosity</span>
        <span class="n">virtual</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">scalarField</span><span class="o">&gt;</span> <span class="n">nut</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="c1">// 计算湍流粘度</span>

        <span class="c1">//- Write local wall function variables</span>
        <span class="n">virtual</span> <span class="kt">void</span> <span class="nf">writeLocalEntries</span><span class="p">(</span><span class="n">Ostream</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">//- Return the nut patchField for the given wall patch</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">nutWallFunctionFvPatchScalarField</span><span class="o">&amp;</span> <span class="n">nutw</span>    <span class="c1">// 返回所选壁面的nut</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">momentumTransportModel</span><span class="o">&amp;</span> <span class="n">turbModel</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">label</span> <span class="n">patchi</span>
<span class="p">);</span>

<span class="c1">//- Calculate the Y+ at the edge of the laminar sublayer</span>
<span class="k">static</span> <span class="n">scalar</span> <span class="nf">yPlusLam</span><span class="p">(</span><span class="k">const</span> <span class="n">scalar</span> <span class="n">kappa</span><span class="p">,</span> <span class="k">const</span> <span class="n">scalar</span> <span class="n">E</span><span class="p">);</span>    <span class="c1">// 计算粘性底层极限位置的y+值yPlusLam</span>

<span class="c1">//- Return the Y+ at the edge of the laminar sublayer</span>
<span class="n">scalar</span> <span class="nf">yPlusLam</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>    <span class="c1">// 返回yPlusLam的值</span>

<span class="c1">//- Calculate and return the yPlus at the boundary</span>
<span class="n">virtual</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">scalarField</span><span class="o">&gt;</span> <span class="n">yPlus</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="c1">// 计算壁面的y+</span>
</pre></div>
</div>
<p>在直接使用该壁面函数时，将会读取设置中的Cmu、kappa和E关键词的赋值。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">nutWallFunctionFvPatchScalarField</span><span class="o">::</span><span class="n">writeLocalEntries</span>
<span class="p">(</span>
    <span class="n">Ostream</span><span class="o">&amp;</span> <span class="n">os</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;Cmu&quot;</span><span class="p">,</span> <span class="n">Cmu_</span><span class="p">);</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;kappa&quot;</span><span class="p">,</span> <span class="n">kappa_</span><span class="p">);</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;E&quot;</span><span class="p">,</span> <span class="n">E_</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>nutWallFunction继承于fixedValue边界条件，默认情况下会初始化 <span class="math notranslate nohighlight">\(C_{\mu}=0.09\)</span> ， <span class="math notranslate nohighlight">\(\kappa = 0.41\)</span> ， <span class="math notranslate nohighlight">\(E=9.8\)</span> 。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Foam</span><span class="o">::</span><span class="n">nutWallFunctionFvPatchScalarField</span><span class="o">::</span><span class="n">nutWallFunctionFvPatchScalarField</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">fvPatch</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">DimensionedField</span><span class="o">&lt;</span><span class="n">scalar</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">iF</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">dictionary</span><span class="o">&amp;</span> <span class="n">dict</span>
<span class="p">)</span>
<span class="o">:</span>
    <span class="n">fixedValueFvPatchScalarField</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">iF</span><span class="p">,</span> <span class="n">dict</span><span class="p">),</span>
    <span class="n">Cmu_</span><span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;Cmu&quot;</span><span class="p">,</span> <span class="mf">0.09</span><span class="p">)),</span>
    <span class="n">kappa_</span><span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;kappa&quot;</span><span class="p">,</span> <span class="mf">0.41</span><span class="p">)),</span>
    <span class="n">E_</span><span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;E&quot;</span><span class="p">,</span> <span class="mf">9.8</span><span class="p">)),</span>
    <span class="n">yPlusLam_</span><span class="p">(</span><span class="n">yPlusLam</span><span class="p">(</span><span class="n">kappa_</span><span class="p">,</span> <span class="n">E_</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">checkType</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>下面的代码定义了yPlusLam是如何通过kappa和E的值进行计算的：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Foam</span><span class="o">::</span><span class="n">scalar</span> <span class="n">Foam</span><span class="o">::</span><span class="n">nutWallFunctionFvPatchScalarField</span><span class="o">::</span><span class="n">yPlusLam</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">kappa</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">E</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">scalar</span> <span class="n">ypl</span> <span class="o">=</span> <span class="mf">11.0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ypl</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">ypl</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">/</span><span class="n">kappa</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ypl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>可以看到，计算过程为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\text{ypl} = \frac{\log (\max(E\times \text{ypl}^{*} , 1))}{\kappa}
\end{align}\]</div>
</div>
<div class="section" id="kqrwallfunction">
<h4>kqRWallFunction<a class="headerlink" href="#kqrwallfunction" title="永久链接至标题">¶</a></h4>
<p>该边界条件为高雷诺数流动情况下的湍流k、q和R场提供了合适的条件。它本质上是对zeroGradient条件的简单包装。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">kqRWallFunctionFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">evaluate</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">Pstream</span><span class="o">::</span><span class="n">commsTypes</span> <span class="n">commsType</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">zeroGradientFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">evaluate</span><span class="p">(</span><span class="n">commsType</span><span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">kqRWallFunctionFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">write</span><span class="p">(</span><span class="n">Ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">zeroGradientFvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">write</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">this</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="klowrewallfunction">
<h4>kLowReWallFunction<a class="headerlink" href="#klowrewallfunction" title="永久链接至标题">¶</a></h4>
<p>该边界条件为低雷诺数和高雷诺数湍流流动情况提供了湍流动能壁函数条件。该模型在两种模式下运行，基于计算得到的层流-湍流转换y+值，该值由对应的nutWallFunction中指定的kappa和E导出。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">kLowReWallFunctionFvPatchScalarField</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">Ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">writeEntry</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s">&quot;Ceps2&quot;</span><span class="p">,</span> <span class="n">Ceps2_</span><span class="p">);</span>
    <span class="n">fixedValueFvPatchField</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;::</span><span class="n">write</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码表明kLowReWallFunction需要读取设置中Ceps2关键词的赋值。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">kLowReWallFunctionFvPatchScalarField</span><span class="o">::</span><span class="n">kLowReWallFunctionFvPatchScalarField</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">fvPatch</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">DimensionedField</span><span class="o">&lt;</span><span class="n">scalar</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">iF</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">dictionary</span><span class="o">&amp;</span> <span class="n">dict</span>
<span class="p">)</span>
<span class="o">:</span>
    <span class="n">fixedValueFvPatchField</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">iF</span><span class="p">,</span> <span class="n">dict</span><span class="p">),</span>
    <span class="n">Ceps2_</span><span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;Ceps2&quot;</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">))</span>
<span class="p">{}</span>
</pre></div>
</div>
<p>上面的代码表明kLowReWallFunction边界条件其实继承于fixedValue边界条件，并初始化Ceps2的值为1.9。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">kLowReWallFunctionFvPatchScalarField</span><span class="o">::</span><span class="n">updateCoeffs</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">updated</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">label</span> <span class="n">patchi</span> <span class="o">=</span> <span class="n">patch</span><span class="p">().</span><span class="n">index</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">momentumTransportModel</span><span class="o">&amp;</span> <span class="n">turbModel</span> <span class="o">=</span>
        <span class="n">db</span><span class="p">().</span><span class="n">lookupObject</span><span class="o">&lt;</span><span class="n">momentumTransportModel</span><span class="o">&gt;</span>
        <span class="p">(</span>
            <span class="n">IOobject</span><span class="o">::</span><span class="n">groupName</span>
            <span class="p">(</span>
                <span class="n">momentumTransportModel</span><span class="o">::</span><span class="n">typeName</span><span class="p">,</span>
                <span class="n">internalField</span><span class="p">().</span><span class="n">group</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="p">);</span>

    <span class="k">const</span> <span class="n">nutWallFunctionFvPatchScalarField</span><span class="o">&amp;</span> <span class="n">nutw</span> <span class="o">=</span>
        <span class="n">nutWallFunctionFvPatchScalarField</span><span class="o">::</span><span class="n">nutw</span><span class="p">(</span><span class="n">turbModel</span><span class="p">,</span> <span class="n">patchi</span><span class="p">);</span>

    <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">turbModel</span><span class="p">.</span><span class="n">y</span><span class="p">()[</span><span class="n">patchi</span><span class="p">];</span>    <span class="c1">// 定义第一层网格中心到壁面的距离y</span>

    <span class="k">const</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">tk</span> <span class="o">=</span> <span class="n">turbModel</span><span class="p">.</span><span class="n">k</span><span class="p">();</span>    <span class="c1">// 定义第一层网格中心的湍动能k</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">k</span> <span class="o">=</span> <span class="n">tk</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">scalarField</span><span class="o">&gt;</span> <span class="n">tnuw</span> <span class="o">=</span> <span class="n">turbModel</span><span class="p">.</span><span class="n">nu</span><span class="p">(</span><span class="n">patchi</span><span class="p">);</span>    <span class="c1">// 定义层流粘性nuw</span>
    <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">nuw</span> <span class="o">=</span> <span class="n">tnuw</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">scalar</span> <span class="n">Cmu25</span> <span class="o">=</span> <span class="n">pow025</span><span class="p">(</span><span class="n">nutw</span><span class="p">.</span><span class="n">Cmu</span><span class="p">());</span>    <span class="c1">// 计算了Cmu系数的0.25次幂，记作Cmu25</span>

    <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">kw</span> <span class="o">=</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>

    <span class="c1">// Set k wall values</span>
    <span class="n">forAll</span><span class="p">(</span><span class="n">kw</span><span class="p">,</span> <span class="n">facei</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">label</span> <span class="n">celli</span> <span class="o">=</span> <span class="n">patch</span><span class="p">().</span><span class="n">faceCells</span><span class="p">()[</span><span class="n">facei</span><span class="p">];</span>

        <span class="n">scalar</span> <span class="n">uTau</span> <span class="o">=</span> <span class="n">Cmu25</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="n">celli</span><span class="p">]);</span>    <span class="c1">// 计算摩擦速度</span>

        <span class="n">scalar</span> <span class="n">yPlus</span> <span class="o">=</span> <span class="n">uTau</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span><span class="o">/</span><span class="n">nuw</span><span class="p">[</span><span class="n">facei</span><span class="p">];</span>    <span class="c1">// 计算y+</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">yPlus</span> <span class="o">&gt;</span> <span class="n">nutw</span><span class="p">.</span><span class="n">yPlusLam</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="n">scalar</span> <span class="n">Ck</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.416</span><span class="p">;</span>
            <span class="n">scalar</span> <span class="n">Bk</span> <span class="o">=</span> <span class="mf">8.366</span><span class="p">;</span>
            <span class="n">kw</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ck</span><span class="o">/</span><span class="n">nutw</span><span class="p">.</span><span class="n">kappa</span><span class="p">()</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">yPlus</span><span class="p">)</span> <span class="o">+</span> <span class="n">Bk</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">scalar</span> <span class="n">C</span> <span class="o">=</span> <span class="mf">11.0</span><span class="p">;</span>
            <span class="n">scalar</span> <span class="n">Cf</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">sqr</span><span class="p">(</span><span class="n">yPlus</span> <span class="o">+</span> <span class="n">C</span><span class="p">)</span> <span class="o">+</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">yPlus</span><span class="o">/</span><span class="n">pow3</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">sqr</span><span class="p">(</span><span class="n">C</span><span class="p">));</span>
            <span class="n">kw</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2400.0</span><span class="o">/</span><span class="n">sqr</span><span class="p">(</span><span class="n">Ceps2_</span><span class="p">)</span><span class="o">*</span><span class="n">Cf</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">kw</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="o">*=</span> <span class="n">sqr</span><span class="p">(</span><span class="n">uTau</span><span class="p">);</span>    <span class="c1">// 更新壁面的湍流动能</span>
    <span class="p">}</span>

    <span class="c1">// Limit kw to avoid failure of the turbulence model due to division by kw</span>
    <span class="n">kw</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">kw</span><span class="p">,</span> <span class="n">small</span><span class="p">);</span>    <span class="c1">// 避免后续除以kw的时候出现数值错误，即防止除以零</span>

    <span class="n">fixedValueFvPatchField</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;::</span><span class="n">updateCoeffs</span><span class="p">();</span>

    <span class="c1">// TODO: perform averaging for cells sharing more than one boundary face</span>
<span class="p">}</span>
</pre></div>
</div>
<p>从上面的代码可以看到摩擦速度 <span class="math notranslate nohighlight">\(u_{\tau}\)</span> 和 <span class="math notranslate nohighlight">\(y^{+}\)</span> 的计算方式为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
u_{\tau} = C_{\mu}^{0.25}\sqrt{k} ,\quad
y^{+} = \frac{u_{\tau}y}{\nu}
\end{align}\]</div>
<p>壁面处的 <span class="math notranslate nohighlight">\(k^{+}\)</span> 计算方式为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
k^{+} =
\left \{\begin{array}{l}
\frac{C_{k}}{\kappa}\log(y^{+}) + B_{k} ,\qquad\qquad\qquad\quad y^{+} &gt; \text{yPlusLam} \\
\frac{2400}{C_{eps}^{2}}\times \Big(\frac{1}{(y^{+} + C)^{2}} + \frac{2y^{+}}{C^{3}} - \frac{1}{C^{2}} \Big) ,\quad y^{+} \le \text{yPlusLam}
\end{array}\right .
\end{align}\end{split}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(C_{k}=-0.416\)</span> ， <span class="math notranslate nohighlight">\(B_{k} = 8.366\)</span> ; <span class="math notranslate nohighlight">\(C = 11\)</span> ， <span class="math notranslate nohighlight">\(C_{eps2}\)</span> 通过读取设置赋值得到。</p>
<p>最后将无量纲数 <span class="math notranslate nohighlight">\(k^{+}\)</span> 计算为壁面边界处的 <span class="math notranslate nohighlight">\(k\)</span> 的方式为：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
k = k^{+} u_{\tau}^{2}
\end{align}\]</div>
</div>
<div class="section" id="v2wallfunction">
<h4>v2WallFunction<a class="headerlink" href="#v2wallfunction" title="永久链接至标题">¶</a></h4>
<p>该边界条件为低雷诺数和高雷诺数湍流流动情况提供了一个垂直于流线壁函数的湍流应力条件。该模型在两种模式下运行，基于计算得到的层流-湍流转换y+值，该值由对应的nutWallFunction中指定的kappa和E导出。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">v2WallFunctionFvPatchScalarField</span><span class="o">::</span><span class="n">updateCoeffs</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">updated</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">label</span> <span class="n">patchi</span> <span class="o">=</span> <span class="n">patch</span><span class="p">().</span><span class="n">index</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">momentumTransportModel</span><span class="o">&amp;</span> <span class="n">turbModel</span> <span class="o">=</span>
        <span class="n">db</span><span class="p">().</span><span class="n">lookupObject</span><span class="o">&lt;</span><span class="n">momentumTransportModel</span><span class="o">&gt;</span>
        <span class="p">(</span>
            <span class="n">IOobject</span><span class="o">::</span><span class="n">groupName</span>
            <span class="p">(</span>
                <span class="n">momentumTransportModel</span><span class="o">::</span><span class="n">typeName</span><span class="p">,</span>
                <span class="n">internalField</span><span class="p">().</span><span class="n">group</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="p">);</span>

    <span class="k">const</span> <span class="n">nutWallFunctionFvPatchScalarField</span><span class="o">&amp;</span> <span class="n">nutw</span> <span class="o">=</span>
        <span class="n">nutWallFunctionFvPatchScalarField</span><span class="o">::</span><span class="n">nutw</span><span class="p">(</span><span class="n">turbModel</span><span class="p">,</span> <span class="n">patchi</span><span class="p">);</span>

    <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">turbModel</span><span class="p">.</span><span class="n">y</span><span class="p">()[</span><span class="n">patchi</span><span class="p">];</span>    <span class="c1">// 定义到壁面的距离y</span>

    <span class="k">const</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">tk</span> <span class="o">=</span> <span class="n">turbModel</span><span class="p">.</span><span class="n">k</span><span class="p">();</span>    <span class="c1">// 定义湍流动能k</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">k</span> <span class="o">=</span> <span class="n">tk</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">scalarField</span><span class="o">&gt;</span> <span class="n">tnuw</span> <span class="o">=</span> <span class="n">turbModel</span><span class="p">.</span><span class="n">nu</span><span class="p">(</span><span class="n">patchi</span><span class="p">);</span>    <span class="c1">// 定义层流粘性nuw</span>
    <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">nuw</span> <span class="o">=</span> <span class="n">tnuw</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">scalar</span> <span class="n">Cmu25</span> <span class="o">=</span> <span class="n">pow025</span><span class="p">(</span><span class="n">nutw</span><span class="p">.</span><span class="n">Cmu</span><span class="p">());</span>    <span class="c1">// 计算了Cmu系数的0.25次幂，记作Cmu25</span>

    <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">v2</span> <span class="o">=</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>

    <span class="c1">// Set v2 wall values</span>
    <span class="n">forAll</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">facei</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">label</span> <span class="n">celli</span> <span class="o">=</span> <span class="n">patch</span><span class="p">().</span><span class="n">faceCells</span><span class="p">()[</span><span class="n">facei</span><span class="p">];</span>

        <span class="n">scalar</span> <span class="n">uTau</span> <span class="o">=</span> <span class="n">Cmu25</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="n">celli</span><span class="p">]);</span>    <span class="c1">// 计算摩擦速度</span>

        <span class="n">scalar</span> <span class="n">yPlus</span> <span class="o">=</span> <span class="n">uTau</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span><span class="o">/</span><span class="n">nuw</span><span class="p">[</span><span class="n">facei</span><span class="p">];</span>    <span class="c1">// 计算y+</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">yPlus</span> <span class="o">&gt;</span> <span class="n">nutw</span><span class="p">.</span><span class="n">yPlusLam</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="n">scalar</span> <span class="n">Cv2</span> <span class="o">=</span> <span class="mf">0.193</span><span class="p">;</span>
            <span class="n">scalar</span> <span class="n">Bv2</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.94</span><span class="p">;</span>
            <span class="n">v2</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="o">=</span> <span class="n">Cv2</span><span class="o">/</span><span class="n">nutw</span><span class="p">.</span><span class="n">kappa</span><span class="p">()</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">yPlus</span><span class="p">)</span> <span class="o">+</span> <span class="n">Bv2</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">scalar</span> <span class="n">Cv2</span> <span class="o">=</span> <span class="mf">0.193</span><span class="p">;</span>
            <span class="n">v2</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="o">=</span> <span class="n">Cv2</span><span class="o">*</span><span class="n">pow4</span><span class="p">(</span><span class="n">yPlus</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">v2</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="o">*=</span> <span class="n">sqr</span><span class="p">(</span><span class="n">uTau</span><span class="p">);</span>    <span class="c1">// 更新壁面的v2</span>
    <span class="p">}</span>

    <span class="n">fixedValueFvPatchField</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;::</span><span class="n">updateCoeffs</span><span class="p">();</span>

    <span class="c1">// TODO: perform averaging for cells sharing more than one boundary face</span>
<span class="p">}</span>
</pre></div>
</div>
<p>从上面的代码可以看到 <span class="math notranslate nohighlight">\((v^{2})^{+}\)</span> 的计算方式为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
(v^{2})^{+} =
\left \{\begin{array}{l}
\frac{C_{V^{2}}}{\kappa}\log(y^{+}) + B_{V^{2}} ,\quad y^{+} &gt; \text{yPlusLam} \\
C_{V^{2}}(y^{+})^{4} ,\qquad\qquad\quad y^{+} \le \text{yPlusLam}
\end{array}\right .
\end{align}\end{split}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(C_{V^{2}} = 0.193\)</span> ， <span class="math notranslate nohighlight">\(B_{V^{2}} = -0.94\)</span> 。</p>
<p>最后将无量纲数 <span class="math notranslate nohighlight">\((v^{2})^{+}\)</span> 计算为壁面处的 <span class="math notranslate nohighlight">\(v^{2}\)</span> 的方式为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
v^{2} = (v^{2})^{+}u_{\tau}^{2}
\end{align}\]</div>
</div>
<div class="section" id="fwallfunction">
<h4>fWallFunction<a class="headerlink" href="#fwallfunction" title="永久链接至标题">¶</a></h4>
<p>该边界条件提供了湍流阻尼函数f，低雷诺数和高雷诺数的壁面函数条件，湍流流动情况下的模型在两种模式下运行，基于计算得到的层流到湍流的转换y+值，由对应的nutWallFunction中指定的kappa和E导出。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">fWallFunctionFvPatchScalarField</span><span class="o">::</span><span class="n">updateCoeffs</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">updated</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">label</span> <span class="n">patchi</span> <span class="o">=</span> <span class="n">patch</span><span class="p">().</span><span class="n">index</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">momentumTransportModel</span><span class="o">&amp;</span> <span class="n">turbModel</span> <span class="o">=</span>
        <span class="n">db</span><span class="p">().</span><span class="n">lookupObject</span><span class="o">&lt;</span><span class="n">momentumTransportModel</span><span class="o">&gt;</span>
        <span class="p">(</span>
            <span class="n">IOobject</span><span class="o">::</span><span class="n">groupName</span>
            <span class="p">(</span>
                <span class="n">momentumTransportModel</span><span class="o">::</span><span class="n">typeName</span><span class="p">,</span>
                <span class="n">internalField</span><span class="p">().</span><span class="n">group</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="p">);</span>
    <span class="k">const</span> <span class="n">v2fBase</span><span class="o">&amp;</span> <span class="n">v2fModel</span> <span class="o">=</span> <span class="n">refCast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">v2fBase</span><span class="o">&gt;</span><span class="p">(</span><span class="n">turbModel</span><span class="p">);</span>

    <span class="k">const</span> <span class="n">nutWallFunctionFvPatchScalarField</span><span class="o">&amp;</span> <span class="n">nutw</span> <span class="o">=</span>
        <span class="n">nutWallFunctionFvPatchScalarField</span><span class="o">::</span><span class="n">nutw</span><span class="p">(</span><span class="n">turbModel</span><span class="p">,</span> <span class="n">patchi</span><span class="p">);</span>

    <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">turbModel</span><span class="p">.</span><span class="n">y</span><span class="p">()[</span><span class="n">patchi</span><span class="p">];</span>    <span class="c1">// 定义到壁面的距离y</span>

    <span class="k">const</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">tk</span> <span class="o">=</span> <span class="n">turbModel</span><span class="p">.</span><span class="n">k</span><span class="p">();</span>    <span class="c1">// 定义湍流动能k</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">k</span> <span class="o">=</span> <span class="n">tk</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">tepsilon</span> <span class="o">=</span> <span class="n">turbModel</span><span class="p">.</span><span class="n">epsilon</span><span class="p">();</span>    <span class="c1">// 定义湍流动能耗散率epsilon</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">epsilon</span> <span class="o">=</span> <span class="n">tepsilon</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">tv2</span> <span class="o">=</span> <span class="n">v2fModel</span><span class="p">.</span><span class="n">v2</span><span class="p">();</span>    <span class="c1">// 定义垂直于流线的湍流应力v2</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">tv2</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">scalarField</span><span class="o">&gt;</span> <span class="n">tnuw</span> <span class="o">=</span> <span class="n">turbModel</span><span class="p">.</span><span class="n">nu</span><span class="p">(</span><span class="n">patchi</span><span class="p">);</span>    <span class="c1">// 定义层流粘度nuw</span>
    <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">nuw</span> <span class="o">=</span> <span class="n">tnuw</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">scalar</span> <span class="n">Cmu25</span> <span class="o">=</span> <span class="n">pow025</span><span class="p">(</span><span class="n">nutw</span><span class="p">.</span><span class="n">Cmu</span><span class="p">());</span>    <span class="c1">// 计算了Cmu系数的0.25次幂，记作Cmu25</span>

    <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">f</span> <span class="o">=</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>

    <span class="c1">// Set f wall values</span>
    <span class="n">forAll</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">facei</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">label</span> <span class="n">celli</span> <span class="o">=</span> <span class="n">patch</span><span class="p">().</span><span class="n">faceCells</span><span class="p">()[</span><span class="n">facei</span><span class="p">];</span>

        <span class="n">scalar</span> <span class="n">uTau</span> <span class="o">=</span> <span class="n">Cmu25</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="n">celli</span><span class="p">]);</span>    <span class="c1">// 计算摩擦速度</span>

        <span class="n">scalar</span> <span class="n">yPlus</span> <span class="o">=</span> <span class="n">uTau</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span><span class="o">/</span><span class="n">nuw</span><span class="p">[</span><span class="n">facei</span><span class="p">];</span>    <span class="c1">// 计算y+</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">yPlus</span> <span class="o">&gt;</span> <span class="n">nutw</span><span class="p">.</span><span class="n">yPlusLam</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="n">scalar</span> <span class="n">N</span> <span class="o">=</span> <span class="mf">6.0</span><span class="p">;</span>
            <span class="n">scalar</span> <span class="n">v2c</span> <span class="o">=</span> <span class="n">v2</span><span class="p">[</span><span class="n">celli</span><span class="p">];</span>
            <span class="n">scalar</span> <span class="n">epsc</span> <span class="o">=</span> <span class="n">epsilon</span><span class="p">[</span><span class="n">celli</span><span class="p">];</span>
            <span class="n">scalar</span> <span class="n">kc</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="n">celli</span><span class="p">];</span>

            <span class="n">f</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span><span class="o">*</span><span class="n">v2c</span><span class="o">*</span><span class="n">epsc</span><span class="o">/</span><span class="p">(</span><span class="n">sqr</span><span class="p">(</span><span class="n">kc</span><span class="p">)</span> <span class="o">+</span> <span class="n">rootVSmall</span><span class="p">);</span>
            <span class="n">f</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="o">/=</span> <span class="n">sqr</span><span class="p">(</span><span class="n">uTau</span><span class="p">)</span> <span class="o">+</span> <span class="n">rootVSmall</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">f</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">fixedValueFvPatchField</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;::</span><span class="n">updateCoeffs</span><span class="p">();</span>

    <span class="c1">// TODO: perform averaging for cells sharing more than one boundary face</span>
<span class="p">}</span>
</pre></div>
</div>
<p><span class="math notranslate nohighlight">\(f\)</span> 的计算方式为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
f =
\left \{\begin{array}{l}
\frac{Nv^{2}\varepsilon}{k^{2}u_{\tau}^{2}}  ,\quad y^{+} &gt; \text{yPlusLam} \\
0 ,\qquad y^{+} \le \text{yPlusLam}
\end{array}\right .
\end{align}\end{split}\]</div>
<p>其中系数 <span class="math notranslate nohighlight">\(N = 6\)</span> 。</p>
<div class="admonition attention">
<p class="first admonition-title">注意</p>
<p class="last">该壁面函数的实现方式与理论存在较大差异，在使用该壁面函数时需要注意是否满足自身需求。</p>
</div>
</div>
<div class="section" id="epsilonwallfunction">
<h4>epsilonWallFunction<a class="headerlink" href="#epsilonwallfunction" title="永久链接至标题">¶</a></h4>
<p>该边界条件为低雷诺数和高雷诺数湍流模型提供了湍流耗散壁约束。该条件可应用于壁面边界，计算出湍流耗散场和湍流产生场，并指定近壁面 <span class="math notranslate nohighlight">\(\epsilon\)</span> 值。</p>
</div>
</div>
</div>
<div class="section" id="id20">
<h2>湍流模型<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h2>
<p>所有包含湍流的求解器都需要读取momentumTransport文件内设置的湍流模型信息。在该文件内，由 <code class="code docutils literal notranslate"><span class="pre">simulationType</span></code> 关键词决定所使用的湍流模型，其可能的赋值有：</p>
<ul class="simple">
<li><code class="code docutils literal notranslate"><span class="pre">laminar</span></code> ，表示不使用湍流模型；</li>
<li><code class="code docutils literal notranslate"><span class="pre">RAS</span></code> ，表示使用雷诺平均模型；</li>
<li><code class="code docutils literal notranslate"><span class="pre">LES</span></code> ，表示使用大涡模拟。</li>
</ul>
<div class="section" id="laminar">
<h3>laminar模型<a class="headerlink" href="#laminar" title="永久链接至标题">¶</a></h3>
<div class="literal-block-wrapper docutils container" id="id69">
<div class="code-block-caption"><span class="caption-text">src/MomentumTranportModels/momentumTransportModels/laminar/laminarModel/laminarModel.C</span><a class="headerlink" href="#id69" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicMomentumTransportModel</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">laminarModel</span><span class="o">&lt;</span><span class="n">BasicMomentumTransportModel</span><span class="o">&gt;::</span><span class="n">laminarModel</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">word</span><span class="o">&amp;</span> <span class="n">type</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">alphaField</span><span class="o">&amp;</span> <span class="n">alpha</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">rhoField</span><span class="o">&amp;</span> <span class="n">rho</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">volVectorField</span><span class="o">&amp;</span> <span class="n">U</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">alphaRhoPhi</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">phi</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">viscosity</span><span class="o">&amp;</span> <span class="n">viscosity</span>
<span class="p">)</span>
<span class="o">:</span>
    <span class="n">BasicMomentumTransportModel</span>
    <span class="p">(</span>
        <span class="n">type</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">,</span>
        <span class="n">rho</span><span class="p">,</span>
        <span class="n">U</span><span class="p">,</span>
        <span class="n">alphaRhoPhi</span><span class="p">,</span>
        <span class="n">phi</span><span class="p">,</span>
        <span class="n">viscosity</span>
    <span class="p">),</span>

    <span class="n">laminarDict_</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">subOrEmptyDict</span><span class="p">(</span><span class="s">&quot;laminar&quot;</span><span class="p">)),</span>
    <span class="n">printCoeffs_</span><span class="p">(</span><span class="n">laminarDict_</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">Switch</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;printCoeffs&quot;</span><span class="p">,</span> <span class="nb">false</span><span class="p">)),</span>
    <span class="n">coeffDict_</span><span class="p">(</span><span class="n">laminarDict_</span><span class="p">.</span><span class="n">optionalSubDict</span><span class="p">(</span><span class="n">type</span> <span class="o">+</span> <span class="s">&quot;Coeffs&quot;</span><span class="p">))</span>
<span class="p">{</span>
    <span class="c1">// Force the construction of the mesh deltaCoeffs which may be needed for the construction of the derived models and BCs</span>
    <span class="n">this</span><span class="o">-&gt;</span><span class="n">mesh_</span><span class="p">.</span><span class="n">deltaCoeffs</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// * * * * * * * * * * * * * * * * Selectors * * * * * * * * * * * * * * * * //</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicMomentumTransportModel</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">autoPtr</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">laminarModel</span><span class="o">&lt;</span><span class="n">BasicMomentumTransportModel</span><span class="o">&gt;&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">laminarModel</span><span class="o">&lt;</span><span class="n">BasicMomentumTransportModel</span><span class="o">&gt;::</span><span class="n">New</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">alphaField</span><span class="o">&amp;</span> <span class="n">alpha</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">rhoField</span><span class="o">&amp;</span> <span class="n">rho</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">volVectorField</span><span class="o">&amp;</span> <span class="n">U</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">alphaRhoPhi</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">phi</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">viscosity</span><span class="o">&amp;</span> <span class="n">viscosity</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">IOdictionary</span> <span class="n">modelDict</span>
    <span class="p">(</span>
        <span class="n">momentumTransportModel</span><span class="o">::</span><span class="n">readModelDict</span>
        <span class="p">(</span>
            <span class="n">U</span><span class="p">.</span><span class="n">db</span><span class="p">(),</span>
            <span class="n">alphaRhoPhi</span><span class="p">.</span><span class="n">group</span><span class="p">()</span>
        <span class="p">)</span>
    <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">modelDict</span><span class="p">.</span><span class="n">found</span><span class="p">(</span><span class="s">&quot;laminar&quot;</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">word</span> <span class="n">modelType</span> <span class="o">=</span> <span class="n">modelDict</span><span class="p">.</span><span class="n">subDict</span><span class="p">(</span><span class="s">&quot;laminar&quot;</span><span class="p">).</span><span class="n">lookupBackwardsCompatible</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span> <span class="p">(</span> <span class="p">{</span><span class="s">&quot;model&quot;</span><span class="p">,</span> <span class="s">&quot;laminarModel&quot;</span><span class="p">}</span> <span class="p">);</span>

        <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Selecting laminar stress model &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">modelType</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

        <span class="kr">typename</span> <span class="n">dictionaryConstructorTable</span><span class="o">::</span><span class="n">iterator</span> <span class="n">cstrIter</span> <span class="o">=</span> <span class="n">dictionaryConstructorTablePtr_</span><span class="o">-&gt;</span><span class="n">find</span><span class="p">(</span><span class="n">modelType</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">cstrIter</span> <span class="o">==</span> <span class="n">dictionaryConstructorTablePtr_</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="n">FatalErrorInFunction</span>
                <span class="o">&lt;&lt;</span> <span class="s">&quot;Unknown laminarModel type &quot;</span>
                <span class="o">&lt;&lt;</span> <span class="n">modelType</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span>
                <span class="o">&lt;&lt;</span> <span class="s">&quot;Valid laminarModel types:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span>
                <span class="o">&lt;&lt;</span> <span class="n">dictionaryConstructorTablePtr_</span><span class="o">-&gt;</span><span class="n">sortedToc</span><span class="p">()</span>
                <span class="o">&lt;&lt;</span> <span class="n">exit</span><span class="p">(</span><span class="n">FatalError</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">autoPtr</span><span class="o">&lt;</span><span class="n">laminarModel</span><span class="o">&gt;</span>
        <span class="p">(</span>
            <span class="n">cstrIter</span><span class="p">()</span>
            <span class="p">(</span>
                <span class="n">alpha</span><span class="p">,</span>
                <span class="n">rho</span><span class="p">,</span>
                <span class="n">U</span><span class="p">,</span>
                <span class="n">alphaRhoPhi</span><span class="p">,</span>
                <span class="n">phi</span><span class="p">,</span>
                <span class="n">viscosity</span>
            <span class="p">)</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>    <span class="c1">// 如果没有进一步设置laminar模型的类型，则默认为Stokes层流模型</span>
    <span class="p">{</span>
        <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Selecting laminar stress model &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">laminarModels</span><span class="o">::</span><span class="n">Stokes</span><span class="o">&lt;</span><span class="n">BasicMomentumTransportModel</span><span class="o">&gt;::</span><span class="n">typeName</span>
            <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">autoPtr</span><span class="o">&lt;</span><span class="n">laminarModel</span><span class="o">&gt;</span>
        <span class="p">(</span>
            <span class="n">new</span> <span class="n">laminarModels</span><span class="o">::</span><span class="n">Stokes</span><span class="o">&lt;</span><span class="n">BasicMomentumTransportModel</span><span class="o">&gt;</span>
            <span class="p">(</span>
                <span class="n">alpha</span><span class="p">,</span>
                <span class="n">rho</span><span class="p">,</span>
                <span class="n">U</span><span class="p">,</span>
                <span class="n">alphaRhoPhi</span><span class="p">,</span>
                <span class="n">phi</span><span class="p">,</span>
                <span class="n">viscosity</span>
            <span class="p">)</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id70">
<div class="code-block-caption"><span class="caption-text">src/MomentumTranportModels/momentumTransportModels/laminar/Stokes/Stokes.C</span><a class="headerlink" href="#id70" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicMomentumTransportModel</span><span class="o">&gt;</span>
<span class="n">Stokes</span><span class="o">&lt;</span><span class="n">BasicMomentumTransportModel</span><span class="o">&gt;::</span><span class="n">Stokes</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">alphaField</span><span class="o">&amp;</span> <span class="n">alpha</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">rhoField</span><span class="o">&amp;</span> <span class="n">rho</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">volVectorField</span><span class="o">&amp;</span> <span class="n">U</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">alphaRhoPhi</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">phi</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">viscosity</span><span class="o">&amp;</span> <span class="n">viscosity</span>
<span class="p">)</span>
<span class="o">:</span>
    <span class="n">linearViscousStress</span><span class="o">&lt;</span><span class="n">laminarModel</span><span class="o">&lt;</span><span class="n">BasicMomentumTransportModel</span><span class="o">&gt;&gt;</span>
    <span class="p">(</span>
        <span class="n">typeName</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">,</span>
        <span class="n">rho</span><span class="p">,</span>
        <span class="n">U</span><span class="p">,</span>
        <span class="n">alphaRhoPhi</span><span class="p">,</span>
        <span class="n">phi</span><span class="p">,</span>
        <span class="n">viscosity</span>
    <span class="p">)</span>
<span class="p">{}</span>


<span class="c1">// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicMomentumTransportModel</span><span class="o">&gt;</span>
<span class="k">const</span> <span class="n">dictionary</span><span class="o">&amp;</span> <span class="n">Stokes</span><span class="o">&lt;</span><span class="n">BasicMomentumTransportModel</span><span class="o">&gt;::</span><span class="n">coeffDict</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">dictionary</span><span class="o">::</span><span class="n">null</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicMomentumTransportModel</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">Stokes</span><span class="o">&lt;</span><span class="n">BasicMomentumTransportModel</span><span class="o">&gt;::</span><span class="n">read</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicMomentumTransportModel</span><span class="o">&gt;</span>
<span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">Stokes</span><span class="o">&lt;</span><span class="n">BasicMomentumTransportModel</span><span class="o">&gt;::</span><span class="n">nuEff</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">volScalarField</span><span class="o">::</span><span class="n">New</span>
    <span class="p">(</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">groupName</span><span class="p">(</span><span class="s">&quot;nuEff&quot;</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">alphaRhoPhi_</span><span class="p">.</span><span class="n">group</span><span class="p">()),</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">nu</span><span class="p">()</span>
    <span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicMomentumTransportModel</span><span class="o">&gt;</span>
<span class="n">tmp</span><span class="o">&lt;</span><span class="n">scalarField</span><span class="o">&gt;</span> <span class="n">Stokes</span><span class="o">&lt;</span><span class="n">BasicMomentumTransportModel</span><span class="o">&gt;::</span><span class="n">nuEff</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">label</span> <span class="n">patchi</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">nu</span><span class="p">(</span><span class="n">patchi</span><span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicMomentumTransportModel</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Stokes</span><span class="o">&lt;</span><span class="n">BasicMomentumTransportModel</span><span class="o">&gt;::</span><span class="n">correct</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">laminarModel</span><span class="o">&lt;</span><span class="n">BasicMomentumTransportModel</span><span class="o">&gt;::</span><span class="n">correct</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id71">
<div class="code-block-caption"><span class="caption-text">src/MomentumTranportModels/momentumTransportModels/linearViscousStress/linearViscousStress.C</span><a class="headerlink" href="#id71" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicMomentumTransportModel</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">volSymmTensorField</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">linearViscousStress</span><span class="o">&lt;</span><span class="n">BasicMomentumTransportModel</span><span class="o">&gt;::</span><span class="n">devTau</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">volSymmTensorField</span><span class="o">::</span><span class="n">New</span>
    <span class="p">(</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">groupName</span><span class="p">(</span><span class="s">&quot;devTau&quot;</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">alphaRhoPhi_</span><span class="p">.</span><span class="n">group</span><span class="p">()),</span>
        <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">alpha_</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rho_</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">nuEff</span><span class="p">()))</span>
       <span class="o">*</span><span class="n">dev</span><span class="p">(</span><span class="n">twoSymm</span><span class="p">(</span><span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">U_</span><span class="p">)))</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicMomentumTransportModel</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">fvVectorMatrix</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">linearViscousStress</span><span class="o">&lt;</span><span class="n">BasicMomentumTransportModel</span><span class="o">&gt;::</span><span class="n">divDevTau</span>
<span class="p">(</span>
    <span class="n">volVectorField</span><span class="o">&amp;</span> <span class="n">U</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span>
    <span class="p">(</span>
      <span class="o">-</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">((</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">alpha_</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rho_</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">nuEff</span><span class="p">())</span><span class="o">*</span><span class="n">dev2</span><span class="p">(</span><span class="n">T</span><span class="p">(</span><span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">U</span><span class="p">))))</span>
      <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">alpha_</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rho_</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">nuEff</span><span class="p">(),</span> <span class="n">U</span><span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicMomentumTransportModel</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">fvVectorMatrix</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">linearViscousStress</span><span class="o">&lt;</span><span class="n">BasicMomentumTransportModel</span><span class="o">&gt;::</span><span class="n">divDevTau</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">rho</span><span class="p">,</span>
    <span class="n">volVectorField</span><span class="o">&amp;</span> <span class="n">U</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span>
    <span class="p">(</span>
      <span class="o">-</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">((</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">alpha_</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">nuEff</span><span class="p">())</span><span class="o">*</span><span class="n">dev2</span><span class="p">(</span><span class="n">T</span><span class="p">(</span><span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">U</span><span class="p">))))</span>
      <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">alpha_</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">nuEff</span><span class="p">(),</span> <span class="n">U</span><span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="ras">
<h3>RAS模型<a class="headerlink" href="#ras" title="永久链接至标题">¶</a></h3>
<p>速度的雷诺分解为其平均贡献和波动贡献的形式为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\mathbf{U}(\mathbf{x},t) = \overline{\mathbf{U}}(\mathbf{x},t) + \mathbf{U}'(\mathbf{x},t)
\end{align}\]</div>
<p>其中，波动分量的均值定义为零，即</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\overline{\mathbf{U}'} = 0
\end{align}\]</div>
<p>应用于Navier Stokes方程，可以得到平均速度和平均压力的方程：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\partial \rho}{\partial t} + \nabla \cdot (\rho\overline{\mathbf{U}}) = 0
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\partial (\rho\overline{\mathbf{U}})}{\partial t} + \nabla \cdot (\rho \overline{\mathbf{U}} \otimes \overline{\mathbf{U}}) = \mathbf{g} + \nabla \cdot \overline{\tau} - \nabla \cdot (\rho \mathbf{R})
\end{align}\]</div>
<p>其中时均切应力 <span class="math notranslate nohighlight">\(\overline{\tau}\)</span> ，对于牛顿流体则表示为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\overline{\tau} =
- \Big( p + \frac{2}{3}\mu \nabla \cdot \overline{\mathbf{U}} \Big) \mathbf{I}
+ \mu \Big( \nabla \overline{\mathbf{U}} + (\nabla \overline{\mathbf{U}})^{T} \Big)
\end{align}\]</div>
<p>根据数学关系：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\nabla \cdot \overline{\mathbf{U}}
= \operatorname{tr}(\nabla \overline{\mathbf{U}})
= \operatorname{tr}\Big( (\nabla \overline{\mathbf{U}})^{T} \Big)
\end{align}\]</div>
<p>时均切应力可以改写为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\overline{\tau} = - p\mathbf{I} + \mu \Big[ \nabla\overline{\mathbf{U}} + (\nabla\overline{\mathbf{U}})^{T} - \frac{2}{3}\operatorname{tr}\Big( (\nabla\overline{\mathbf{U}})^{T} \Big)\mathbf{I} \Big]
\end{align}\]</div>
<p><span class="math notranslate nohighlight">\(\mathbf{R}\)</span> 为雷诺应力张量，可以进一步分解为各向同性贡献和偏向各向异性贡献：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\mathbf{R} = \overline{\mathbf{U}' \otimes \mathbf{U}'}
= \frac{2}{3}k\mathbf{I} + \overline{\mathbf{U}' \otimes \mathbf{U}'} - \frac{2}{3}k\mathbf{I}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(k\)</span> 是湍流动能，定义为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
k = \frac{1}{2} \overline{\mathbf{U}' \cdot \mathbf{U}'} = \frac{1}{2}\operatorname{tr}(\mathbf{R})
\end{align}\]</div>
<p>只有雷诺应力张量的各向异性贡献才能传递动量，因此各向同性贡献可以加到平均压力上，从而得到完整的形式：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\partial (\rho\overline{\mathbf{U}})}{\partial t}
+ \nabla \cdot (\rho \overline{\mathbf{U}}\otimes \overline{\mathbf{U}})
= \mathbf{g}
- \nabla \overline{p}'
+ \nabla\cdot (\mu \nabla \overline{\mathbf{U}})
+ \nabla \cdot \Big[ \mu \Big( (\nabla\overline{\mathbf{U}})^{T} - \frac{2}{3}\operatorname{tr}\big( (\nabla\overline{\mathbf{U}})^{T} \big)\mathbf{I} \Big) \Big]
- \nabla \cdot (\rho \mathbf{R}_{dev})
\end{align}\]</div>
<p>其中</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; \mathbf{R}_{dev} = \overline{\mathbf{U}' \otimes \mathbf{U}'} - \frac{2}{3}k\mathbf{I} \\
&amp; \overline{p}' = \overline{p} + \frac{2}{3}\rho k
\end{align}\end{split}\]</div>
<p>湍流模型RAS家族提供了近似由 <span class="math notranslate nohighlight">\(\mathbf{R}_{dev}\)</span> 引起的偏差各向异性应力贡献的方法。</p>
<p>如果选用了RAS模型，就需要在momentumTransport文件内进一步创建RAS子字典，该子字典需要包含下列内容：</p>
<ul class="simple">
<li><code class="code docutils literal notranslate"><span class="pre">model</span></code> ：具体采用的RAS湍流模型的名称；</li>
<li><code class="code docutils literal notranslate"><span class="pre">turbulence</span></code> ：开启或关闭湍流模型，可能的赋值有 <code class="code docutils literal notranslate"><span class="pre">on</span></code> 或 <code class="code docutils literal notranslate"><span class="pre">off</span></code> ；</li>
<li><code class="code docutils literal notranslate"><span class="pre">printCoeffs</span></code> ：输出或不输出湍流模型系数，可能的赋值有 <code class="code docutils literal notranslate"><span class="pre">on</span></code> 或 <code class="code docutils literal notranslate"><span class="pre">off</span></code> ；</li>
<li><code class="code docutils literal notranslate"><span class="pre">&lt;model&gt;Coeffs</span></code> ：可选参数，指定后可以覆盖默认的湍流模型参数。</li>
</ul>
<p>可用的RAS湍流模型包括：</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="35%" />
<col width="12%" />
<col width="39%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">不可压缩RAS湍流模型</th>
<th class="head">含义</th>
<th class="head">可压缩RAS湍流模型</th>
<th class="head">含义</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>LRR</td>
<td>Launder Reece and Rodi雷诺应力湍流模型</td>
<td>LRR</td>
<td>Launder Reece and Rodi雷诺应力湍流模型</td>
</tr>
<tr class="row-odd"><td>LamBremhorstKE</td>
<td>Lam and Bremhorst低雷诺数kEpsilon湍流模型</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>LaunderSharmaKE</td>
<td>不可压缩Launder and Sharma低雷诺数湍流模型</td>
<td>LaunderSharmaKE</td>
<td>基于RDT理论的Launder and Sharma低雷诺数kEpsilon燃烧湍流模型</td>
</tr>
<tr class="row-odd"><td>LienCubicKE</td>
<td>三次非线性低雷诺数kEpsilon湍流模型</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>LienLeschziner</td>
<td>Lien and Leschziner低雷诺数kEpsilon湍流模型</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>RNGkEpsilon</td>
<td>重整化群kEpsilon湍流模型</td>
<td>RNGkEpsilon</td>
<td>重整化群kEpsilon湍流模型</td>
</tr>
<tr class="row-even"><td>SSG</td>
<td>Speziale Sarkar and Gatski雷诺应力湍流模型</td>
<td>SSG</td>
<td>Speziale Sarkar and Gatski雷诺应力湍流模型</td>
</tr>
<tr class="row-odd"><td>ShihQuadraticKE</td>
<td>Shih四次代数雷诺应力kEpsilon湍流模型</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>SpalartAllmaras</td>
<td>Spalart Allmaras一方程混合长外流湍流模型</td>
<td>SpalartAllmaras</td>
<td>Spalart Allmaras一方程混合长外流湍流模型</td>
</tr>
<tr class="row-odd"><td>kEpsilon</td>
<td>标准kEpsilon湍流模型</td>
<td>kEpsilon</td>
<td>标准kEpsilon湍流模型</td>
</tr>
<tr class="row-even"><td>kOmega</td>
<td>标准kOmega湍流模型</td>
<td>kOmega</td>
<td>标准kOmega湍流模型</td>
</tr>
<tr class="row-odd"><td>kOmega2006</td>
<td>标准(2006)高雷诺数kOmega湍流模型</td>
<td>kOmega2006</td>
<td>标准(2006)高雷诺数kOmega湍流模型</td>
</tr>
<tr class="row-even"><td>kOmegaSST</td>
<td>kOmegaSST湍流模型</td>
<td>kOmegaSST</td>
<td>kOmegaSST湍流模型</td>
</tr>
<tr class="row-odd"><td>kOmegaSSTLM</td>
<td>基于kOmegaSST的Langtry Menter四方程转变区SST湍流模型</td>
<td>kOmegaSSTLM</td>
<td>基于kOmegaSST的Langtry Menter四方程转变区SST湍流模型</td>
</tr>
<tr class="row-even"><td>kOmegaSSTSAS</td>
<td>基于kOmegaSST的自适应URANS湍流模型</td>
<td>kOmegaSSTSAS</td>
<td>基于kOmegaSST的自适应URANS湍流模型</td>
</tr>
<tr class="row-odd"><td>kklOmega</td>
<td>低雷诺数k-kl-Omega湍流模型</td>
<td>buoyantKEpsilon</td>
<td>附带浮力项的标准kEpsilon湍流模型</td>
</tr>
<tr class="row-even"><td>qZeta</td>
<td>Gibson and Dafa Alla低雷诺数湍流模型</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>realizableKE</td>
<td>可实现的kEpsilon湍流模型</td>
<td>realizableKE</td>
<td>可实现的kEpsilon湍流模型</td>
</tr>
<tr class="row-even"><td>v2f</td>
<td>Lien and Kalitzin V2F湍流模型</td>
<td>v2f</td>
<td>Lien and Kalitzin V2F湍流模型</td>
</tr>
</tbody>
</table>
<div class="literal-block-wrapper docutils container" id="id72">
<div class="code-block-caption"><span class="caption-text">src/MomentumTranportModels/momentumTransportModels/eddyViscosity/eddyViscosity.C</span><a class="headerlink" href="#id72" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicMomentumTransportModel</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">eddyViscosity</span><span class="o">&lt;</span><span class="n">BasicMomentumTransportModel</span><span class="o">&gt;::</span><span class="n">eddyViscosity</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">word</span><span class="o">&amp;</span> <span class="n">type</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">alphaField</span><span class="o">&amp;</span> <span class="n">alpha</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">rhoField</span><span class="o">&amp;</span> <span class="n">rho</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">volVectorField</span><span class="o">&amp;</span> <span class="n">U</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">alphaRhoPhi</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">phi</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">viscosity</span><span class="o">&amp;</span> <span class="n">viscosity</span>
<span class="p">)</span>
<span class="o">:</span>
    <span class="n">linearViscousStress</span><span class="o">&lt;</span><span class="n">BasicMomentumTransportModel</span><span class="o">&gt;</span>    <span class="c1">// 继承于linearViscousStress模型</span>
    <span class="p">(</span>
        <span class="n">type</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">,</span>
        <span class="n">rho</span><span class="p">,</span>
        <span class="n">U</span><span class="p">,</span>
        <span class="n">alphaRhoPhi</span><span class="p">,</span>
        <span class="n">phi</span><span class="p">,</span>
        <span class="n">viscosity</span>
    <span class="p">),</span>

    <span class="n">nut_</span>
    <span class="p">(</span>
        <span class="n">IOobject</span>
        <span class="p">(</span>
            <span class="n">IOobject</span><span class="o">::</span><span class="n">groupName</span><span class="p">(</span><span class="s">&quot;nut&quot;</span><span class="p">,</span> <span class="n">alphaRhoPhi</span><span class="p">.</span><span class="n">group</span><span class="p">()),</span>
            <span class="n">this</span><span class="o">-&gt;</span><span class="n">runTime_</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>
            <span class="n">this</span><span class="o">-&gt;</span><span class="n">mesh_</span><span class="p">,</span>
            <span class="n">IOobject</span><span class="o">::</span><span class="n">MUST_READ</span><span class="p">,</span>
            <span class="n">IOobject</span><span class="o">::</span><span class="n">AUTO_WRITE</span>
        <span class="p">),</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">mesh_</span>
    <span class="p">)</span>
<span class="p">{}</span>

<span class="c1">// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicMomentumTransportModel</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">Foam</span><span class="o">::</span><span class="n">eddyViscosity</span><span class="o">&lt;</span><span class="n">BasicMomentumTransportModel</span><span class="o">&gt;::</span><span class="n">read</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">BasicMomentumTransportModel</span><span class="o">::</span><span class="n">read</span><span class="p">();</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicMomentumTransportModel</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">volSymmTensorField</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">eddyViscosity</span><span class="o">&lt;</span><span class="n">BasicMomentumTransportModel</span><span class="o">&gt;::</span><span class="n">sigma</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">tk</span><span class="p">(</span><span class="n">k</span><span class="p">());</span>

    <span class="c1">// Get list of patchField type names from k</span>
    <span class="n">wordList</span> <span class="nf">patchFieldTypes</span><span class="p">(</span><span class="n">tk</span><span class="p">().</span><span class="n">boundaryField</span><span class="p">().</span><span class="n">types</span><span class="p">());</span>

    <span class="c1">// For k patchField types which do not have an equivalent for symmTensor set to calculated</span>
    <span class="n">forAll</span><span class="p">(</span><span class="n">patchFieldTypes</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span>
        <span class="p">(</span>
           <span class="o">!</span><span class="n">fvPatchField</span><span class="o">&lt;</span><span class="n">symmTensor</span><span class="o">&gt;::</span><span class="n">patchConstructorTablePtr_</span> <span class="o">-&gt;</span><span class="n">found</span><span class="p">(</span><span class="n">patchFieldTypes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">patchFieldTypes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">calculatedFvPatchField</span><span class="o">&lt;</span><span class="n">symmTensor</span><span class="o">&gt;::</span><span class="n">typeName</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">volSymmTensorField</span><span class="o">::</span><span class="n">New</span>
    <span class="p">(</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">groupName</span><span class="p">(</span><span class="s">&quot;R&quot;</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">alphaRhoPhi_</span><span class="p">.</span><span class="n">group</span><span class="p">()),</span>
        <span class="p">((</span><span class="mf">2.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">*</span><span class="n">tk</span><span class="p">()</span> <span class="o">-</span> <span class="p">(</span><span class="n">nut_</span><span class="p">)</span><span class="o">*</span><span class="n">dev</span><span class="p">(</span><span class="n">twoSymm</span><span class="p">(</span><span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">U_</span><span class="p">))),</span>
        <span class="n">patchFieldTypes</span>
    <span class="p">);</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicMomentumTransportModel</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">eddyViscosity</span><span class="o">&lt;</span><span class="n">BasicMomentumTransportModel</span><span class="o">&gt;::</span><span class="n">validate</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">correctNut</span><span class="p">();</span>
<span class="p">}</span>


<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicMomentumTransportModel</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">eddyViscosity</span><span class="o">&lt;</span><span class="n">BasicMomentumTransportModel</span><span class="o">&gt;::</span><span class="n">correct</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">BasicMomentumTransportModel</span><span class="o">::</span><span class="n">correct</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="kepsilon">
<h4>kEpsilon<a class="headerlink" href="#kepsilon" title="永久链接至标题">¶</a></h4>
<p>OpenFOAM中的kEpsilon模型为Launder和Spalding提出的标准kEpsilon湍流模型，所求解的 <span class="math notranslate nohighlight">\(\varepsilon\)</span> 方程为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\partial (\alpha \rho\varepsilon_{n+1} )}{\partial t}
+ \nabla \cdot (\alpha \rho\mathbf{U}\varepsilon_{n+1} )
- \nabla \cdot (\alpha \rho D_{\varepsilon }\nabla\varepsilon_{n+1} )
= C_{1}\alpha \rho G \frac{\varepsilon}{k}
- (\frac{2}{3}C_{1} - C_{3})\alpha \rho (\nabla \cdot \mathbf{U})\varepsilon_{n+1}
- C_{2}\alpha \rho \frac{\varepsilon_{n}}{k}\varepsilon_{n+1}
+ S_{\varepsilon }
\end{align}\]</div>
<p>对应的代码为</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">fvScalarMatrix</span><span class="o">&gt;</span> <span class="n">epsEqn</span>    <span class="c1">// 湍流耗散率方程</span>
<span class="p">(</span>
    <span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">epsilon_</span><span class="p">)</span>                                   <span class="c1">// 非稳态项</span>
  <span class="o">+</span> <span class="n">fvm</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">alphaRhoPhi</span><span class="p">,</span> <span class="n">epsilon_</span><span class="p">)</span>                                  <span class="c1">// 对流项</span>
  <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="n">DepsilonEff</span><span class="p">(),</span> <span class="n">epsilon_</span><span class="p">)</span>                <span class="c1">// 扩散项</span>
 <span class="o">==</span>
    <span class="n">C1_</span><span class="o">*</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">G</span><span class="o">*</span><span class="n">epsilon_</span><span class="p">()</span><span class="o">/</span><span class="n">k_</span><span class="p">()</span>                              <span class="c1">// 生成项</span>
  <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">SuSp</span><span class="p">(((</span><span class="mf">2.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span><span class="o">*</span><span class="n">C1_</span> <span class="o">-</span> <span class="n">C3_</span><span class="p">)</span><span class="o">*</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">divU</span><span class="p">,</span> <span class="n">epsilon_</span><span class="p">)</span>    <span class="c1">// 连续性误差修正项</span>
  <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">Sp</span><span class="p">(</span><span class="n">C2_</span><span class="o">*</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">epsilon_</span><span class="p">()</span><span class="o">/</span><span class="n">k_</span><span class="p">(),</span> <span class="n">epsilon_</span><span class="p">)</span>             <span class="c1">// 耗散项</span>
  <span class="o">+</span> <span class="n">epsilonSource</span><span class="p">()</span>                                                  <span class="c1">// 自定义源项</span>
  <span class="o">+</span> <span class="n">fvModels</span><span class="p">.</span><span class="n">source</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">epsilon_</span><span class="p">)</span>                            <span class="c1">// fvOption添加的源项</span>
<span class="p">);</span>
</pre></div>
</div>
<p>所求解的 <span class="math notranslate nohighlight">\(k\)</span> 方程为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\partial (\alpha \rho k_{n+1})}{\partial t}
+ \nabla \cdot (\alpha \rho\mathbf{U}k_{n+1})
- \nabla\cdot (\alpha \rho D_{k}\nabla k_{n+1})
= \alpha \rho G
- \frac{2}{3}\alpha \rho (\nabla \cdot \mathbf{U})k_{n+1}
- \alpha \rho \frac{\varepsilon}{k_{n}}k_{n+1}
+ S_{k}
\end{align}\]</div>
<p>对应的代码为</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">fvScalarMatrix</span><span class="o">&gt;</span> <span class="n">kEqn</span>    <span class="c1">// 湍流动能方程</span>
<span class="p">(</span>
    <span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">k_</span><span class="p">)</span>                       <span class="c1">// 湍流动能当地变化率，非稳态项</span>
  <span class="o">+</span> <span class="n">fvm</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">alphaRhoPhi</span><span class="p">,</span> <span class="n">k_</span><span class="p">)</span>                      <span class="c1">// 湍流动能迁移变化率，对流项</span>
  <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="n">DkEff</span><span class="p">(),</span> <span class="n">k_</span><span class="p">)</span>          <span class="c1">// 湍流扩散项</span>
 <span class="o">==</span>
    <span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">G</span>                                <span class="c1">// 湍流生成项</span>
  <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">SuSp</span><span class="p">((</span><span class="mf">2.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span><span class="o">*</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">divU</span><span class="p">,</span> <span class="n">k_</span><span class="p">)</span>    <span class="c1">// 连续性误差修正项</span>
  <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">Sp</span><span class="p">(</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">epsilon_</span><span class="p">()</span><span class="o">/</span><span class="n">k_</span><span class="p">(),</span> <span class="n">k_</span><span class="p">)</span>     <span class="c1">// 黏性耗散项</span>
  <span class="o">+</span> <span class="n">kSource</span><span class="p">()</span>                                      <span class="c1">// 自定义源项</span>
  <span class="o">+</span> <span class="n">fvModels</span><span class="p">.</span><span class="n">source</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">k_</span><span class="p">)</span>                <span class="c1">// fvOption源项</span>
<span class="p">);</span>
</pre></div>
</div>
<p>其中 <span class="math notranslate nohighlight">\(\alpha\)</span> 为质量分数，用于多相流的情况。另外有</p>
<div class="math notranslate nohighlight">
\[\begin{align}
G = \nu_{t} \Big( \nabla\mathbf{U} + (\nabla\mathbf{U})^{T} - \frac{2}{3}(\nabla\cdot\mathbf{U})\mathbf{I} \Big) : \nabla\mathbf{U}
\end{align}\]</div>
<p>对应的代码为</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">volTensorField</span><span class="o">&gt;</span> <span class="n">tgradU</span> <span class="o">=</span> <span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">U</span><span class="p">);</span>    <span class="c1">// 显式计算速度梯度张量</span>
<span class="n">volScalarField</span><span class="o">::</span><span class="n">Internal</span> <span class="n">G</span>    <span class="c1">// 湍流产生项G</span>
<span class="p">(</span>
    <span class="n">this</span><span class="o">-&gt;</span><span class="n">GName</span><span class="p">(),</span>
    <span class="n">nut</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="n">dev</span><span class="p">(</span><span class="n">twoSymm</span><span class="p">(</span><span class="n">tgradU</span><span class="p">().</span><span class="n">v</span><span class="p">()))</span> <span class="o">&amp;&amp;</span> <span class="n">tgradU</span><span class="p">().</span><span class="n">v</span><span class="p">())</span>
<span class="p">);</span>
<span class="n">tgradU</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</pre></div>
</div>
<div class="math notranslate nohighlight">
\[\begin{align}
\nu_{t} = C_{\mu}\frac{k^{2}}{\varepsilon}
\end{align}\]</div>
<p>对应的代码为</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicMomentumTransportModel</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">kEpsilon</span><span class="o">&lt;</span><span class="n">BasicMomentumTransportModel</span><span class="o">&gt;::</span><span class="n">correctNut</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">this</span><span class="o">-&gt;</span><span class="n">nut_</span> <span class="o">=</span> <span class="n">Cmu_</span><span class="o">*</span><span class="n">sqr</span><span class="p">(</span><span class="n">k_</span><span class="p">)</span><span class="o">/</span><span class="n">epsilon_</span><span class="p">;</span>    <span class="c1">// 通过nut的定义式计算nut更新值</span>
    <span class="n">this</span><span class="o">-&gt;</span><span class="n">nut_</span><span class="p">.</span><span class="n">correctBoundaryConditions</span><span class="p">();</span>
    <span class="n">fvConstraints</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">mesh_</span><span class="p">).</span><span class="n">constrain</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">nut_</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="math notranslate nohighlight">
\[\begin{align}
D_{k} = \frac{\nu_{t}}{\sigma_{k}} + \nu
\end{align}\]</div>
<p>对应的代码为</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">DkEff</span><span class="p">()</span> <span class="k">const</span>    <span class="c1">// 湍流动能的有效扩散系数</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">volScalarField</span><span class="o">::</span><span class="n">New</span>
    <span class="p">(</span>
        <span class="s">&quot;DkEff&quot;</span><span class="p">,</span>
        <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">nut_</span><span class="o">/</span><span class="n">sigmak_</span> <span class="o">+</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">nu</span><span class="p">())</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="math notranslate nohighlight">
\[\begin{align}
D_{\varepsilon } = \frac{\nu_{t}}{\sigma_{\varepsilon }} + \nu
\end{align}\]</div>
<p>对应的代码为</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">DepsilonEff</span><span class="p">()</span> <span class="k">const</span>    <span class="c1">// 湍流耗散率的有效扩散系数</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">volScalarField</span><span class="o">::</span><span class="n">New</span>
    <span class="p">(</span>
        <span class="s">&quot;DepsilonEff&quot;</span><span class="p">,</span>
        <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">nut_</span><span class="o">/</span><span class="n">sigmaEps_</span> <span class="o">+</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">nu</span><span class="p">())</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>各系数的默认取值如下：</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="18%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><span class="math notranslate nohighlight">\(C_{\mu}\)</span></th>
<th class="head"><span class="math notranslate nohighlight">\(C_{1}\)</span></th>
<th class="head"><span class="math notranslate nohighlight">\(C_{2}\)</span></th>
<th class="head"><span class="math notranslate nohighlight">\(C_{3}\)</span></th>
<th class="head"><span class="math notranslate nohighlight">\(\sigma_{k}\)</span></th>
<th class="head"><span class="math notranslate nohighlight">\(\sigma_{\varepsilon}\)</span></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0.09</td>
<td>1.44</td>
<td>1.92</td>
<td>0</td>
<td>1</td>
<td>1.3</td>
</tr>
</tbody>
</table>
<p>进入src/MomentumTransportModels/momentumTransportModels/RAS/kEpsilon/kEpsilon.C文件，可以看到完整的求解策略：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicMomentumTransportModel</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">kEpsilon</span><span class="o">&lt;</span><span class="n">BasicMomentumTransportModel</span><span class="o">&gt;::</span><span class="n">correct</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">turbulence_</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Local references</span>
    <span class="k">const</span> <span class="n">alphaField</span><span class="o">&amp;</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">alpha_</span><span class="p">;</span>    <span class="c1">// 质量分数</span>
    <span class="k">const</span> <span class="n">rhoField</span><span class="o">&amp;</span> <span class="n">rho</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">rho_</span><span class="p">;</span>    <span class="c1">// 密度</span>
    <span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">alphaRhoPhi</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">alphaRhoPhi_</span><span class="p">;</span>    <span class="c1">// 质量分数乘以密度后插值到面上的面通量</span>
    <span class="k">const</span> <span class="n">volVectorField</span><span class="o">&amp;</span> <span class="n">U</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">U_</span><span class="p">;</span>    <span class="c1">// 速度</span>
    <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">nut</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">nut_</span><span class="p">;</span>    <span class="c1">// 湍流粘度</span>
    <span class="k">const</span> <span class="n">Foam</span><span class="o">::</span><span class="n">fvModels</span><span class="o">&amp;</span> <span class="n">fvModels</span><span class="p">(</span><span class="n">Foam</span><span class="o">::</span><span class="n">fvModels</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">mesh_</span><span class="p">));</span>
    <span class="k">const</span> <span class="n">Foam</span><span class="o">::</span><span class="n">fvConstraints</span><span class="o">&amp;</span> <span class="n">fvConstraints</span>
    <span class="p">(</span>
        <span class="n">Foam</span><span class="o">::</span><span class="n">fvConstraints</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">mesh_</span><span class="p">)</span>
    <span class="p">);</span>

    <span class="n">eddyViscosity</span><span class="o">&lt;</span><span class="n">RASModel</span><span class="o">&lt;</span><span class="n">BasicMomentumTransportModel</span><span class="o">&gt;&gt;::</span><span class="n">correct</span><span class="p">();</span>

    <span class="n">volScalarField</span><span class="o">::</span><span class="n">Internal</span> <span class="n">divU</span>    <span class="c1">// 速度场的散度</span>
    <span class="p">(</span>
        <span class="cm">/* 通过显式离散计算出速度散度的具体值。</span>
<span class="cm">           这里的fvc::absolute只在动网格的情况发挥作用，</span>
<span class="cm">           其定义可以查看fvcMeshPhi.C中的Foam::fvc::absolute</span>
<span class="cm">        */</span>
        <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">fvc</span><span class="o">::</span><span class="n">absolute</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">phi</span><span class="p">(),</span> <span class="n">U</span><span class="p">))()</span>
    <span class="p">);</span>

    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volTensorField</span><span class="o">&gt;</span> <span class="n">tgradU</span> <span class="o">=</span> <span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">U</span><span class="p">);</span>    <span class="c1">// 显式计算速度梯度张量</span>
    <span class="n">volScalarField</span><span class="o">::</span><span class="n">Internal</span> <span class="n">G</span>    <span class="c1">// 湍流产生项G</span>
    <span class="p">(</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">GName</span><span class="p">(),</span>
        <span class="n">nut</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="n">dev</span><span class="p">(</span><span class="n">twoSymm</span><span class="p">(</span><span class="n">tgradU</span><span class="p">().</span><span class="n">v</span><span class="p">()))</span> <span class="o">&amp;&amp;</span> <span class="n">tgradU</span><span class="p">().</span><span class="n">v</span><span class="p">())</span>
    <span class="p">);</span>
    <span class="n">tgradU</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>

    <span class="c1">// Update epsilon and G at the wall</span>
    <span class="n">epsilon_</span><span class="p">.</span><span class="n">boundaryFieldRef</span><span class="p">().</span><span class="n">updateCoeffs</span><span class="p">();</span>

    <span class="c1">// Dissipation equation</span>
    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">fvScalarMatrix</span><span class="o">&gt;</span> <span class="n">epsEqn</span>    <span class="c1">// 湍流耗散率方程</span>
    <span class="p">(</span>
        <span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">epsilon_</span><span class="p">)</span>                                   <span class="c1">// 非稳态项</span>
      <span class="o">+</span> <span class="n">fvm</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">alphaRhoPhi</span><span class="p">,</span> <span class="n">epsilon_</span><span class="p">)</span>                                  <span class="c1">// 对流项</span>
      <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="n">DepsilonEff</span><span class="p">(),</span> <span class="n">epsilon_</span><span class="p">)</span>                <span class="c1">// 扩散项</span>
     <span class="o">==</span>
        <span class="n">C1_</span><span class="o">*</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">G</span><span class="o">*</span><span class="n">epsilon_</span><span class="p">()</span><span class="o">/</span><span class="n">k_</span><span class="p">()</span>                              <span class="c1">// 生成项</span>
      <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">SuSp</span><span class="p">(((</span><span class="mf">2.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span><span class="o">*</span><span class="n">C1_</span> <span class="o">-</span> <span class="n">C3_</span><span class="p">)</span><span class="o">*</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">divU</span><span class="p">,</span> <span class="n">epsilon_</span><span class="p">)</span>    <span class="c1">// 连续性误差修正项</span>
      <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">Sp</span><span class="p">(</span><span class="n">C2_</span><span class="o">*</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">epsilon_</span><span class="p">()</span><span class="o">/</span><span class="n">k_</span><span class="p">(),</span> <span class="n">epsilon_</span><span class="p">)</span>             <span class="c1">// 耗散项</span>
      <span class="o">+</span> <span class="n">epsilonSource</span><span class="p">()</span>                                                  <span class="c1">// 自定义源项</span>
      <span class="o">+</span> <span class="n">fvModels</span><span class="p">.</span><span class="n">source</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">epsilon_</span><span class="p">)</span>                            <span class="c1">// fvOption添加的源项</span>
    <span class="p">);</span>

    <span class="n">epsEqn</span><span class="p">.</span><span class="n">ref</span><span class="p">().</span><span class="n">relax</span><span class="p">();</span>
    <span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">epsEqn</span><span class="p">.</span><span class="n">ref</span><span class="p">());</span>
    <span class="n">epsEqn</span><span class="p">.</span><span class="n">ref</span><span class="p">().</span><span class="n">boundaryManipulate</span><span class="p">(</span><span class="n">epsilon_</span><span class="p">.</span><span class="n">boundaryFieldRef</span><span class="p">());</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">epsEqn</span><span class="p">);</span>    <span class="c1">// 求解湍流耗散率方程</span>
    <span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">epsilon_</span><span class="p">);</span>
    <span class="n">bound</span><span class="p">(</span><span class="n">epsilon_</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">epsilonMin_</span><span class="p">);</span>

    <span class="c1">// Turbulent kinetic energy equation</span>
    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">fvScalarMatrix</span><span class="o">&gt;</span> <span class="n">kEqn</span>    <span class="c1">// 湍流动能方程</span>
    <span class="p">(</span>
        <span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">k_</span><span class="p">)</span>                       <span class="c1">// 湍流动能当地变化率，非稳态项</span>
      <span class="o">+</span> <span class="n">fvm</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">alphaRhoPhi</span><span class="p">,</span> <span class="n">k_</span><span class="p">)</span>                      <span class="c1">// 湍流动能迁移变化率，对流项</span>
      <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="n">DkEff</span><span class="p">(),</span> <span class="n">k_</span><span class="p">)</span>          <span class="c1">// 湍流扩散项</span>
     <span class="o">==</span>
        <span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">G</span>                                <span class="c1">// 湍流生成项</span>
      <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">SuSp</span><span class="p">((</span><span class="mf">2.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span><span class="o">*</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">divU</span><span class="p">,</span> <span class="n">k_</span><span class="p">)</span>    <span class="c1">// 连续性误差修正项</span>
      <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">Sp</span><span class="p">(</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">epsilon_</span><span class="p">()</span><span class="o">/</span><span class="n">k_</span><span class="p">(),</span> <span class="n">k_</span><span class="p">)</span>     <span class="c1">// 黏性耗散项</span>
      <span class="o">+</span> <span class="n">kSource</span><span class="p">()</span>                                      <span class="c1">// 自定义源项</span>
      <span class="o">+</span> <span class="n">fvModels</span><span class="p">.</span><span class="n">source</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">k_</span><span class="p">)</span>                <span class="c1">// fvOption源项</span>
    <span class="p">);</span>

    <span class="n">kEqn</span><span class="p">.</span><span class="n">ref</span><span class="p">().</span><span class="n">relax</span><span class="p">();</span>
    <span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">kEqn</span><span class="p">.</span><span class="n">ref</span><span class="p">());</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">kEqn</span><span class="p">);</span>    <span class="c1">// 求解湍流动能方程</span>
    <span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">k_</span><span class="p">);</span>
    <span class="n">bound</span><span class="p">(</span><span class="n">k_</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">kMin_</span><span class="p">);</span>

    <span class="n">correctNut</span><span class="p">();</span>    <span class="c1">// 更新湍流粘度nut</span>
<span class="p">}</span>
</pre></div>
</div>
<p>使用该模型时需要在system/momentumTransport文件中写入下面内容：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">simulationType</span> <span class="n">RAS</span><span class="p">;</span>
<span class="n">RAS</span>
<span class="p">{</span>
    <span class="n">RASModel</span>            <span class="n">kEpsilon</span><span class="p">;</span>
    <span class="n">turbulence</span>          <span class="n">on</span><span class="p">;</span>
    <span class="n">printCoeffs</span>         <span class="n">on</span><span class="p">;</span>

    <span class="n">kEpsilonCoeffs</span>
    <span class="p">{</span>
        <span class="n">Cmu</span>        <span class="mf">0.09</span><span class="p">;</span>
        <span class="n">C1</span>         <span class="mf">1.44</span><span class="p">;</span>
        <span class="n">C2</span>         <span class="mf">1.92</span><span class="p">;</span>
        <span class="n">C3</span>         <span class="mi">0</span><span class="p">;</span>
        <span class="n">sigmak</span>     <span class="mf">1.0</span><span class="p">;</span>
        <span class="n">sigmaEps</span>   <span class="mf">1.3</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>场文件中需要额外添加nut、k、epsilon、alphat，并设置相应的初始条件和边界条件。</p>
<p>fvSchemes中需要额外添加：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>ddtSchemes
{
    turbulence          Euler;
    ddt(rho,epsilon)    $turbulence;
    ddt(epsilon)        $turbulence;
    ddt(rho,k)          $turbulence;
}

gradSchemes
{
    turbulence       Gauss linear;
    grad(epsilon)    $turbulence;
    grad(k)          $turbulence;
}

divSchemes
{
    turbulence          Gauss upwind;
    div(phi,epsilon)    $turbulence;
    div(phi,k)          $turbulence;
}

laplacianSchemes
{
    turbulence              Gauss linear limited corrected 0.5;
    laplacian(alphaEff,e)                   $turbulence;
    laplacian((rho*DepsilonEff),epsilon)    $turbulence;
    laplacian((rho*DkEff),k)                $turbulence;
}

interpolationSchemes
{
    turbulence                  linear;
    interpolate(rho)            $turbulence;
}
</pre></div>
</div>
<p>fvSolution中需要额外添加：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">solvers</span>
<span class="p">{</span>
    <span class="s">&quot;(epsilon|k)&quot;</span>
    <span class="p">{</span>
        <span class="n">solver</span>          <span class="n">smoothSolver</span><span class="p">;</span>
        <span class="n">smoother</span>        <span class="n">GaussSeidel</span><span class="p">;</span>
        <span class="n">nSweeps</span>         <span class="mi">2</span><span class="p">;</span>
        <span class="n">tolerance</span>       <span class="mf">1e-09</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="komega">
<h4>kOmega<a class="headerlink" href="#komega" title="永久链接至标题">¶</a></h4>
<p>OpenFOAM中的kOmega模型为Wilcox-1988版，不过使用的系数存在部分区别。所求解的湍流比耗散率方程为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\partial (\alpha \rho\omega)}{\partial t}
+ \nabla \cdot (\alpha \rho\mathbf{U}\omega)
- \nabla \cdot (\alpha \rho D_{\omega}\nabla\omega)
= \alpha \rho G \frac{\gamma \omega}{k}
- \frac{2}{3}\gamma \alpha \rho (\nabla \cdot \mathbf{U}) \omega
- \beta \alpha \rho \omega^{2}
+ S_{\omega}
\end{align}\]</div>
<p>对应的代码为</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">fvScalarMatrix</span><span class="o">&gt;</span> <span class="n">omegaEqn</span>
<span class="p">(</span>
    <span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">omega_</span><span class="p">)</span>
  <span class="o">+</span> <span class="n">fvm</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">alphaRhoPhi</span><span class="p">,</span> <span class="n">omega_</span><span class="p">)</span>
  <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="n">DomegaEff</span><span class="p">(),</span> <span class="n">omega_</span><span class="p">)</span>
 <span class="o">==</span>
    <span class="n">gamma_</span><span class="o">*</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">G</span><span class="o">*</span><span class="n">omega_</span><span class="p">()</span><span class="o">/</span><span class="n">k_</span><span class="p">()</span>
  <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">SuSp</span><span class="p">(((</span><span class="mf">2.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span><span class="o">*</span><span class="n">gamma_</span><span class="p">)</span><span class="o">*</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">divU</span><span class="p">,</span> <span class="n">omega_</span><span class="p">)</span>
  <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">Sp</span><span class="p">(</span><span class="n">beta_</span><span class="o">*</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">omega_</span><span class="p">(),</span> <span class="n">omega_</span><span class="p">)</span>
  <span class="o">+</span> <span class="n">omegaSource</span><span class="p">()</span>
  <span class="o">+</span> <span class="n">fvModels</span><span class="p">.</span><span class="n">source</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">omega_</span><span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<p>所求解的湍流动能方程为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\partial (\alpha \rho k)}{\partial t}
+ \nabla \cdot (\alpha \rho\mathbf{U}k)
- \nabla \cdot (\alpha \rho D_{k}\nabla k)
= \alpha \rho G
- \frac{2}{3}\alpha \rho (\nabla \cdot \mathbf{U})k
- C_{\mu}\alpha \rho \omega k
+ S_{k}
\end{align}\]</div>
<p>对应的代码为</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">fvScalarMatrix</span><span class="o">&gt;</span> <span class="n">kEqn</span>
<span class="p">(</span>
    <span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">k_</span><span class="p">)</span>
  <span class="o">+</span> <span class="n">fvm</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">alphaRhoPhi</span><span class="p">,</span> <span class="n">k_</span><span class="p">)</span>
  <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="n">DkEff</span><span class="p">(),</span> <span class="n">k_</span><span class="p">)</span>
 <span class="o">==</span>
    <span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">G</span>
  <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">SuSp</span><span class="p">((</span><span class="mf">2.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span><span class="o">*</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">divU</span><span class="p">,</span> <span class="n">k_</span><span class="p">)</span>
  <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">Sp</span><span class="p">(</span><span class="n">betaStar_</span><span class="o">*</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">omega_</span><span class="p">(),</span> <span class="n">k_</span><span class="p">)</span>
  <span class="o">+</span> <span class="n">kSource</span><span class="p">()</span>
  <span class="o">+</span> <span class="n">fvModels</span><span class="p">.</span><span class="n">source</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">k_</span><span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<p>其中 <span class="math notranslate nohighlight">\(\alpha\)</span> 为质量分数，用于多相流的情况。另外有</p>
<div class="math notranslate nohighlight">
\[\begin{align}
G = \nu_{t} \Big( \nabla\mathbf{U} + (\nabla\mathbf{U})^{T} - \frac{2}{3}(\nabla\cdot\mathbf{U})\mathbf{I} \Big) : \nabla\mathbf{U}
\end{align}\]</div>
<p>对应的代码为</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">volTensorField</span><span class="o">&gt;</span> <span class="n">tgradU</span> <span class="o">=</span> <span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">U</span><span class="p">);</span>
<span class="n">volScalarField</span><span class="o">::</span><span class="n">Internal</span> <span class="n">G</span>
<span class="p">(</span>
    <span class="n">this</span><span class="o">-&gt;</span><span class="n">GName</span><span class="p">(),</span>
    <span class="n">nut</span><span class="p">.</span><span class="n">v</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="n">dev</span><span class="p">(</span><span class="n">twoSymm</span><span class="p">(</span><span class="n">tgradU</span><span class="p">().</span><span class="n">v</span><span class="p">()))</span> <span class="o">&amp;&amp;</span> <span class="n">tgradU</span><span class="p">().</span><span class="n">v</span><span class="p">())</span>
<span class="p">);</span>
<span class="n">tgradU</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</pre></div>
</div>
<div class="math notranslate nohighlight">
\[\begin{align}
\nu_{t} = \frac{k}{\omega}
\end{align}\]</div>
<p>对应的代码为</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicMomentumTransportModel</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">kOmega</span><span class="o">&lt;</span><span class="n">BasicMomentumTransportModel</span><span class="o">&gt;::</span><span class="n">correctNut</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">this</span><span class="o">-&gt;</span><span class="n">nut_</span> <span class="o">=</span> <span class="n">k_</span><span class="o">/</span><span class="n">omega_</span><span class="p">;</span>
    <span class="n">this</span><span class="o">-&gt;</span><span class="n">nut_</span><span class="p">.</span><span class="n">correctBoundaryConditions</span><span class="p">();</span>
    <span class="n">fvConstraints</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">mesh_</span><span class="p">).</span><span class="n">constrain</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">nut_</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="math notranslate nohighlight">
\[\begin{align}
D_{k} = \alpha _{k}\nu_{t} + \nu
\end{align}\]</div>
<p>对应的代码为</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">DkEff</span><span class="p">()</span> <span class="k">const</span>    <span class="c1">// 湍流动能的有效扩散系数</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">volScalarField</span><span class="o">::</span><span class="n">New</span>
    <span class="p">(</span>
        <span class="s">&quot;DkEff&quot;</span><span class="p">,</span>
        <span class="n">alphaK_</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">nut_</span> <span class="o">+</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">nu</span><span class="p">()</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="math notranslate nohighlight">
\[\begin{align}
D_{\omega} = \alpha_{\omega}\nu_{t} + \nu
\end{align}\]</div>
<p>对应的代码为</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">DomegaEff</span><span class="p">()</span> <span class="k">const</span>    <span class="c1">// 湍流比耗散率的有效扩散系数</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">volScalarField</span><span class="o">::</span><span class="n">New</span>
    <span class="p">(</span>
        <span class="s">&quot;DomegaEff&quot;</span><span class="p">,</span>
        <span class="n">alphaOmega_</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">nut_</span> <span class="o">+</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">nu</span><span class="p">()</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>各系数的默认取值如下：</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="16%" />
<col width="22%" />
<col width="27%" />
<col width="17%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><span class="math notranslate nohighlight">\(C_{\mu}\)</span></th>
<th class="head"><span class="math notranslate nohighlight">\(\beta\)</span></th>
<th class="head"><span class="math notranslate nohighlight">\(\alpha_{k}\)</span></th>
<th class="head"><span class="math notranslate nohighlight">\(\alpha_{\omega}\)</span></th>
<th class="head"><span class="math notranslate nohighlight">\(\gamma\)</span></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0.09</td>
<td>0.072</td>
<td>0.5</td>
<td>0.5</td>
<td>0.52</td>
</tr>
</tbody>
</table>
<p>进入src/MomentumTransportModels/momentumTransportModels/RAS/kOmega/kOmega.C文件，可以看到完整的方程求解策略：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">BasicMomentumTransportModel</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">kOmega</span><span class="o">&lt;</span><span class="n">BasicMomentumTransportModel</span><span class="o">&gt;::</span><span class="n">correct</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">turbulence_</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Local references</span>
    <span class="k">const</span> <span class="n">alphaField</span><span class="o">&amp;</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">alpha_</span><span class="p">;</span>    <span class="c1">// 质量分数</span>
    <span class="k">const</span> <span class="n">rhoField</span><span class="o">&amp;</span> <span class="n">rho</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">rho_</span><span class="p">;</span>          <span class="c1">// 密度</span>
    <span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">alphaRhoPhi</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">alphaRhoPhi_</span><span class="p">;</span>    <span class="c1">// 质量分数乘以密度插值到面上的通量</span>
    <span class="k">const</span> <span class="n">volVectorField</span><span class="o">&amp;</span> <span class="n">U</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">U_</span><span class="p">;</span>    <span class="c1">// 速度场</span>
    <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">nut</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">nut_</span><span class="p">;</span>      <span class="c1">// 湍流粘度</span>
    <span class="k">const</span> <span class="n">Foam</span><span class="o">::</span><span class="n">fvModels</span><span class="o">&amp;</span> <span class="n">fvModels</span><span class="p">(</span><span class="n">Foam</span><span class="o">::</span><span class="n">fvModels</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">mesh_</span><span class="p">));</span>
    <span class="k">const</span> <span class="n">Foam</span><span class="o">::</span><span class="n">fvConstraints</span><span class="o">&amp;</span> <span class="n">fvConstraints</span>
    <span class="p">(</span>
        <span class="n">Foam</span><span class="o">::</span><span class="n">fvConstraints</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">mesh_</span><span class="p">)</span>
    <span class="p">);</span>

    <span class="n">eddyViscosity</span><span class="o">&lt;</span><span class="n">RASModel</span><span class="o">&lt;</span><span class="n">BasicMomentumTransportModel</span><span class="o">&gt;&gt;::</span><span class="n">correct</span><span class="p">();</span>

    <span class="n">volScalarField</span><span class="o">::</span><span class="n">Internal</span> <span class="n">divU</span>    <span class="c1">// 速度场的散度</span>
    <span class="p">(</span>
        <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">fvc</span><span class="o">::</span><span class="n">absolute</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">phi</span><span class="p">(),</span> <span class="n">U</span><span class="p">))().</span><span class="n">v</span><span class="p">()</span>    <span class="c1">// 显式计算散度</span>
    <span class="p">);</span>

    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volTensorField</span><span class="o">&gt;</span> <span class="n">tgradU</span> <span class="o">=</span> <span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">U</span><span class="p">);</span>    <span class="c1">// 速度梯度张量</span>
    <span class="n">volScalarField</span><span class="o">::</span><span class="n">Internal</span> <span class="n">G</span>    <span class="c1">// 湍流产生项</span>
    <span class="p">(</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">GName</span><span class="p">(),</span>
        <span class="n">nut</span><span class="p">.</span><span class="n">v</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="n">dev</span><span class="p">(</span><span class="n">twoSymm</span><span class="p">(</span><span class="n">tgradU</span><span class="p">().</span><span class="n">v</span><span class="p">()))</span> <span class="o">&amp;&amp;</span> <span class="n">tgradU</span><span class="p">().</span><span class="n">v</span><span class="p">())</span>
    <span class="p">);</span>
    <span class="n">tgradU</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>

    <span class="c1">// Update omega and G at the wall</span>
    <span class="n">omega_</span><span class="p">.</span><span class="n">boundaryFieldRef</span><span class="p">().</span><span class="n">updateCoeffs</span><span class="p">();</span>

    <span class="c1">// Turbulence specific dissipation rate equation</span>
    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">fvScalarMatrix</span><span class="o">&gt;</span> <span class="n">omegaEqn</span>    <span class="c1">// 湍流比耗散率方程</span>
    <span class="p">(</span>
        <span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">omega_</span><span class="p">)</span>
      <span class="o">+</span> <span class="n">fvm</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">alphaRhoPhi</span><span class="p">,</span> <span class="n">omega_</span><span class="p">)</span>
      <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="n">DomegaEff</span><span class="p">(),</span> <span class="n">omega_</span><span class="p">)</span>
     <span class="o">==</span>
        <span class="n">gamma_</span><span class="o">*</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">G</span><span class="o">*</span><span class="n">omega_</span><span class="p">()</span><span class="o">/</span><span class="n">k_</span><span class="p">()</span>
      <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">SuSp</span><span class="p">(((</span><span class="mf">2.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span><span class="o">*</span><span class="n">gamma_</span><span class="p">)</span><span class="o">*</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">divU</span><span class="p">,</span> <span class="n">omega_</span><span class="p">)</span>
      <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">Sp</span><span class="p">(</span><span class="n">beta_</span><span class="o">*</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">omega_</span><span class="p">(),</span> <span class="n">omega_</span><span class="p">)</span>
      <span class="o">+</span> <span class="n">omegaSource</span><span class="p">()</span>
      <span class="o">+</span> <span class="n">fvModels</span><span class="p">.</span><span class="n">source</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">omega_</span><span class="p">)</span>
    <span class="p">);</span>

    <span class="n">omegaEqn</span><span class="p">.</span><span class="n">ref</span><span class="p">().</span><span class="n">relax</span><span class="p">();</span>
    <span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">omegaEqn</span><span class="p">.</span><span class="n">ref</span><span class="p">());</span>
    <span class="n">omegaEqn</span><span class="p">.</span><span class="n">ref</span><span class="p">().</span><span class="n">boundaryManipulate</span><span class="p">(</span><span class="n">omega_</span><span class="p">.</span><span class="n">boundaryFieldRef</span><span class="p">());</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">omegaEqn</span><span class="p">);</span>    <span class="c1">// 求解湍流比耗散率方程</span>
    <span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">omega_</span><span class="p">);</span>
    <span class="n">bound</span><span class="p">(</span><span class="n">omega_</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">omegaMin_</span><span class="p">);</span>


    <span class="c1">// Turbulent kinetic energy equation</span>
    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">fvScalarMatrix</span><span class="o">&gt;</span> <span class="n">kEqn</span>    <span class="c1">// 湍流动能方程</span>
    <span class="p">(</span>
        <span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">k_</span><span class="p">)</span>
      <span class="o">+</span> <span class="n">fvm</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">alphaRhoPhi</span><span class="p">,</span> <span class="n">k_</span><span class="p">)</span>
      <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="n">DkEff</span><span class="p">(),</span> <span class="n">k_</span><span class="p">)</span>
     <span class="o">==</span>
        <span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">G</span>
      <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">SuSp</span><span class="p">((</span><span class="mf">2.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span><span class="o">*</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">divU</span><span class="p">,</span> <span class="n">k_</span><span class="p">)</span>
      <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">Sp</span><span class="p">(</span><span class="n">betaStar_</span><span class="o">*</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">omega_</span><span class="p">(),</span> <span class="n">k_</span><span class="p">)</span>
      <span class="o">+</span> <span class="n">kSource</span><span class="p">()</span>
      <span class="o">+</span> <span class="n">fvModels</span><span class="p">.</span><span class="n">source</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">k_</span><span class="p">)</span>
    <span class="p">);</span>

    <span class="n">kEqn</span><span class="p">.</span><span class="n">ref</span><span class="p">().</span><span class="n">relax</span><span class="p">();</span>
    <span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">kEqn</span><span class="p">.</span><span class="n">ref</span><span class="p">());</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">kEqn</span><span class="p">);</span>    <span class="c1">// 求解湍流动能方程</span>
    <span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">k_</span><span class="p">);</span>
    <span class="n">bound</span><span class="p">(</span><span class="n">k_</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">kMin_</span><span class="p">);</span>

    <span class="n">correctNut</span><span class="p">();</span>    <span class="c1">// 更新湍流粘度</span>
<span class="p">}</span>
</pre></div>
</div>
<p>使用该模型时需要在system/momentumTransport文件中写入下面内容：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">simulationType</span> <span class="n">RAS</span><span class="p">;</span>
<span class="n">RAS</span>
<span class="p">{</span>
    <span class="n">RASModel</span>            <span class="n">kOmega</span><span class="p">;</span>
    <span class="n">turbulence</span>          <span class="n">on</span><span class="p">;</span>
    <span class="n">printCoeffs</span>         <span class="n">on</span><span class="p">;</span>

    <span class="n">kOmegaCoeffs</span>
    <span class="p">{</span>
        <span class="n">betaStar</span>      <span class="mf">0.09</span><span class="p">;</span>
        <span class="n">beta</span>          <span class="mf">0.072</span><span class="p">;</span>
        <span class="n">gamma</span>         <span class="mf">0.52</span><span class="p">;</span>
        <span class="n">alphaK</span>        <span class="mf">0.5</span><span class="p">;</span>
        <span class="n">alphaOmega</span>    <span class="mf">0.5</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="komegasst">
<h4>kOmegaSST<a class="headerlink" href="#komegasst" title="永久链接至标题">¶</a></h4>
<p>所求解的湍流动能方程为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\partial (\alpha \rho k)}{\partial t}
+ \nabla \cdot (\alpha \rho \mathbf{U}k)
- \nabla \cdot (\alpha \rho D_{k}\nabla k)
= \alpha \rho P_{k}
- \frac{2}{3}\alpha \rho k(\nabla \cdot \mathbf{U})
- \alpha \rho \beta^{*} \omega k
+ S_{k}
\end{align}\]</div>
<p>对应的代码为</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">fvScalarMatrix</span><span class="o">&gt;</span> <span class="n">kEqn</span>
<span class="p">(</span>
    <span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">k_</span><span class="p">)</span>
  <span class="o">+</span> <span class="n">fvm</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">alphaRhoPhi</span><span class="p">,</span> <span class="n">k_</span><span class="p">)</span>
  <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="n">DkEff</span><span class="p">(</span><span class="n">F1</span><span class="p">),</span> <span class="n">k_</span><span class="p">)</span>
 <span class="o">==</span>
    <span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">Pk</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
  <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">SuSp</span><span class="p">((</span><span class="mf">2.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span><span class="o">*</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">divU</span><span class="p">,</span> <span class="n">k_</span><span class="p">)</span>
  <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">Sp</span><span class="p">(</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">epsilonByk</span><span class="p">(</span><span class="n">F1</span><span class="p">,</span> <span class="n">F23</span><span class="p">),</span> <span class="n">k_</span><span class="p">)</span>
  <span class="o">+</span> <span class="n">kSource</span><span class="p">()</span>
  <span class="o">+</span> <span class="n">fvModels</span><span class="p">.</span><span class="n">source</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">k_</span><span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<p>所求解的湍流比耗散率方程为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; \quad \frac{\partial (\alpha \rho \omega)}{\partial t}
+ \nabla \cdot (\alpha \rho \mathbf{U}\omega)
- \nabla \cdot (\alpha \rho D_{\omega}\nabla\omega) \\
&amp;= \alpha \rho \gamma \min \Big\{ \frac{G}{\nu_{t}}, \frac{c_{1}}{a_{1}}\beta^{*}\omega \max(a_{1}\omega,b_{1}F_{2}\sqrt{S_{2}} ) \Big\}
- \frac{2}{3}\alpha \rho\gamma (\nabla \cdot \mathbf{U})\omega
- \alpha \rho \beta \omega^{2}
- \alpha \rho (F_{1} - 1)\frac{CD_{k\omega}}{\omega}\omega
+ S_{\omega }
\end{align}\end{split}\]</div>
<p>对应的代码为</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">fvScalarMatrix</span><span class="o">&gt;</span> <span class="n">omegaEqn</span>
<span class="p">(</span>
    <span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">omega_</span><span class="p">)</span>
  <span class="o">+</span> <span class="n">fvm</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">alphaRhoPhi</span><span class="p">,</span> <span class="n">omega_</span><span class="p">)</span>
  <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="n">DomegaEff</span><span class="p">(</span><span class="n">F1</span><span class="p">),</span> <span class="n">omega_</span><span class="p">)</span>
 <span class="o">==</span>
    <span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">gamma</span>
   <span class="o">*</span><span class="n">min</span>
    <span class="p">(</span>
        <span class="n">GbyNu</span><span class="p">,</span>
        <span class="p">(</span><span class="n">c1_</span><span class="o">/</span><span class="n">a1_</span><span class="p">)</span><span class="o">*</span><span class="n">betaStar_</span><span class="o">*</span><span class="n">omega_</span><span class="p">()</span>
       <span class="o">*</span><span class="n">max</span><span class="p">(</span><span class="n">a1_</span><span class="o">*</span><span class="n">omega_</span><span class="p">(),</span> <span class="n">b1_</span><span class="o">*</span><span class="n">F23</span><span class="p">()</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">S2</span><span class="p">()))</span>
    <span class="p">)</span>
  <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">SuSp</span><span class="p">((</span><span class="mf">2.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span><span class="o">*</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">gamma</span><span class="o">*</span><span class="n">divU</span><span class="p">,</span> <span class="n">omega_</span><span class="p">)</span>
  <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">Sp</span><span class="p">(</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">beta</span><span class="o">*</span><span class="n">omega_</span><span class="p">(),</span> <span class="n">omega_</span><span class="p">)</span>
  <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">SuSp</span>
    <span class="p">(</span>
        <span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="n">F1</span><span class="p">()</span> <span class="o">-</span> <span class="n">scalar</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="n">CDkOmega</span><span class="p">()</span><span class="o">/</span><span class="n">omega_</span><span class="p">(),</span>
        <span class="n">omega_</span>
    <span class="p">)</span>
  <span class="o">+</span> <span class="n">Qsas</span><span class="p">(</span><span class="n">S2</span><span class="p">(),</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
  <span class="o">+</span> <span class="n">omegaSource</span><span class="p">()</span>
  <span class="o">+</span> <span class="n">fvModels</span><span class="p">.</span><span class="n">source</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">omega_</span><span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<p>其中 <span class="math notranslate nohighlight">\(\alpha\)</span> 为质量分数，用于多相流的情况。另外有</p>
<div class="math notranslate nohighlight">
\[\begin{align}
P_{k} = \min(G , c_{1}\beta^{*}k\omega)
\end{align}\]</div>
<p>对应的代码为</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">MomentumTransportModel</span><span class="p">,</span> <span class="n">class</span> <span class="n">BasicMomentumTransportModel</span><span class="o">&gt;</span>
<span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">::</span><span class="n">Internal</span><span class="o">&gt;</span>
<span class="n">kOmegaSST</span><span class="o">&lt;</span><span class="n">MomentumTransportModel</span><span class="p">,</span> <span class="n">BasicMomentumTransportModel</span><span class="o">&gt;::</span><span class="n">Pk</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">::</span><span class="n">Internal</span><span class="o">&amp;</span> <span class="n">G</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">min</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">(</span><span class="n">c1_</span><span class="o">*</span><span class="n">betaStar_</span><span class="p">)</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">k_</span><span class="p">()</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">omega_</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="math notranslate nohighlight">
\[\begin{align}
CD_{k\omega} = \frac{2\alpha_{\omega2}(\nabla k \cdot \nabla\omega)}{\omega}
\end{align}\]</div>
<p>对应的代码为</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">volScalarField</span> <span class="nf">CDkOmega</span>
<span class="p">(</span>
    <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">alphaOmega2_</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">k_</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">omega_</span><span class="p">))</span><span class="o">/</span><span class="n">omega_</span>
<span class="p">);</span>
</pre></div>
</div>
<div class="math notranslate nohighlight">
\[\begin{align}
G = \nu_{t} \Big( \nabla\mathbf{U} + (\nabla\mathbf{U})^{T} - \frac{2}{3}(\nabla\cdot \mathbf{U})\mathbf{I} \Big) : \nabla \mathbf{U}
\end{align}\]</div>
<p>对应的代码为</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">volTensorField</span><span class="o">&gt;</span> <span class="n">tgradU</span> <span class="o">=</span> <span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">U</span><span class="p">);</span>

<span class="n">volScalarField</span><span class="o">::</span><span class="n">Internal</span> <span class="n">GbyNu</span><span class="p">(</span><span class="n">dev</span><span class="p">(</span><span class="n">twoSymm</span><span class="p">(</span><span class="n">tgradU</span><span class="p">()()))</span> <span class="o">&amp;&amp;</span> <span class="n">tgradU</span><span class="p">()());</span>
<span class="n">volScalarField</span><span class="o">::</span><span class="n">Internal</span> <span class="n">G</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">GName</span><span class="p">(),</span> <span class="n">nut</span><span class="p">()</span><span class="o">*</span><span class="n">GbyNu</span><span class="p">);</span>
</pre></div>
</div>
<div class="math notranslate nohighlight">
\[\begin{align}
S_{2} = 2 \Big| \frac{\nabla\mathbf{U} + (\nabla\mathbf{U})^{T}}{2}  \Big|^{2}
\end{align}\]</div>
<p>对应的代码为</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">volScalarField</span> <span class="nf">S2</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">symm</span><span class="p">(</span><span class="n">tgradU</span><span class="p">())));</span>
</pre></div>
</div>
<div class="math notranslate nohighlight">
\[\begin{align}
F_{1} = \tanh\left \{  \min\bigg[\min\Big[ \max\Big(\frac{\sqrt{k}}{\beta^{*}\omega y},  \frac{500\nu}{\omega y^{2}}\Big), \frac{4\alpha_{\omega2}k}{CD_{k\omega}y^{2}} \Big] , 10\bigg]\right \} ^{4}
\end{align}\]</div>
<p>对应的代码为</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">MomentumTransportModel</span><span class="p">,</span> <span class="n">class</span> <span class="n">BasicMomentumTransportModel</span><span class="o">&gt;</span>
<span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span>
<span class="n">kOmegaSST</span><span class="o">&lt;</span><span class="n">MomentumTransportModel</span><span class="p">,</span> <span class="n">BasicMomentumTransportModel</span><span class="o">&gt;::</span><span class="n">kOmegaSST</span><span class="o">::</span><span class="n">F1</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">CDkOmega</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">CDkOmegaPlus</span> <span class="o">=</span> <span class="n">max</span>
    <span class="p">(</span>
        <span class="n">CDkOmega</span><span class="p">,</span>
        <span class="n">dimensionedScalar</span><span class="p">(</span><span class="n">dimless</span><span class="o">/</span><span class="n">sqr</span><span class="p">(</span><span class="n">dimTime</span><span class="p">),</span> <span class="mf">1.0e-10</span><span class="p">)</span>
    <span class="p">);</span>

    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">arg1</span> <span class="o">=</span> <span class="n">min</span>
    <span class="p">(</span>
        <span class="n">min</span>
        <span class="p">(</span>
            <span class="n">max</span>
            <span class="p">(</span>
                <span class="p">(</span><span class="n">scalar</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">betaStar_</span><span class="p">)</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">k_</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">omega_</span><span class="o">*</span><span class="n">y_</span><span class="p">),</span>
                <span class="n">scalar</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">nu</span><span class="p">()</span><span class="o">/</span><span class="p">(</span><span class="n">sqr</span><span class="p">(</span><span class="n">y_</span><span class="p">)</span><span class="o">*</span><span class="n">omega_</span><span class="p">)</span>
            <span class="p">),</span>
            <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">alphaOmega2_</span><span class="p">)</span><span class="o">*</span><span class="n">k_</span><span class="o">/</span><span class="p">(</span><span class="n">CDkOmegaPlus</span><span class="o">*</span><span class="n">sqr</span><span class="p">(</span><span class="n">y_</span><span class="p">))</span>
        <span class="p">),</span>
        <span class="n">scalar</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="p">);</span>

    <span class="k">return</span> <span class="nf">tanh</span><span class="p">(</span><span class="n">pow4</span><span class="p">(</span><span class="n">arg1</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="math notranslate nohighlight">
\[\begin{align}
F_{2} = \tanh \left \{ \min\Big[ \max\Big( \frac{2\sqrt{k}}{\beta^{*}\omega y}, \frac{500 \nu}{\omega y^{2}} \Big), 100\Big] \right \}^{2}
\end{align}\]</div>
<p>对应的代码为</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">MomentumTransportModel</span><span class="p">,</span> <span class="n">class</span> <span class="n">BasicMomentumTransportModel</span><span class="o">&gt;</span>
<span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span>
<span class="n">kOmegaSST</span><span class="o">&lt;</span><span class="n">MomentumTransportModel</span><span class="p">,</span> <span class="n">BasicMomentumTransportModel</span><span class="o">&gt;::</span><span class="n">kOmegaSST</span><span class="o">::</span>
<span class="n">F2</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">arg2</span> <span class="o">=</span> <span class="n">min</span>
    <span class="p">(</span>
        <span class="n">max</span>
        <span class="p">(</span>
            <span class="p">(</span><span class="n">scalar</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">betaStar_</span><span class="p">)</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">k_</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">omega_</span><span class="o">*</span><span class="n">y_</span><span class="p">),</span>
            <span class="n">scalar</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">nu</span><span class="p">()</span><span class="o">/</span><span class="p">(</span><span class="n">sqr</span><span class="p">(</span><span class="n">y_</span><span class="p">)</span><span class="o">*</span><span class="n">omega_</span><span class="p">)</span>
        <span class="p">),</span>
        <span class="n">scalar</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
    <span class="p">);</span>

    <span class="k">return</span> <span class="nf">tanh</span><span class="p">(</span><span class="n">sqr</span><span class="p">(</span><span class="n">arg2</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="math notranslate nohighlight">
\[\begin{align}
D_{k} = B(F_{1}, \alpha_{k1}, \alpha_{k2})\nu_{t} + \nu
\end{align}\]</div>
<p>对应的代码为</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">alphaK</span><span class="p">(</span><span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">F1</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">blend</span><span class="p">(</span><span class="n">F1</span><span class="p">,</span> <span class="n">alphaK1_</span><span class="p">,</span> <span class="n">alphaK2_</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">DkEff</span><span class="p">(</span><span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">F1</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">volScalarField</span><span class="o">::</span><span class="n">New</span>
    <span class="p">(</span>
        <span class="s">&quot;DkEff&quot;</span><span class="p">,</span>
        <span class="n">alphaK</span><span class="p">(</span><span class="n">F1</span><span class="p">)</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">nut_</span> <span class="o">+</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">nu</span><span class="p">()</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="math notranslate nohighlight">
\[\begin{align}
D_{\omega} = B(F_{1}, \alpha_{\omega2}, \alpha_{\omega2})\nu_{t} + \nu
\end{align}\]</div>
<p>对应的代码为</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">alphaOmega</span><span class="p">(</span><span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">F1</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">blend</span><span class="p">(</span><span class="n">F1</span><span class="p">,</span> <span class="n">alphaOmega1_</span><span class="p">,</span> <span class="n">alphaOmega2_</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">DomegaEff</span><span class="p">(</span><span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">F1</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">volScalarField</span><span class="o">::</span><span class="n">New</span>
    <span class="p">(</span>
        <span class="s">&quot;DomegaEff&quot;</span><span class="p">,</span>
        <span class="n">alphaOmega</span><span class="p">(</span><span class="n">F1</span><span class="p">)</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">nut_</span> <span class="o">+</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">nu</span><span class="p">()</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="math notranslate nohighlight">
\[\begin{align}
\beta = B(F_{1}, \beta_{1}, \beta_{2})
\end{align}\]</div>
<p>对应的代码为</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">::</span><span class="n">Internal</span><span class="o">&gt;</span> <span class="n">beta</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">::</span><span class="n">Internal</span><span class="o">&amp;</span> <span class="n">F1</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">blend</span><span class="p">(</span><span class="n">F1</span><span class="p">,</span> <span class="n">beta1_</span><span class="p">,</span> <span class="n">beta2_</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="math notranslate nohighlight">
\[\begin{align}
\gamma = B(F_{1}, \gamma_{1}, \gamma_{2})
\end{align}\]</div>
<p>对应的代码为</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">::</span><span class="n">Internal</span><span class="o">&gt;</span> <span class="n">gamma</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">::</span><span class="n">Internal</span><span class="o">&amp;</span> <span class="n">F1</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">blend</span><span class="p">(</span><span class="n">F1</span><span class="p">,</span> <span class="n">gamma1_</span><span class="p">,</span> <span class="n">gamma2_</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="math notranslate nohighlight">
\[\begin{align}
B(a,b,c) = ab + (1-a)c
\end{align}\]</div>
<p>对应的代码为</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">blend</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">F1</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">dimensionedScalar</span><span class="o">&amp;</span> <span class="n">psi1</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">dimensionedScalar</span><span class="o">&amp;</span> <span class="n">psi2</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">F1</span><span class="o">*</span><span class="p">(</span><span class="n">psi1</span> <span class="o">-</span> <span class="n">psi2</span><span class="p">)</span> <span class="o">+</span> <span class="n">psi2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="math notranslate nohighlight">
\[\begin{align}
\nu_{t} = \frac{a_{1}k}{\max(a_{1}\omega, b_{1}F_{2}\sqrt{S_{2}})}
\end{align}\]</div>
<p>对应的代码为</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">MomentumTransportModel</span><span class="p">,</span> <span class="n">class</span> <span class="n">BasicMomentumTransportModel</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">kOmegaSST</span><span class="o">&lt;</span><span class="n">MomentumTransportModel</span><span class="p">,</span> <span class="n">BasicMomentumTransportModel</span><span class="o">&gt;::</span><span class="n">correctNut</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">S2</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">F2</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">this</span><span class="o">-&gt;</span><span class="n">nut_</span> <span class="o">=</span> <span class="n">a1_</span><span class="o">*</span><span class="n">k_</span><span class="o">/</span><span class="n">max</span><span class="p">(</span><span class="n">a1_</span><span class="o">*</span><span class="n">omega_</span><span class="p">,</span> <span class="n">b1_</span><span class="o">*</span><span class="n">F2</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">S2</span><span class="p">));</span>
    <span class="n">this</span><span class="o">-&gt;</span><span class="n">nut_</span><span class="p">.</span><span class="n">correctBoundaryConditions</span><span class="p">();</span>
    <span class="n">fvConstraints</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">mesh_</span><span class="p">).</span><span class="n">constrain</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">nut_</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="math notranslate nohighlight">
\[\begin{align}
\varepsilon = \beta^{*} k \omega
\end{align}\]</div>
<p>对应的代码为</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">virtual</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">epsilon</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">volScalarField</span><span class="o">::</span><span class="n">New</span>
    <span class="p">(</span>
        <span class="s">&quot;epsilon&quot;</span><span class="p">,</span>
        <span class="n">betaStar_</span><span class="o">*</span><span class="n">k_</span><span class="o">*</span><span class="n">omega_</span><span class="p">,</span>
        <span class="n">omega_</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">().</span><span class="n">types</span><span class="p">()</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>各参数的默认取值如下：</p>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="9%" />
<col width="11%" />
<col width="11%" />
<col width="9%" />
<col width="9%" />
<col width="8%" />
<col width="8%" />
<col width="8%" />
<col width="6%" />
<col width="6%" />
<col width="6%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><span class="math notranslate nohighlight">\(\alpha_{k1}\)</span></th>
<th class="head"><span class="math notranslate nohighlight">\(\alpha_{k2}\)</span></th>
<th class="head"><span class="math notranslate nohighlight">\(\alpha_{\omega1}\)</span></th>
<th class="head"><span class="math notranslate nohighlight">\(\alpha_{omega2}\)</span></th>
<th class="head"><span class="math notranslate nohighlight">\(\gamma_{1}\)</span></th>
<th class="head"><span class="math notranslate nohighlight">\(\gamma_{2}\)</span></th>
<th class="head"><span class="math notranslate nohighlight">\(\beta_{1}\)</span></th>
<th class="head"><span class="math notranslate nohighlight">\(\beta_{2}\)</span></th>
<th class="head"><span class="math notranslate nohighlight">\(\beta^{*}\)</span></th>
<th class="head"><span class="math notranslate nohighlight">\(a_{1}\)</span></th>
<th class="head"><span class="math notranslate nohighlight">\(b_{1}\)</span></th>
<th class="head"><span class="math notranslate nohighlight">\(c_{1}\)</span></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0.85</td>
<td>1</td>
<td>0.5</td>
<td>0.856</td>
<td>5/9</td>
<td>0.44</td>
<td>0.075</td>
<td>0.0828</td>
<td>0.09</td>
<td>0.31</td>
<td>1</td>
<td>10</td>
</tr>
</tbody>
</table>
<div class="admonition attention">
<p class="first admonition-title">注意</p>
<p>另外还定义了F3函数，它默认关闭，需要通过字典设置为True来激活，如果激活了则可以处理粗糙壁面问题。它的定义为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
F_{3} = 1 - \tanh \Big[ \min\Big( \frac{150\nu}{\omega y^{2}} ,10 \Big) \Big]^{4}
\end{align}\]</div>
<p class="last">F3通过作用于F2来发挥作用。涉及到的代码如下所示。</p>
</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">MomentumTransportModel</span><span class="p">,</span> <span class="n">class</span> <span class="n">BasicMomentumTransportModel</span><span class="o">&gt;</span>
<span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span>
<span class="n">kOmegaSST</span><span class="o">&lt;</span><span class="n">MomentumTransportModel</span><span class="p">,</span> <span class="n">BasicMomentumTransportModel</span><span class="o">&gt;::</span><span class="n">kOmegaSST</span><span class="o">::</span>
<span class="n">F3</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">arg3</span> <span class="o">=</span> <span class="n">min</span>
    <span class="p">(</span>
        <span class="mi">150</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">nu</span><span class="p">()</span><span class="o">/</span><span class="p">(</span><span class="n">omega_</span><span class="o">*</span><span class="n">sqr</span><span class="p">(</span><span class="n">y_</span><span class="p">)),</span>
        <span class="n">scalar</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="p">);</span>

    <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">tanh</span><span class="p">(</span><span class="n">pow4</span><span class="p">(</span><span class="n">arg3</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">MomentumTransportModel</span><span class="p">,</span> <span class="n">class</span> <span class="n">BasicMomentumTransportModel</span><span class="o">&gt;</span>
<span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span>
<span class="n">kOmegaSST</span><span class="o">&lt;</span><span class="n">MomentumTransportModel</span><span class="p">,</span> <span class="n">BasicMomentumTransportModel</span><span class="o">&gt;::</span><span class="n">kOmegaSST</span><span class="o">::</span>
<span class="n">F23</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">f23</span><span class="p">(</span><span class="n">F2</span><span class="p">());</span>    <span class="c1">// 默认是输出F2</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">F3_</span><span class="p">)</span>    <span class="c1">// 如果激活F3</span>
    <span class="p">{</span>
        <span class="n">f23</span><span class="p">.</span><span class="n">ref</span><span class="p">()</span> <span class="o">*=</span> <span class="n">F3</span><span class="p">();</span>    <span class="c1">// 则在F2基础上乘以F3</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">f23</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>进入src/MomentumTransportModels/momentumTransportModels/Base/kOmegaSST/kOmegaSSTBase.C文件，可以看到完整的求解策略：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">MomentumTransportModel</span><span class="p">,</span> <span class="n">class</span> <span class="n">BasicMomentumTransportModel</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">kOmegaSST</span><span class="o">&lt;</span><span class="n">MomentumTransportModel</span><span class="p">,</span> <span class="n">BasicMomentumTransportModel</span><span class="o">&gt;::</span><span class="n">correct</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">turbulence_</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Local references</span>
    <span class="k">const</span> <span class="n">alphaField</span><span class="o">&amp;</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">alpha_</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">rhoField</span><span class="o">&amp;</span> <span class="n">rho</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">rho_</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">alphaRhoPhi</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">alphaRhoPhi_</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">volVectorField</span><span class="o">&amp;</span> <span class="n">U</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">U_</span><span class="p">;</span>
    <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">nut</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">nut_</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">Foam</span><span class="o">::</span><span class="n">fvModels</span><span class="o">&amp;</span> <span class="n">fvModels</span><span class="p">(</span><span class="n">Foam</span><span class="o">::</span><span class="n">fvModels</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">mesh_</span><span class="p">));</span>
    <span class="k">const</span> <span class="n">Foam</span><span class="o">::</span><span class="n">fvConstraints</span><span class="o">&amp;</span> <span class="n">fvConstraints</span>
    <span class="p">(</span>
        <span class="n">Foam</span><span class="o">::</span><span class="n">fvConstraints</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">mesh_</span><span class="p">)</span>
    <span class="p">);</span>

    <span class="n">MomentumTransportModel</span><span class="o">::</span><span class="n">correct</span><span class="p">();</span>

    <span class="n">volScalarField</span><span class="o">::</span><span class="n">Internal</span> <span class="n">divU</span>
    <span class="p">(</span>
        <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">fvc</span><span class="o">::</span><span class="n">absolute</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">phi</span><span class="p">(),</span> <span class="n">U</span><span class="p">))()()</span>
    <span class="p">);</span>

    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volTensorField</span><span class="o">&gt;</span> <span class="n">tgradU</span> <span class="o">=</span> <span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">U</span><span class="p">);</span>
    <span class="n">volScalarField</span> <span class="nf">S2</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">symm</span><span class="p">(</span><span class="n">tgradU</span><span class="p">())));</span>
    <span class="n">volScalarField</span><span class="o">::</span><span class="n">Internal</span> <span class="n">GbyNu</span><span class="p">(</span><span class="n">dev</span><span class="p">(</span><span class="n">twoSymm</span><span class="p">(</span><span class="n">tgradU</span><span class="p">()()))</span> <span class="o">&amp;&amp;</span> <span class="n">tgradU</span><span class="p">()());</span>
    <span class="n">volScalarField</span><span class="o">::</span><span class="n">Internal</span> <span class="n">G</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">GName</span><span class="p">(),</span> <span class="n">nut</span><span class="p">()</span><span class="o">*</span><span class="n">GbyNu</span><span class="p">);</span>
    <span class="n">tgradU</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>

    <span class="c1">// Update omega and G at the wall</span>
    <span class="n">omega_</span><span class="p">.</span><span class="n">boundaryFieldRef</span><span class="p">().</span><span class="n">updateCoeffs</span><span class="p">();</span>

    <span class="n">volScalarField</span> <span class="nf">CDkOmega</span>
    <span class="p">(</span>
        <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">alphaOmega2_</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">k_</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">omega_</span><span class="p">))</span><span class="o">/</span><span class="n">omega_</span>
    <span class="p">);</span>

    <span class="n">volScalarField</span> <span class="nf">F1</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">F1</span><span class="p">(</span><span class="n">CDkOmega</span><span class="p">));</span>
    <span class="n">volScalarField</span> <span class="nf">F23</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">F23</span><span class="p">());</span>

    <span class="p">{</span>
        <span class="n">volScalarField</span><span class="o">::</span><span class="n">Internal</span> <span class="n">gamma</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">gamma</span><span class="p">(</span><span class="n">F1</span><span class="p">));</span>
        <span class="n">volScalarField</span><span class="o">::</span><span class="n">Internal</span> <span class="n">beta</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">beta</span><span class="p">(</span><span class="n">F1</span><span class="p">));</span>

        <span class="c1">// Turbulent frequency equation</span>
        <span class="n">tmp</span><span class="o">&lt;</span><span class="n">fvScalarMatrix</span><span class="o">&gt;</span> <span class="n">omegaEqn</span>
        <span class="p">(</span>
            <span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">omega_</span><span class="p">)</span>
          <span class="o">+</span> <span class="n">fvm</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">alphaRhoPhi</span><span class="p">,</span> <span class="n">omega_</span><span class="p">)</span>
          <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="n">DomegaEff</span><span class="p">(</span><span class="n">F1</span><span class="p">),</span> <span class="n">omega_</span><span class="p">)</span>
         <span class="o">==</span>
            <span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">gamma</span>
           <span class="o">*</span><span class="n">min</span>
            <span class="p">(</span>
                <span class="n">GbyNu</span><span class="p">,</span>
                <span class="p">(</span><span class="n">c1_</span><span class="o">/</span><span class="n">a1_</span><span class="p">)</span><span class="o">*</span><span class="n">betaStar_</span><span class="o">*</span><span class="n">omega_</span><span class="p">()</span>
               <span class="o">*</span><span class="n">max</span><span class="p">(</span><span class="n">a1_</span><span class="o">*</span><span class="n">omega_</span><span class="p">(),</span> <span class="n">b1_</span><span class="o">*</span><span class="n">F23</span><span class="p">()</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">S2</span><span class="p">()))</span>
            <span class="p">)</span>
          <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">SuSp</span><span class="p">((</span><span class="mf">2.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span><span class="o">*</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">gamma</span><span class="o">*</span><span class="n">divU</span><span class="p">,</span> <span class="n">omega_</span><span class="p">)</span>
          <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">Sp</span><span class="p">(</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">beta</span><span class="o">*</span><span class="n">omega_</span><span class="p">(),</span> <span class="n">omega_</span><span class="p">)</span>
          <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">SuSp</span>
            <span class="p">(</span>
                <span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="n">F1</span><span class="p">()</span> <span class="o">-</span> <span class="n">scalar</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="n">CDkOmega</span><span class="p">()</span><span class="o">/</span><span class="n">omega_</span><span class="p">(),</span>
                <span class="n">omega_</span>
            <span class="p">)</span>
          <span class="o">+</span> <span class="n">Qsas</span><span class="p">(</span><span class="n">S2</span><span class="p">(),</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
          <span class="o">+</span> <span class="n">omegaSource</span><span class="p">()</span>
          <span class="o">+</span> <span class="n">fvModels</span><span class="p">.</span><span class="n">source</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">omega_</span><span class="p">)</span>
        <span class="p">);</span>

        <span class="n">omegaEqn</span><span class="p">.</span><span class="n">ref</span><span class="p">().</span><span class="n">relax</span><span class="p">();</span>
        <span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">omegaEqn</span><span class="p">.</span><span class="n">ref</span><span class="p">());</span>
        <span class="n">omegaEqn</span><span class="p">.</span><span class="n">ref</span><span class="p">().</span><span class="n">boundaryManipulate</span><span class="p">(</span><span class="n">omega_</span><span class="p">.</span><span class="n">boundaryFieldRef</span><span class="p">());</span>
        <span class="n">solve</span><span class="p">(</span><span class="n">omegaEqn</span><span class="p">);</span>
        <span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">omega_</span><span class="p">);</span>
        <span class="n">bound</span><span class="p">(</span><span class="n">omega_</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">omegaMin_</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Turbulent kinetic energy equation</span>
    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">fvScalarMatrix</span><span class="o">&gt;</span> <span class="n">kEqn</span>
    <span class="p">(</span>
        <span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">k_</span><span class="p">)</span>
      <span class="o">+</span> <span class="n">fvm</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">alphaRhoPhi</span><span class="p">,</span> <span class="n">k_</span><span class="p">)</span>
      <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="n">DkEff</span><span class="p">(</span><span class="n">F1</span><span class="p">),</span> <span class="n">k_</span><span class="p">)</span>
     <span class="o">==</span>
        <span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">Pk</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
      <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">SuSp</span><span class="p">((</span><span class="mf">2.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span><span class="o">*</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">divU</span><span class="p">,</span> <span class="n">k_</span><span class="p">)</span>
      <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">Sp</span><span class="p">(</span><span class="n">alpha</span><span class="p">()</span><span class="o">*</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">epsilonByk</span><span class="p">(</span><span class="n">F1</span><span class="p">,</span> <span class="n">F23</span><span class="p">),</span> <span class="n">k_</span><span class="p">)</span>
      <span class="o">+</span> <span class="n">kSource</span><span class="p">()</span>
      <span class="o">+</span> <span class="n">fvModels</span><span class="p">.</span><span class="n">source</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">k_</span><span class="p">)</span>
    <span class="p">);</span>

    <span class="n">kEqn</span><span class="p">.</span><span class="n">ref</span><span class="p">().</span><span class="n">relax</span><span class="p">();</span>
    <span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">kEqn</span><span class="p">.</span><span class="n">ref</span><span class="p">());</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">kEqn</span><span class="p">);</span>
    <span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">k_</span><span class="p">);</span>
    <span class="n">bound</span><span class="p">(</span><span class="n">k_</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">kMin_</span><span class="p">);</span>

    <span class="n">correctNut</span><span class="p">(</span><span class="n">S2</span><span class="p">,</span> <span class="n">F23</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>使用该模型时需要在system/momentumTransport文件中写入下面内容：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">simulationType</span> <span class="n">RAS</span><span class="p">;</span>
<span class="n">RAS</span>
<span class="p">{</span>
    <span class="n">RASModel</span>            <span class="n">kOmegaSST</span><span class="p">;</span>
    <span class="n">turbulence</span>          <span class="n">on</span><span class="p">;</span>
    <span class="n">printCoeffs</span>         <span class="n">on</span><span class="p">;</span>

    <span class="n">kOmegaSSTCoeffs</span>
    <span class="p">{</span>
        <span class="n">alphaK1</span>        <span class="mf">0.85</span><span class="p">;</span>
        <span class="n">alphaK2</span>        <span class="mf">1.0</span><span class="p">;</span>
        <span class="n">alphaOmega1</span>    <span class="mf">0.5</span><span class="p">;</span>
        <span class="n">alphaOmega2</span>    <span class="mf">0.856</span><span class="p">;</span>
        <span class="n">gamma1</span>         <span class="mf">5.0</span><span class="o">/</span><span class="mf">9.0</span><span class="p">;</span>
        <span class="n">gamma2</span>         <span class="mf">0.44</span><span class="p">;</span>
        <span class="n">beta1</span>          <span class="mf">0.075</span><span class="p">;</span>
        <span class="n">beta2</span>          <span class="mf">0.0828</span><span class="p">;</span>
        <span class="n">betaStar</span>       <span class="mf">0.09</span><span class="p">;</span>
        <span class="n">a1</span>             <span class="mf">0.31</span><span class="p">;</span>
        <span class="n">b1</span>             <span class="mf">1.0</span><span class="p">;</span>
        <span class="n">c1</span>             <span class="mf">10.0</span><span class="p">;</span>
        <span class="n">F3</span>             <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>场文件需要额外添加</p>
<p>fvSchemes文件需要额外添加：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>ddtSchemes
{
    turbulence        CrankNicolson 0.9;
    ddt(rho,omega)    $turbulence;
    ddt(omega)        $turbulence;
    ddt(rho,k)        $turbulence;
}

gradSchemes
{
    turbulence     Gauss linear;
    grad(yPsi)     $turbulence;
    grad(omega)    $turbulence;
    grad(k)        $turbulence;
}

divSchemes
{
    turbulence        Gauss upwind;
    div(phi,omega)    $turbulence;
    div(phi,k)        $turbulence;
}

laplacianSchemes
{
    turbulence    Gauss linear limited corrected 0.5;
    laplacian(yPsi)                     $turbulence;
    laplacian(alphaEff,e)               $turbulence;
    laplacian((rho*DomegaEff),omega)    $turbulence;
    laplacian((rho*DkEff),k)            $turbulence;
}

interpolationSchemes
{
    turbulence          linear;
    interpolate(rho)    $turbulence;
}

wallDist
{
    method Poisson;
}
</pre></div>
</div>
<p>fvSolution文件需要额外添加：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">solvers</span>
<span class="p">{</span>
    <span class="s">&quot;(omega|k)&quot;</span>
    <span class="p">{</span>
        <span class="n">solver</span>          <span class="n">smoothSolver</span><span class="p">;</span>
        <span class="n">smoother</span>        <span class="n">GaussSeidel</span><span class="p">;</span>
        <span class="n">nSweeps</span>         <span class="mi">2</span><span class="p">;</span>
        <span class="n">tolerance</span>       <span class="mf">1e-09</span><span class="p">;</span>
        <span class="n">relTol</span>          <span class="mf">0.01</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">yPsi</span>
    <span class="p">{</span>
        <span class="n">solver</span>         <span class="n">PCG</span><span class="p">;</span>
        <span class="n">preconditioner</span> <span class="n">DIC</span><span class="p">;</span>
        <span class="n">tolerance</span>      <span class="mf">1e-9</span><span class="p">;</span>
        <span class="n">relTol</span>         <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="fvshemes">
<h2>fvShemes离散格式设置<a class="headerlink" href="#fvshemes" title="永久链接至标题">¶</a></h2>
<p>参考 <a class="reference external" href="https://www.zybuluo.com/daidezhi/note/389113">OpenFOAM中fvSchemes字典文件解析</a></p>
<p>system/fvSchemes文件用来设置离散格式，凡是求解器里面出现的方程，都需要在这里进行离散格式设置。需要指定的信息主要以下子字典：</p>
<table border="1" class="docutils">
<colgroup>
<col width="55%" />
<col width="45%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">子字典关键词</th>
<th class="head">含义</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>interpolationSchemes</td>
<td>插值格式</td>
</tr>
<tr class="row-odd"><td>snGradSchemes</td>
<td>面法向梯度格式</td>
</tr>
<tr class="row-even"><td>ddtSchemes</td>
<td>时间一阶导项格式</td>
</tr>
<tr class="row-odd"><td>d2dt2Schemes</td>
<td>时间二阶导项格式</td>
</tr>
<tr class="row-even"><td>divSchemes</td>
<td>散度项格式</td>
</tr>
<tr class="row-odd"><td>gradSchemes</td>
<td>梯度项格式</td>
</tr>
<tr class="row-even"><td>laplacianSchemes</td>
<td>拉普拉斯项格式</td>
</tr>
<tr class="row-odd"><td>fluxRequired</td>
<td>需要计算通量的场</td>
</tr>
</tbody>
</table>
<div class="section" id="interpolationschemes">
<h3>插值格式interpolationSchemes<a class="headerlink" href="#interpolationschemes" title="永久链接至标题">¶</a></h3>
<p>插值格式在子字典interpolationSchemes下设置，通常用来指定从相邻两个体单元计算公共面单元处变量值的计算方法：</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="28%" />
<col width="38%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">插值格式</th>
<th class="head">具体方法</th>
<th class="head">含义</th>
<th class="head">用途</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td rowspan="3">中心格式</td>
<td>linear</td>
<td>线性插值(中心差分)格式</td>
<td rowspan="3">应用于普通场插值</td>
</tr>
<tr class="row-odd"><td>cubicCorrection</td>
<td>立方正交格式</td>
</tr>
<tr class="row-even"><td>midPoint</td>
<td>对称加权线性插值格式</td>
</tr>
<tr class="row-odd"><td rowspan="4">迎风格式</td>
<td>upwind</td>
<td>一阶迎风格式</td>
<td rowspan="4">主要应用于对流项</td>
</tr>
<tr class="row-even"><td>linearUpwind</td>
<td>线性迎风格式</td>
</tr>
<tr class="row-odd"><td>skewLinear</td>
<td>带畸变修正线性迎风格式</td>
</tr>
<tr class="row-even"><td>filteredLinear2</td>
<td>高频波过滤线性迎风格式</td>
</tr>
<tr class="row-odd"><td rowspan="11">TVD家族</td>
<td>limitedLinear</td>
<td>有界线性格式</td>
<td rowspan="11">主要应用于对流项</td>
</tr>
<tr class="row-even"><td>limitedLimitedLinear</td>
<td>有界线性格式(带限制器)</td>
</tr>
<tr class="row-odd"><td>limitedLinearV</td>
<td>有界线性格式(矢量场专用)</td>
</tr>
<tr class="row-even"><td>vanLeer</td>
<td>van Leer有界格式</td>
</tr>
<tr class="row-odd"><td>limitedVanLeer</td>
<td>van Leer有界格式(带限制器)</td>
</tr>
<tr class="row-even"><td>vanLeerV</td>
<td>van Leer有界格式(矢量场专用)</td>
</tr>
<tr class="row-odd"><td>MUSCL</td>
<td>MUSCL有界格式</td>
</tr>
<tr class="row-even"><td>limitedMUSCL</td>
<td>MUSCL有界格式(带限制器)</td>
</tr>
<tr class="row-odd"><td>limitedCubic</td>
<td>立方正交有界格式</td>
</tr>
<tr class="row-even"><td>limitedLimitedCubic</td>
<td>立方正交有界格式(带限制器)</td>
</tr>
<tr class="row-odd"><td>limitedCubicV</td>
<td>立方正交有界格式(矢量场专用)</td>
</tr>
<tr class="row-even"><td rowspan="5">NVD家族</td>
<td>SFCD</td>
<td>自过滤中心格式</td>
<td rowspan="5">主要应用于对流项</td>
</tr>
<tr class="row-odd"><td>SFCDV</td>
<td>自过滤中心格式(矢量场专用)</td>
</tr>
<tr class="row-even"><td>Gamma</td>
<td>Gamma差分格式</td>
</tr>
<tr class="row-odd"><td>limitedGamma</td>
<td>Gamma差分格式(带限制器)</td>
</tr>
<tr class="row-even"><td>GammaV</td>
<td>Gamma差分格式(矢量场专用)</td>
</tr>
</tbody>
</table>
<p>针对对流项的插值格式需要在通量的基础上计算插值，因此这些格式的指定需要提供通量场的名称。在OpenFOAM标准求解器中，体积通量名称一般为phi，类型为surfaceScalarField（面心标量场），因此针对对流项的插值格式指定方式为：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">default</span> <span class="n">upwind</span> <span class="n">phi</span><span class="p">;</span>
</pre></div>
</div>
<p>一些基于TVD或者NVD的格式需要系数 <span class="math notranslate nohighlight">\(\psi\)</span> ，该系数的值介于0和1之间。当 <span class="math notranslate nohighlight">\(\psi=1\)</span> 时对应标准TVD格式，能够达到最快的收敛速度；当 <span class="math notranslate nohighlight">\(\psi=0\)</span> 时对应最高精度，例如：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">default</span> <span class="n">limitedLinear</span> <span class="n">phi</span> <span class="mf">1.0</span><span class="p">;</span>
</pre></div>
</div>
<p>某些标量场是严格有界的，例如VOF模型中的流体体积分数场 <span class="math notranslate nohighlight">\(F\)</span> 的值严格介于0和1之间，因此才会出现一些带有限制器的增强版格式。如果想要指定有界场的上下限，需要在格式名称前加上limited前缀。例如将vanLeer格式的上下限设置为 <span class="math notranslate nohighlight">\([-2,3]\)</span> ：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">default</span> <span class="n">limitedVanLeer</span> <span class="o">-</span><span class="mf">2.0</span> <span class="mf">3.0</span><span class="p">;</span>
</pre></div>
</div>
<p>特别地，对于类似于流体体积分数场上下限严格为 <span class="math notranslate nohighlight">\([0,1]\)</span> 的情况，可以添加后缀01，例如：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">default</span> <span class="n">vanLeer01</span><span class="p">;</span>
</pre></div>
</div>
<p>针对矢量场的有向性，一些带有限制器的格式具有矢量场的专用版本，使用方法为添加后缀V，如：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">default</span> <span class="n">limitedLinearV</span><span class="p">;</span>
</pre></div>
</div>
<p>插值到网格表面的方式主要通过interpolate函数和dotInterpolate函数来实现：</p>
<div class="literal-block-wrapper docutils container" id="id73">
<div class="code-block-caption"><span class="caption-text">src/finiteVolume/interpolation/surfaceInterpolation/surfaceInterpolationScheme/surfaceInterpolationScheme.C</span><a class="headerlink" href="#id73" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Foam</span><span class="o">::</span><span class="n">fvsPatchField</span><span class="p">,</span> <span class="n">Foam</span><span class="o">::</span><span class="n">surfaceMesh</span><span class="o">&gt;&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">surfaceInterpolationScheme</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">interpolate</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">vf</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="o">&gt;&amp;</span> <span class="n">tlambdas</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="o">&gt;&amp;</span> <span class="n">tys</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">surfaceInterpolation</span><span class="o">::</span><span class="n">debug</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">InfoInFunction</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;Interpolating &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">vf</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">vf</span><span class="p">.</span><span class="n">name</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot; from cells to faces &quot;</span>
               <span class="s">&quot;without explicit correction&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">lambdas</span> <span class="o">=</span> <span class="n">tlambdas</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">ys</span> <span class="o">=</span> <span class="n">tys</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&amp;</span> <span class="n">vfi</span> <span class="o">=</span> <span class="n">vf</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">lambda</span> <span class="o">=</span> <span class="n">lambdas</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ys</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">fvMesh</span><span class="o">&amp;</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">vf</span><span class="p">.</span><span class="n">mesh</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">labelUList</span><span class="o">&amp;</span> <span class="n">P</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">owner</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">labelUList</span><span class="o">&amp;</span> <span class="n">N</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">neighbour</span><span class="p">();</span>

    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvsPatchField</span><span class="p">,</span> <span class="n">surfaceMesh</span><span class="o">&gt;&gt;</span> <span class="n">tsf</span>
    <span class="p">(</span>
        <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvsPatchField</span><span class="p">,</span> <span class="n">surfaceMesh</span><span class="o">&gt;::</span><span class="n">New</span>
        <span class="p">(</span>
            <span class="s">&quot;interpolate(&quot;</span><span class="o">+</span><span class="n">vf</span><span class="p">.</span><span class="n">name</span><span class="p">()</span><span class="o">+</span><span class="sc">&#39;)&#39;</span><span class="p">,</span>
            <span class="n">mesh</span><span class="p">,</span>
            <span class="n">vf</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()</span>
        <span class="p">)</span>
    <span class="p">);</span>
    <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvsPatchField</span><span class="p">,</span> <span class="n">surfaceMesh</span><span class="o">&gt;&amp;</span> <span class="n">sf</span> <span class="o">=</span> <span class="n">tsf</span><span class="p">.</span><span class="n">ref</span><span class="p">();</span>

    <span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&amp;</span> <span class="n">sfi</span> <span class="o">=</span> <span class="n">sf</span><span class="p">.</span><span class="n">primitiveFieldRef</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">label</span> <span class="n">fi</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">fi</span><span class="o">&lt;</span><span class="n">P</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">fi</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">sfi</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span> <span class="o">=</span> <span class="n">lambda</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span><span class="o">*</span><span class="n">vfi</span><span class="p">[</span><span class="n">P</span><span class="p">[</span><span class="n">fi</span><span class="p">]]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span><span class="o">*</span><span class="n">vfi</span><span class="p">[</span><span class="n">N</span><span class="p">[</span><span class="n">fi</span><span class="p">]];</span>
    <span class="p">}</span>


    <span class="c1">// Interpolate across coupled patches using given lambdas and ys</span>
    <span class="kr">typename</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvsPatchField</span><span class="p">,</span> <span class="n">surfaceMesh</span><span class="o">&gt;::</span>
        <span class="n">Boundary</span><span class="o">&amp;</span> <span class="n">sfbf</span> <span class="o">=</span> <span class="n">sf</span><span class="p">.</span><span class="n">boundaryFieldRef</span><span class="p">();</span>

    <span class="n">forAll</span><span class="p">(</span><span class="n">lambdas</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">(),</span> <span class="n">pi</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">fvsPatchScalarField</span><span class="o">&amp;</span> <span class="n">pLambda</span> <span class="o">=</span> <span class="n">lambdas</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">pi</span><span class="p">];</span>
        <span class="k">const</span> <span class="n">fvsPatchScalarField</span><span class="o">&amp;</span> <span class="n">pY</span> <span class="o">=</span> <span class="n">ys</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">pi</span><span class="p">];</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">vf</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">pi</span><span class="p">].</span><span class="n">coupled</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="n">sfbf</span><span class="p">[</span><span class="n">pi</span><span class="p">]</span> <span class="o">=</span>
                <span class="n">pLambda</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">pi</span><span class="p">].</span><span class="n">patchInternalField</span><span class="p">()</span>
              <span class="o">+</span> <span class="n">pY</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">pi</span><span class="p">].</span><span class="n">patchNeighbourField</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">sfbf</span><span class="p">[</span><span class="n">pi</span><span class="p">]</span> <span class="o">=</span> <span class="n">vf</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">pi</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">tlambdas</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">tys</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">tsf</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">SFType</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span>
<span class="o">&lt;</span>
    <span class="n">Foam</span><span class="o">::</span><span class="n">GeometricField</span>
    <span class="o">&lt;</span>
        <span class="kr">typename</span> <span class="n">Foam</span><span class="o">::</span><span class="n">innerProduct</span><span class="o">&lt;</span><span class="kr">typename</span> <span class="n">SFType</span><span class="o">::</span><span class="n">value_type</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">,</span>
        <span class="n">Foam</span><span class="o">::</span><span class="n">fvsPatchField</span><span class="p">,</span>
        <span class="n">Foam</span><span class="o">::</span><span class="n">surfaceMesh</span>
    <span class="o">&gt;</span>
<span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">surfaceInterpolationScheme</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">dotInterpolate</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">SFType</span><span class="o">&amp;</span> <span class="n">Sf</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">vf</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="o">&gt;&amp;</span> <span class="n">tlambdas</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">surfaceInterpolation</span><span class="o">::</span><span class="n">debug</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">InfoInFunction</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;Interpolating &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">vf</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">vf</span><span class="p">.</span><span class="n">name</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot; from cells to faces &quot;</span>
               <span class="s">&quot;without explicit correction&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">typedef</span> <span class="kr">typename</span> <span class="n">Foam</span><span class="o">::</span><span class="n">innerProduct</span><span class="o">&lt;</span><span class="kr">typename</span> <span class="n">SFType</span><span class="o">::</span><span class="n">value_type</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">type</span>
        <span class="n">RetType</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">lambdas</span> <span class="o">=</span> <span class="n">tlambdas</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">Field</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&amp;</span> <span class="n">vfi</span> <span class="o">=</span> <span class="n">vf</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">lambda</span> <span class="o">=</span> <span class="n">lambdas</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">fvMesh</span><span class="o">&amp;</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">vf</span><span class="p">.</span><span class="n">mesh</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">labelUList</span><span class="o">&amp;</span> <span class="n">P</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">owner</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">labelUList</span><span class="o">&amp;</span> <span class="n">N</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">neighbour</span><span class="p">();</span>

    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">RetType</span><span class="p">,</span> <span class="n">fvsPatchField</span><span class="p">,</span> <span class="n">surfaceMesh</span><span class="o">&gt;&gt;</span> <span class="n">tsf</span>
    <span class="p">(</span>
        <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">RetType</span><span class="p">,</span> <span class="n">fvsPatchField</span><span class="p">,</span> <span class="n">surfaceMesh</span><span class="o">&gt;::</span><span class="n">New</span>
        <span class="p">(</span>
            <span class="s">&quot;interpolate(&quot;</span><span class="o">+</span><span class="n">vf</span><span class="p">.</span><span class="n">name</span><span class="p">()</span><span class="o">+</span><span class="sc">&#39;)&#39;</span><span class="p">,</span>
            <span class="n">mesh</span><span class="p">,</span>
            <span class="n">Sf</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()</span>
        <span class="p">)</span>
    <span class="p">);</span>
    <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">RetType</span><span class="p">,</span> <span class="n">fvsPatchField</span><span class="p">,</span> <span class="n">surfaceMesh</span><span class="o">&gt;&amp;</span> <span class="n">sf</span> <span class="o">=</span> <span class="n">tsf</span><span class="p">.</span><span class="n">ref</span><span class="p">();</span>

    <span class="n">Field</span><span class="o">&lt;</span><span class="n">RetType</span><span class="o">&gt;&amp;</span> <span class="n">sfi</span> <span class="o">=</span> <span class="n">sf</span><span class="p">.</span><span class="n">primitiveFieldRef</span><span class="p">();</span>

    <span class="k">const</span> <span class="kr">typename</span> <span class="n">SFType</span><span class="o">::</span><span class="n">Internal</span><span class="o">&amp;</span> <span class="n">Sfi</span> <span class="o">=</span> <span class="n">Sf</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">label</span> <span class="n">fi</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">fi</span><span class="o">&lt;</span><span class="n">P</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">fi</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">sfi</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sfi</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">lambda</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">vfi</span><span class="p">[</span><span class="n">P</span><span class="p">[</span><span class="n">fi</span><span class="p">]]</span> <span class="o">-</span> <span class="n">vfi</span><span class="p">[</span><span class="n">N</span><span class="p">[</span><span class="n">fi</span><span class="p">]])</span> <span class="o">+</span> <span class="n">vfi</span><span class="p">[</span><span class="n">N</span><span class="p">[</span><span class="n">fi</span><span class="p">]]);</span>
    <span class="p">}</span>

    <span class="c1">// Interpolate across coupled patches using given lambdas</span>

    <span class="kr">typename</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">RetType</span><span class="p">,</span> <span class="n">fvsPatchField</span><span class="p">,</span> <span class="n">surfaceMesh</span><span class="o">&gt;::</span>
        <span class="n">Boundary</span><span class="o">&amp;</span> <span class="n">sfbf</span> <span class="o">=</span> <span class="n">sf</span><span class="p">.</span><span class="n">boundaryFieldRef</span><span class="p">();</span>

    <span class="n">forAll</span><span class="p">(</span><span class="n">lambdas</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">(),</span> <span class="n">pi</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">fvsPatchScalarField</span><span class="o">&amp;</span> <span class="n">pLambda</span> <span class="o">=</span> <span class="n">lambdas</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">pi</span><span class="p">];</span>
        <span class="k">const</span> <span class="kr">typename</span> <span class="n">SFType</span><span class="o">::</span><span class="n">Patch</span><span class="o">&amp;</span> <span class="n">pSf</span> <span class="o">=</span> <span class="n">Sf</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">pi</span><span class="p">];</span>
        <span class="n">fvsPatchField</span><span class="o">&lt;</span><span class="n">RetType</span><span class="o">&gt;&amp;</span> <span class="n">psf</span> <span class="o">=</span> <span class="n">sfbf</span><span class="p">[</span><span class="n">pi</span><span class="p">];</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">vf</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">pi</span><span class="p">].</span><span class="n">coupled</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="n">psf</span> <span class="o">=</span>
                <span class="n">pSf</span>
              <span class="o">&amp;</span> <span class="p">(</span>
                    <span class="n">pLambda</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">pi</span><span class="p">].</span><span class="n">patchInternalField</span><span class="p">()</span>
                  <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">pLambda</span><span class="p">)</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">pi</span><span class="p">].</span><span class="n">patchNeighbourField</span><span class="p">()</span>
                <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">psf</span> <span class="o">=</span> <span class="n">pSf</span> <span class="o">&amp;</span> <span class="n">vf</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">pi</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">tlambdas</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">tsf</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>可以看到，核心的插值计算方式为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\phi_{f} = \lambda \phi_{O} + (1 - \lambda)\phi_{N} = \phi_{N} + \lambda(\phi_{O} - \phi_{N})
\end{align}\]</div>
<p>lambda这个参数会通过weights函数来赋值，weights函数初始化时设置为了0，而具体的插值格式就是要确定各自不同的weights。</p>
<p>一些插值格式会使用到修正函数correction，该函数返回的值作为附加内容加到原本的权重计算结果，具体实现过程如下所示：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Foam</span><span class="o">::</span><span class="n">fvsPatchField</span><span class="p">,</span> <span class="n">Foam</span><span class="o">::</span><span class="n">surfaceMesh</span><span class="o">&gt;&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">surfaceInterpolationScheme</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">interpolate</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">vf</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">surfaceInterpolation</span><span class="o">::</span><span class="n">debug</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">InfoInFunction</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;Interpolating &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">vf</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">vf</span><span class="p">.</span><span class="n">name</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot; from cells to faces&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvsPatchField</span><span class="p">,</span> <span class="n">surfaceMesh</span><span class="o">&gt;&gt;</span> <span class="n">tsf</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">vf</span><span class="p">,</span> <span class="n">weights</span><span class="p">(</span><span class="n">vf</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">corrected</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">tsf</span><span class="p">.</span><span class="n">ref</span><span class="p">()</span> <span class="o">+=</span> <span class="n">correction</span><span class="p">(</span><span class="n">vf</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">tsf</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span>
<span class="o">&lt;</span>
    <span class="n">Foam</span><span class="o">::</span><span class="n">GeometricField</span>
    <span class="o">&lt;</span>
        <span class="kr">typename</span> <span class="n">Foam</span><span class="o">::</span><span class="n">innerProduct</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">vector</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">,</span>
        <span class="n">Foam</span><span class="o">::</span><span class="n">fvsPatchField</span><span class="p">,</span>
        <span class="n">Foam</span><span class="o">::</span><span class="n">surfaceMesh</span>
    <span class="o">&gt;</span>
<span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">surfaceInterpolationScheme</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">dotInterpolate</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">surfaceVectorField</span><span class="o">&amp;</span> <span class="n">Sf</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">vf</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">surfaceInterpolation</span><span class="o">::</span><span class="n">debug</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">InfoInFunction</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;Interpolating &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">vf</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">vf</span><span class="p">.</span><span class="n">name</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot; from cells to faces&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">tmp</span>
    <span class="o">&lt;</span>
        <span class="n">GeometricField</span>
        <span class="o">&lt;</span>
            <span class="kr">typename</span> <span class="n">Foam</span><span class="o">::</span><span class="n">innerProduct</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">vector</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">,</span>
            <span class="n">fvsPatchField</span><span class="p">,</span>
            <span class="n">surfaceMesh</span>
        <span class="o">&gt;</span>
    <span class="o">&gt;</span> <span class="n">tsf</span> <span class="o">=</span> <span class="n">dotInterpolate</span><span class="p">(</span><span class="n">Sf</span><span class="p">,</span> <span class="n">vf</span><span class="p">,</span> <span class="n">weights</span><span class="p">(</span><span class="n">vf</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">corrected</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">tsf</span><span class="p">.</span><span class="n">ref</span><span class="p">()</span> <span class="o">+=</span> <span class="n">Sf</span> <span class="o">&amp;</span> <span class="n">correction</span><span class="p">(</span><span class="n">vf</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">tsf</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="linear">
<h4>linear<a class="headerlink" href="#linear" title="永久链接至标题">¶</a></h4>
<p>进入src/finiteVolume/interpolation/surfaceInterpolation/schemes/linear/linear.H文件，可以看到权重函数与网格有关，因此定义了中心差分离散：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="o">&gt;</span> <span class="n">weights</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">mesh</span><span class="p">().</span><span class="n">surfaceInterpolation</span><span class="o">::</span><span class="n">weights</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="cubic">
<h4>cubic<a class="headerlink" href="#cubic" title="永久链接至标题">¶</a></h4>
<p>该格式继承于linear格式，同样返回线性权重，但是使用了修正函数。进入src/finiteVolume/interpolation/surfaceInterpolation/schemes/cubic/cubic.H文件可以看到定义的修正函数：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">virtual</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvsPatchField</span><span class="p">,</span> <span class="n">surfaceMesh</span><span class="o">&gt;&gt;</span>
<span class="n">correction</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">vf</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">fvMesh</span><span class="o">&amp;</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">mesh</span><span class="p">();</span>

    <span class="c1">// calculate the appropriate interpolation factors</span>
    <span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">lambda</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">weights</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">surfaceScalarField</span> <span class="nf">kSc</span>
    <span class="p">(</span>
        <span class="n">lambda</span><span class="o">*</span><span class="p">(</span><span class="n">scalar</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">lambda</span><span class="o">*</span><span class="p">(</span><span class="n">scalar</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="n">scalar</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">lambda</span><span class="p">))</span>
    <span class="p">);</span>

    <span class="k">const</span> <span class="n">surfaceScalarField</span> <span class="nf">kVecP</span><span class="p">(</span><span class="n">sqr</span><span class="p">(</span><span class="n">scalar</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">lambda</span><span class="p">)</span><span class="o">*</span><span class="n">lambda</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">surfaceScalarField</span> <span class="nf">kVecN</span><span class="p">(</span><span class="n">sqr</span><span class="p">(</span><span class="n">lambda</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">lambda</span> <span class="o">-</span> <span class="n">scalar</span><span class="p">(</span><span class="mi">1</span><span class="p">)));</span>

    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvsPatchField</span><span class="p">,</span> <span class="n">surfaceMesh</span><span class="o">&gt;&gt;</span> <span class="n">tsfCorr</span>
    <span class="p">(</span>
        <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvsPatchField</span><span class="p">,</span> <span class="n">surfaceMesh</span><span class="o">&gt;::</span><span class="n">New</span>
        <span class="p">(</span>
            <span class="s">&quot;cubic::correction(&quot;</span> <span class="o">+</span> <span class="n">vf</span><span class="p">.</span><span class="n">name</span><span class="p">()</span> <span class="o">+</span><span class="sc">&#39;)&#39;</span><span class="p">,</span>
            <span class="n">surfaceInterpolationScheme</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">vf</span><span class="p">,</span> <span class="n">kSc</span><span class="p">,</span> <span class="o">-</span><span class="n">kSc</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">);</span>
    <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvsPatchField</span><span class="p">,</span> <span class="n">surfaceMesh</span><span class="o">&gt;&amp;</span> <span class="n">sfCorr</span> <span class="o">=</span> <span class="n">tsfCorr</span><span class="p">.</span><span class="n">ref</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">direction</span> <span class="n">cmpt</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">cmpt</span><span class="o">&lt;</span><span class="n">pTraits</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">nComponents</span><span class="p">;</span> <span class="n">cmpt</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">sfCorr</span><span class="p">.</span><span class="n">replace</span>
        <span class="p">(</span>
            <span class="n">cmpt</span><span class="p">,</span>
            <span class="n">sfCorr</span><span class="p">.</span><span class="n">component</span><span class="p">(</span><span class="n">cmpt</span><span class="p">)</span>
          <span class="o">+</span> <span class="p">(</span>
                <span class="n">surfaceInterpolationScheme</span>
                <span class="o">&lt;</span>
                    <span class="kr">typename</span> <span class="n">outerProduct</span>
                    <span class="o">&lt;</span>
                        <span class="n">vector</span><span class="p">,</span>
                        <span class="kr">typename</span> <span class="n">pTraits</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">cmptType</span>
                    <span class="o">&gt;::</span><span class="n">type</span>
                <span class="o">&gt;::</span><span class="n">interpolate</span>
                <span class="p">(</span>
                    <span class="n">fv</span><span class="o">::</span><span class="n">gaussGrad</span>
                    <span class="o">&lt;</span><span class="kr">typename</span> <span class="n">pTraits</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">cmptType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
                   <span class="p">.</span><span class="n">grad</span><span class="p">(</span><span class="n">vf</span><span class="p">.</span><span class="n">component</span><span class="p">(</span><span class="n">cmpt</span><span class="p">)),</span>
                    <span class="n">kVecP</span><span class="p">,</span>
                    <span class="n">kVecN</span>
                <span class="p">)</span> <span class="o">&amp;</span> <span class="n">mesh</span><span class="p">.</span><span class="n">Sf</span><span class="p">()</span>
            <span class="p">)</span><span class="o">/</span><span class="n">mesh</span><span class="p">.</span><span class="n">magSf</span><span class="p">()</span><span class="o">/</span><span class="n">mesh</span><span class="p">.</span><span class="n">surfaceInterpolation</span><span class="o">::</span><span class="n">deltaCoeffs</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="kr">typename</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvsPatchField</span><span class="p">,</span> <span class="n">surfaceMesh</span><span class="o">&gt;::</span><span class="n">Boundary</span><span class="o">&amp;</span> <span class="n">sfCorrbf</span> <span class="o">=</span> <span class="n">sfCorr</span><span class="p">.</span><span class="n">boundaryFieldRef</span><span class="p">();</span>

    <span class="n">forAll</span><span class="p">(</span><span class="n">sfCorrbf</span><span class="p">,</span> <span class="n">pi</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sfCorrbf</span><span class="p">[</span><span class="n">pi</span><span class="p">].</span><span class="n">coupled</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="n">sfCorrbf</span><span class="p">[</span><span class="n">pi</span><span class="p">]</span> <span class="o">=</span> <span class="n">Zero</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">tsfCorr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="downwind">
<h4>downwind<a class="headerlink" href="#downwind" title="永久链接至标题">¶</a></h4>
<p>进入src/finiteVolume/interpolation/surfaceInterpolation/schemes/downwind/downwind.H文件，可以看到该格式设置的权重函数为</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">virtual</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="o">&gt;</span> <span class="n">weights</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">neg</span><span class="p">(</span><span class="n">faceFlux_</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>其中neg的定义可以在src/OpenFOAM/primitives/Scalar/Scalar.H文件中看到：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">neg</span><span class="p">(</span><span class="k">const</span> <span class="n">Scalar</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">s</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>因此downwind格式设置的权重表达式为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\lambda = \left \{\begin{array}{l}
1, \quad \text{flux} &lt; 0 \\
0, \quad \text{flux} \ge 0
\end{array}\right .
\end{align}\end{split}\]</div>
</div>
<div class="section" id="upwind">
<h4>upwind<a class="headerlink" href="#upwind" title="永久链接至标题">¶</a></h4>
<p>进入src/finiteVolume/interpolation/surfaceInterpolation/limitedSchemes/upwind/upwind.H文件，可以看到该格式设置的权重函数为</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="o">&gt;</span> <span class="n">weights</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">pos0</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">faceFlux_</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>其中pos0的定义可以在src/OpenFOAM/primitives/Scalar/Scalar.H文件中看到：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pos0</span><span class="p">(</span><span class="k">const</span> <span class="n">Scalar</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">s</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>因此upwind格式设置的权重表达式为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\lambda = \left \{\begin{array}{l}
1, \quad \text{flux} \ge 0 \\
0, \quad \text{flux &lt; 0}
\end{array}\right .
\end{align}\end{split}\]</div>
</div>
<div class="section" id="linearupwind">
<h4>linearUpwind<a class="headerlink" href="#linearupwind" title="永久链接至标题">¶</a></h4>
<p>该格式继承于upwind格式，使用的权重函数相同，但是该格式启用了correction函数，并定义了自己修正函数，其定义的修正函数如下：</p>
<div class="literal-block-wrapper docutils container" id="id74">
<div class="code-block-caption"><span class="caption-text">src/finiteVolume/interpolation/surfaceInterpolation/schemes/linearUpwind/linearUpwind.C</span><a class="headerlink" href="#id74" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">surfaceVectorField</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">linearUpwind</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">vector</span><span class="o">&gt;::</span><span class="n">correction</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">volVectorField</span><span class="o">&amp;</span> <span class="n">vf</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">fvMesh</span><span class="o">&amp;</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">mesh</span><span class="p">();</span>

    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">surfaceVectorField</span><span class="o">&gt;</span> <span class="n">tsfCorr</span>    <span class="c1">// 创建修正项，是一个定义在网格面上的矢量场</span>
    <span class="p">(</span>
        <span class="n">surfaceVectorField</span><span class="o">::</span><span class="n">New</span>
        <span class="p">(</span>
            <span class="s">&quot;linearUpwind::correction(&quot;</span> <span class="o">+</span> <span class="n">vf</span><span class="p">.</span><span class="n">name</span><span class="p">()</span> <span class="o">+</span> <span class="sc">&#39;)&#39;</span><span class="p">,</span>
            <span class="n">mesh</span><span class="p">,</span>
            <span class="n">dimensioned</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&gt;</span><span class="p">(</span><span class="n">vf</span><span class="p">.</span><span class="n">name</span><span class="p">(),</span> <span class="n">vf</span><span class="p">.</span><span class="n">dimensions</span><span class="p">(),</span> <span class="n">Zero</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">);</span>

    <span class="n">surfaceVectorField</span><span class="o">&amp;</span> <span class="n">sfCorr</span> <span class="o">=</span> <span class="n">tsfCorr</span><span class="p">.</span><span class="n">ref</span><span class="p">();</span>    <span class="c1">// 通过创建引用来后续修改修正项的值</span>

    <span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">faceFlux</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">faceFlux_</span><span class="p">;</span>    <span class="c1">// 面通量</span>

    <span class="k">const</span> <span class="n">labelList</span><span class="o">&amp;</span> <span class="n">owner</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">owner</span><span class="p">();</span>    <span class="c1">// 当前网格的label</span>
    <span class="k">const</span> <span class="n">labelList</span><span class="o">&amp;</span> <span class="n">neighbour</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">neighbour</span><span class="p">();</span>    <span class="c1">// 相邻网格的label</span>

    <span class="k">const</span> <span class="n">volVectorField</span><span class="o">&amp;</span> <span class="n">C</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">C</span><span class="p">();</span>    <span class="c1">// 网格中心位置矢量</span>
    <span class="k">const</span> <span class="n">surfaceVectorField</span><span class="o">&amp;</span> <span class="n">Cf</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">Cf</span><span class="p">();</span>    <span class="c1">// 网格面心位置矢量</span>

    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">fv</span><span class="o">::</span><span class="n">gradScheme</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&gt;&gt;</span> <span class="n">gradScheme_</span>
    <span class="p">(</span>
        <span class="n">fv</span><span class="o">::</span><span class="n">gradScheme</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&gt;::</span><span class="n">New</span>
        <span class="p">(</span>
            <span class="n">mesh</span><span class="p">,</span>
            <span class="n">mesh</span><span class="p">.</span><span class="n">schemes</span><span class="p">().</span><span class="n">grad</span><span class="p">(</span><span class="n">gradSchemeName_</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">);</span>

    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volTensorField</span><span class="o">&gt;</span> <span class="n">tgradVf</span> <span class="o">=</span> <span class="n">gradScheme_</span><span class="p">().</span><span class="n">grad</span><span class="p">(</span><span class="n">vf</span><span class="p">,</span> <span class="n">gradSchemeName_</span><span class="p">);</span>    <span class="c1">// 通过gradScheme确定的方式获取体心的梯度值</span>
    <span class="k">const</span> <span class="n">volTensorField</span><span class="o">&amp;</span> <span class="n">gradVf</span> <span class="o">=</span> <span class="n">tgradVf</span><span class="p">();</span>    <span class="c1">// 存储通过tmp建立的梯度值</span>

    <span class="n">forAll</span><span class="p">(</span><span class="n">faceFlux</span><span class="p">,</span> <span class="n">facei</span><span class="p">)</span>    <span class="c1">// 计算内部场的修正项</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">label</span> <span class="n">celli</span> <span class="o">=</span> <span class="p">(</span><span class="n">faceFlux</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">owner</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="o">:</span> <span class="n">neighbour</span><span class="p">[</span><span class="n">facei</span><span class="p">];</span>
        <span class="n">sfCorr</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Cf</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="n">celli</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">gradVf</span><span class="p">[</span><span class="n">celli</span><span class="p">];</span>
    <span class="p">}</span>


    <span class="kr">typename</span> <span class="n">surfaceVectorField</span><span class="o">::</span><span class="n">Boundary</span><span class="o">&amp;</span> <span class="n">bSfCorr</span> <span class="o">=</span> <span class="n">sfCorr</span><span class="p">.</span><span class="n">boundaryFieldRef</span><span class="p">();</span>    <span class="c1">// 边界处的修正项的值</span>

    <span class="n">forAll</span><span class="p">(</span><span class="n">bSfCorr</span><span class="p">,</span> <span class="n">patchi</span><span class="p">)</span>    <span class="c1">// 当使用coupled类型边界时，计算边界处的修正项</span>
    <span class="p">{</span>
        <span class="n">fvsPatchVectorField</span><span class="o">&amp;</span> <span class="n">pSfCorr</span> <span class="o">=</span> <span class="n">bSfCorr</span><span class="p">[</span><span class="n">patchi</span><span class="p">];</span>    <span class="c1">// 每个边界处网格的值</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">pSfCorr</span><span class="p">.</span><span class="n">coupled</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">const</span> <span class="n">labelUList</span><span class="o">&amp;</span> <span class="n">pOwner</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">boundary</span><span class="p">()[</span><span class="n">patchi</span><span class="p">].</span><span class="n">faceCells</span><span class="p">();</span>     <span class="c1">// 边界处网格的label</span>
            <span class="k">const</span> <span class="n">vectorField</span><span class="o">&amp;</span> <span class="n">pCf</span> <span class="o">=</span> <span class="n">Cf</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">];</span>                <span class="c1">// 边界处网格面心位置矢量</span>
            <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">pFaceFlux</span> <span class="o">=</span> <span class="n">faceFlux</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">];</span>    <span class="c1">// 边界网格面通量</span>

            <span class="k">const</span> <span class="n">tensorField</span> <span class="n">pGradVfNei</span>    <span class="c1">// 相邻网格的梯度值</span>
            <span class="p">(</span>
                <span class="n">gradVf</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">].</span><span class="n">patchNeighbourField</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="c1">// Build the d-vectors</span>
            <span class="n">vectorField</span> <span class="nf">pd</span><span class="p">(</span><span class="n">Cf</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">].</span><span class="n">patch</span><span class="p">().</span><span class="n">delta</span><span class="p">());</span>    <span class="c1">// coupled边界面的距离矢量d</span>

            <span class="n">forAll</span><span class="p">(</span><span class="n">pOwner</span><span class="p">,</span> <span class="n">facei</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">label</span> <span class="n">own</span> <span class="o">=</span> <span class="n">pOwner</span><span class="p">[</span><span class="n">facei</span><span class="p">];</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">pFaceFlux</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>    <span class="c1">// 如果边界面通量为正</span>
                <span class="p">{</span>
                    <span class="n">pSfCorr</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pCf</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="n">own</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">gradVf</span><span class="p">[</span><span class="n">own</span><span class="p">];</span>
                <span class="p">}</span>
                <span class="k">else</span>    <span class="c1">// 如果边界面通量为负</span>
                <span class="p">{</span>
                    <span class="n">pSfCorr</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pCf</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="o">-</span> <span class="n">pd</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="n">own</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">pGradVfNei</span><span class="p">[</span><span class="n">facei</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">tsfCorr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>从上面的代码可以看到，修正项的表达式为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\text{correction} = \left \{\begin{array}{l}
(\mathbf{r}_{Cf} - \mathbf{r}_{C}) \cdot \nabla \phi_{C} ,\quad \text{flux} &gt; 0 \\
(\mathbf{r}_{Cf} - \mathbf{r}_{N}) \cdot \nabla \phi_{N} ,\quad \text{flux} \le 0
\end{array}\right .
\end{align}\end{split}\]</div>
<p>当使用了coupled边界条件时，边界处的修正项表达式为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\text{correction} = \left \{\begin{array}{l}
(\mathbf{r}_{Cfp} - \mathbf{r}_{C}) \cdot \nabla\phi_{C} ,\quad \text{flux}_{p} &gt; 0 \\
(\mathbf{r}_{Cfp} - \mathbf{d} - \mathbf{r}_{C}) \cdot \nabla\phi_{N} ,\quad \text{flux}_{p} \le 0
\end{array}\right .
\end{align}\end{split}\]</div>
<p>其中delta()函数的定义位于src/finiteVolume/fvMesh/fvPatches/basic/coupled/coupledFvPatch.C文件当中：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">vectorField</span><span class="o">&gt;</span> <span class="n">Foam</span><span class="o">::</span><span class="n">coupledFvPatch</span><span class="o">::</span><span class="n">delta</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">Cf</span><span class="p">()</span> <span class="o">-</span> <span class="n">Cn</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="nvd-tvd">
<h4>NVD/TVD格式<a class="headerlink" href="#nvd-tvd" title="永久链接至标题">¶</a></h4>
<p>参考 <a class="reference external" href="https://blog.csdn.net/weixin_43325228/article/details/126356303">OpenFOAM类库介绍（六）对流项高分辨率格式理论</a></p>
<p>OpenFOAM定义了limitedScheme类库来常见NVD/TVD有限权重因子，特定的插值格式则确定了各自的权重函数limiter。权重函数提供中心插值权重因子、面通量、单元和面梯度以及单元中心距离。limiter的使用方式如下所示：</p>
<div class="literal-block-wrapper docutils container" id="id75">
<div class="code-block-caption"><span class="caption-text">src/finiteVolume/interpolation/surfaceInterpolation/limitedSchemes/LimitedScheme/LimitedScheme.C</span><a class="headerlink" href="#id75" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="p">,</span> <span class="n">class</span> <span class="n">Limiter</span><span class="p">,</span> <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="n">class</span> <span class="n">LimitFunc</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">LimitedScheme</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">Limiter</span><span class="p">,</span> <span class="n">LimitFunc</span><span class="o">&gt;::</span><span class="n">calcLimiter</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">phi</span><span class="p">,</span>
    <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">limiterField</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">fvMesh</span><span class="o">&amp;</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">mesh</span><span class="p">();</span>

    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">GeometricField</span><span class="o">&lt;</span><span class="kr">typename</span> <span class="n">Limiter</span><span class="o">::</span><span class="n">phiType</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&gt;</span> <span class="n">tlPhi</span> <span class="o">=</span> <span class="n">LimitFunc</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">phi</span><span class="p">);</span>

    <span class="k">const</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="kr">typename</span> <span class="n">Limiter</span><span class="o">::</span><span class="n">phiType</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">lPhi</span> <span class="o">=</span> <span class="n">tlPhi</span><span class="p">();</span>

    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">GeometricField</span><span class="o">&lt;</span><span class="kr">typename</span> <span class="n">Limiter</span><span class="o">::</span><span class="n">gradPhiType</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&gt;</span> <span class="n">tgradc</span><span class="p">(</span><span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">lPhi</span><span class="p">));</span>
    <span class="k">const</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="kr">typename</span> <span class="n">Limiter</span><span class="o">::</span><span class="n">gradPhiType</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">gradc</span> <span class="o">=</span> <span class="n">tgradc</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">CDweights</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">surfaceInterpolation</span><span class="o">::</span><span class="n">weights</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">labelUList</span><span class="o">&amp;</span> <span class="n">owner</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">owner</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">labelUList</span><span class="o">&amp;</span> <span class="n">neighbour</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">neighbour</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">vectorField</span><span class="o">&amp;</span> <span class="n">C</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">C</span><span class="p">();</span>

    <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">pLim</span> <span class="o">=</span> <span class="n">limiterField</span><span class="p">.</span><span class="n">primitiveFieldRef</span><span class="p">();</span>

    <span class="n">forAll</span><span class="p">(</span><span class="n">pLim</span><span class="p">,</span> <span class="n">face</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">label</span> <span class="n">own</span> <span class="o">=</span> <span class="n">owner</span><span class="p">[</span><span class="n">face</span><span class="p">];</span>
        <span class="n">label</span> <span class="n">nei</span> <span class="o">=</span> <span class="n">neighbour</span><span class="p">[</span><span class="n">face</span><span class="p">];</span>

        <span class="n">pLim</span><span class="p">[</span><span class="n">face</span><span class="p">]</span> <span class="o">=</span> <span class="n">Limiter</span><span class="o">::</span><span class="n">limiter</span>
        <span class="p">(</span>
            <span class="n">CDweights</span><span class="p">[</span><span class="n">face</span><span class="p">],</span>
            <span class="n">this</span><span class="o">-&gt;</span><span class="n">faceFlux_</span><span class="p">[</span><span class="n">face</span><span class="p">],</span>
            <span class="n">lPhi</span><span class="p">[</span><span class="n">own</span><span class="p">],</span>
            <span class="n">lPhi</span><span class="p">[</span><span class="n">nei</span><span class="p">],</span>
            <span class="n">gradc</span><span class="p">[</span><span class="n">own</span><span class="p">],</span>
            <span class="n">gradc</span><span class="p">[</span><span class="n">nei</span><span class="p">],</span>
            <span class="n">C</span><span class="p">[</span><span class="n">nei</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="n">own</span><span class="p">]</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="kr">typename</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;::</span><span class="n">Boundary</span><span class="o">&amp;</span> <span class="n">bPhi</span> <span class="o">=</span> <span class="n">phi</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">();</span>

    <span class="n">surfaceScalarField</span><span class="o">::</span><span class="n">Boundary</span><span class="o">&amp;</span> <span class="n">bLim</span> <span class="o">=</span> <span class="n">limiterField</span><span class="p">.</span><span class="n">boundaryFieldRef</span><span class="p">();</span>

    <span class="n">forAll</span><span class="p">(</span><span class="n">bLim</span><span class="p">,</span> <span class="n">patchi</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">pLim</span> <span class="o">=</span> <span class="n">bLim</span><span class="p">[</span><span class="n">patchi</span><span class="p">];</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">bPhi</span><span class="p">[</span><span class="n">patchi</span><span class="p">].</span><span class="n">coupled</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">pCDweights</span> <span class="o">=</span> <span class="n">CDweights</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">];</span>
            <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">pFaceFlux</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">faceFlux_</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">];</span>

            <span class="k">const</span> <span class="n">Field</span><span class="o">&lt;</span><span class="kr">typename</span> <span class="n">Limiter</span><span class="o">::</span><span class="n">phiType</span><span class="o">&gt;</span> <span class="n">plPhiP</span>
            <span class="p">(</span>
                <span class="n">lPhi</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">].</span><span class="n">patchInternalField</span><span class="p">()</span>
            <span class="p">);</span>
            <span class="k">const</span> <span class="n">Field</span><span class="o">&lt;</span><span class="kr">typename</span> <span class="n">Limiter</span><span class="o">::</span><span class="n">phiType</span><span class="o">&gt;</span> <span class="n">plPhiN</span>
            <span class="p">(</span>
                <span class="n">lPhi</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">].</span><span class="n">patchNeighbourField</span><span class="p">()</span>
            <span class="p">);</span>
            <span class="k">const</span> <span class="n">Field</span><span class="o">&lt;</span><span class="kr">typename</span> <span class="n">Limiter</span><span class="o">::</span><span class="n">gradPhiType</span><span class="o">&gt;</span> <span class="n">pGradcP</span>
            <span class="p">(</span>
                <span class="n">gradc</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">].</span><span class="n">patchInternalField</span><span class="p">()</span>
            <span class="p">);</span>
            <span class="k">const</span> <span class="n">Field</span><span class="o">&lt;</span><span class="kr">typename</span> <span class="n">Limiter</span><span class="o">::</span><span class="n">gradPhiType</span><span class="o">&gt;</span> <span class="n">pGradcN</span>
            <span class="p">(</span>
                <span class="n">gradc</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">].</span><span class="n">patchNeighbourField</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="c1">// Build the d-vectors</span>
            <span class="n">vectorField</span> <span class="nf">pd</span><span class="p">(</span><span class="n">CDweights</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">].</span><span class="n">patch</span><span class="p">().</span><span class="n">delta</span><span class="p">());</span>

            <span class="n">forAll</span><span class="p">(</span><span class="n">pLim</span><span class="p">,</span> <span class="n">face</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">pLim</span><span class="p">[</span><span class="n">face</span><span class="p">]</span> <span class="o">=</span> <span class="n">Limiter</span><span class="o">::</span><span class="n">limiter</span>
                <span class="p">(</span>
                    <span class="n">pCDweights</span><span class="p">[</span><span class="n">face</span><span class="p">],</span>
                    <span class="n">pFaceFlux</span><span class="p">[</span><span class="n">face</span><span class="p">],</span>
                    <span class="n">plPhiP</span><span class="p">[</span><span class="n">face</span><span class="p">],</span>
                    <span class="n">plPhiN</span><span class="p">[</span><span class="n">face</span><span class="p">],</span>
                    <span class="n">pGradcP</span><span class="p">[</span><span class="n">face</span><span class="p">],</span>
                    <span class="n">pGradcN</span><span class="p">[</span><span class="n">face</span><span class="p">],</span>
                    <span class="n">pd</span><span class="p">[</span><span class="n">face</span><span class="p">]</span>
                <span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">pLim</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>权重函数通过如下方式来使用limiter进行计算：</p>
<div class="literal-block-wrapper docutils container" id="id76">
<div class="code-block-caption"><span class="caption-text">src/finiteVolume/interpolation/surfaceInterpolation/limitedSchemes/limitedSurfaceInterpolationScheme/limitedSurfaceInterpolationScheme.C</span><a class="headerlink" href="#id76" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">surfaceScalarField</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">limitedSurfaceInterpolationScheme</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">weights</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">phi</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">CDweights</span><span class="p">,</span>
    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="o">&gt;</span> <span class="n">tLimiter</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="c1">// Note that here the weights field is initialised as the limiter</span>
    <span class="c1">// from which the weight is calculated using the limiter value</span>
    <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">Weights</span> <span class="o">=</span> <span class="n">tLimiter</span><span class="p">.</span><span class="n">ref</span><span class="p">();</span>

    <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">pWeights</span> <span class="o">=</span> <span class="n">Weights</span><span class="p">.</span><span class="n">primitiveFieldRef</span><span class="p">();</span>    <span class="c1">// 初始化weight为limiter的值</span>

    <span class="n">forAll</span><span class="p">(</span><span class="n">pWeights</span><span class="p">,</span> <span class="n">face</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">pWeights</span><span class="p">[</span><span class="n">face</span><span class="p">]</span> <span class="o">=</span> <span class="n">pWeights</span><span class="p">[</span><span class="n">face</span><span class="p">]</span><span class="o">*</span><span class="n">CDweights</span><span class="p">[</span><span class="n">face</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">pWeights</span><span class="p">[</span><span class="n">face</span><span class="p">])</span><span class="o">*</span><span class="n">pos0</span><span class="p">(</span><span class="n">faceFlux_</span><span class="p">[</span><span class="n">face</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="n">surfaceScalarField</span><span class="o">::</span><span class="n">Boundary</span><span class="o">&amp;</span> <span class="n">bWeights</span> <span class="o">=</span> <span class="n">Weights</span><span class="p">.</span><span class="n">boundaryFieldRef</span><span class="p">();</span>

    <span class="n">forAll</span><span class="p">(</span><span class="n">bWeights</span><span class="p">,</span> <span class="n">patchi</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">pWeights</span> <span class="o">=</span> <span class="n">bWeights</span><span class="p">[</span><span class="n">patchi</span><span class="p">];</span>

        <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">pCDweights</span> <span class="o">=</span> <span class="n">CDweights</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">];</span>
        <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">pFaceFlux</span> <span class="o">=</span> <span class="n">faceFlux_</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">];</span>

        <span class="n">forAll</span><span class="p">(</span><span class="n">pWeights</span><span class="p">,</span> <span class="n">face</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">pWeights</span><span class="p">[</span><span class="n">face</span><span class="p">]</span> <span class="o">=</span> <span class="n">pWeights</span><span class="p">[</span><span class="n">face</span><span class="p">]</span><span class="o">*</span><span class="n">pCDweights</span><span class="p">[</span><span class="n">face</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">pWeights</span><span class="p">[</span><span class="n">face</span><span class="p">])</span><span class="o">*</span><span class="n">pos0</span><span class="p">(</span><span class="n">pFaceFlux</span><span class="p">[</span><span class="n">face</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">tLimiter</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>其中CDweights是使用中性差分得到的权重，用 <span class="math notranslate nohighlight">\(\lambda_{CD}\)</span> 来表示，于是权重的表达式为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\lambda = \left \{\begin{array}{l}
\lambda_{CD} \psi + (1 - \psi) ,\quad \text{flux} \ge 0 \\
\lambda_{CD} \psi ,\quad \text{flux} &lt; 0
\end{array}\right .
\end{align}\end{split}\]</div>
<p>将权重表达式代入到interpolate表达式中，即可得到NVD/TVD插值的通用表达式为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\phi_{f} = \left \{ \begin{array}{l}
\phi_{C} + \frac{\psi}{2}(\phi_{N} - \phi_{C}) ,\quad \text{flux} \ge 0 \\
\phi_{N} + \frac{\psi}{2}(\phi_{C} - \phi_{N}) ,\quad \text{flux} &lt; 0
\end{array} \right .
\end{align}\end{split}\]</div>
<p>其物理意义是非常明确的，第一项表示一阶迎风，即上游的体心物理量，由于一阶迎风有较大的数值粘性，第二项做出修正，该修正可以使数值粘性减小，最终达到二阶精度。通量限制器 <span class="math notranslate nohighlight">\(\psi\)</span> 的要求是：当物理量变化剧烈时返回一阶迎风格式，当物理量变化平缓时返回高阶格式。于是就需要引入一个无量纲数 <span class="math notranslate nohighlight">\(r\)</span> 来定量描述物理量变化是否剧烈。不同的高阶格式就是设计不同的 <span class="math notranslate nohighlight">\(\psi(r)\)</span> 函数。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">upwind格式也有定义 <span class="math notranslate nohighlight">\(\psi\)</span> ，只不过是均匀的0场。</p>
</div>
<p>上面参数 <span class="math notranslate nohighlight">\(r\)</span> 的一般定义为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
r = \frac{\phi_{C} - \phi_{\text{up}}}{\phi_{\text{down}} - \phi_{C}}
\end{align}\]</div>
<p>其中下标C表示所考察面的上游网格单元，up表示C的上游单元，down表示C的下游单元。对于非结构网格，我们可以很容易知道C和down单元，但是很难知道up单元是哪个，所以需要用线性近似的方式得到 <span class="math notranslate nohighlight">\(\phi_{\text{up}}\)</span> 的值：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\phi_{\text{up} } = \phi_{\text{down} } - 2d_{C-\text{down}}\cdot (\nabla \phi)_{C}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(d\)</span> 是一个距离矢量，从C的体心指向down的体心。将上式代入 <span class="math notranslate nohighlight">\(r\)</span> 的表达式则得到</p>
<div class="math notranslate nohighlight">
\[\begin{align}
r = \frac{2d_{C-\text{down}}\cdot (\nabla\phi)_{C}}{\phi_{\text{down} } - \phi_{C}} - 1
\end{align}\]</div>
<p>因此，在使用OpenFOAM的网格格式来表示则为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
r = \left \{\begin{array}{l}
\frac{2d_{CN} \cdot (\nabla\phi)_{O}}{\phi_{C} - \phi_{N}} - 1 ,\quad \text{flux}\ge 0 \\
\frac{2d_{CN} \cdot (\nabla\phi)_{N}}{\phi_{N} - \phi_{C}} - 1 ,\quad \text{flux} &lt; 0
\end{array}\right .
\end{align}\end{split}\]</div>
<p>该函数r()的定义位于src/finiteVolume/interpolation/surfaceInterpolation/limitedSchemes/LimitedScheme/NVDTVD.H文件中：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">scalar</span> <span class="nf">r</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">faceFlux</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">phiP</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">phiN</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&amp;</span> <span class="n">gradcP</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&amp;</span> <span class="n">gradcN</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&amp;</span> <span class="n">d</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">scalar</span> <span class="n">gradf</span> <span class="o">=</span> <span class="n">phiN</span> <span class="o">-</span> <span class="n">phiP</span><span class="p">;</span>

    <span class="n">scalar</span> <span class="n">gradcf</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">faceFlux</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">gradcf</span> <span class="o">=</span> <span class="n">d</span> <span class="o">&amp;</span> <span class="n">gradcP</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">gradcf</span> <span class="o">=</span> <span class="n">d</span> <span class="o">&amp;</span> <span class="n">gradcN</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">mag</span><span class="p">(</span><span class="n">gradcf</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1000</span><span class="o">*</span><span class="n">mag</span><span class="p">(</span><span class="n">gradf</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="mi">1000</span><span class="o">*</span><span class="n">sign</span><span class="p">(</span><span class="n">gradcf</span><span class="p">)</span><span class="o">*</span><span class="n">sign</span><span class="p">(</span><span class="n">gradf</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">gradcf</span><span class="o">/</span><span class="n">gradf</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="minmod">
<h4>Minmod<a class="headerlink" href="#minmod" title="永久链接至标题">¶</a></h4>
<p>进入src/finiteVolume/interpolation/surfaceInterpolation/limitedSchemes/Minmod/Minmod.H文件可以看到Minmod格式的限制器的定义：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">scalar</span> <span class="nf">limiter</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">cdWeight</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">faceFlux</span><span class="p">,</span>
    <span class="k">const</span> <span class="kr">typename</span> <span class="n">LimiterFunc</span><span class="o">::</span><span class="n">phiType</span><span class="o">&amp;</span> <span class="n">phiP</span><span class="p">,</span>
    <span class="k">const</span> <span class="kr">typename</span> <span class="n">LimiterFunc</span><span class="o">::</span><span class="n">phiType</span><span class="o">&amp;</span> <span class="n">phiN</span><span class="p">,</span>
    <span class="k">const</span> <span class="kr">typename</span> <span class="n">LimiterFunc</span><span class="o">::</span><span class="n">gradPhiType</span><span class="o">&amp;</span> <span class="n">gradcP</span><span class="p">,</span>
    <span class="k">const</span> <span class="kr">typename</span> <span class="n">LimiterFunc</span><span class="o">::</span><span class="n">gradPhiType</span><span class="o">&amp;</span> <span class="n">gradcN</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&amp;</span> <span class="n">d</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">scalar</span> <span class="n">r</span> <span class="o">=</span> <span class="n">LimiterFunc</span><span class="o">::</span><span class="n">r</span>
    <span class="p">(</span>
        <span class="n">faceFlux</span><span class="p">,</span> <span class="n">phiP</span><span class="p">,</span> <span class="n">phiN</span><span class="p">,</span> <span class="n">gradcP</span><span class="p">,</span> <span class="n">gradcN</span><span class="p">,</span> <span class="n">d</span>
    <span class="p">);</span>

    <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="vanleer">
<h4>vanLeer<a class="headerlink" href="#vanleer" title="永久链接至标题">¶</a></h4>
<p>进入src/finiteVolume/interpolation/surfaceInterpolation/limitedSchemes/vanLeer/vanLeer.H文件可以看到vanLeer格式的限制器的定义：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">scalar</span> <span class="nf">limiter</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">faceFlux</span><span class="p">,</span>
    <span class="k">const</span> <span class="kr">typename</span> <span class="n">LimiterFunc</span><span class="o">::</span><span class="n">phiType</span><span class="o">&amp;</span> <span class="n">phiP</span><span class="p">,</span>
    <span class="k">const</span> <span class="kr">typename</span> <span class="n">LimiterFunc</span><span class="o">::</span><span class="n">phiType</span><span class="o">&amp;</span> <span class="n">phiN</span><span class="p">,</span>
    <span class="k">const</span> <span class="kr">typename</span> <span class="n">LimiterFunc</span><span class="o">::</span><span class="n">gradPhiType</span><span class="o">&amp;</span> <span class="n">gradcP</span><span class="p">,</span>
    <span class="k">const</span> <span class="kr">typename</span> <span class="n">LimiterFunc</span><span class="o">::</span><span class="n">gradPhiType</span><span class="o">&amp;</span> <span class="n">gradcN</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&amp;</span> <span class="n">d</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">scalar</span> <span class="n">r</span> <span class="o">=</span> <span class="n">LimiterFunc</span><span class="o">::</span><span class="n">r</span>
    <span class="p">(</span>
        <span class="n">faceFlux</span><span class="p">,</span> <span class="n">phiP</span><span class="p">,</span> <span class="n">phiN</span><span class="p">,</span> <span class="n">gradcP</span><span class="p">,</span> <span class="n">gradcN</span><span class="p">,</span> <span class="n">d</span>
    <span class="p">);</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="n">mag</span><span class="p">(</span><span class="n">r</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">mag</span><span class="p">(</span><span class="n">r</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="muscl">
<h4>MUSCL<a class="headerlink" href="#muscl" title="永久链接至标题">¶</a></h4>
<p>进入src/finiteVolume/interpolation/surfaceInterpolation/limitedSchemes/MUSCL/MUSCL.H文件可以看到MUSCL格式的限制器的定义：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">scalar</span> <span class="nf">limiter</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">cdWeight</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">faceFlux</span><span class="p">,</span>
    <span class="k">const</span> <span class="kr">typename</span> <span class="n">LimiterFunc</span><span class="o">::</span><span class="n">phiType</span><span class="o">&amp;</span> <span class="n">phiP</span><span class="p">,</span>
    <span class="k">const</span> <span class="kr">typename</span> <span class="n">LimiterFunc</span><span class="o">::</span><span class="n">phiType</span><span class="o">&amp;</span> <span class="n">phiN</span><span class="p">,</span>
    <span class="k">const</span> <span class="kr">typename</span> <span class="n">LimiterFunc</span><span class="o">::</span><span class="n">gradPhiType</span><span class="o">&amp;</span> <span class="n">gradcP</span><span class="p">,</span>
    <span class="k">const</span> <span class="kr">typename</span> <span class="n">LimiterFunc</span><span class="o">::</span><span class="n">gradPhiType</span><span class="o">&amp;</span> <span class="n">gradcN</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&amp;</span> <span class="n">d</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">scalar</span> <span class="n">r</span> <span class="o">=</span> <span class="n">LimiterFunc</span><span class="o">::</span><span class="n">r</span>
    <span class="p">(</span>
        <span class="n">faceFlux</span><span class="p">,</span> <span class="n">phiP</span><span class="p">,</span> <span class="n">phiN</span><span class="p">,</span> <span class="n">gradcP</span><span class="p">,</span> <span class="n">gradcN</span><span class="p">,</span> <span class="n">d</span>
    <span class="p">);</span>

    <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">r</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">),</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="ospre">
<h4>OSPRE<a class="headerlink" href="#ospre" title="永久链接至标题">¶</a></h4>
<p>进入src/finiteVolume/interpolation/surfaceInterpolation/limitedSchemes/OSPRE/OSPRE.H文件可以看到OSPRE格式的限制器的定义：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">scalar</span> <span class="nf">limiter</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">cdWeight</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">faceFlux</span><span class="p">,</span>
    <span class="k">const</span> <span class="kr">typename</span> <span class="n">LimiterFunc</span><span class="o">::</span><span class="n">phiType</span><span class="o">&amp;</span> <span class="n">phiP</span><span class="p">,</span>
    <span class="k">const</span> <span class="kr">typename</span> <span class="n">LimiterFunc</span><span class="o">::</span><span class="n">phiType</span><span class="o">&amp;</span> <span class="n">phiN</span><span class="p">,</span>
    <span class="k">const</span> <span class="kr">typename</span> <span class="n">LimiterFunc</span><span class="o">::</span><span class="n">gradPhiType</span><span class="o">&amp;</span> <span class="n">gradcP</span><span class="p">,</span>
    <span class="k">const</span> <span class="kr">typename</span> <span class="n">LimiterFunc</span><span class="o">::</span><span class="n">gradPhiType</span><span class="o">&amp;</span> <span class="n">gradcN</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&amp;</span> <span class="n">d</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">r</span> <span class="o">=</span> <span class="n">max</span>
    <span class="p">(</span>
        <span class="n">LimiterFunc</span><span class="o">::</span><span class="n">r</span><span class="p">(</span><span class="n">faceFlux</span><span class="p">,</span> <span class="n">phiP</span><span class="p">,</span> <span class="n">phiN</span><span class="p">,</span> <span class="n">gradcP</span><span class="p">,</span> <span class="n">gradcN</span><span class="p">,</span> <span class="n">d</span><span class="p">),</span> <span class="mi">0</span>
    <span class="p">);</span>

    <span class="k">const</span> <span class="n">scalar</span> <span class="n">rrp1</span> <span class="o">=</span> <span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

    <span class="k">return</span> <span class="mf">1.5</span><span class="o">*</span><span class="n">rrp1</span><span class="o">/</span><span class="p">(</span><span class="n">rrp1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="quick">
<h4>QUICK<a class="headerlink" href="#quick" title="永久链接至标题">¶</a></h4>
<p>进入src/finiteVolume/interpolation/surfaceInterpolation/limitedSchemes/QUICK/QUICK.H文件可以看到MUSCL格式的限制器的定义，值得注意的是QUICK格式没有使用r来定义自己的limiter，而是从头开始定义：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">scalar</span> <span class="nf">limiter</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">cdWeight</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">faceFlux</span><span class="p">,</span>
    <span class="k">const</span> <span class="kr">typename</span> <span class="n">LimiterFunc</span><span class="o">::</span><span class="n">phiType</span><span class="o">&amp;</span> <span class="n">phiP</span><span class="p">,</span>
    <span class="k">const</span> <span class="kr">typename</span> <span class="n">LimiterFunc</span><span class="o">::</span><span class="n">phiType</span><span class="o">&amp;</span> <span class="n">phiN</span><span class="p">,</span>
    <span class="k">const</span> <span class="kr">typename</span> <span class="n">LimiterFunc</span><span class="o">::</span><span class="n">gradPhiType</span><span class="o">&amp;</span> <span class="n">gradcP</span><span class="p">,</span>
    <span class="k">const</span> <span class="kr">typename</span> <span class="n">LimiterFunc</span><span class="o">::</span><span class="n">gradPhiType</span><span class="o">&amp;</span> <span class="n">gradcN</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&amp;</span> <span class="n">d</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">scalar</span> <span class="n">phiCD</span> <span class="o">=</span> <span class="n">cdWeight</span><span class="o">*</span><span class="n">phiP</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cdWeight</span><span class="p">)</span><span class="o">*</span><span class="n">phiN</span><span class="p">;</span>

    <span class="n">scalar</span> <span class="n">phiU</span><span class="p">,</span> <span class="n">phif</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">faceFlux</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">phiU</span> <span class="o">=</span> <span class="n">phiP</span><span class="p">;</span>
        <span class="n">phif</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">phiCD</span> <span class="o">+</span> <span class="n">phiP</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cdWeight</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">d</span> <span class="o">&amp;</span> <span class="n">gradcP</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">phiU</span> <span class="o">=</span> <span class="n">phiN</span><span class="p">;</span>
        <span class="n">phif</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">phiCD</span> <span class="o">+</span> <span class="n">phiN</span> <span class="o">-</span> <span class="n">cdWeight</span><span class="o">*</span><span class="p">(</span><span class="n">d</span> <span class="o">&amp;</span> <span class="n">gradcN</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="c1">// Calculate the effective limiter for the QUICK interpolation</span>
    <span class="n">scalar</span> <span class="n">QLimiter</span> <span class="o">=</span> <span class="p">(</span><span class="n">phif</span> <span class="o">-</span> <span class="n">phiU</span><span class="p">)</span><span class="o">/</span><span class="n">stabilise</span><span class="p">(</span><span class="n">phiCD</span> <span class="o">-</span> <span class="n">phiU</span><span class="p">,</span> <span class="n">small</span><span class="p">);</span>

    <span class="c1">// Limit the limiter between upwind and downwind</span>
    <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">QLimiter</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="umist">
<h4>UMIST<a class="headerlink" href="#umist" title="永久链接至标题">¶</a></h4>
<p>进入src/finiteVolume/interpolation/surfaceInterpolation/limitedSchemes/UMIST/UMIST.H文件可以看到OSPRE格式的限制器的定义：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">scalar</span> <span class="nf">limiter</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">cdWeight</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">faceFlux</span><span class="p">,</span>
    <span class="k">const</span> <span class="kr">typename</span> <span class="n">LimiterFunc</span><span class="o">::</span><span class="n">phiType</span><span class="o">&amp;</span> <span class="n">phiP</span><span class="p">,</span>
    <span class="k">const</span> <span class="kr">typename</span> <span class="n">LimiterFunc</span><span class="o">::</span><span class="n">phiType</span><span class="o">&amp;</span> <span class="n">phiN</span><span class="p">,</span>
    <span class="k">const</span> <span class="kr">typename</span> <span class="n">LimiterFunc</span><span class="o">::</span><span class="n">gradPhiType</span><span class="o">&amp;</span> <span class="n">gradcP</span><span class="p">,</span>
    <span class="k">const</span> <span class="kr">typename</span> <span class="n">LimiterFunc</span><span class="o">::</span><span class="n">gradPhiType</span><span class="o">&amp;</span> <span class="n">gradcN</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&amp;</span> <span class="n">d</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">scalar</span> <span class="n">r</span> <span class="o">=</span> <span class="n">LimiterFunc</span><span class="o">::</span><span class="n">r</span>
    <span class="p">(</span>
        <span class="n">faceFlux</span><span class="p">,</span> <span class="n">phiP</span><span class="p">,</span> <span class="n">phiN</span><span class="p">,</span> <span class="n">gradcP</span><span class="p">,</span> <span class="n">gradcN</span><span class="p">,</span> <span class="n">d</span>
    <span class="p">);</span>

    <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="mf">0.75</span><span class="o">*</span><span class="n">r</span> <span class="o">+</span> <span class="mf">0.25</span><span class="p">),</span> <span class="mf">0.25</span><span class="o">*</span><span class="n">r</span> <span class="o">+</span> <span class="mf">0.75</span><span class="p">),</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="sngradschemes">
<h3>面法向梯度格式snGradSchemes<a class="headerlink" href="#sngradschemes" title="永久链接至标题">¶</a></h3>
<p>面法向梯度指的是变量场梯度在面 <span class="math notranslate nohighlight">\(f\)</span> 处的法向分量，一般需要在单独计算面法向梯度 <span class="math notranslate nohighlight">\(\nabla_{f}\cdot \mathbf{A}_{f}\)</span> 或者指定拉普拉斯项 <span class="math notranslate nohighlight">\(\nabla^{2}\cdot\)</span> 离散格式时指定面法向梯度格式。支持的标准格式有：</p>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="62%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">面法向梯度格式</th>
<th class="head">含义</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>corrected</td>
<td>显示非正交修正格式</td>
</tr>
<tr class="row-odd"><td>uncorrected</td>
<td>无非正交修正格式</td>
</tr>
<tr class="row-even"><td>limited</td>
<td>非完全正交修正格式</td>
</tr>
<tr class="row-odd"><td>bounded</td>
<td>对正值标量的有界修正格式</td>
</tr>
<tr class="row-even"><td>fourth</td>
<td>四阶格式</td>
</tr>
</tbody>
</table>
<p>特别地，非完全正交修正格式limited需要指定系数 <span class="math notranslate nohighlight">\(\psi\)</span> ，其值介于0和1之间：</p>
<ul class="simple">
<li>取值为0时，无非正交修正；</li>
<li>取值为0.333时，限制非正交修正部分不超过正交部分的一半；</li>
<li>取值为0.5时，限制非正交修正部分不超过正交部分；</li>
<li>取值为1时，不限制非正交修正部分，等同于corrected格式。</li>
</ul>
<p>下面是一些具体的设置案例：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">default</span>         <span class="n">corrected</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="ddtschemes">
<h3>时间一阶导项格式ddtSchemes<a class="headerlink" href="#ddtschemes" title="永久链接至标题">¶</a></h3>
<p>时间一阶导项 <span class="math notranslate nohighlight">\(\frac{\partial}{\partial t}\)</span> 格式支持的标准格式有：</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">时间一阶导项格式</th>
<th class="head">含义</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>backward</td>
<td>二阶向后差分格式(BDS2)，隐式</td>
</tr>
<tr class="row-odd"><td>bounded</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>CoEuler</td>
<td>一阶，可控制局部库朗数</td>
</tr>
<tr class="row-odd"><td>CrankNicolson</td>
<td>二阶精度，有界，隐式</td>
</tr>
<tr class="row-even"><td>Euler</td>
<td>一阶精度，有界，隐式</td>
</tr>
<tr class="row-odd"><td>localEuler</td>
<td>局部时间步，一阶精度，有界，隐式</td>
</tr>
<tr class="row-even"><td>SLTS</td>
<td>稳定局部时间步一阶欧拉隐式/显式</td>
</tr>
<tr class="row-odd"><td>steadyState</td>
<td>定常，忽略时间导数项</td>
</tr>
</tbody>
</table>
<div class="section" id="backward">
<h4>backward<a class="headerlink" href="#backward" title="永久链接至标题">¶</a></h4>
<p>该格式使用当前和前两个时间步长来得到二阶时间精度。进入src/finiteVolume/finiteVolume/ddtSchemes/backwardDdtScheme/backwardDdtScheme.C文件可以看到</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">tmp</span><span class="o">&lt;</span><span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&gt;</span>
<span class="n">backwardDdtScheme</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">fvcDdt</span>    <span class="c1">// fvc::ddt(phi)的类型</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">vf</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">dimensionedScalar</span> <span class="n">rDeltaT</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">mesh</span><span class="p">().</span><span class="n">time</span><span class="p">().</span><span class="n">deltaT</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">word</span> <span class="nf">ddtName</span><span class="p">(</span><span class="s">&quot;ddt(&quot;</span><span class="o">+</span><span class="n">vf</span><span class="p">.</span><span class="n">name</span><span class="p">()</span><span class="o">+</span><span class="sc">&#39;)&#39;</span><span class="p">);</span>

    <span class="k">const</span> <span class="n">scalar</span> <span class="n">deltaT</span> <span class="o">=</span> <span class="n">deltaT_</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">deltaT0</span> <span class="o">=</span> <span class="n">deltaT0_</span><span class="p">(</span><span class="n">vf</span><span class="p">);</span>

    <span class="k">const</span> <span class="n">scalar</span> <span class="n">coefft</span>   <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">deltaT</span><span class="o">/</span><span class="p">(</span><span class="n">deltaT</span> <span class="o">+</span> <span class="n">deltaT0</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">coefft00</span> <span class="o">=</span> <span class="n">deltaT</span><span class="o">*</span><span class="n">deltaT</span><span class="o">/</span><span class="p">(</span><span class="n">deltaT0</span><span class="o">*</span><span class="p">(</span><span class="n">deltaT</span> <span class="o">+</span> <span class="n">deltaT0</span><span class="p">));</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">coefft0</span>  <span class="o">=</span> <span class="n">coefft</span> <span class="o">+</span> <span class="n">coefft00</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">mesh</span><span class="p">().</span><span class="n">moving</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&gt;</span>
        <span class="p">(</span>
            <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;::</span><span class="n">New</span>
            <span class="p">(</span>
                <span class="n">ddtName</span><span class="p">,</span>
                <span class="n">rDeltaT</span><span class="o">*</span>
                <span class="p">(</span>
                    <span class="n">coefft</span><span class="o">*</span><span class="n">vf</span><span class="p">()</span> <span class="o">-</span>
                    <span class="p">(</span>
                        <span class="n">coefft0</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">()()</span><span class="o">*</span><span class="n">mesh</span><span class="p">().</span><span class="n">V0</span><span class="p">()</span>
                      <span class="o">-</span> <span class="n">coefft00</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">oldTime</span><span class="p">()()</span>
                       <span class="o">*</span><span class="n">mesh</span><span class="p">().</span><span class="n">V00</span><span class="p">()</span>
                    <span class="p">)</span><span class="o">/</span><span class="n">mesh</span><span class="p">().</span><span class="n">V</span><span class="p">()</span>
                <span class="p">),</span>
                <span class="n">rDeltaT</span><span class="p">.</span><span class="n">value</span><span class="p">()</span><span class="o">*</span>
                <span class="p">(</span>
                    <span class="n">coefft</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()</span> <span class="o">-</span>
                    <span class="p">(</span>
                        <span class="n">coefft0</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">boundaryField</span><span class="p">()</span>
                      <span class="o">-</span> <span class="n">coefft00</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">oldTime</span><span class="p">().</span><span class="n">boundaryField</span><span class="p">()</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&gt;</span>
        <span class="p">(</span>
            <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;::</span><span class="n">New</span>
            <span class="p">(</span>
                <span class="n">ddtName</span><span class="p">,</span>
                <span class="n">rDeltaT</span><span class="o">*</span>
                <span class="p">(</span>
                    <span class="n">coefft</span><span class="o">*</span><span class="n">vf</span>
                  <span class="o">-</span> <span class="n">coefft0</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">()</span>
                  <span class="o">+</span> <span class="n">coefft00</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">oldTime</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>从上面的代码可以看到，对于静网格的情况，计算方式为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\partial \phi}{\partial t} =
\frac{1}{\Delta t}\Big( A\phi - B\phi_{\text{old}} + C\phi_{\text{oldold}} \Big)
\end{align}\]</div>
<p>对于动网格的情况，计算方式为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\partial \phi}{\partial t} =
\frac{1}{\Delta t}\Big( A\phi - \frac{1}{V} (B\phi_{\text{old}}V_{\text{old}} - C\phi_{\text{oldold}}V_{\text{oldold}}) \Big)
\end{align}\]</div>
<p>其中各系数的计算方式为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; A = 1 + \frac{\Delta t}{\Delta t + \Delta t_{\text{old}}} \\
&amp; B = A + C = 1 + \frac{\Delta t}{\Delta t + \Delta t_{\text{old}}} + \frac{\Delta t^{2}}{\Delta t_{\text{old}} \cdot (\Delta t + \Delta t_{\text{old}})} \\
&amp; C = \frac{\Delta t^{2}}{\Delta t_{\text{old}} \cdot (\Delta t + \Delta t_{\text{old}})}
\end{align}\end{split}\]</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>对于恒定时间步长的情况就化简为了经典backward(SOU)格式：</p>
<div class="last math notranslate nohighlight">
\[\begin{align}
\frac{\partial \phi}{\partial t} = \frac{3\phi - 4\phi_{\text{old}} + \phi_{\text{oldold}}}{2\Delta t}
\end{align}\]</div>
</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">tmp</span><span class="o">&lt;</span><span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">backwardDdtScheme</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">fvmDdt</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">vf</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span> <span class="n">tfvm</span>
    <span class="p">(</span>
        <span class="n">new</span> <span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span>
        <span class="p">(</span>
            <span class="n">vf</span><span class="p">,</span>
            <span class="n">vf</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()</span><span class="o">*</span><span class="n">dimVol</span><span class="o">/</span><span class="n">dimTime</span>
        <span class="p">)</span>
    <span class="p">);</span>

    <span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&amp;</span> <span class="n">fvm</span> <span class="o">=</span> <span class="n">tfvm</span><span class="p">.</span><span class="n">ref</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">scalar</span> <span class="n">rDeltaT</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">deltaT_</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">scalar</span> <span class="n">deltaT</span> <span class="o">=</span> <span class="n">deltaT_</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">deltaT0</span> <span class="o">=</span> <span class="n">deltaT0_</span><span class="p">(</span><span class="n">vf</span><span class="p">);</span>

    <span class="k">const</span> <span class="n">scalar</span> <span class="n">coefft</span>   <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">deltaT</span><span class="o">/</span><span class="p">(</span><span class="n">deltaT</span> <span class="o">+</span> <span class="n">deltaT0</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">coefft00</span> <span class="o">=</span> <span class="n">deltaT</span><span class="o">*</span><span class="n">deltaT</span><span class="o">/</span><span class="p">(</span><span class="n">deltaT0</span><span class="o">*</span><span class="p">(</span><span class="n">deltaT</span> <span class="o">+</span> <span class="n">deltaT0</span><span class="p">));</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">coefft0</span>  <span class="o">=</span> <span class="n">coefft</span> <span class="o">+</span> <span class="n">coefft00</span><span class="p">;</span>

    <span class="n">fvm</span><span class="p">.</span><span class="n">diag</span><span class="p">()</span> <span class="o">=</span> <span class="p">(</span><span class="n">coefft</span><span class="o">*</span><span class="n">rDeltaT</span><span class="p">)</span><span class="o">*</span><span class="n">mesh</span><span class="p">().</span><span class="n">V</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">mesh</span><span class="p">().</span><span class="n">moving</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">fvm</span><span class="p">.</span><span class="n">source</span><span class="p">()</span> <span class="o">=</span> <span class="n">rDeltaT</span><span class="o">*</span>
        <span class="p">(</span>
            <span class="n">coefft0</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">primitiveField</span><span class="p">()</span><span class="o">*</span><span class="n">mesh</span><span class="p">().</span><span class="n">V0</span><span class="p">()</span>
          <span class="o">-</span> <span class="n">coefft00</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">oldTime</span><span class="p">().</span><span class="n">primitiveField</span><span class="p">()</span>
           <span class="o">*</span><span class="n">mesh</span><span class="p">().</span><span class="n">V00</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">fvm</span><span class="p">.</span><span class="n">source</span><span class="p">()</span> <span class="o">=</span> <span class="n">rDeltaT</span><span class="o">*</span><span class="n">mesh</span><span class="p">().</span><span class="n">V</span><span class="p">()</span><span class="o">*</span>
        <span class="p">(</span>
            <span class="n">coefft0</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">primitiveField</span><span class="p">()</span>
          <span class="o">-</span> <span class="n">coefft00</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">oldTime</span><span class="p">().</span><span class="n">primitiveField</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">tfvm</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>当使用隐式backward离散格式时，得到的系数矩阵对角项为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\operatorname{diag}(\mathbf{A}) = A\frac{V}{\Delta t}
\end{align}\]</div>
<p>对于静网格的情况，得到的源项为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
b = \frac{V}{\Delta t}\Big(B\phi_{\text{old}} - C\phi_{\text{oldold}}\Big)
\end{align}\]</div>
<p>对于动网格的情况，得到的源项为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
b = \frac{1}{\Delta t}\Big( B\phi_{\text{old}}V_{\text{old}} - C\phi_{\text{oldold}}V_{\text{oldold}} \Big)
\end{align}\]</div>
<p>其中各系数的计算方式为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; A = 1 + \frac{\Delta t}{\Delta t + \Delta t_{\text{old}}} \\
&amp; B = A + C = 1 + \frac{\Delta t}{\Delta t + \Delta t_{\text{old}}} + \frac{\Delta t^{2}}{\Delta t_{\text{old}} \cdot (\Delta t + \Delta t_{\text{old}})} \\
&amp; C = \frac{\Delta t^{2}}{\Delta t_{\text{old}} \cdot (\Delta t + \Delta t_{\text{old}})}
\end{align}\end{split}\]</div>
</div>
<div class="section" id="cranknicolson">
<h4>CrankNicolson<a class="headerlink" href="#cranknicolson" title="永久链接至标题">¶</a></h4>
<p>二阶CrankNicolson格式使用当前时间步长、前一次时间步长以及前一次时间步的ddt。对于复杂几何中的复杂流动，CrankNicolson格式通常是不稳定的，因此有必要在保持比一阶Euler隐式格式更大时间精度的同时，将该格式偏离中心(off-center)以使其稳定。偏离中心是通过额外设置的强制系数ocCoeff来实现的，它的取值范围为 <span class="math notranslate nohighlight">\([0,1]\)</span> ，或者也可以使用ramp函数，在初始阶段从Euler格式过渡到CrankNicolson格式，以避免启动问题。</p>
<p>当强制系数为1时，该格式是完全中心的二阶格式；当系数为0时，该格式等效于欧拉隐式格式。系数取0.9时适用于需要更高阶时间精度的一系列情况，并提供与backward格式相似的精度和稳定性。不过，backward更具有鲁棒性且在时间上提供了正式的二阶精度。</p>
<p>与backward格式相比，CrankNicolson格式的优点是只需要新的和旧的时间值，与通量和源有关的附加项在时间步长的中点进行计算，这提供了限制通量的机会，以确保有界性，同时与Euler隐式格式相比保持更高的时间精度。而backward格式不能保证有界性。</p>
<p>进入src/finiteVolume/finiteVolume/ddtSchemes/CrankNicolsonDdtScheme/CrankNicolsonDdtScheme.C文件可以看到</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">tmp</span><span class="o">&lt;</span><span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&gt;</span>
<span class="n">CrankNicolsonDdtScheme</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">fvcDdt</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">vf</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">DDt0Field</span><span class="o">&lt;</span><span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&gt;&amp;</span> <span class="n">ddt0</span> <span class="o">=</span>
        <span class="n">ddt0_</span><span class="o">&lt;</span><span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&gt;</span>
        <span class="p">(</span>
            <span class="s">&quot;ddt0(&quot;</span> <span class="o">+</span> <span class="n">vf</span><span class="p">.</span><span class="n">name</span><span class="p">()</span> <span class="o">+</span> <span class="sc">&#39;)&#39;</span><span class="p">,</span>
            <span class="n">vf</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()</span>
        <span class="p">);</span>

    <span class="k">const</span> <span class="n">word</span> <span class="nf">ddtName</span><span class="p">(</span><span class="s">&quot;ddt(&quot;</span> <span class="o">+</span> <span class="n">vf</span><span class="p">.</span><span class="n">name</span><span class="p">()</span> <span class="o">+</span> <span class="sc">&#39;)&#39;</span><span class="p">);</span>

    <span class="n">dimensionedScalar</span> <span class="n">rDtCoef</span> <span class="o">=</span> <span class="n">rDtCoef_</span><span class="p">(</span><span class="n">ddt0</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">mesh</span><span class="p">().</span><span class="n">moving</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ddt0</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="k">const</span> <span class="n">scalar</span> <span class="n">rDtCoef0</span> <span class="o">=</span> <span class="n">rDtCoef0_</span><span class="p">(</span><span class="n">ddt0</span><span class="p">).</span><span class="n">value</span><span class="p">();</span>

            <span class="n">ddt0</span><span class="p">.</span><span class="n">primitiveFieldRef</span><span class="p">()</span> <span class="o">=</span>
            <span class="p">(</span>
                <span class="n">rDtCoef0</span><span class="o">*</span>
                <span class="p">(</span>
                    <span class="n">mesh</span><span class="p">().</span><span class="n">V0</span><span class="p">()</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">primitiveField</span><span class="p">()</span>
                  <span class="o">-</span> <span class="n">mesh</span><span class="p">().</span><span class="n">V00</span><span class="p">()</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">oldTime</span><span class="p">().</span><span class="n">primitiveField</span><span class="p">()</span>
                <span class="p">)</span> <span class="o">-</span> <span class="n">mesh</span><span class="p">().</span><span class="n">V00</span><span class="p">()</span><span class="o">*</span><span class="n">offCentre_</span><span class="p">(</span><span class="n">ddt0</span><span class="p">.</span><span class="n">primitiveField</span><span class="p">())</span>
            <span class="p">)</span><span class="o">/</span><span class="n">mesh</span><span class="p">().</span><span class="n">V0</span><span class="p">();</span>

            <span class="n">ddt0</span><span class="p">.</span><span class="n">boundaryFieldRef</span><span class="p">()</span> <span class="o">=</span>
            <span class="p">(</span>
                <span class="n">rDtCoef0</span><span class="o">*</span>
                <span class="p">(</span>
                    <span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">boundaryField</span><span class="p">()</span>
                  <span class="o">-</span> <span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">oldTime</span><span class="p">().</span><span class="n">boundaryField</span><span class="p">()</span>
                <span class="p">)</span> <span class="o">-</span> <span class="n">offCentre_</span><span class="p">(</span><span class="n">ff</span><span class="p">(</span><span class="n">ddt0</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()))</span>
            <span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;::</span><span class="n">New</span>
        <span class="p">(</span>
            <span class="n">ddtName</span><span class="p">,</span>
            <span class="p">(</span>
                <span class="n">rDtCoef</span><span class="o">*</span>
                <span class="p">(</span>
                    <span class="n">mesh</span><span class="p">().</span><span class="n">V</span><span class="p">()</span><span class="o">*</span><span class="n">vf</span>
                  <span class="o">-</span> <span class="n">mesh</span><span class="p">().</span><span class="n">V0</span><span class="p">()</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">()</span>
                <span class="p">)</span> <span class="o">-</span> <span class="n">mesh</span><span class="p">().</span><span class="n">V0</span><span class="p">()</span><span class="o">*</span><span class="n">offCentre_</span><span class="p">(</span><span class="n">ddt0</span><span class="p">()())</span>
            <span class="p">)</span><span class="o">/</span><span class="n">mesh</span><span class="p">().</span><span class="n">V</span><span class="p">(),</span>
            <span class="n">rDtCoef</span><span class="p">.</span><span class="n">value</span><span class="p">()</span><span class="o">*</span>
            <span class="p">(</span>
                <span class="n">vf</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()</span> <span class="o">-</span> <span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">boundaryField</span><span class="p">()</span>
            <span class="p">)</span> <span class="o">-</span> <span class="n">offCentre_</span><span class="p">(</span><span class="n">ff</span><span class="p">(</span><span class="n">ddt0</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()))</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ddt0</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">ddt0</span> <span class="o">=</span> <span class="n">rDtCoef0_</span><span class="p">(</span><span class="n">ddt0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">()</span> <span class="o">-</span> <span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">oldTime</span><span class="p">())</span>
                 <span class="o">-</span> <span class="n">offCentre_</span><span class="p">(</span><span class="n">ddt0</span><span class="p">());</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;::</span><span class="n">New</span>
        <span class="p">(</span>
            <span class="n">ddtName</span><span class="p">,</span>
            <span class="n">rDtCoef</span><span class="o">*</span><span class="p">(</span><span class="n">vf</span> <span class="o">-</span> <span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">())</span> <span class="o">-</span> <span class="n">offCentre_</span><span class="p">(</span><span class="n">ddt0</span><span class="p">())</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>对于静网格的情况，计算方式为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\partial \phi}{\partial t} =
(1 + \text{ocCoeff})\frac{\phi - \phi_{\text{old}}}{\Delta t}
- \text{ocCoeff}\times \Big(\frac{\partial \phi}{\partial t} \Big)_{\text{old}}
\end{align}\]</div>
<div class="admonition attention">
<p class="first admonition-title">注意</p>
<ul class="last simple">
<li>可以看到，在OpenFOAM中实现的方式与原始的CrankNicolson格式定义有所不同，详细讨论参考 <a class="reference external" href="https://www.cfd-online.com/Forums/openfoam-programming-development/226125-crank-nicolson-scheme-implemented-wrong.html">Crank Nicolson scheme implemented wrong?</a></li>
<li>由于需要读取两个时间步之前的数据，所以在只有0时间步场数据的情况下使用该格式时将会报错。因此，在初次计算时不应该使用该格式，而应该在用Euler格式计算出一定数据后再使用该格式。</li>
</ul>
</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">tmp</span><span class="o">&lt;</span><span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">CrankNicolsonDdtScheme</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">fvmDdt</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">vf</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">DDt0Field</span><span class="o">&lt;</span><span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&gt;&amp;</span> <span class="n">ddt0</span> <span class="o">=</span>
        <span class="n">ddt0_</span><span class="o">&lt;</span><span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&gt;</span>
        <span class="p">(</span>
            <span class="s">&quot;ddt0(&quot;</span> <span class="o">+</span> <span class="n">vf</span><span class="p">.</span><span class="n">name</span><span class="p">()</span> <span class="o">+</span> <span class="sc">&#39;)&#39;</span><span class="p">,</span>
            <span class="n">vf</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()</span>
        <span class="p">);</span>

    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span> <span class="n">tfvm</span>
    <span class="p">(</span>
        <span class="n">new</span> <span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span>
        <span class="p">(</span>
            <span class="n">vf</span><span class="p">,</span>
            <span class="n">vf</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()</span><span class="o">*</span><span class="n">dimVol</span><span class="o">/</span><span class="n">dimTime</span>
        <span class="p">)</span>
    <span class="p">);</span>

    <span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&amp;</span> <span class="n">fvm</span> <span class="o">=</span> <span class="n">tfvm</span><span class="p">.</span><span class="n">ref</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">scalar</span> <span class="n">rDtCoef</span> <span class="o">=</span> <span class="n">rDtCoef_</span><span class="p">(</span><span class="n">ddt0</span><span class="p">).</span><span class="n">value</span><span class="p">();</span>
    <span class="n">fvm</span><span class="p">.</span><span class="n">diag</span><span class="p">()</span> <span class="o">=</span> <span class="n">rDtCoef</span><span class="o">*</span><span class="n">mesh</span><span class="p">().</span><span class="n">V</span><span class="p">();</span>

    <span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">oldTime</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">mesh</span><span class="p">().</span><span class="n">moving</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ddt0</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="k">const</span> <span class="n">scalar</span> <span class="n">rDtCoef0</span> <span class="o">=</span> <span class="n">rDtCoef0_</span><span class="p">(</span><span class="n">ddt0</span><span class="p">).</span><span class="n">value</span><span class="p">();</span>

            <span class="n">ddt0</span><span class="p">.</span><span class="n">primitiveFieldRef</span><span class="p">()</span> <span class="o">=</span>
            <span class="p">(</span>
                <span class="n">rDtCoef0</span><span class="o">*</span>
                <span class="p">(</span>
                    <span class="n">mesh</span><span class="p">().</span><span class="n">V0</span><span class="p">()</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">primitiveField</span><span class="p">()</span>
                  <span class="o">-</span> <span class="n">mesh</span><span class="p">().</span><span class="n">V00</span><span class="p">()</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">oldTime</span><span class="p">().</span><span class="n">primitiveField</span><span class="p">()</span>
                <span class="p">)</span>
              <span class="o">-</span> <span class="n">mesh</span><span class="p">().</span><span class="n">V00</span><span class="p">()</span><span class="o">*</span><span class="n">offCentre_</span><span class="p">(</span><span class="n">ddt0</span><span class="p">.</span><span class="n">primitiveField</span><span class="p">())</span>
            <span class="p">)</span><span class="o">/</span><span class="n">mesh</span><span class="p">().</span><span class="n">V0</span><span class="p">();</span>

            <span class="n">ddt0</span><span class="p">.</span><span class="n">boundaryFieldRef</span><span class="p">()</span> <span class="o">=</span>
            <span class="p">(</span>
                <span class="n">rDtCoef0</span><span class="o">*</span>
                <span class="p">(</span>
                    <span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">boundaryField</span><span class="p">()</span>
                  <span class="o">-</span> <span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">oldTime</span><span class="p">().</span><span class="n">boundaryField</span><span class="p">()</span>
                <span class="p">)</span>
              <span class="o">-</span> <span class="n">offCentre_</span><span class="p">(</span><span class="n">ff</span><span class="p">(</span><span class="n">ddt0</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()))</span>
            <span class="p">);</span>
        <span class="p">}</span>

        <span class="n">fvm</span><span class="p">.</span><span class="n">source</span><span class="p">()</span> <span class="o">=</span>
        <span class="p">(</span>
            <span class="n">rDtCoef</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">primitiveField</span><span class="p">()</span>
          <span class="o">+</span> <span class="n">offCentre_</span><span class="p">(</span><span class="n">ddt0</span><span class="p">.</span><span class="n">primitiveField</span><span class="p">())</span>
        <span class="p">)</span><span class="o">*</span><span class="n">mesh</span><span class="p">().</span><span class="n">V0</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ddt0</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">ddt0</span> <span class="o">=</span> <span class="n">rDtCoef0_</span><span class="p">(</span><span class="n">ddt0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">()</span> <span class="o">-</span> <span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">oldTime</span><span class="p">())</span>
                 <span class="o">-</span> <span class="n">offCentre_</span><span class="p">(</span><span class="n">ddt0</span><span class="p">());</span>
        <span class="p">}</span>

        <span class="n">fvm</span><span class="p">.</span><span class="n">source</span><span class="p">()</span> <span class="o">=</span>
        <span class="p">(</span>
            <span class="n">rDtCoef</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">primitiveField</span><span class="p">()</span>
          <span class="o">+</span> <span class="n">offCentre_</span><span class="p">(</span><span class="n">ddt0</span><span class="p">.</span><span class="n">primitiveField</span><span class="p">())</span>
        <span class="p">)</span><span class="o">*</span><span class="n">mesh</span><span class="p">().</span><span class="n">V</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">tfvm</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="euler">
<h4>Euler<a class="headerlink" href="#euler" title="永久链接至标题">¶</a></h4>
<p>进入src/finiteVolume/finiteVolume/ddtSchemes/EulerDdtScheme/EulerDdtScheme.C文件可以看到如下代码：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">tmp</span><span class="o">&lt;</span><span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&gt;</span>
<span class="n">EulerDdtScheme</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">fvcDdt</span>    <span class="c1">// 显式离散</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">vf</span>    <span class="c1">// fvc::ddt(phi)的类型</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">dimensionedScalar</span> <span class="n">rDeltaT</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">mesh</span><span class="p">().</span><span class="n">time</span><span class="p">().</span><span class="n">deltaT</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">word</span> <span class="nf">ddtName</span><span class="p">(</span><span class="s">&quot;ddt(&quot;</span><span class="o">+</span><span class="n">vf</span><span class="p">.</span><span class="n">name</span><span class="p">()</span><span class="o">+</span><span class="sc">&#39;)&#39;</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">mesh</span><span class="p">().</span><span class="n">moving</span><span class="p">())</span>    <span class="c1">// 动网格的情形</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;::</span><span class="n">New</span>
        <span class="p">(</span>
            <span class="n">ddtName</span><span class="p">,</span>
            <span class="n">rDeltaT</span><span class="o">*</span>
            <span class="p">(</span>
                <span class="n">vf</span><span class="p">()</span>
              <span class="o">-</span> <span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">()()</span><span class="o">*</span><span class="n">mesh</span><span class="p">().</span><span class="n">Vsc0</span><span class="p">()</span><span class="o">/</span><span class="n">mesh</span><span class="p">().</span><span class="n">Vsc</span><span class="p">()</span>
            <span class="p">),</span>
            <span class="n">rDeltaT</span><span class="p">.</span><span class="n">value</span><span class="p">()</span><span class="o">*</span>
            <span class="p">(</span>
                <span class="n">vf</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()</span> <span class="o">-</span> <span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">boundaryField</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>    <span class="c1">// 静网格的情形</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;::</span><span class="n">New</span>
        <span class="p">(</span>
            <span class="n">ddtName</span><span class="p">,</span>
            <span class="n">rDeltaT</span><span class="o">*</span><span class="p">(</span><span class="n">vf</span> <span class="o">-</span> <span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">())</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>可以看到，对于Euler格式，当网格属于静网格时，计算方式为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\partial \phi}{\partial t} = \frac{\phi - \phi_{\text{old}}}{\Delta t}
\end{align}\]</div>
<p>当网格属于动网格时，计算方式为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\partial \phi}{\partial t} = \frac{1}{\Delta t}\Big( \phi - \phi_{\text{old}}\frac{V_{\text{sc}_{\text{old}}}}{V_{\text{sc}}} \Big)
\end{align}\]</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">tmp</span><span class="o">&lt;</span><span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">EulerDdtScheme</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">fvmDdt</span>    <span class="c1">// 隐式离散</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">vf</span>    <span class="c1">// fvm::ddt(phi)的类型</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span> <span class="n">tfvm</span>
    <span class="p">(</span>
        <span class="n">new</span> <span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span>
        <span class="p">(</span>
            <span class="n">vf</span><span class="p">,</span>
            <span class="n">vf</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()</span><span class="o">*</span><span class="n">dimVol</span><span class="o">/</span><span class="n">dimTime</span>
        <span class="p">)</span>
    <span class="p">);</span>

    <span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&amp;</span> <span class="n">fvm</span> <span class="o">=</span> <span class="n">tfvm</span><span class="p">.</span><span class="n">ref</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">scalar</span> <span class="n">rDeltaT</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">mesh</span><span class="p">().</span><span class="n">time</span><span class="p">().</span><span class="n">deltaTValue</span><span class="p">();</span>

    <span class="n">fvm</span><span class="p">.</span><span class="n">diag</span><span class="p">()</span> <span class="o">=</span> <span class="n">rDeltaT</span><span class="o">*</span><span class="n">mesh</span><span class="p">().</span><span class="n">Vsc</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">mesh</span><span class="p">().</span><span class="n">moving</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">fvm</span><span class="p">.</span><span class="n">source</span><span class="p">()</span> <span class="o">=</span> <span class="n">rDeltaT</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">primitiveField</span><span class="p">()</span><span class="o">*</span><span class="n">mesh</span><span class="p">().</span><span class="n">Vsc0</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">fvm</span><span class="p">.</span><span class="n">source</span><span class="p">()</span> <span class="o">=</span> <span class="n">rDeltaT</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">primitiveField</span><span class="p">()</span><span class="o">*</span><span class="n">mesh</span><span class="p">().</span><span class="n">Vsc</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">tfvm</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>当使用隐式Euler离散格式的时候，其产生的系数矩阵对角项为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\operatorname{diag}(\mathbf{A}) = \frac{V_{\text{sc}}}{\Delta t}
\end{align}\]</div>
<p>当网格为静网格时，产生的源项为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
b = \frac{1}{\Delta t}\phi_{\text{old}}V_{\text{sc}}
\end{align}\]</div>
<p>当网格为动网格时，产生的源项为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
b = \frac{1}{\Delta t}\phi_{\text{old}}V_{\text{sc}_{\text{old}}}
\end{align}\]</div>
</div>
<div class="section" id="slts">
<h4>SLTS<a class="headerlink" href="#slts" title="永久链接至标题">¶</a></h4>
<p>全称为Stabilised local time-step first-order Euler scheme。能够局部调整时间步长，使对流方程保持对角占优。该格式只能用于使用瞬态代码计算稳态问题的情况，其中由于传输一致性的原因，局部时间步长最好设置为欠松弛状态。</p>
<p>进入src/finiteVolume/finiteVolume/ddtSchemes/SLTSDdtScheme/SLTSDdtScheme.C文件，可以看到</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">SLTSDdtScheme</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">relaxedDiag</span>
<span class="p">(</span>
    <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">rD</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">phi</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">labelUList</span><span class="o">&amp;</span> <span class="n">owner</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">().</span><span class="n">owner</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">labelUList</span><span class="o">&amp;</span> <span class="n">neighbour</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">().</span><span class="n">neighbour</span><span class="p">();</span>
    <span class="n">scalarField</span> <span class="nf">diag</span><span class="p">(</span><span class="n">rD</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="mf">0.0</span><span class="p">);</span>

    <span class="n">forAll</span><span class="p">(</span><span class="n">owner</span><span class="p">,</span> <span class="n">facei</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">phi</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">diag</span><span class="p">[</span><span class="n">owner</span><span class="p">[</span><span class="n">facei</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">phi</span><span class="p">[</span><span class="n">facei</span><span class="p">];</span>
            <span class="n">rD</span><span class="p">[</span><span class="n">neighbour</span><span class="p">[</span><span class="n">facei</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">phi</span><span class="p">[</span><span class="n">facei</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">diag</span><span class="p">[</span><span class="n">neighbour</span><span class="p">[</span><span class="n">facei</span><span class="p">]]</span> <span class="o">-=</span> <span class="n">phi</span><span class="p">[</span><span class="n">facei</span><span class="p">];</span>
            <span class="n">rD</span><span class="p">[</span><span class="n">owner</span><span class="p">[</span><span class="n">facei</span><span class="p">]]</span> <span class="o">-=</span> <span class="n">phi</span><span class="p">[</span><span class="n">facei</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">forAll</span><span class="p">(</span><span class="n">phi</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">(),</span> <span class="n">patchi</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">fvsPatchScalarField</span><span class="o">&amp;</span> <span class="n">pphi</span> <span class="o">=</span> <span class="n">phi</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">];</span>
        <span class="k">const</span> <span class="n">labelUList</span><span class="o">&amp;</span> <span class="n">faceCells</span> <span class="o">=</span> <span class="n">pphi</span><span class="p">.</span><span class="n">patch</span><span class="p">().</span><span class="n">patch</span><span class="p">().</span><span class="n">faceCells</span><span class="p">();</span>

        <span class="n">forAll</span><span class="p">(</span><span class="n">pphi</span><span class="p">,</span> <span class="n">patchFacei</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pphi</span><span class="p">[</span><span class="n">patchFacei</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">diag</span><span class="p">[</span><span class="n">faceCells</span><span class="p">[</span><span class="n">patchFacei</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">pphi</span><span class="p">[</span><span class="n">patchFacei</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">rD</span><span class="p">[</span><span class="n">faceCells</span><span class="p">[</span><span class="n">patchFacei</span><span class="p">]]</span> <span class="o">-=</span> <span class="n">pphi</span><span class="p">[</span><span class="n">patchFacei</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">rD</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">alpha_</span> <span class="o">-</span> <span class="mf">2.0</span><span class="p">)</span><span class="o">*</span><span class="n">diag</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="steadystate">
<h4>steadyState<a class="headerlink" href="#steadystate" title="永久链接至标题">¶</a></h4>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">tmp</span><span class="o">&lt;</span><span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&gt;</span>
<span class="n">steadyStateDdtScheme</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">fvcDdt</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">dimensionedScalar</span><span class="o">&amp;</span> <span class="n">rho</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">vf</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;::</span><span class="n">New</span>
    <span class="p">(</span>
        <span class="s">&quot;ddt(&quot;</span><span class="o">+</span><span class="n">rho</span><span class="p">.</span><span class="n">name</span><span class="p">()</span><span class="o">+</span><span class="sc">&#39;,&#39;</span><span class="o">+</span><span class="n">vf</span><span class="p">.</span><span class="n">name</span><span class="p">()</span><span class="o">+</span><span class="sc">&#39;)&#39;</span><span class="p">,</span>
        <span class="n">mesh</span><span class="p">(),</span>
        <span class="n">dimensioned</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span>
        <span class="p">(</span>
            <span class="s">&quot;0&quot;</span><span class="p">,</span>
            <span class="n">rho</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()</span><span class="o">/</span><span class="n">dimTime</span><span class="p">,</span>
            <span class="n">Zero</span>
        <span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">tmp</span><span class="o">&lt;</span><span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">steadyStateDdtScheme</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">fvmDdt</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">vf</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
    <span class="p">(</span>
        <span class="n">new</span> <span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span>
        <span class="p">(</span>
            <span class="n">vf</span><span class="p">,</span>
            <span class="n">vf</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()</span><span class="o">*</span><span class="n">dimVol</span><span class="o">/</span><span class="n">dimTime</span>
        <span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="d2dt2schemes">
<h3>时间二阶导项格式d2dt2Schemes<a class="headerlink" href="#d2dt2schemes" title="永久链接至标题">¶</a></h3>
<p>时间二阶导项 <span class="math notranslate nohighlight">\(\frac{\partial^{2}}{\partial t^{2}}\)</span> 格式只支持Euler格式或steadyState格式。对于Euler格式，进入src/finiteVolume/finiteVolume/d2dt2Schemes/EulerD2dt2Scheme/EulerD2dt2Scheme.C文件，可以看到</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">tmp</span><span class="o">&lt;</span><span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&gt;</span>
<span class="n">EulerD2dt2Scheme</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">fvcD2dt2</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">vf</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">dimensionedScalar</span> <span class="n">rDeltaT2</span>
    <span class="p">(</span>
        <span class="mf">4.0</span><span class="o">/</span><span class="n">sqr</span><span class="p">(</span><span class="n">mesh</span><span class="p">().</span><span class="n">time</span><span class="p">().</span><span class="n">deltaT</span><span class="p">()</span> <span class="o">+</span> <span class="n">mesh</span><span class="p">().</span><span class="n">time</span><span class="p">().</span><span class="n">deltaT0</span><span class="p">())</span>
    <span class="p">);</span>

    <span class="k">const</span> <span class="n">word</span> <span class="nf">d2dt2name</span><span class="p">(</span><span class="s">&quot;d2dt2(&quot;</span><span class="o">+</span><span class="n">vf</span><span class="p">.</span><span class="n">name</span><span class="p">()</span><span class="o">+</span><span class="sc">&#39;)&#39;</span><span class="p">);</span>

    <span class="k">const</span> <span class="n">scalar</span> <span class="n">deltaT</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">().</span><span class="n">time</span><span class="p">().</span><span class="n">deltaTValue</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">deltaT0</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">().</span><span class="n">time</span><span class="p">().</span><span class="n">deltaT0Value</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">scalar</span> <span class="n">coefft</span>   <span class="o">=</span> <span class="p">(</span><span class="n">deltaT</span> <span class="o">+</span> <span class="n">deltaT0</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">deltaT</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">coefft00</span> <span class="o">=</span> <span class="p">(</span><span class="n">deltaT</span> <span class="o">+</span> <span class="n">deltaT0</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">deltaT0</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">coefft0</span>  <span class="o">=</span> <span class="n">coefft</span> <span class="o">+</span> <span class="n">coefft00</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">mesh</span><span class="p">().</span><span class="n">moving</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">dimensionedScalar</span> <span class="n">halfRdeltaT2</span><span class="p">(</span><span class="n">rDeltaT2</span><span class="o">/</span><span class="mf">2.0</span><span class="p">);</span>

        <span class="k">const</span> <span class="n">volScalarField</span><span class="o">::</span><span class="n">Internal</span> <span class="n">VV0</span><span class="p">(</span><span class="n">mesh</span><span class="p">().</span><span class="n">V</span><span class="p">()</span> <span class="o">+</span> <span class="n">mesh</span><span class="p">().</span><span class="n">V0</span><span class="p">());</span>
        <span class="k">const</span> <span class="n">volScalarField</span><span class="o">::</span><span class="n">Internal</span> <span class="n">V0V00</span><span class="p">(</span><span class="n">mesh</span><span class="p">().</span><span class="n">V0</span><span class="p">()</span> <span class="o">+</span> <span class="n">mesh</span><span class="p">().</span><span class="n">V00</span><span class="p">());</span>

        <span class="k">return</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;::</span><span class="n">New</span>
        <span class="p">(</span>
            <span class="n">d2dt2name</span><span class="p">,</span>
            <span class="n">halfRdeltaT2</span><span class="o">*</span>
            <span class="p">(</span>
                <span class="n">coefft</span><span class="o">*</span><span class="n">VV0</span><span class="o">*</span><span class="n">vf</span><span class="p">()</span>

              <span class="o">-</span> <span class="p">(</span><span class="n">coefft</span><span class="o">*</span><span class="n">VV0</span> <span class="o">+</span> <span class="n">coefft00</span><span class="o">*</span><span class="n">V0V00</span><span class="p">)</span>
               <span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">()()</span>

              <span class="o">+</span> <span class="p">(</span><span class="n">coefft00</span><span class="o">*</span><span class="n">V0V00</span><span class="p">)</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">oldTime</span><span class="p">()()</span>
            <span class="p">)</span><span class="o">/</span><span class="n">mesh</span><span class="p">().</span><span class="n">V</span><span class="p">(),</span>
            <span class="n">rDeltaT2</span><span class="p">.</span><span class="n">value</span><span class="p">()</span><span class="o">*</span>
            <span class="p">(</span>
                <span class="n">coefft</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()</span>
              <span class="o">-</span> <span class="n">coefft0</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">boundaryField</span><span class="p">()</span>
              <span class="o">+</span> <span class="n">coefft00</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">oldTime</span><span class="p">().</span><span class="n">boundaryField</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;::</span><span class="n">New</span>
        <span class="p">(</span>
            <span class="n">d2dt2name</span><span class="p">,</span>
            <span class="n">rDeltaT2</span><span class="o">*</span>
            <span class="p">(</span>
                <span class="n">coefft</span><span class="o">*</span><span class="n">vf</span>
              <span class="o">-</span> <span class="n">coefft0</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">()</span>
              <span class="o">+</span> <span class="n">coefft00</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">oldTime</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">tmp</span><span class="o">&lt;</span><span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">EulerD2dt2Scheme</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">fvmD2dt2</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">vf</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span> <span class="n">tfvm</span>
    <span class="p">(</span>
        <span class="n">new</span> <span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span>
        <span class="p">(</span>
            <span class="n">vf</span><span class="p">,</span>
            <span class="n">vf</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()</span><span class="o">*</span><span class="n">dimVol</span><span class="o">/</span><span class="n">dimTime</span><span class="o">/</span><span class="n">dimTime</span>
        <span class="p">)</span>
    <span class="p">);</span>

    <span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&amp;</span> <span class="n">fvm</span> <span class="o">=</span> <span class="n">tfvm</span><span class="p">.</span><span class="n">ref</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">scalar</span> <span class="n">deltaT</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">().</span><span class="n">time</span><span class="p">().</span><span class="n">deltaTValue</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">deltaT0</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">().</span><span class="n">time</span><span class="p">().</span><span class="n">deltaT0Value</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">scalar</span> <span class="n">coefft</span>   <span class="o">=</span> <span class="p">(</span><span class="n">deltaT</span> <span class="o">+</span> <span class="n">deltaT0</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">deltaT</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">coefft00</span> <span class="o">=</span> <span class="p">(</span><span class="n">deltaT</span> <span class="o">+</span> <span class="n">deltaT0</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">deltaT0</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">coefft0</span>  <span class="o">=</span> <span class="n">coefft</span> <span class="o">+</span> <span class="n">coefft00</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">scalar</span> <span class="n">rDeltaT2</span> <span class="o">=</span> <span class="mf">4.0</span><span class="o">/</span><span class="n">sqr</span><span class="p">(</span><span class="n">deltaT</span> <span class="o">+</span> <span class="n">deltaT0</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">mesh</span><span class="p">().</span><span class="n">moving</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">scalar</span> <span class="n">halfRdeltaT2</span> <span class="o">=</span> <span class="n">rDeltaT2</span><span class="o">/</span><span class="mf">2.0</span><span class="p">;</span>

        <span class="k">const</span> <span class="n">scalarField</span> <span class="nf">VV0</span><span class="p">(</span><span class="n">mesh</span><span class="p">().</span><span class="n">V</span><span class="p">()</span> <span class="o">+</span> <span class="n">mesh</span><span class="p">().</span><span class="n">V0</span><span class="p">());</span>
        <span class="k">const</span> <span class="n">scalarField</span> <span class="nf">V0V00</span><span class="p">(</span><span class="n">mesh</span><span class="p">().</span><span class="n">V0</span><span class="p">()</span> <span class="o">+</span> <span class="n">mesh</span><span class="p">().</span><span class="n">V00</span><span class="p">());</span>

        <span class="n">fvm</span><span class="p">.</span><span class="n">diag</span><span class="p">()</span> <span class="o">=</span> <span class="p">(</span><span class="n">coefft</span><span class="o">*</span><span class="n">halfRdeltaT2</span><span class="p">)</span><span class="o">*</span><span class="n">VV0</span><span class="p">;</span>

        <span class="n">fvm</span><span class="p">.</span><span class="n">source</span><span class="p">()</span> <span class="o">=</span> <span class="n">halfRdeltaT2</span><span class="o">*</span>
        <span class="p">(</span>
            <span class="p">(</span><span class="n">coefft</span><span class="o">*</span><span class="n">VV0</span> <span class="o">+</span> <span class="n">coefft00</span><span class="o">*</span><span class="n">V0V00</span><span class="p">)</span>
           <span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">primitiveField</span><span class="p">()</span>

          <span class="o">-</span> <span class="p">(</span><span class="n">coefft00</span><span class="o">*</span><span class="n">V0V00</span><span class="p">)</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">oldTime</span><span class="p">().</span><span class="n">primitiveField</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">fvm</span><span class="p">.</span><span class="n">diag</span><span class="p">()</span> <span class="o">=</span> <span class="p">(</span><span class="n">coefft</span><span class="o">*</span><span class="n">rDeltaT2</span><span class="p">)</span><span class="o">*</span><span class="n">mesh</span><span class="p">().</span><span class="n">V</span><span class="p">();</span>

        <span class="n">fvm</span><span class="p">.</span><span class="n">source</span><span class="p">()</span> <span class="o">=</span> <span class="n">rDeltaT2</span><span class="o">*</span><span class="n">mesh</span><span class="p">().</span><span class="n">V</span><span class="p">()</span><span class="o">*</span>
        <span class="p">(</span>
            <span class="n">coefft0</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">primitiveField</span><span class="p">()</span>
          <span class="o">-</span> <span class="n">coefft00</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">oldTime</span><span class="p">().</span><span class="n">oldTime</span><span class="p">().</span><span class="n">primitiveField</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">tfvm</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="gradschemes">
<h3>梯度项格式gradSchemes<a class="headerlink" href="#gradschemes" title="永久链接至标题">¶</a></h3>
<p>梯度项 <span class="math notranslate nohighlight">\(\nabla\)</span> 格式支持的标准格式有：</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">梯度项格式</th>
<th class="head">含义</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Gauss &lt;interpolationScheme&gt;</td>
<td>高斯积分，&lt;interpolationScheme&gt;设置插值格式，二阶精度</td>
</tr>
<tr class="row-odd"><td>leastSquares</td>
<td>最小二乘法，二阶精度</td>
</tr>
<tr class="row-even"><td>fourth</td>
<td>最小二乘法，四阶精度</td>
</tr>
<tr class="row-odd"><td>cellLimited &lt;gradScheme&gt;</td>
<td>上述格式的体单元有界版本</td>
</tr>
<tr class="row-even"><td>faceLimited &lt;gradScheme&gt;</td>
<td>上述格式的面单元有界版本</td>
</tr>
</tbody>
</table>
<p>下面是一些具体的设置案例：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">default</span>         <span class="n">Gauss</span> <span class="n">linear</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="divschemes">
<h3>散度项格式divSchemes<a class="headerlink" href="#divschemes" title="永久链接至标题">¶</a></h3>
<p>参考 <a class="reference external" href="https://www.openfoam.com/documentation/guides/latest/doc/guide-schemes-divergence.html">Divergence schemes</a></p>
<p>此项一般只出现在涉及流体流动的数值模拟中，例如标量形式的 <span class="math notranslate nohighlight">\(\nabla\cdot(\rho \mathbf{U}T)\)</span> 和矢量形式的 <span class="math notranslate nohighlight">\(\nabla\cdot(\rho \mathbf{U}\mathbf{U})\)</span> 。以动量方程中的对流项 <span class="math notranslate nohighlight">\(\nabla\cdot(\rho \mathbf{U}\mathbf{U})\)</span> 为例，基于有限体积积分有</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\int_{V}\nabla\cdot(\rho\mathbf{U}\mathbf{U})~\mathrm{d}V=\int_{\mathbf{A}_{f}}\rho\mathbf{U}\mathbf{U}\cdot \mathrm{d}\mathbf{A}_{f}=\sum \rho_{f}\mathbf{U}_{f}\mathbf{U}_{f}\cdot \mathbf{A}_{f}=\sum \phi_{f}\mathbf{U}_{f}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\phi_{f}\)</span> 表示面 <span class="math notranslate nohighlight">\(f\)</span> 处的质量通量，即 <span class="math notranslate nohighlight">\(\rho_{f}\mathbf{U}_{f}\cdot\mathbf{A}_{f}\)</span> ，也因此在OpenFOAM中表示为 <code class="code docutils literal notranslate"><span class="pre">div(phi,</span> <span class="pre">U)</span></code> 。</p>
<p>散度项格式一般为下面的格式：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Gauss</span> <span class="o">&lt;</span><span class="n">interpolationScheme</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>为线性化此非线性项，在对对流项进行离散的过程中， <span class="math notranslate nohighlight">\(\phi_{f}\)</span> 是作为已知量参与计算的，一般使用上一时间步的速度场 <span class="math notranslate nohighlight">\(\mathbf{U}^{n}\)</span> 计算得到，即</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\sum\rho_{f}\mathbf{U}_{f}\mathbf{U}_{f}\cdot\mathbf{A}_{f}=\sum\rho_{f}^{n}\mathbf{U}_{f}^{n+1}\mathbf{U}_{f}^{n}\cdot\mathbf{A}_{f}=\sum\phi_{f}^{n}\mathbf{U}_{f}^{n+1}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\phi_{f}^{n}\)</span> 的数值通过Rhie-Chow动量插值计算得到。因此，这里的插值格式&lt;interpolationScheme&gt;只针对上式中的 <span class="math notranslate nohighlight">\(\mathbf{U}_{f}^{n+1}\)</span> 。</p>
<p>对于 <span class="math notranslate nohighlight">\(\nabla \cdot \phi\)</span> 的情况，进入src/finiteVolume/finiteVolume/divSchemes/gaussDivScheme/GaussDivScheme.C文件可以看到基于Gauss积分理论的散度计算实现方式：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">tmp</span>
<span class="o">&lt;</span>
    <span class="n">GeometricField</span>
    <span class="o">&lt;</span><span class="kr">typename</span> <span class="n">innerProduct</span><span class="o">&lt;</span><span class="n">vector</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;</span>
<span class="o">&gt;</span>
<span class="n">gaussDivScheme</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">fvcDiv</span>    <span class="c1">// 散度的显式离散</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">vf</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">tmp</span>
    <span class="o">&lt;</span>
        <span class="n">GeometricField</span>
        <span class="o">&lt;</span><span class="kr">typename</span> <span class="n">innerProduct</span><span class="o">&lt;</span><span class="n">vector</span><span class="p">,</span> <span class="n">Type</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;</span>
    <span class="o">&gt;</span> <span class="n">tDiv</span>
    <span class="p">(</span>
        <span class="n">fvc</span><span class="o">::</span><span class="n">surfaceIntegrate</span>
        <span class="p">(</span>
            <span class="n">this</span><span class="o">-&gt;</span><span class="n">tinterpScheme_</span><span class="p">().</span><span class="n">dotInterpolate</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">mesh_</span><span class="p">.</span><span class="n">Sf</span><span class="p">(),</span> <span class="n">vf</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">);</span>

    <span class="n">tDiv</span><span class="p">.</span><span class="n">ref</span><span class="p">().</span><span class="n">rename</span><span class="p">(</span><span class="s">&quot;div(&quot;</span> <span class="o">+</span> <span class="n">vf</span><span class="p">.</span><span class="n">name</span><span class="p">()</span> <span class="o">+</span> <span class="sc">&#39;)&#39;</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">tDiv</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>对于 <span class="math notranslate nohighlight">\(\nabla \cdot (\phi\mathbf{U})\)</span> 的情况，进入src/finiteVolume/finiteVolume/convectionSchemes/gaussConvectionScheme/gaussConvectionScheme.C文件可以看到：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">tmp</span><span class="o">&lt;</span><span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&gt;</span>
<span class="n">gaussConvectionScheme</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">fvcDiv</span>    <span class="c1">// 散度的显式离散</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">faceFlux</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">vf</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&gt;</span> <span class="n">tConvection</span>
    <span class="p">(</span>
        <span class="n">fvc</span><span class="o">::</span><span class="n">surfaceIntegrate</span><span class="p">(</span><span class="n">flux</span><span class="p">(</span><span class="n">faceFlux</span><span class="p">,</span> <span class="n">vf</span><span class="p">))</span>
    <span class="p">);</span>

    <span class="n">tConvection</span><span class="p">.</span><span class="n">ref</span><span class="p">().</span><span class="n">rename</span>
    <span class="p">(</span>
        <span class="s">&quot;convection(&quot;</span> <span class="o">+</span> <span class="n">faceFlux</span><span class="p">.</span><span class="n">name</span><span class="p">()</span> <span class="o">+</span> <span class="sc">&#39;,&#39;</span> <span class="o">+</span> <span class="n">vf</span><span class="p">.</span><span class="n">name</span><span class="p">()</span> <span class="o">+</span> <span class="sc">&#39;)&#39;</span>
    <span class="p">);</span>

    <span class="k">return</span> <span class="n">tConvection</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">tmp</span><span class="o">&lt;</span><span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">gaussConvectionScheme</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">fvmDiv</span>    <span class="c1">// 散度的隐式离散</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">faceFlux</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">vf</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="o">&gt;</span> <span class="n">tweights</span> <span class="o">=</span> <span class="n">tinterpScheme_</span><span class="p">().</span><span class="n">weights</span><span class="p">(</span><span class="n">vf</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">tweights</span><span class="p">();</span>

    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span> <span class="n">tfvm</span>
    <span class="p">(</span>
        <span class="n">new</span> <span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span>
        <span class="p">(</span>
            <span class="n">vf</span><span class="p">,</span>
            <span class="n">faceFlux</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()</span>
        <span class="p">)</span>
    <span class="p">);</span>
    <span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&amp;</span> <span class="n">fvm</span> <span class="o">=</span> <span class="n">tfvm</span><span class="p">.</span><span class="n">ref</span><span class="p">();</span>

    <span class="n">fvm</span><span class="p">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">=</span> <span class="o">-</span><span class="n">weights</span><span class="p">.</span><span class="n">primitiveField</span><span class="p">()</span><span class="o">*</span><span class="n">faceFlux</span><span class="p">.</span><span class="n">primitiveField</span><span class="p">();</span>
    <span class="n">fvm</span><span class="p">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">=</span> <span class="n">fvm</span><span class="p">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">+</span> <span class="n">faceFlux</span><span class="p">.</span><span class="n">primitiveField</span><span class="p">();</span>
    <span class="n">fvm</span><span class="p">.</span><span class="n">negSumDiag</span><span class="p">();</span>

    <span class="n">forAll</span><span class="p">(</span><span class="n">vf</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">(),</span> <span class="n">patchi</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">fvPatchField</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&amp;</span> <span class="n">psf</span> <span class="o">=</span> <span class="n">vf</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">];</span>
        <span class="k">const</span> <span class="n">fvsPatchScalarField</span><span class="o">&amp;</span> <span class="n">patchFlux</span> <span class="o">=</span> <span class="n">faceFlux</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">];</span>
        <span class="k">const</span> <span class="n">fvsPatchScalarField</span><span class="o">&amp;</span> <span class="n">pw</span> <span class="o">=</span> <span class="n">weights</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">];</span>

        <span class="n">fvm</span><span class="p">.</span><span class="n">internalCoeffs</span><span class="p">()[</span><span class="n">patchi</span><span class="p">]</span> <span class="o">=</span> <span class="n">patchFlux</span><span class="o">*</span><span class="n">psf</span><span class="p">.</span><span class="n">valueInternalCoeffs</span><span class="p">(</span><span class="n">pw</span><span class="p">);</span>
        <span class="n">fvm</span><span class="p">.</span><span class="n">boundaryCoeffs</span><span class="p">()[</span><span class="n">patchi</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">patchFlux</span><span class="o">*</span><span class="n">psf</span><span class="p">.</span><span class="n">valueBoundaryCoeffs</span><span class="p">(</span><span class="n">pw</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">tinterpScheme_</span><span class="p">().</span><span class="n">corrected</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">fvm</span> <span class="o">+=</span> <span class="n">fvc</span><span class="o">::</span><span class="n">surfaceIntegrate</span><span class="p">(</span><span class="n">faceFlux</span><span class="o">*</span><span class="n">tinterpScheme_</span><span class="p">().</span><span class="n">correction</span><span class="p">(</span><span class="n">vf</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">tfvm</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">散度项格式</th>
<th class="head">数学特性</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Gauss limitedLinear &lt;coeff&gt;</td>
<td>一阶或二阶，无界</td>
</tr>
<tr class="row-odd"><td>Gauss linear</td>
<td>二阶，无界，低耗散(适合于LES)，用于各项同性网格</td>
</tr>
<tr class="row-even"><td>Gauss linearUpwind grad(U)</td>
<td>二阶，无界，采用迎风插值权重并基于局部单元梯度进行显式修正</td>
</tr>
<tr class="row-odd"><td>Gauss midPoint</td>
<td>一阶或二阶，无界，应用于各向同性网格时等价于linear，使用表面通量计算</td>
</tr>
<tr class="row-even"><td>Gauss Minmod</td>
<td>一阶，无界，最小模量</td>
</tr>
<tr class="row-odd"><td>Gauss MUSCL</td>
<td>二阶，无界，守恒定律的单调上游中心格式</td>
</tr>
<tr class="row-even"><td>Gauss QUICK</td>
<td>二阶，无界，对流运动学的二次上游插值</td>
</tr>
<tr class="row-odd"><td>Gauss UMIST</td>
<td>二阶，无界，标量传输的上游单调插值</td>
</tr>
<tr class="row-even"><td>Gauss upwind</td>
<td>一阶，有界，根据上游值设置面值，相当于假设单元值是各向同性的且其值代表平均值</td>
</tr>
<tr class="row-odd"><td>Gauss vanLeer</td>
<td>二阶，无界</td>
</tr>
<tr class="row-even"><td>Gauss CoBlended &lt;co1&gt; &lt;scheme1&gt; &lt;co2&gt; &lt;scheme2&gt;</td>
<td>基于表面库朗数混合两种格式：当Co小于&lt;co1&gt;时采用&lt;scheme1&gt;，当Co大于&lt;co2&gt;时采用&lt;scheme2&gt;，当&lt;co1&gt;小于Co小于&lt;co2&gt;时线性混合&lt;scheme1&gt;和&lt;scheme2&gt;</td>
</tr>
<tr class="row-odd"><td>Gauss DEShybrid &lt;many coeff&gt;</td>
<td>基于局部属性混合两种格式</td>
</tr>
<tr class="row-even"><td>Gauss filteredLinear2 &lt;k&gt; &lt;l&gt;</td>
<td>二阶，无界，试图限制linear格式的无界性。&lt;k&gt;是缩放校正应用的比率，取0时为线性，取1时为完全限制；&lt;l&gt;是相对于difference across the face的最大允许overshoot/undershoot，取0时为没有overshoot/undershoot，取1时为overshoot/undershoot与difference across the face相等</td>
</tr>
<tr class="row-odd"><td>Gauss LUST &lt;grad-scheme&gt;</td>
<td>无界，线性迎风稳定输送，固定使用linearUpwind权重0.25，linear权重0.75</td>
</tr>
</tbody>
</table>
<p>对于某些流动情况，有几种对流方案可供选择：稳态，有界标量传输和有限方案。对于稳态情况，可以应用有界形式：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">bounded</span> <span class="n">Gauss</span> <span class="o">&lt;</span><span class="n">interpolation</span> <span class="n">scheme</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>这增加了一个线性化，隐式源贡献的传输方程的形式。也就是说，它去掉了一个与连续性误差成比例的分量。随着计算的进行，这作为收敛辅助，趋向于有界解。在收敛时，这一项变为零，对最终解没有贡献。</p>
</div>
<div class="section" id="laplacianschemes">
<h3>拉普拉斯项格式laplacianSchemes<a class="headerlink" href="#laplacianschemes" title="永久链接至标题">¶</a></h3>
<p>在流体流动的动量方程中，拉普拉斯项一般为 <span class="math notranslate nohighlight">\(\nabla\cdot(\nu\nabla\mathbf{U})\)</span> ，在OpenFOAM中表示为 <code class="code docutils literal notranslate"><span class="pre">laplacian(nu,</span> <span class="pre">U)</span></code> ，基于有限体积积分有：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\int_{V}\nabla\cdot(\nu\nabla\mathbf{U})~\mathrm{d}V=\int_{\mathbf{A}_{f}}\nu_{f}\nabla\mathbf{U}_{f}\cdot\mathrm{d}\mathbf{A}_{f}=\sum\nu_{f}\nabla\mathbf{U}_{f}\cdot\mathbf{A}_{f}
\end{align}\]</div>
<p>因此，需要指定 <span class="math notranslate nohighlight">\(\nu_{f}\)</span> 的插值格式，同时也要指定面法向梯度 <span class="math notranslate nohighlight">\(\nabla\mathbf{U}_{f}\)</span> 的离散格式。拉普拉斯格式laplacianSchemes只支持下面的格式：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Gauss</span> <span class="o">&lt;</span><span class="n">interpolationScheme</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">snGradScheme</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>其中 <code class="code docutils literal notranslate"><span class="pre">&lt;interpolationScheme&gt;</span></code> 用于指定 <span class="math notranslate nohighlight">\(\nu_{f}\)</span> 的插值格式； <code class="code docutils literal notranslate"><span class="pre">&lt;snGradScheme&gt;</span></code> 用于指定面法向梯度 <span class="math notranslate nohighlight">\(\nabla\mathbf{U}_{f}\cdot\mathbf{A}_{f}\)</span> 的离散格式：</p>
<table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="61%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">所选的&lt;snGradScheme&gt;</th>
<th class="head">数学特性</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>corrected</td>
<td>无界，二阶，守恒</td>
</tr>
<tr class="row-odd"><td>uncorrected</td>
<td>有界，一阶，非守恒</td>
</tr>
<tr class="row-even"><td>limited</td>
<td>corrected和uncorrected的混合格式</td>
</tr>
<tr class="row-odd"><td>bounded</td>
<td>有界，一阶</td>
</tr>
<tr class="row-even"><td>fourth</td>
<td>无界，四阶，守恒</td>
</tr>
</tbody>
</table>
<p>下面是一些具体的设置案例：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">default</span>         <span class="n">Gauss</span> <span class="n">linear</span> <span class="n">corrected</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="fluxrequired">
<h3>需要计算通量的场fluxRequired<a class="headerlink" href="#fluxrequired" title="永久链接至标题">¶</a></h3>
<p>fluxRequired子字典列举了数值模拟过程中需要计算通量的场。例如流体流动模拟中，在求解压力p的方程后需要计算通量，这可以通过在fluxRequired子字典中简单地指定：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">fluxRequired</span>
<span class="p">{</span>
    <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="fvsolution">
<h2>fvSolution代数方程组求解设置<a class="headerlink" href="#fvsolution" title="永久链接至标题">¶</a></h2>
<p>该文件由solvers、所采用耦合算法(PISO、SIMPLE、PIMPLE)以及relaxationFactors等子字典组成。</p>
<div class="section" id="solvers">
<h3>solvers设置<a class="headerlink" href="#solvers" title="永久链接至标题">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">solvers关键词</th>
<th class="head">含义</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td rowspan="6">solver</td>
<td rowspan="6"><p class="first">代数方程组求解器，可选的求解器包括：</p>
<ul class="last simple">
<li>PCG：预处理共轭梯度(对称)求解器；</li>
<li>PBiCG：预处理稳定双共轭梯度(非对称)求解器；</li>
<li>smoothSolver：光滑求解器；</li>
<li>GAMG：几何-代数多重网格求解器；</li>
<li>diagonal：对角求解器(显式离散)；</li>
</ul>
</td>
</tr>
<tr class="row-odd"></tr>
<tr class="row-even"></tr>
<tr class="row-odd"></tr>
<tr class="row-even"></tr>
<tr class="row-odd"></tr>
<tr class="row-even"><td rowspan="7">preconditioner</td>
<td rowspan="7"><p class="first">当solver采用了PCG/PBiCG求解器时进行设置。本质上为一个改变原先系数矩阵条件数的左乘矩阵。可选的预处理器包括：</p>
<ul class="last simple">
<li>DIC：不完全的对角Cholesky预处理器(对称矩阵)；</li>
<li>FDIC：不完全的快速对角Cholesky预处理器(相当于带缓存的DIC)；</li>
<li>DILU：对角不完全LU预处理器(非对称)；</li>
<li>diagonal：对角预处理器；</li>
<li>GAMG：几何-代数多重网格预处理器；</li>
<li>none：不进行预处理；</li>
</ul>
</td>
</tr>
<tr class="row-odd"></tr>
<tr class="row-even"></tr>
<tr class="row-odd"></tr>
<tr class="row-even"></tr>
<tr class="row-odd"></tr>
<tr class="row-even"></tr>
<tr class="row-odd"><td rowspan="4">smoother</td>
<td rowspan="4"><p class="first">当solver采用了smoothSolver时进行设置，可以选择的光滑器包括：</p>
<ul class="last simple">
<li>GaussSeidel：高斯塞德尔光顺器。一般情况下最可靠；</li>
<li>DIC：不完全的对角Cholesky光顺器(对称矩阵)。对于有些条件数不好的矩阵收敛性更好；</li>
<li>DICGaussSeidel：不完全的对角Cholesky-高斯塞德尔光顺器(对称矩阵)；</li>
</ul>
</td>
</tr>
<tr class="row-even"></tr>
<tr class="row-odd"></tr>
<tr class="row-even"></tr>
<tr class="row-odd"><td>tolerance</td>
<td>绝对残差(前后两次迭代结果的差值)。决定了求解器退出的标准。对于稳态问题应该取得很小，而对于瞬态问题则不能取得太小。</td>
</tr>
<tr class="row-even"><td>relTol</td>
<td>相对残差(前后两次迭代残差的比值)。当设置为非零数时将忽略tolerance的设置。</td>
</tr>
<tr class="row-odd"><td>maxIter</td>
<td>最大迭代次数。</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id22">
<h3>耦合算法设置<a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h3>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">//PISO算法设置</span>
<span class="n">PISO</span>
<span class="p">{</span>
    <span class="n">nCorrectors</span>     <span class="mi">2</span><span class="p">;</span>                  <span class="c1">//PISO修正次数</span>
    <span class="n">nNonOrthogonalCorrectors</span> <span class="mi">0</span><span class="p">;</span>         <span class="c1">//非正交修正次数</span>
    <span class="n">pRefCell</span>        <span class="mi">0</span><span class="p">;</span>                  <span class="c1">//压力参考单元</span>
    <span class="n">pRefValue</span>       <span class="mi">0</span><span class="p">;</span>                  <span class="c1">//压力参考值</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id23">
<h3>欠松弛处理设置<a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h3>
<p>欠松弛处理主要有两种不同的使用方式：</p>
<ul class="simple">
<li>在迭代之前提高系数矩阵主对角元素数值，并且降低源项来保证系数矩阵对角占优，比如速度场U；</li>
<li>限制变量在迭代后改变的大小，比如压力场p。</li>
</ul>
<p>欠松弛因子 <span class="math notranslate nohighlight">\(\alpha\)</span> 介于0和1之间，越接近0求解越稳定，但同时也会降低求解效率；提高 <span class="math notranslate nohighlight">\(\alpha\)</span> 的数值会提高求解效率，但同时也会降低稳定性。</p>
<p>欠松弛因子在子字典relaxationFactors下指定，通过子字典名equations和fields来设置不同的欠松弛方式，例如：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">relaxationFactors</span>
<span class="p">{</span>
    <span class="n">fields</span>
    <span class="p">{</span>
        <span class="n">p</span> <span class="mf">0.3</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">equations</span>
    <span class="p">{</span>
        <span class="n">U</span> <span class="mf">0.7</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="controldict">
<h2>controlDict设置<a class="headerlink" href="#controldict" title="永久链接至标题">¶</a></h2>
<p>位于system文件夹内的controlDict文件用于设置时间和输入输出控制，包括时间控制、计算结果输出控制、时间步长自适应控制、字典读取控制和运行时加载库或者函数五个部分。</p>
<div class="section" id="id24">
<h3>常规设置<a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h3>
<p>时间控制部分startFrom关键词决定了开始计算的时间，可选的取值包括：</p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">startFrom</th>
<th class="head">含义</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>firstTime</td>
<td>所有时间目录中最早的时间步</td>
</tr>
<tr class="row-odd"><td>latestTime</td>
<td>所有时间目录中最近的时间步</td>
</tr>
<tr class="row-even"><td>startTime</td>
<td>从指定开始的时间步开始计算，需要在下面指定startTime关键词的值</td>
</tr>
</tbody>
</table>
<p>时间控制部分stopAt关键词决定了停止计算的时间，可选的取值包括：</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="83%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">stopAt</th>
<th class="head">含义</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>endTime</td>
<td>在指定的结束时间停止计算，需要在下面指定endTime关键词的值</td>
</tr>
<tr class="row-odd"><td>writeNow</td>
<td>当前时间步完成时结束计算并且输出计算结果</td>
</tr>
<tr class="row-even"><td>noWriteNow</td>
<td>当前时间步完成时结束计算但是不输出计算结果</td>
</tr>
<tr class="row-odd"><td>nextWrite</td>
<td>下一个时间步完成时结束计算并且输出计算结果</td>
</tr>
</tbody>
</table>
<p>计算结果输出控制部分writeControl关键词决定计算结果输出间隔方式，可选的取值包括：</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">writeControl</th>
<th class="head">含义</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>timeStep</td>
<td>按照时间步输出，间隔由关键字writeInterval指定，单位为[步]</td>
</tr>
<tr class="row-odd"><td>runTime</td>
<td>按照计算时间输出，间隔由关键字writeInterval指定，单位为[s]</td>
</tr>
<tr class="row-even"><td>adjustableRunTime</td>
<td>时间自适应下按照计算时间输出，间隔由关键字writeInterval指定，单位为[s]</td>
</tr>
<tr class="row-odd"><td>cpuTime</td>
<td>按照CPU时间输出，间隔由关键字writeInterval指定，单位为[s]</td>
</tr>
<tr class="row-even"><td>clockTime</td>
<td>按照真实时间输出，间隔由关键字writeInterval指定，单位为[s]</td>
</tr>
</tbody>
</table>
<p>计算结果输出控制部分writeFormat关键词决定了计算结果输出的格式，可选的取值包括：</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="85%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">writeFormat</th>
<th class="head">含义</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>ascii</td>
<td>文本格式，由writePrecision关键词控制有效数字位数</td>
</tr>
<tr class="row-odd"><td>binary</td>
<td>二进制格式，直接将内存内容写入文件，能够减少文件存储空间，提高读写效率</td>
</tr>
</tbody>
</table>
<p>计算结果输出控制部分writeCompression关键词决定了输出文件是否压缩，可选的取值包括：</p>
<table border="1" class="docutils">
<colgroup>
<col width="56%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">writeCompression</th>
<th class="head">含义</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>uncompressed</td>
<td>不压缩</td>
</tr>
<tr class="row-odd"><td>compressed</td>
<td>gzip压缩格式</td>
</tr>
</tbody>
</table>
<p>计算结果输出控制部分timeFormat关键词决定了时间的格式，可选的取值包括：</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="86%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">timeFormat</th>
<th class="head">含义</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>fixed</td>
<td><span class="math notranslate nohighlight">\(\pm\text{m.dddddd}\)</span> ，其中d由timePrecision来控制</td>
</tr>
<tr class="row-odd"><td>scientific</td>
<td><span class="math notranslate nohighlight">\(\pm\text{m.dddddd}\pm\text{xx}\)</span> ，其中d由timePrecision来控制</td>
</tr>
<tr class="row-even"><td>general</td>
<td>使用scientific格式，默认小数点后有4位有效位数，也可通过timePrecision来调节</td>
</tr>
</tbody>
</table>
<p>自适应时间步长需要指定自适应开关adjustTimeStep，最大库朗数maxCo时间步长最大值maxDeltaT的数值，例如：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">//时间步长自适应控制</span>
<span class="n">adjustTimeStep</span>  <span class="n">yes</span><span class="p">;</span>                <span class="c1">//是否开启时间步长自适应</span>
<span class="n">maxCo</span>           <span class="mf">0.5</span><span class="p">;</span>                <span class="c1">//最大库郎数</span>
<span class="n">maxDeltaT</span>       <span class="mf">1.0</span><span class="p">;</span>                <span class="c1">//最大时间步长</span>
</pre></div>
</div>
<p>在计算过程当中，一些字典文件可能会被修改，这时需要打开读取开关runTimeModifiable，以让求解器更新一些参数。</p>
</div>
<div class="section" id="id25">
<h3>运行时加载库或者函数控制<a class="headerlink" href="#id25" title="永久链接至标题">¶</a></h3>
<p>设置运行时需要加载的库或函数如下所示：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">libs</span>        <span class="n">libUser1</span><span class="p">.</span><span class="n">so</span><span class="p">;</span>    <span class="c1">//库列表，库文件位于$LD_LIBRARY_PATH</span>
<span class="n">functions</span>   <span class="n">probes</span><span class="p">;</span>         <span class="c1">//函数列表</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id26">
<h2>后处理<a class="headerlink" href="#id26" title="永久链接至标题">¶</a></h2>
<div class="section" id="postprocess">
<h3>postProcess<a class="headerlink" href="#postprocess" title="永久链接至标题">¶</a></h3>
<p>可以在终端通过下面的命令查看可用的后处理方法：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>postProcess -list
</pre></div>
</div>
<p>在使用postProcess功能前，需要在controlDict文件内的functions字典内添加相应的子字典设置。然后通过在终端输入下面的命令进行后处理：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>&lt;solver&gt; -postProcess
</pre></div>
</div>
<div class="section" id="age">
<h4>age<a class="headerlink" href="#age" title="永久链接至标题">¶</a></h4>
<p>Calculates and writes out the time taken for a particle to travel from an inlet to the location. Solves the following equation when incompressible: f[ div (phi t) = 1 f] where: t is Age [s], phi is Volumetric flux [m^3/s]. Boundary conditions are generated automatically as zeroGradient on all walls and inletOutlet everywhere else.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">age1</span>
<span class="p">{</span>
    <span class="n">type</span>            <span class="n">age</span><span class="p">;</span>
    <span class="n">libs</span>            <span class="p">(</span><span class="s">&quot;libsolverFunctionObjects.so&quot;</span><span class="p">);</span>

    <span class="n">executeControl</span>  <span class="n">writeTime</span><span class="p">;</span>
    <span class="n">writeControl</span>    <span class="n">writeTime</span><span class="p">;</span>

    <span class="n">schemesField</span>    <span class="n">k</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="literal-block-wrapper docutils container" id="id77">
<div class="code-block-caption"><span class="caption-text">src/functionObjects/field/age/age.C</span><a class="headerlink" href="#id77" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">Foam</span><span class="o">::</span><span class="n">functionObjects</span><span class="o">::</span><span class="n">age</span><span class="o">::</span><span class="n">read</span><span class="p">(</span><span class="k">const</span> <span class="n">dictionary</span><span class="o">&amp;</span> <span class="n">dict</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">phiName_</span> <span class="o">=</span> <span class="n">dict</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;phi&quot;</span><span class="p">,</span> <span class="s">&quot;phi&quot;</span><span class="p">);</span>
    <span class="n">rhoName_</span> <span class="o">=</span> <span class="n">dict</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;rho&quot;</span><span class="p">,</span> <span class="s">&quot;rho&quot;</span><span class="p">);</span>
    <span class="n">nCorr_</span> <span class="o">=</span> <span class="n">dict</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;nCorr&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
    <span class="n">schemesField_</span> <span class="o">=</span> <span class="n">dict</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;schemesField&quot;</span><span class="p">,</span> <span class="n">typeName</span><span class="p">);</span>
    <span class="n">diffusion_</span> <span class="o">=</span> <span class="n">dict</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">Switch</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;diffusion&quot;</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="n">tolerance_</span> <span class="o">=</span> <span class="n">dict</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;tolerance&quot;</span><span class="p">,</span> <span class="mf">1e-5</span><span class="p">);</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id78">
<div class="code-block-caption"><span class="caption-text">src/functionObjects/field/age/age.C</span><a class="headerlink" href="#id78" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">Foam</span><span class="o">::</span><span class="n">functionObjects</span><span class="o">::</span><span class="n">age</span><span class="o">::</span><span class="n">execute</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">tage</span>
    <span class="p">(</span>
        <span class="n">new</span> <span class="n">volScalarField</span>
        <span class="p">(</span>
            <span class="n">IOobject</span>
            <span class="p">(</span>
                <span class="n">typeName</span><span class="p">,</span>
                <span class="n">mesh_</span><span class="p">.</span><span class="n">time</span><span class="p">().</span><span class="n">timeName</span><span class="p">(),</span>
                <span class="n">mesh_</span><span class="p">,</span>
                <span class="n">IOobject</span><span class="o">::</span><span class="n">READ_IF_PRESENT</span><span class="p">,</span>
                <span class="n">IOobject</span><span class="o">::</span><span class="n">AUTO_WRITE</span><span class="p">,</span>
                <span class="nb">false</span>
            <span class="p">),</span>
            <span class="n">mesh_</span><span class="p">,</span>
            <span class="n">dimensionedScalar</span><span class="p">(</span><span class="n">dimTime</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="n">patchTypes</span><span class="p">()</span>
        <span class="p">)</span>
    <span class="p">);</span>
    <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">age</span> <span class="o">=</span> <span class="n">tage</span><span class="p">.</span><span class="n">ref</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">word</span> <span class="nf">divScheme</span><span class="p">(</span><span class="s">&quot;div(phi,&quot;</span> <span class="o">+</span> <span class="n">schemesField_</span> <span class="o">+</span> <span class="s">&quot;)&quot;)</span><span class="p">;</span>

    <span class="c1">// Set under-relaxation coeff</span>
    <span class="n">scalar</span> <span class="n">relaxCoeff</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mesh_</span><span class="p">.</span><span class="n">solution</span><span class="p">().</span><span class="n">relaxEquation</span><span class="p">(</span><span class="n">schemesField_</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">relaxCoeff</span> <span class="o">=</span> <span class="n">mesh_</span><span class="p">.</span><span class="n">solution</span><span class="p">().</span><span class="n">equationRelaxationFactor</span><span class="p">(</span><span class="n">schemesField_</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">Foam</span><span class="o">::</span><span class="n">fvModels</span><span class="o">&amp;</span> <span class="n">fvModels</span><span class="p">(</span><span class="n">Foam</span><span class="o">::</span><span class="n">fvModels</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">mesh_</span><span class="p">));</span>
    <span class="k">const</span> <span class="n">Foam</span><span class="o">::</span><span class="n">fvConstraints</span><span class="o">&amp;</span> <span class="n">fvConstraints</span>
    <span class="p">(</span>
        <span class="n">Foam</span><span class="o">::</span><span class="n">fvConstraints</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">mesh_</span><span class="p">)</span>
    <span class="p">);</span>

    <span class="c1">// This only works because the null constructed inletValue for an inletOutletFvPatchField is zero.</span>
    <span class="c1">// If we needed any other value we would have to loop over the inletOutlet patches and explicitly set the inletValues.</span>
    <span class="c1">// We would need to change the interface of inletOutlet in order to do this.</span>

    <span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">phi</span> <span class="o">=</span> <span class="n">mesh_</span><span class="p">.</span><span class="n">lookupObject</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="o">&gt;</span><span class="p">(</span><span class="n">phiName_</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">phi</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()</span> <span class="o">==</span> <span class="n">dimMass</span><span class="o">/</span><span class="n">dimTime</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">rho</span> <span class="o">=</span> <span class="n">mesh_</span><span class="p">.</span><span class="n">lookupObject</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rhoName_</span><span class="p">);</span>

        <span class="k">const</span> <span class="n">word</span> <span class="nf">laplacianScheme</span><span class="p">(</span><span class="s">&quot;laplacian(muEff,&quot;</span> <span class="o">+</span> <span class="n">schemesField_</span> <span class="o">+</span> <span class="s">&quot;)&quot;)</span><span class="p">;</span>

        <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">tnuEff</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">diffusion_</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">tnuEff</span> <span class="o">=</span> <span class="n">mesh_</span><span class="p">.</span><span class="n">lookupObject</span><span class="o">&lt;</span><span class="n">momentumTransportModel</span><span class="o">&gt;</span><span class="p">(</span><span class="n">momentumTransportModel</span><span class="o">::</span><span class="n">typeName</span><span class="p">).</span><span class="n">nuEff</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">nCorr_</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">fvScalarMatrix</span> <span class="n">ageEqn</span>
            <span class="p">(</span>
                <span class="n">fvm</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">age</span><span class="p">,</span> <span class="n">divScheme</span><span class="p">)</span> <span class="o">==</span> <span class="n">rho</span> <span class="o">+</span> <span class="n">fvModels</span><span class="p">.</span><span class="n">source</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span>
            <span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">diffusion_</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">ageEqn</span> <span class="o">-=</span> <span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">rho</span><span class="o">*</span><span class="n">tnuEff</span><span class="p">(),</span> <span class="n">age</span><span class="p">,</span> <span class="n">laplacianScheme</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="n">ageEqn</span><span class="p">.</span><span class="n">relax</span><span class="p">(</span><span class="n">relaxCoeff</span><span class="p">);</span>

            <span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">ageEqn</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">converged</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ageEqn</span><span class="p">.</span><span class="n">solve</span><span class="p">(</span><span class="n">schemesField_</span><span class="p">).</span><span class="n">initialResidual</span><span class="p">()))</span>
            <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">};</span>

            <span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">age</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">tnuEff</span><span class="p">;</span>
        <span class="n">word</span> <span class="n">laplacianScheme</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">diffusion_</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">tnuEff</span> <span class="o">=</span> <span class="n">mesh_</span><span class="p">.</span><span class="n">lookupObject</span><span class="o">&lt;</span><span class="n">momentumTransportModel</span><span class="o">&gt;</span><span class="p">(</span><span class="n">momentumTransportModel</span><span class="o">::</span><span class="n">typeName</span><span class="p">).</span><span class="n">nuEff</span><span class="p">();</span>

            <span class="n">laplacianScheme</span> <span class="o">=</span> <span class="s">&quot;laplacian(&quot;</span> <span class="o">+</span> <span class="n">tnuEff</span><span class="p">().</span><span class="n">name</span><span class="p">()</span> <span class="o">+</span> <span class="sc">&#39;,&#39;</span> <span class="o">+</span> <span class="n">schemesField_</span> <span class="o">+</span> <span class="s">&quot;)&quot;</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">nCorr_</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">fvScalarMatrix</span> <span class="n">ageEqn</span>
            <span class="p">(</span>
                <span class="n">fvm</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">age</span><span class="p">,</span> <span class="n">divScheme</span><span class="p">)</span> <span class="o">==</span> <span class="n">dimensionedScalar</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fvModels</span><span class="p">.</span><span class="n">source</span><span class="p">(</span><span class="n">age</span><span class="p">)</span>
            <span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">diffusion_</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">ageEqn</span> <span class="o">-=</span> <span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">tnuEff</span><span class="p">(),</span> <span class="n">age</span><span class="p">,</span> <span class="n">laplacianScheme</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="n">ageEqn</span><span class="p">.</span><span class="n">relax</span><span class="p">(</span><span class="n">relaxCoeff</span><span class="p">);</span>

            <span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">ageEqn</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">converged</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ageEqn</span><span class="p">.</span><span class="n">solve</span><span class="p">(</span><span class="n">schemesField_</span><span class="p">).</span><span class="n">initialResidual</span><span class="p">()))</span>
            <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">age</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Min/max age:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">min</span><span class="p">(</span><span class="n">age</span><span class="p">).</span><span class="n">value</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span> <span class="o">&lt;&lt;</span> <span class="n">max</span><span class="p">(</span><span class="n">age</span><span class="p">).</span><span class="n">value</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="nf">store</span><span class="p">(</span><span class="n">tage</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="courantno">
<h4>CourantNo<a class="headerlink" href="#courantno" title="永久链接至标题">¶</a></h4>
<p>Calculates and outputs the Courant number as a volScalarField.  The field is stored on the mesh database so that it can be retrieved and used for other applications.</p>
<div class="literal-block-wrapper docutils container" id="id79">
<div class="code-block-caption"><span class="caption-text">src/functionObjects/field/CourantNo/CourantNo.C</span><a class="headerlink" href="#id79" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">volScalarField</span><span class="o">::</span><span class="n">Internal</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">functionObjects</span><span class="o">::</span><span class="n">CourantNo</span><span class="o">::</span><span class="n">byRho</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">::</span><span class="n">Internal</span><span class="o">&gt;&amp;</span> <span class="n">Co</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Co</span><span class="p">().</span><span class="n">dimensions</span><span class="p">()</span> <span class="o">==</span> <span class="n">dimDensity</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Co</span><span class="o">/</span><span class="n">obr_</span><span class="p">.</span><span class="n">lookupObject</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rhoName_</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Co</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="kt">bool</span> <span class="n">Foam</span><span class="o">::</span><span class="n">functionObjects</span><span class="o">::</span><span class="n">CourantNo</span><span class="o">::</span><span class="n">calc</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">foundObject</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fieldName_</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">phi</span> <span class="o">=</span> <span class="n">lookupObject</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fieldName_</span><span class="p">);</span>

        <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">tCo</span>
        <span class="p">(</span>
            <span class="n">volScalarField</span><span class="o">::</span><span class="n">New</span>
            <span class="p">(</span>
                <span class="n">resultName_</span><span class="p">,</span>
                <span class="n">mesh_</span><span class="p">,</span>
                <span class="n">dimensionedScalar</span><span class="p">(</span><span class="n">dimless</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                <span class="n">zeroGradientFvPatchScalarField</span><span class="o">::</span><span class="n">typeName</span>
            <span class="p">)</span>
        <span class="p">);</span>

        <span class="n">tCo</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">()</span> <span class="o">=</span> <span class="n">byRho</span><span class="p">(</span> <span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">mesh_</span><span class="p">.</span><span class="n">time</span><span class="p">().</span><span class="n">deltaT</span><span class="p">())</span> <span class="o">*</span> <span class="n">fvc</span><span class="o">::</span><span class="n">surfaceSum</span><span class="p">(</span><span class="n">mag</span><span class="p">(</span><span class="n">phi</span><span class="p">))()()</span><span class="o">/</span><span class="n">mesh_</span><span class="p">.</span><span class="n">V</span><span class="p">()</span> <span class="p">);</span>

        <span class="n">tCo</span><span class="o">-&gt;</span><span class="n">correctBoundaryConditions</span><span class="p">();</span>

        <span class="k">return</span> <span class="nf">store</span><span class="p">(</span><span class="n">resultName_</span><span class="p">,</span> <span class="n">tCo</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">cannotFindObject</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fieldName_</span><span class="p">);</span>

        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="c1">// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //</span>

<span class="n">Foam</span><span class="o">::</span><span class="n">functionObjects</span><span class="o">::</span><span class="n">CourantNo</span><span class="o">::</span><span class="n">CourantNo</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">word</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Time</span><span class="o">&amp;</span> <span class="n">runTime</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">dictionary</span><span class="o">&amp;</span> <span class="n">dict</span>
<span class="p">)</span>
<span class="o">:</span>
    <span class="n">fieldExpression</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">runTime</span><span class="p">,</span> <span class="n">dict</span><span class="p">,</span> <span class="s">&quot;Co&quot;</span><span class="p">,</span> <span class="s">&quot;phi&quot;</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">read</span><span class="p">(</span><span class="n">dict</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //</span>

<span class="kt">bool</span> <span class="n">Foam</span><span class="o">::</span><span class="n">functionObjects</span><span class="o">::</span><span class="n">CourantNo</span><span class="o">::</span><span class="n">read</span><span class="p">(</span><span class="k">const</span> <span class="n">dictionary</span><span class="o">&amp;</span> <span class="n">dict</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">fieldExpression</span><span class="o">::</span><span class="n">read</span><span class="p">(</span><span class="n">dict</span><span class="p">);</span>

    <span class="n">rhoName_</span> <span class="o">=</span> <span class="n">dict</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;rho&quot;</span><span class="p">,</span> <span class="s">&quot;rho&quot;</span><span class="p">);</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="machno">
<h4>MachNo<a class="headerlink" href="#machno" title="永久链接至标题">¶</a></h4>
<p>Calculates and writes the Mach number as a volScalarField.</p>
<div class="literal-block-wrapper docutils container" id="id80">
<div class="code-block-caption"><span class="caption-text">src/functionObjects/field/MachNo/MachNo.C</span><a class="headerlink" href="#id80" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">Foam</span><span class="o">::</span><span class="n">functionObjects</span><span class="o">::</span><span class="n">MachNo</span><span class="o">::</span><span class="n">calc</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span>
    <span class="p">(</span>
        <span class="n">foundObject</span><span class="o">&lt;</span><span class="n">volVectorField</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fieldName_</span><span class="p">)</span>
     <span class="o">&amp;&amp;</span> <span class="n">foundObject</span><span class="o">&lt;</span><span class="n">fluidThermo</span><span class="o">&gt;</span><span class="p">(</span><span class="n">physicalProperties</span><span class="o">::</span><span class="n">typeName</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">fluidThermo</span><span class="o">&amp;</span> <span class="n">thermo</span> <span class="o">=</span> <span class="n">lookupObject</span><span class="o">&lt;</span><span class="n">fluidThermo</span><span class="o">&gt;</span><span class="p">(</span><span class="n">physicalProperties</span><span class="o">::</span><span class="n">typeName</span><span class="p">);</span>

        <span class="k">const</span> <span class="n">volVectorField</span><span class="o">&amp;</span> <span class="n">U</span> <span class="o">=</span> <span class="n">lookupObject</span><span class="o">&lt;</span><span class="n">volVectorField</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fieldName_</span><span class="p">);</span>

        <span class="k">return</span> <span class="nf">store</span>
        <span class="p">(</span>
            <span class="n">resultName_</span><span class="p">,</span>
            <span class="n">mag</span><span class="p">(</span><span class="n">U</span><span class="p">)</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="n">thermo</span><span class="p">.</span><span class="n">gamma</span><span class="p">()</span><span class="o">*</span><span class="n">thermo</span><span class="p">.</span><span class="n">p</span><span class="p">()</span><span class="o">/</span><span class="n">thermo</span><span class="p">.</span><span class="n">rho</span><span class="p">())</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="c1">// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //</span>

<span class="n">Foam</span><span class="o">::</span><span class="n">functionObjects</span><span class="o">::</span><span class="n">MachNo</span><span class="o">::</span><span class="n">MachNo</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">word</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Time</span><span class="o">&amp;</span> <span class="n">runTime</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">dictionary</span><span class="o">&amp;</span> <span class="n">dict</span>
<span class="p">)</span>
<span class="o">:</span>
    <span class="n">fieldExpression</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">runTime</span><span class="p">,</span> <span class="n">dict</span><span class="p">,</span> <span class="s">&quot;Ma&quot;</span><span class="p">,</span> <span class="s">&quot;U&quot;</span><span class="p">)</span>
<span class="p">{}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="forces">
<h4>forces<a class="headerlink" href="#forces" title="永久链接至标题">¶</a></h4>
<p>使用forces功能需要在controlDict的functions字典中添加如下内容：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">forces1</span>
<span class="p">{</span>
    <span class="c1">// Mandatory entries</span>
    <span class="n">type</span>            <span class="n">forces</span><span class="p">;</span>
    <span class="n">libs</span>            <span class="p">(</span><span class="s">&quot;libforces.so&quot;</span><span class="p">);</span>
    <span class="n">patches</span>         <span class="p">(</span><span class="o">&lt;</span><span class="n">list</span> <span class="n">of</span> <span class="n">patch</span> <span class="n">names</span><span class="o">&gt;</span><span class="p">);</span>

    <span class="c1">// Field names</span>
    <span class="n">p</span>               <span class="n">p</span><span class="p">;</span>
    <span class="n">U</span>               <span class="n">U</span><span class="p">;</span>
    <span class="n">rho</span>             <span class="n">rho</span><span class="p">;</span>
    <span class="c1">// 如果是不可压缩流则将rho修改为如下设置</span>
    <span class="c1">// rho         rhoInf;</span>
    <span class="c1">// rhoInf      100000;</span>

    <span class="n">pRef</span>            <span class="mi">0</span><span class="p">;</span>          <span class="c1">// Reference pressure [Pa]</span>
    <span class="n">porosity</span>        <span class="n">no</span><span class="p">;</span>         <span class="c1">// Include porosity effects?</span>
    <span class="n">writeFields</span>     <span class="n">yes</span><span class="p">;</span>        <span class="c1">// Store and write volume field representations of forces and moments</span>
    <span class="n">CofR</span>            <span class="p">(</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">);</span>    <span class="c1">// Centre of rotation for moment calculations</span>

    <span class="c1">// Spatial data binning</span>
    <span class="c1">// - extents given by the bounds of the input geometry</span>
    <span class="cm">/* binData</span>
<span class="cm">    {</span>
<span class="cm">        nBin        20;</span>
<span class="cm">        direction   (1 0 0);</span>
<span class="cm">        cumulative  yes;</span>
<span class="cm">    } */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>forces功能读取controlDict中functions字典的逻辑如下：</p>
<div class="literal-block-wrapper docutils container" id="id81">
<div class="code-block-caption"><span class="caption-text">src/functionObjects/forces/forces/forces.C</span><a class="headerlink" href="#id81" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">Foam</span><span class="o">::</span><span class="n">functionObjects</span><span class="o">::</span><span class="n">forces</span><span class="o">::</span><span class="n">read</span><span class="p">(</span><span class="k">const</span> <span class="n">dictionary</span><span class="o">&amp;</span> <span class="n">dict</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">fvMeshFunctionObject</span><span class="o">::</span><span class="n">read</span><span class="p">(</span><span class="n">dict</span><span class="p">);</span>

    <span class="n">initialised_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="n">Log</span> <span class="o">&lt;&lt;</span> <span class="n">type</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span><span class="p">;</span>

    <span class="n">directForceDensity_</span> <span class="o">=</span> <span class="n">dict</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="p">(</span><span class="s">&quot;directForceDensity&quot;</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>    <span class="c1">// 是否直接提供force density，默认为false</span>

    <span class="k">const</span> <span class="n">polyBoundaryMesh</span><span class="o">&amp;</span> <span class="n">pbm</span> <span class="o">=</span> <span class="n">mesh_</span><span class="p">.</span><span class="n">boundaryMesh</span><span class="p">();</span>
    <span class="n">patchSet_</span> <span class="o">=</span> <span class="n">pbm</span><span class="p">.</span><span class="n">patchSet</span><span class="p">(</span><span class="n">wordReList</span><span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="s">&quot;patches&quot;</span><span class="p">)));</span>    <span class="c1">// 读取边界面名称</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">directForceDensity_</span><span class="p">)</span>    <span class="c1">// 如果直接提供force density</span>
    <span class="p">{</span>
        <span class="c1">// Optional entry for fDName</span>
        <span class="n">fDName_</span> <span class="o">=</span> <span class="n">dict</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;fD&quot;</span><span class="p">,</span> <span class="s">&quot;fD&quot;</span><span class="p">);</span>    <span class="c1">// 读取fD</span>
    <span class="p">}</span>
    <span class="k">else</span>    <span class="c1">// 如果没有直接提供force density(默认情况)</span>
    <span class="p">{</span>
        <span class="c1">// Optional phase entry</span>
        <span class="n">phaseName_</span> <span class="o">=</span> <span class="n">dict</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;phase&quot;</span><span class="p">,</span> <span class="n">word</span><span class="o">::</span><span class="n">null</span><span class="p">);</span>    <span class="c1">// 读取相名称，默认为空</span>

        <span class="c1">// Optional U, p and rho entries</span>
        <span class="n">pName_</span> <span class="o">=</span> <span class="n">dict</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span> <span class="p">(</span> <span class="s">&quot;p&quot;</span><span class="p">,</span> <span class="n">IOobject</span><span class="o">::</span><span class="n">groupName</span><span class="p">(</span><span class="s">&quot;p&quot;</span><span class="p">,</span> <span class="n">phaseName_</span><span class="p">)</span> <span class="p">);</span>    <span class="c1">// 读取压强场名称</span>
        <span class="n">UName_</span> <span class="o">=</span> <span class="n">dict</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span> <span class="p">(</span> <span class="s">&quot;U&quot;</span><span class="p">,</span> <span class="n">IOobject</span><span class="o">::</span><span class="n">groupName</span><span class="p">(</span><span class="s">&quot;U&quot;</span><span class="p">,</span> <span class="n">phaseName_</span><span class="p">)</span> <span class="p">);</span>    <span class="c1">// 读取速度场名称</span>
        <span class="n">rhoName_</span> <span class="o">=</span> <span class="n">dict</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span> <span class="p">(</span> <span class="s">&quot;rho&quot;</span><span class="p">,</span> <span class="n">IOobject</span><span class="o">::</span><span class="n">groupName</span><span class="p">(</span><span class="s">&quot;rho&quot;</span><span class="p">,</span> <span class="n">phaseName_</span><span class="p">)</span> <span class="p">);</span>    <span class="c1">// 读取密度场名称</span>

        <span class="c1">// Reference density needed for incompressible calculations</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rhoName_</span> <span class="o">==</span> <span class="s">&quot;rhoInf&quot;</span><span class="p">)</span>    <span class="c1">// 如果密度场名称设置为了rhoInf</span>
        <span class="p">{</span>
            <span class="n">dict</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="s">&quot;rhoInf&quot;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">rhoRef_</span><span class="p">;</span>    <span class="c1">// 那么rhoRef的值即为rhoInf的值</span>
        <span class="p">}</span>

        <span class="c1">// Reference pressure, 0 by default</span>
        <span class="n">pRef_</span> <span class="o">=</span> <span class="n">dict</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;pRef&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>    <span class="c1">// 读取参考压强，默认为零</span>
    <span class="p">}</span>

    <span class="c1">// Centre of rotation for moment calculations specified directly, from coordinate system, or implicitly (0 0 0)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">found</span><span class="p">(</span><span class="s">&quot;CofR&quot;</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">coordSys_</span> <span class="o">=</span> <span class="n">coordinateSystem</span><span class="p">(</span><span class="s">&quot;coordSys&quot;</span><span class="p">,</span> <span class="n">vector</span><span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="s">&quot;CofR&quot;</span><span class="p">)));</span>
        <span class="n">localSystem_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">coordSys_</span> <span class="o">=</span> <span class="n">coordinateSystem</span><span class="p">(</span><span class="s">&quot;coordSys&quot;</span><span class="p">,</span> <span class="n">dict</span><span class="p">);</span>
        <span class="n">localSystem_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">dict</span><span class="p">.</span><span class="n">readIfPresent</span><span class="p">(</span><span class="s">&quot;porosity&quot;</span><span class="p">,</span> <span class="n">porosity_</span><span class="p">);</span>    <span class="c1">// 孔隙度</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">porosity_</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Log</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;    Including porosity effects&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">Log</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;    Not including porosity effects&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">found</span><span class="p">(</span><span class="s">&quot;binData&quot;</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">dictionary</span><span class="o">&amp;</span> <span class="n">binDict</span><span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">subDict</span><span class="p">(</span><span class="s">&quot;binData&quot;</span><span class="p">));</span>
        <span class="n">binDict</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="s">&quot;nBin&quot;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">nBin_</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">nBin_</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">FatalIOErrorInFunction</span><span class="p">(</span><span class="n">dict</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Number of bins (nBin) must be zero or greater&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">exit</span><span class="p">(</span><span class="n">FatalIOError</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">nBin_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">nBin_</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">nBin_</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">forAll</span><span class="p">(</span><span class="n">force_</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">force_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">setSize</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
                <span class="n">moment_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">setSize</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">nBin_</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">binDict</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="s">&quot;direction&quot;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">binDir_</span><span class="p">;</span>
            <span class="n">binDir_</span> <span class="o">/=</span> <span class="n">mag</span><span class="p">(</span><span class="n">binDir_</span><span class="p">);</span>

            <span class="n">binMin_</span> <span class="o">=</span> <span class="n">great</span><span class="p">;</span>
            <span class="n">scalar</span> <span class="n">binMax</span> <span class="o">=</span> <span class="o">-</span><span class="n">great</span><span class="p">;</span>
            <span class="n">forAllConstIter</span><span class="p">(</span><span class="n">labelHashSet</span><span class="p">,</span> <span class="n">patchSet_</span><span class="p">,</span> <span class="n">iter</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">const</span> <span class="n">label</span> <span class="n">patchi</span> <span class="o">=</span> <span class="n">iter</span><span class="p">.</span><span class="n">key</span><span class="p">();</span>
                <span class="k">const</span> <span class="n">polyPatch</span><span class="o">&amp;</span> <span class="n">pp</span> <span class="o">=</span> <span class="n">pbm</span><span class="p">[</span><span class="n">patchi</span><span class="p">];</span>
                <span class="k">const</span> <span class="n">scalarField</span> <span class="nf">d</span><span class="p">(</span><span class="n">pp</span><span class="p">.</span><span class="n">faceCentres</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">binDir_</span><span class="p">);</span>
                <span class="n">binMin_</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">binMin_</span><span class="p">);</span>
                <span class="n">binMax</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">binMax</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">reduce</span><span class="p">(</span><span class="n">binMin_</span><span class="p">,</span> <span class="n">minOp</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;</span><span class="p">());</span>
            <span class="n">reduce</span><span class="p">(</span><span class="n">binMax</span><span class="p">,</span> <span class="n">maxOp</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;</span><span class="p">());</span>

            <span class="c1">// slightly boost binMax so that region of interest is fully within bounds</span>
            <span class="n">binMax</span> <span class="o">=</span> <span class="mf">1.0001</span><span class="o">*</span><span class="p">(</span><span class="n">binMax</span> <span class="o">-</span> <span class="n">binMin_</span><span class="p">)</span> <span class="o">+</span> <span class="n">binMin_</span><span class="p">;</span>

            <span class="n">binDx_</span> <span class="o">=</span> <span class="p">(</span><span class="n">binMax</span> <span class="o">-</span> <span class="n">binMin_</span><span class="p">)</span><span class="o">/</span><span class="n">scalar</span><span class="p">(</span><span class="n">nBin_</span><span class="p">);</span>

            <span class="c1">// create the bin points used for writing</span>
            <span class="n">binPoints_</span><span class="p">.</span><span class="n">setSize</span><span class="p">(</span><span class="n">nBin_</span><span class="p">);</span>
            <span class="n">forAll</span><span class="p">(</span><span class="n">binPoints_</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">binPoints_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">binDir_</span><span class="o">*</span><span class="n">binDx_</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">binDict</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="s">&quot;cumulative&quot;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">binCumulative_</span><span class="p">;</span>

            <span class="c1">// allocate storage for forces and moments</span>
            <span class="n">forAll</span><span class="p">(</span><span class="n">force_</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">force_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">setSize</span><span class="p">(</span><span class="n">nBin_</span><span class="p">);</span>
                <span class="n">moment_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">setSize</span><span class="p">(</span><span class="n">nBin_</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">nBin_</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// allocate storage for forces and moments</span>
        <span class="n">force_</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">setSize</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">force_</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">setSize</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">force_</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">setSize</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">moment_</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">setSize</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">moment_</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">setSize</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">moment_</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">setSize</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">resetNames</span><span class="p">(</span><span class="n">createFileNames</span><span class="p">(</span><span class="n">dict</span><span class="p">));</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>在forces功能中计算forces和moment的方式如下：</p>
<div class="literal-block-wrapper docutils container" id="id82">
<div class="code-block-caption"><span class="caption-text">src/functionObjects/forces/forces/forces.C</span><a class="headerlink" href="#id82" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">functionObjects</span><span class="o">::</span><span class="n">forces</span><span class="o">::</span><span class="n">calcForcesMoment</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">initialise</span><span class="p">();</span>

    <span class="n">force_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Zero</span><span class="p">;</span>    <span class="c1">// pressure force per bin</span>
    <span class="n">force_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Zero</span><span class="p">;</span>    <span class="c1">// viscous force per bin</span>
    <span class="n">force_</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">Zero</span><span class="p">;</span>    <span class="c1">// porous force per bin</span>

    <span class="n">moment_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Zero</span><span class="p">;</span>    <span class="c1">// pressure moment per bin</span>
    <span class="n">moment_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Zero</span><span class="p">;</span>    <span class="c1">// viscous moment per bin</span>
    <span class="n">moment_</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">Zero</span><span class="p">;</span>    <span class="c1">// porous moment per bin</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">directForceDensity_</span><span class="p">)</span>    <span class="c1">// 如果直接提供了force density的数据</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">volVectorField</span><span class="o">&amp;</span> <span class="n">fD</span> <span class="o">=</span> <span class="n">obr_</span><span class="p">.</span><span class="n">lookupObject</span><span class="o">&lt;</span><span class="n">volVectorField</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fDName_</span><span class="p">);</span>    <span class="c1">// 读取force density</span>

        <span class="k">const</span> <span class="n">surfaceVectorField</span><span class="o">::</span><span class="n">Boundary</span><span class="o">&amp;</span> <span class="n">Sfb</span> <span class="o">=</span> <span class="n">mesh_</span><span class="p">.</span><span class="n">Sf</span><span class="p">().</span><span class="n">boundaryField</span><span class="p">();</span>    <span class="c1">// 边界面的面法向量</span>

        <span class="n">forAllConstIter</span><span class="p">(</span><span class="n">labelHashSet</span><span class="p">,</span> <span class="n">patchSet_</span><span class="p">,</span> <span class="n">iter</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">const</span> <span class="n">label</span> <span class="n">patchi</span> <span class="o">=</span> <span class="n">iter</span><span class="p">.</span><span class="n">key</span><span class="p">();</span>

            <span class="k">const</span> <span class="n">vectorField</span> <span class="nf">Md</span> <span class="p">(</span> <span class="n">mesh_</span><span class="p">.</span><span class="n">C</span><span class="p">().</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">]</span> <span class="o">-</span> <span class="n">coordSys_</span><span class="p">.</span><span class="n">origin</span><span class="p">()</span> <span class="p">);</span>

            <span class="k">const</span> <span class="n">scalarField</span> <span class="nf">sA</span><span class="p">(</span><span class="n">mag</span><span class="p">(</span><span class="n">Sfb</span><span class="p">[</span><span class="n">patchi</span><span class="p">]));</span>    <span class="c1">// 边界面的网格面积</span>

            <span class="c1">// Normal force = surfaceUnitNormal*(surfaceNormal &amp; forceDensity)</span>
            <span class="k">const</span> <span class="n">vectorField</span> <span class="n">fN</span>    <span class="c1">// 法向力</span>
            <span class="p">(</span>
                <span class="n">Sfb</span><span class="p">[</span><span class="n">patchi</span><span class="p">]</span><span class="o">/</span><span class="n">sA</span> <span class="o">*</span> <span class="p">(</span> <span class="n">Sfb</span><span class="p">[</span><span class="n">patchi</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">fD</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">]</span> <span class="p">)</span>
            <span class="p">);</span>

            <span class="c1">// Tangential force (total force minus normal fN)</span>
            <span class="k">const</span> <span class="n">vectorField</span> <span class="nf">fT</span><span class="p">(</span><span class="n">sA</span><span class="o">*</span><span class="n">fD</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">]</span> <span class="o">-</span> <span class="n">fN</span><span class="p">);</span>    <span class="c1">// 切向力</span>

            <span class="c1">//- Porous force</span>
            <span class="k">const</span> <span class="n">vectorField</span> <span class="nf">fP</span><span class="p">(</span><span class="n">Md</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">Zero</span><span class="p">);</span>    <span class="c1">// 孔隙力</span>

            <span class="n">applyBins</span><span class="p">(</span><span class="n">Md</span><span class="p">,</span> <span class="n">fN</span><span class="p">,</span> <span class="n">fT</span><span class="p">,</span> <span class="n">fP</span><span class="p">,</span> <span class="n">mesh_</span><span class="p">.</span><span class="n">C</span><span class="p">().</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span>    <span class="c1">// 如果没有直接提供force density的数据(默认情况)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">obr_</span><span class="p">.</span><span class="n">lookupObject</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pName_</span><span class="p">);</span>    <span class="c1">// 读取压强</span>

        <span class="k">const</span> <span class="n">surfaceVectorField</span><span class="o">::</span><span class="n">Boundary</span><span class="o">&amp;</span> <span class="n">Sfb</span> <span class="o">=</span> <span class="n">mesh_</span><span class="p">.</span><span class="n">Sf</span><span class="p">().</span><span class="n">boundaryField</span><span class="p">();</span>    <span class="c1">// 边界面的面法向量</span>

        <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volSymmTensorField</span><span class="o">&gt;</span> <span class="n">tdevTau</span> <span class="o">=</span> <span class="n">devTau</span><span class="p">();</span>
        <span class="k">const</span> <span class="n">volSymmTensorField</span><span class="o">::</span><span class="n">Boundary</span><span class="o">&amp;</span> <span class="n">devTaub</span> <span class="o">=</span> <span class="n">tdevTau</span><span class="p">().</span><span class="n">boundaryField</span><span class="p">();</span>    <span class="c1">// 在边界面处的切应力</span>

        <span class="c1">// Scale pRef by density for incompressible simulations</span>
        <span class="k">const</span> <span class="n">scalar</span> <span class="n">pRef</span> <span class="o">=</span> <span class="n">pRef_</span><span class="o">/</span><span class="n">rho</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>    <span class="c1">// 如果是可压缩流则不会做任何事；如果是不可压缩流则将pRef除以rhoRef(rhoInf)</span>

        <span class="n">forAllConstIter</span><span class="p">(</span><span class="n">labelHashSet</span><span class="p">,</span> <span class="n">patchSet_</span><span class="p">,</span> <span class="n">iter</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">const</span> <span class="n">label</span> <span class="n">patchi</span> <span class="o">=</span> <span class="n">iter</span><span class="p">.</span><span class="n">key</span><span class="p">();</span>

            <span class="k">const</span> <span class="n">vectorField</span> <span class="nf">Md</span>
            <span class="p">(</span>
                <span class="n">mesh_</span><span class="p">.</span><span class="n">C</span><span class="p">().</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">]</span> <span class="o">-</span> <span class="n">coordSys_</span><span class="p">.</span><span class="n">origin</span><span class="p">()</span>
            <span class="p">);</span>

            <span class="k">const</span> <span class="n">vectorField</span> <span class="n">fN</span>    <span class="c1">// 法向力</span>
            <span class="p">(</span>
                <span class="n">alpha</span><span class="p">(</span><span class="n">patchi</span><span class="p">)</span> <span class="o">*</span> <span class="n">rho</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="n">Sfb</span><span class="p">[</span><span class="n">patchi</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">]</span> <span class="o">-</span> <span class="n">pRef</span><span class="p">)</span>
            <span class="p">);</span>

            <span class="k">const</span> <span class="n">vectorField</span> <span class="nf">fT</span><span class="p">(</span><span class="n">Sfb</span><span class="p">[</span><span class="n">patchi</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">devTaub</span><span class="p">[</span><span class="n">patchi</span><span class="p">]);</span>    <span class="c1">// 切向力</span>

            <span class="k">const</span> <span class="n">vectorField</span> <span class="nf">fP</span><span class="p">(</span><span class="n">Md</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">Zero</span><span class="p">);</span>    <span class="c1">// 孔隙力</span>

            <span class="n">applyBins</span><span class="p">(</span><span class="n">Md</span><span class="p">,</span> <span class="n">fN</span><span class="p">,</span> <span class="n">fT</span><span class="p">,</span> <span class="n">fP</span><span class="p">,</span> <span class="n">mesh_</span><span class="p">.</span><span class="n">C</span><span class="p">().</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">porosity_</span><span class="p">)</span>    <span class="c1">// 如果考虑孔隙作用</span>
    <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>

    <span class="n">Pstream</span><span class="o">::</span><span class="n">listCombineGather</span><span class="p">(</span><span class="n">force_</span><span class="p">,</span> <span class="n">plusEqOp</span><span class="o">&lt;</span><span class="n">vectorField</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="n">Pstream</span><span class="o">::</span><span class="n">listCombineGather</span><span class="p">(</span><span class="n">moment_</span><span class="p">,</span> <span class="n">plusEqOp</span><span class="o">&lt;</span><span class="n">vectorField</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="n">Pstream</span><span class="o">::</span><span class="n">listCombineScatter</span><span class="p">(</span><span class="n">force_</span><span class="p">);</span>
    <span class="n">Pstream</span><span class="o">::</span><span class="n">listCombineScatter</span><span class="p">(</span><span class="n">moment_</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>其中applyBins()函数的具体执行内容如下，实际上由该函数计算出最终的forces和moment：</p>
<div class="literal-block-wrapper docutils container" id="id83">
<div class="code-block-caption"><span class="caption-text">src/functionObjects/forces/forces/forces.C</span><a class="headerlink" href="#id83" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">functionObjects</span><span class="o">::</span><span class="n">forces</span><span class="o">::</span><span class="n">applyBins</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">vectorField</span><span class="o">&amp;</span> <span class="n">Md</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vectorField</span><span class="o">&amp;</span> <span class="n">fN</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vectorField</span><span class="o">&amp;</span> <span class="n">fT</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vectorField</span><span class="o">&amp;</span> <span class="n">fP</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vectorField</span><span class="o">&amp;</span> <span class="n">d</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nBin_</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">force_</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sum</span><span class="p">(</span><span class="n">fN</span><span class="p">);</span>
        <span class="n">force_</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sum</span><span class="p">(</span><span class="n">fT</span><span class="p">);</span>
        <span class="n">force_</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sum</span><span class="p">(</span><span class="n">fP</span><span class="p">);</span>
        <span class="n">moment_</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sum</span><span class="p">(</span><span class="n">Md</span><span class="o">^</span><span class="n">fN</span><span class="p">);</span>
        <span class="n">moment_</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sum</span><span class="p">(</span><span class="n">Md</span><span class="o">^</span><span class="n">fT</span><span class="p">);</span>
        <span class="n">moment_</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sum</span><span class="p">(</span><span class="n">Md</span><span class="o">^</span><span class="n">fP</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">scalarField</span> <span class="n">dd</span><span class="p">((</span><span class="n">d</span> <span class="o">&amp;</span> <span class="n">binDir_</span><span class="p">)</span> <span class="o">-</span> <span class="n">binMin_</span><span class="p">);</span>

        <span class="n">forAll</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">label</span> <span class="n">bini</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">dd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">binDx_</span><span class="p">),</span> <span class="mi">0</span><span class="p">),</span> <span class="n">force_</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

            <span class="n">force_</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">bini</span><span class="p">]</span> <span class="o">+=</span> <span class="n">fN</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">force_</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">bini</span><span class="p">]</span> <span class="o">+=</span> <span class="n">fT</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">force_</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">bini</span><span class="p">]</span> <span class="o">+=</span> <span class="n">fP</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">moment_</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">bini</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Md</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">^</span><span class="n">fN</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">moment_</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">bini</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Md</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">^</span><span class="n">fT</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">moment_</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">bini</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Md</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">^</span><span class="n">fP</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>forces计算结果输出为dat文件的逻辑如下：</p>
<div class="literal-block-wrapper docutils container" id="id84">
<div class="code-block-caption"><span class="caption-text">src/functionObjects/forces/forces/forces.C</span><a class="headerlink" href="#id84" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">functionObjects</span><span class="o">::</span><span class="n">forces</span><span class="o">::</span><span class="n">writeForces</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Log</span> <span class="o">&lt;&lt;</span> <span class="n">type</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; write:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span>
        <span class="o">&lt;&lt;</span> <span class="s">&quot;    sum of forces:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span>
        <span class="o">&lt;&lt;</span> <span class="s">&quot;        pressure : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span><span class="p">(</span><span class="n">force_</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span>
        <span class="o">&lt;&lt;</span> <span class="s">&quot;        viscous  : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span><span class="p">(</span><span class="n">force_</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span>
        <span class="o">&lt;&lt;</span> <span class="s">&quot;        porous   : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span><span class="p">(</span><span class="n">force_</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span>
        <span class="o">&lt;&lt;</span> <span class="s">&quot;    sum of moments:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span>
        <span class="o">&lt;&lt;</span> <span class="s">&quot;        pressure : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span><span class="p">(</span><span class="n">moment_</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span>
        <span class="o">&lt;&lt;</span> <span class="s">&quot;        viscous  : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span><span class="p">(</span><span class="n">moment_</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span>
        <span class="o">&lt;&lt;</span> <span class="s">&quot;        porous   : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span><span class="p">(</span><span class="n">moment_</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="n">writeTime</span><span class="p">(</span><span class="n">file</span><span class="p">(</span><span class="n">fileID</span><span class="o">::</span><span class="n">mainFile</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">porosity_</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">file</span><span class="p">(</span><span class="n">fileID</span><span class="o">::</span><span class="n">mainFile</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">tab</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;(&#39;</span>
            <span class="o">&lt;&lt;</span> <span class="n">sum</span><span class="p">(</span><span class="n">force_</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span>
            <span class="o">&lt;&lt;</span> <span class="n">sum</span><span class="p">(</span><span class="n">force_</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span>
            <span class="o">&lt;&lt;</span> <span class="n">sum</span><span class="p">(</span><span class="n">force_</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;) (&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">sum</span><span class="p">(</span><span class="n">moment_</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span>
            <span class="o">&lt;&lt;</span> <span class="n">sum</span><span class="p">(</span><span class="n">moment_</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span>
            <span class="o">&lt;&lt;</span> <span class="n">sum</span><span class="p">(</span><span class="n">moment_</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;)&#39;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">file</span><span class="p">(</span><span class="n">fileID</span><span class="o">::</span><span class="n">mainFile</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">tab</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;(&#39;</span>
            <span class="o">&lt;&lt;</span> <span class="n">sum</span><span class="p">(</span><span class="n">force_</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span>
            <span class="o">&lt;&lt;</span> <span class="n">sum</span><span class="p">(</span><span class="n">force_</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;) (&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">sum</span><span class="p">(</span><span class="n">moment_</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span>
            <span class="o">&lt;&lt;</span> <span class="n">sum</span><span class="p">(</span><span class="n">moment_</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;)&#39;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">localSystem_</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">porosity_</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">file</span><span class="p">(</span><span class="n">fileID</span><span class="o">::</span><span class="n">mainFile</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">tab</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;(&#39;</span>
                <span class="o">&lt;&lt;</span> <span class="n">sum</span><span class="p">(</span><span class="n">coordSys_</span><span class="p">.</span><span class="n">localVector</span><span class="p">(</span><span class="n">force_</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span>
                <span class="o">&lt;&lt;</span> <span class="n">sum</span><span class="p">(</span><span class="n">coordSys_</span><span class="p">.</span><span class="n">localVector</span><span class="p">(</span><span class="n">force_</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span>
                <span class="o">&lt;&lt;</span> <span class="n">sum</span><span class="p">(</span><span class="n">coordSys_</span><span class="p">.</span><span class="n">localVector</span><span class="p">(</span><span class="n">force_</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;) (&quot;</span>
                <span class="o">&lt;&lt;</span> <span class="n">sum</span><span class="p">(</span><span class="n">coordSys_</span><span class="p">.</span><span class="n">localVector</span><span class="p">(</span><span class="n">moment_</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span>
                <span class="o">&lt;&lt;</span> <span class="n">sum</span><span class="p">(</span><span class="n">coordSys_</span><span class="p">.</span><span class="n">localVector</span><span class="p">(</span><span class="n">moment_</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span>
                <span class="o">&lt;&lt;</span> <span class="n">sum</span><span class="p">(</span><span class="n">coordSys_</span><span class="p">.</span><span class="n">localVector</span><span class="p">(</span><span class="n">moment_</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;)&#39;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">file</span><span class="p">(</span><span class="n">fileID</span><span class="o">::</span><span class="n">mainFile</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">tab</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;(&#39;</span>
                <span class="o">&lt;&lt;</span> <span class="n">sum</span><span class="p">(</span><span class="n">coordSys_</span><span class="p">.</span><span class="n">localVector</span><span class="p">(</span><span class="n">force_</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span>
                <span class="o">&lt;&lt;</span> <span class="n">sum</span><span class="p">(</span><span class="n">coordSys_</span><span class="p">.</span><span class="n">localVector</span><span class="p">(</span><span class="n">force_</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;) (&quot;</span>
                <span class="o">&lt;&lt;</span> <span class="n">sum</span><span class="p">(</span><span class="n">coordSys_</span><span class="p">.</span><span class="n">localVector</span><span class="p">(</span><span class="n">moment_</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span>
                <span class="o">&lt;&lt;</span> <span class="n">sum</span><span class="p">(</span><span class="n">coordSys_</span><span class="p">.</span><span class="n">localVector</span><span class="p">(</span><span class="n">moment_</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;)&#39;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">file</span><span class="p">(</span><span class="n">fileID</span><span class="o">::</span><span class="n">mainFile</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="forcecoeffs">
<h4>forceCoeffs<a class="headerlink" href="#forcecoeffs" title="永久链接至标题">¶</a></h4>
<p>使用forceCoeffs功能需要在controlDict的functions字典中添加如下内容：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">forceCoeffs1</span>
<span class="p">{</span>
    <span class="c1">// Mandatory entries</span>
    <span class="n">type</span>            <span class="n">forceCoeffs</span><span class="p">;</span>
    <span class="n">libs</span>            <span class="p">(</span><span class="s">&quot;libforces.so&quot;</span><span class="p">);</span>
    <span class="n">patches</span>         <span class="p">(</span><span class="o">&lt;</span><span class="n">list</span> <span class="n">of</span> <span class="n">patch</span> <span class="n">names</span><span class="o">&gt;</span><span class="p">);</span>

    <span class="c1">// Field names</span>
    <span class="n">p</span>               <span class="n">p</span><span class="p">;</span>
    <span class="n">U</span>               <span class="n">U</span><span class="p">;</span>
    <span class="n">rho</span>             <span class="n">rho</span><span class="p">;</span>    <span class="c1">// 不可压缩流则设置为rhoInf</span>

    <span class="n">rhoInf</span>      <span class="mi">100000</span><span class="p">;</span>         <span class="c1">// Freestream density</span>
    <span class="n">magUInf</span>         <span class="mi">30</span><span class="p">;</span>         <span class="c1">// Freestream velocity magnitude [m/s]</span>
    <span class="n">pRef</span>            <span class="mi">0</span><span class="p">;</span>          <span class="c1">// Reference pressure [Pa]</span>

    <span class="n">porosity</span>        <span class="n">no</span><span class="p">;</span>         <span class="c1">// Include porosity effects?</span>
    <span class="n">writeFields</span>     <span class="n">yes</span><span class="p">;</span>        <span class="c1">// Store and write volume field representations of forces and moments</span>
    <span class="n">CofR</span>            <span class="p">(</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">);</span>    <span class="c1">// Centre of rotation for moment calculations</span>
    <span class="n">liftDir</span>         <span class="p">(</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">);</span>    <span class="c1">// Lift direction</span>
    <span class="n">dragDir</span>         <span class="p">(</span><span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">);</span>    <span class="c1">// Drag direction</span>
    <span class="n">pitchAxis</span>       <span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">);</span>    <span class="c1">// Pitch axis</span>

    <span class="n">lRef</span>            <span class="mi">1</span><span class="p">;</span>          <span class="c1">// Reference length [m]</span>
    <span class="n">Aref</span>            <span class="mf">1.75</span><span class="p">;</span>       <span class="c1">// Reference area [m2]</span>

    <span class="c1">// Spatial data binning</span>
    <span class="c1">// - extents given by the bounds of the input geometry</span>
    <span class="cm">/* binData</span>
<span class="cm">    {</span>
<span class="cm">        nBin        20;</span>
<span class="cm">        direction   (1 0 0);</span>
<span class="cm">        cumulative  yes;</span>
<span class="cm">    } */</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; C_{l} = \frac{\mathbf{F}_{total} \cdot \mathbf{n}_{lift}}{A_{ref}\times (\frac{1}{2}\rho_{Inf}|\mathbf{U}_{Inf}|^{2})} \\
&amp; C_{d} = \frac{\mathbf{F}_{total} \cdot \mathbf{n}_{drag}}{A_{ref}\times (\frac{1}{2}\rho_{Inf}|\mathbf{U}_{Inf}|^{2})} \\
&amp; C_{m} = \frac{totMoment \cdot pitchAxis}{A_{ref}\times l_{ref} \times (\frac{1}{2}\rho_{Inf}|\mathbf{U}_{Inf}|^{2})}
\end{align}\end{split}\]</div>
<p>forceCoeffs功能读取controlDict中functions字典的逻辑如下：</p>
<div class="literal-block-wrapper docutils container" id="id85">
<div class="code-block-caption"><span class="caption-text">src/functionObjects/forces/forceCoeffs/forceCoeffs.C</span><a class="headerlink" href="#id85" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">Foam</span><span class="o">::</span><span class="n">functionObjects</span><span class="o">::</span><span class="n">forceCoeffs</span><span class="o">::</span><span class="n">read</span><span class="p">(</span><span class="k">const</span> <span class="n">dictionary</span><span class="o">&amp;</span> <span class="n">dict</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">forces</span><span class="o">::</span><span class="n">read</span><span class="p">(</span><span class="n">dict</span><span class="p">);</span>    <span class="c1">// 按照forces功能的方式先读取一遍字典</span>

    <span class="c1">// Directions for lift and drag forces, and pitch moment</span>
    <span class="c1">// Normalise to ensure that the directions are unit vectors</span>

    <span class="n">dict</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="s">&quot;liftDir&quot;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">liftDir_</span><span class="p">;</span>    <span class="c1">// 读取lift force方向</span>
    <span class="n">liftDir_</span> <span class="o">/=</span> <span class="n">mag</span><span class="p">(</span><span class="n">liftDir_</span><span class="p">);</span>    <span class="c1">// 修正为单位向量</span>

    <span class="n">dict</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="s">&quot;dragDir&quot;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">dragDir_</span><span class="p">;</span>    <span class="c1">// 读取drag force方向</span>
    <span class="n">dragDir_</span> <span class="o">/=</span> <span class="n">mag</span><span class="p">(</span><span class="n">dragDir_</span><span class="p">);</span>    <span class="c1">// 修正为单位向量</span>

    <span class="n">dict</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="s">&quot;pitchAxis&quot;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">pitchAxis_</span><span class="p">;</span>    <span class="c1">// 读取pitch坐标系方向</span>
    <span class="n">pitchAxis_</span> <span class="o">/=</span> <span class="n">mag</span><span class="p">(</span><span class="n">pitchAxis_</span><span class="p">);</span>    <span class="c1">// 修正为单位向量</span>

    <span class="c1">// Free stream velocity magnitude</span>
    <span class="n">dict</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="s">&quot;magUInf&quot;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">magUInf_</span><span class="p">;</span>    <span class="c1">// 读取自由流的速度大小</span>

    <span class="c1">// Reference (free stream) density</span>
    <span class="n">dict</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="s">&quot;rhoInf&quot;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">rhoRef_</span><span class="p">;</span>    <span class="c1">// 读取自由流的密度</span>

    <span class="c1">// Reference length and area scales</span>
    <span class="n">dict</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="s">&quot;lRef&quot;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">lRef_</span><span class="p">;</span>    <span class="c1">// 读取参考长度</span>
    <span class="n">dict</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="s">&quot;Aref&quot;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">Aref_</span><span class="p">;</span>    <span class="c1">//  读取参考面积</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>forceCoeffs功能计算各力系数的方式如下，它首先通过forces功能计算总力，再点乘对应方向的单位向量得到升力、曳力等：</p>
<div class="literal-block-wrapper docutils container" id="id86">
<div class="code-block-caption"><span class="caption-text">src/functionObjects/forces/forceCoeffs/forceCoeffs.C</span><a class="headerlink" href="#id86" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">Foam</span><span class="o">::</span><span class="n">functionObjects</span><span class="o">::</span><span class="n">forceCoeffs</span><span class="o">::</span><span class="n">write</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">forces</span><span class="o">::</span><span class="n">calcForcesMoment</span><span class="p">();</span>    <span class="c1">// 计算 forces 和 moment</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">Pstream</span><span class="o">::</span><span class="n">master</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">logFiles</span><span class="o">::</span><span class="n">write</span><span class="p">();</span>

        <span class="n">scalar</span> <span class="n">pDyn</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">rhoRef_</span><span class="o">*</span><span class="n">magUInf_</span><span class="o">*</span><span class="n">magUInf_</span><span class="p">;</span>    <span class="c1">// 动压</span>

        <span class="n">Field</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&gt;</span> <span class="n">totForce</span><span class="p">(</span><span class="n">force_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">force_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">force_</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
        <span class="n">Field</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&gt;</span> <span class="n">totMoment</span><span class="p">(</span><span class="n">moment_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">moment_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">moment_</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

        <span class="n">List</span><span class="o">&lt;</span><span class="n">Field</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;&gt;</span> <span class="n">coeffs</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
        <span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">setSize</span><span class="p">(</span><span class="n">nBin_</span><span class="p">);</span>
        <span class="n">coeffs</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">setSize</span><span class="p">(</span><span class="n">nBin_</span><span class="p">);</span>
        <span class="n">coeffs</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">setSize</span><span class="p">(</span><span class="n">nBin_</span><span class="p">);</span>

        <span class="c1">// lift, drag and moment</span>
        <span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">totForce</span> <span class="o">&amp;</span> <span class="n">liftDir_</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">Aref_</span><span class="o">*</span><span class="n">pDyn</span><span class="p">);</span>
        <span class="n">coeffs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">totForce</span> <span class="o">&amp;</span> <span class="n">dragDir_</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">Aref_</span><span class="o">*</span><span class="n">pDyn</span><span class="p">);</span>
        <span class="n">coeffs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">totMoment</span> <span class="o">&amp;</span> <span class="n">pitchAxis_</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">Aref_</span><span class="o">*</span><span class="n">lRef_</span><span class="o">*</span><span class="n">pDyn</span><span class="p">);</span>

        <span class="n">scalar</span> <span class="n">Cl</span> <span class="o">=</span> <span class="n">sum</span><span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>    <span class="c1">// total lift coefficient</span>
        <span class="n">scalar</span> <span class="n">Cd</span> <span class="o">=</span> <span class="n">sum</span><span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>    <span class="c1">// total drag coefficient</span>
        <span class="n">scalar</span> <span class="n">Cm</span> <span class="o">=</span> <span class="n">sum</span><span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>    <span class="c1">// total moment coefficient</span>

        <span class="n">scalar</span> <span class="n">Clf</span> <span class="o">=</span> <span class="n">Cl</span><span class="o">/</span><span class="mf">2.0</span> <span class="o">+</span> <span class="n">Cm</span><span class="p">;</span>    <span class="c1">// total front lift coefficient</span>
        <span class="n">scalar</span> <span class="n">Clr</span> <span class="o">=</span> <span class="n">Cl</span><span class="o">/</span><span class="mf">2.0</span> <span class="o">-</span> <span class="n">Cm</span><span class="p">;</span>    <span class="c1">// total rear lift coefficient</span>

        <span class="n">writeTime</span><span class="p">(</span><span class="n">file</span><span class="p">(</span><span class="n">fileID</span><span class="o">::</span><span class="n">mainFile</span><span class="p">));</span>
        <span class="n">file</span><span class="p">(</span><span class="n">fileID</span><span class="o">::</span><span class="n">mainFile</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">tab</span> <span class="o">&lt;&lt;</span> <span class="n">Cm</span> <span class="o">&lt;&lt;</span> <span class="n">tab</span>  <span class="o">&lt;&lt;</span> <span class="n">Cd</span> <span class="o">&lt;&lt;</span> <span class="n">tab</span> <span class="o">&lt;&lt;</span> <span class="n">Cl</span> <span class="o">&lt;&lt;</span> <span class="n">tab</span> <span class="o">&lt;&lt;</span> <span class="n">Clf</span> <span class="o">&lt;&lt;</span> <span class="n">tab</span> <span class="o">&lt;&lt;</span> <span class="n">Clr</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

        <span class="n">Log</span> <span class="o">&lt;&lt;</span> <span class="n">type</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; write:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;    Cm    = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">Cm</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;    Cd    = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">Cd</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;    Cl    = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">Cl</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;    Cl(f) = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">Clf</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;    Cl(r) = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">Clr</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">nBin_</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">binCumulative_</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">label</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
                    <span class="n">coeffs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">coeffs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
                    <span class="n">coeffs</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">coeffs</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">writeTime</span><span class="p">(</span><span class="n">file</span><span class="p">(</span><span class="n">fileID</span><span class="o">::</span><span class="n">binsFile</span><span class="p">));</span>

            <span class="n">forAll</span><span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">file</span><span class="p">(</span><span class="n">fileID</span><span class="o">::</span><span class="n">binsFile</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">tab</span> <span class="o">&lt;&lt;</span> <span class="n">coeffs</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">tab</span> <span class="o">&lt;&lt;</span> <span class="n">coeffs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">tab</span> <span class="o">&lt;&lt;</span> <span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
            <span class="p">}</span>

            <span class="n">file</span><span class="p">(</span><span class="n">fileID</span><span class="o">::</span><span class="n">binsFile</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">Log</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="lambda2">
<h4>Lambda2<a class="headerlink" href="#lambda2" title="永久链接至标题">¶</a></h4>
<p>Calculates and outputs the second largest eigenvalue of the sum of the square of the symmetrical and anti-symmetrical parts of the velocity gradient tensor.</p>
<div class="literal-block-wrapper docutils container" id="id87">
<div class="code-block-caption"><span class="caption-text">src/functionObjects/field/Lambda2/Lambda2.C</span><a class="headerlink" href="#id87" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">Foam</span><span class="o">::</span><span class="n">functionObjects</span><span class="o">::</span><span class="n">Lambda2</span><span class="o">::</span><span class="n">calc</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">foundObject</span><span class="o">&lt;</span><span class="n">volVectorField</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fieldName_</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">volVectorField</span><span class="o">&amp;</span> <span class="n">U</span> <span class="o">=</span> <span class="n">lookupObject</span><span class="o">&lt;</span><span class="n">volVectorField</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fieldName_</span><span class="p">);</span>
        <span class="k">const</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volTensorField</span><span class="o">&gt;</span> <span class="n">tgradU</span><span class="p">(</span><span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">U</span><span class="p">));</span>
        <span class="k">const</span> <span class="n">volTensorField</span><span class="o">&amp;</span> <span class="n">gradU</span> <span class="o">=</span> <span class="n">tgradU</span><span class="p">();</span>

        <span class="k">const</span> <span class="n">volTensorField</span> <span class="nf">SSplusWW</span>
        <span class="p">(</span>
            <span class="p">(</span><span class="n">symm</span><span class="p">(</span><span class="n">gradU</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">symm</span><span class="p">(</span><span class="n">gradU</span><span class="p">))</span>
          <span class="o">+</span> <span class="p">(</span><span class="n">skew</span><span class="p">(</span><span class="n">gradU</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">skew</span><span class="p">(</span><span class="n">gradU</span><span class="p">))</span>
        <span class="p">);</span>

        <span class="k">return</span> <span class="nf">store</span>
        <span class="p">(</span>
            <span class="n">resultName_</span><span class="p">,</span>
           <span class="o">-</span><span class="n">eigenValues</span><span class="p">(</span><span class="n">SSplusWW</span><span class="p">)().</span><span class="n">component</span><span class="p">(</span><span class="n">vector</span><span class="o">::</span><span class="n">Y</span><span class="p">)</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">cannotFindObject</span><span class="o">&lt;</span><span class="n">volVectorField</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fieldName_</span><span class="p">);</span>

        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="q">
<h4>Q<a class="headerlink" href="#q" title="永久链接至标题">¶</a></h4>
<p>Calculates and outputs the second invariant of the velocity gradient tensor [1/s^2]. f[ Q = 0.5(sqr(tr(nabla U)) - tr(((nabla U) cdot (nabla U)))) f].</p>
<div class="literal-block-wrapper docutils container" id="id88">
<div class="code-block-caption"><span class="caption-text">src/functionObjects/field/Q/Q.C</span><a class="headerlink" href="#id88" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">Foam</span><span class="o">::</span><span class="n">functionObjects</span><span class="o">::</span><span class="n">Q</span><span class="o">::</span><span class="n">calc</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">foundObject</span><span class="o">&lt;</span><span class="n">volVectorField</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fieldName_</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">volVectorField</span><span class="o">&amp;</span> <span class="n">U</span> <span class="o">=</span> <span class="n">lookupObject</span><span class="o">&lt;</span><span class="n">volVectorField</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fieldName_</span><span class="p">);</span>
        <span class="k">const</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volTensorField</span><span class="o">&gt;</span> <span class="n">tgradU</span><span class="p">(</span><span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">U</span><span class="p">));</span>
        <span class="k">const</span> <span class="n">volTensorField</span><span class="o">&amp;</span> <span class="n">gradU</span> <span class="o">=</span> <span class="n">tgradU</span><span class="p">();</span>

        <span class="k">return</span> <span class="nf">store</span>
        <span class="p">(</span>
            <span class="n">resultName_</span><span class="p">,</span>
            <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">sqr</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="n">gradU</span><span class="p">))</span> <span class="o">-</span> <span class="n">tr</span><span class="p">(((</span><span class="n">gradU</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">gradU</span><span class="p">))))</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">cannotFindObject</span><span class="o">&lt;</span><span class="n">volVectorField</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fieldName_</span><span class="p">);</span>

        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="yplus">
<h4>yPlus<a class="headerlink" href="#yplus" title="永久链接至标题">¶</a></h4>
<p>Evaluates and outputs turbulence y+ for models. Values written to time directories as field ‘yPlus’ or ‘yPlus.&lt;phase&gt;’.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">yPlus1</span>
<span class="p">{</span>
    <span class="n">type</span>        <span class="n">yPlus</span><span class="p">;</span>
    <span class="n">libs</span>        <span class="p">(</span><span class="s">&quot;libfieldFunctionObjects.so&quot;</span><span class="p">);</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="literal-block-wrapper docutils container" id="id89">
<div class="code-block-caption"><span class="caption-text">src/functionObjects/field/yPlus/yPlus.C</span><a class="headerlink" href="#id89" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //</span>

<span class="n">Foam</span><span class="o">::</span><span class="n">functionObjects</span><span class="o">::</span><span class="n">yPlus</span><span class="o">::</span><span class="n">yPlus</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">word</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Time</span><span class="o">&amp;</span> <span class="n">runTime</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">dictionary</span><span class="o">&amp;</span> <span class="n">dict</span>
<span class="p">)</span>
<span class="o">:</span>
    <span class="n">fvMeshFunctionObject</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">runTime</span><span class="p">,</span> <span class="n">dict</span><span class="p">),</span>
    <span class="n">logFiles</span><span class="p">(</span><span class="n">obr_</span><span class="p">,</span> <span class="n">name</span><span class="p">),</span>
    <span class="n">writeLocalObjects</span><span class="p">(</span><span class="n">obr_</span><span class="p">,</span> <span class="n">log</span><span class="p">),</span>
    <span class="n">phaseName_</span><span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;phase&quot;</span><span class="p">,</span> <span class="n">word</span><span class="o">::</span><span class="n">null</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">read</span><span class="p">(</span><span class="n">dict</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //</span>

<span class="kt">bool</span> <span class="n">Foam</span><span class="o">::</span><span class="n">functionObjects</span><span class="o">::</span><span class="n">yPlus</span><span class="o">::</span><span class="n">read</span><span class="p">(</span><span class="k">const</span> <span class="n">dictionary</span><span class="o">&amp;</span> <span class="n">dict</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">fvMeshFunctionObject</span><span class="o">::</span><span class="n">read</span><span class="p">(</span><span class="n">dict</span><span class="p">);</span>
    <span class="n">writeLocalObjects</span><span class="o">::</span><span class="n">read</span><span class="p">(</span><span class="n">dict</span><span class="p">);</span>

    <span class="n">resetName</span><span class="p">(</span><span class="n">IOobject</span><span class="o">::</span><span class="n">groupName</span><span class="p">(</span><span class="n">typeName</span><span class="p">,</span> <span class="n">phaseName_</span><span class="p">));</span>
    <span class="n">resetLocalObjectName</span><span class="p">(</span><span class="n">IOobject</span><span class="o">::</span><span class="n">groupName</span><span class="p">(</span><span class="n">typeName</span><span class="p">,</span> <span class="n">phaseName_</span><span class="p">));</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id90">
<div class="code-block-caption"><span class="caption-text">src/functionObjects/field/yPlus/yPlus.C</span><a class="headerlink" href="#id90" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">Foam</span><span class="o">::</span><span class="n">functionObjects</span><span class="o">::</span><span class="n">yPlus</span><span class="o">::</span><span class="n">execute</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mesh_</span><span class="p">.</span><span class="n">foundObject</span><span class="o">&lt;</span><span class="n">momentumTransportModel</span><span class="o">&gt;</span>
    <span class="p">(</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">groupName</span><span class="p">(</span><span class="n">momentumTransportModel</span><span class="o">::</span><span class="n">typeName</span><span class="p">,</span> <span class="n">phaseName_</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">momentumTransportModel</span><span class="o">&amp;</span> <span class="n">model</span> <span class="o">=</span>
            <span class="n">mesh_</span><span class="p">.</span><span class="n">lookupObject</span><span class="o">&lt;</span><span class="n">momentumTransportModel</span><span class="o">&gt;</span>
            <span class="p">(</span>
                <span class="n">IOobject</span><span class="o">::</span><span class="n">groupName</span>
                <span class="p">(</span>
                    <span class="n">momentumTransportModel</span><span class="o">::</span><span class="n">typeName</span><span class="p">,</span>
                    <span class="n">phaseName_</span>
                <span class="p">)</span>
            <span class="p">);</span>

        <span class="n">word</span> <span class="nf">name</span><span class="p">(</span><span class="n">IOobject</span><span class="o">::</span><span class="n">groupName</span><span class="p">(</span><span class="n">type</span><span class="p">(),</span> <span class="n">phaseName_</span><span class="p">));</span>

        <span class="k">return</span> <span class="nf">store</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">calcYPlus</span><span class="p">(</span><span class="n">model</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">FatalErrorInFunction</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Unable to find turbulence model in the &quot;</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;database&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">exit</span><span class="p">(</span><span class="n">FatalError</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">Foam</span><span class="o">::</span><span class="n">functionObjects</span><span class="o">::</span><span class="n">yPlus</span><span class="o">::</span><span class="n">calcYPlus</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">momentumTransportModel</span><span class="o">&amp;</span> <span class="n">turbModel</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">tyPlus</span>
    <span class="p">(</span>
        <span class="n">volScalarField</span><span class="o">::</span><span class="n">New</span>
        <span class="p">(</span>
            <span class="n">IOobject</span><span class="o">::</span><span class="n">groupName</span><span class="p">(</span><span class="n">type</span><span class="p">(),</span> <span class="n">phaseName_</span><span class="p">),</span>
            <span class="n">mesh_</span><span class="p">,</span>
            <span class="n">dimensionedScalar</span><span class="p">(</span><span class="n">dimless</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">);</span>

    <span class="n">volScalarField</span><span class="o">::</span><span class="n">Boundary</span><span class="o">&amp;</span> <span class="n">yPlusBf</span> <span class="o">=</span> <span class="n">tyPlus</span><span class="p">.</span><span class="n">ref</span><span class="p">().</span><span class="n">boundaryFieldRef</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">::</span><span class="n">Boundary</span><span class="o">&amp;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">nearWallDist</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">mesh_</span><span class="p">).</span><span class="n">y</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">tnut</span> <span class="o">=</span> <span class="n">turbModel</span><span class="p">.</span><span class="n">nut</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">::</span><span class="n">Boundary</span><span class="o">&amp;</span> <span class="n">nutBf</span> <span class="o">=</span> <span class="n">tnut</span><span class="p">().</span><span class="n">boundaryField</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">tnuEff</span> <span class="o">=</span> <span class="n">turbModel</span><span class="p">.</span><span class="n">nuEff</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">::</span><span class="n">Boundary</span><span class="o">&amp;</span> <span class="n">nuEffBf</span> <span class="o">=</span> <span class="n">tnuEff</span><span class="p">().</span><span class="n">boundaryField</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">tnu</span> <span class="o">=</span> <span class="n">turbModel</span><span class="p">.</span><span class="n">nu</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">::</span><span class="n">Boundary</span><span class="o">&amp;</span> <span class="n">nuBf</span> <span class="o">=</span> <span class="n">tnu</span><span class="p">().</span><span class="n">boundaryField</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">fvPatchList</span><span class="o">&amp;</span> <span class="n">patches</span> <span class="o">=</span> <span class="n">mesh_</span><span class="p">.</span><span class="n">boundary</span><span class="p">();</span>

    <span class="n">forAll</span><span class="p">(</span><span class="n">patches</span><span class="p">,</span> <span class="n">patchi</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">fvPatch</span><span class="o">&amp;</span> <span class="n">patch</span> <span class="o">=</span> <span class="n">patches</span><span class="p">[</span><span class="n">patchi</span><span class="p">];</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">isA</span><span class="o">&lt;</span><span class="n">nutWallFunctionFvPatchScalarField</span><span class="o">&gt;</span><span class="p">(</span><span class="n">nutBf</span><span class="p">[</span><span class="n">patchi</span><span class="p">]))</span>
        <span class="p">{</span>
            <span class="k">const</span> <span class="n">nutWallFunctionFvPatchScalarField</span><span class="o">&amp;</span> <span class="n">nutPf</span> <span class="o">=</span> <span class="n">dynamic_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">nutWallFunctionFvPatchScalarField</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">nutBf</span><span class="p">[</span><span class="n">patchi</span><span class="p">]);</span>

            <span class="n">yPlusBf</span><span class="p">[</span><span class="n">patchi</span><span class="p">]</span> <span class="o">=</span> <span class="n">nutPf</span><span class="p">.</span><span class="n">yPlus</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">isA</span><span class="o">&lt;</span><span class="n">wallFvPatch</span><span class="o">&gt;</span><span class="p">(</span><span class="n">patch</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">yPlusBf</span><span class="p">[</span><span class="n">patchi</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">patchi</span><span class="p">]</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span> <span class="n">nuEffBf</span><span class="p">[</span><span class="n">patchi</span><span class="p">]</span> <span class="o">*</span> <span class="n">mag</span><span class="p">(</span><span class="n">turbModel</span><span class="p">.</span><span class="n">U</span><span class="p">().</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">].</span><span class="n">snGrad</span><span class="p">())</span> <span class="p">)</span><span class="o">/</span><span class="n">nuBf</span><span class="p">[</span><span class="n">patchi</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">tyPlus</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id91">
<div class="code-block-caption"><span class="caption-text">src/functionObjects/field/yPlus/yPlus.C</span><a class="headerlink" href="#id91" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">Foam</span><span class="o">::</span><span class="n">functionObjects</span><span class="o">::</span><span class="n">yPlus</span><span class="o">::</span><span class="n">write</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Log</span> <span class="o">&lt;&lt;</span> <span class="n">type</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; write:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span><span class="p">;</span>

    <span class="n">writeLocalObjects</span><span class="o">::</span><span class="n">write</span><span class="p">();</span>
    <span class="n">logFiles</span><span class="o">::</span><span class="n">write</span><span class="p">();</span>

    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">yPlus</span> <span class="o">=</span> <span class="n">mesh_</span><span class="p">.</span><span class="n">lookupObject</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span><span class="p">(</span><span class="n">IOobject</span><span class="o">::</span><span class="n">groupName</span><span class="p">(</span><span class="n">type</span><span class="p">(),</span> <span class="n">phaseName_</span><span class="p">));</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">::</span><span class="n">Boundary</span><span class="o">&amp;</span> <span class="n">yPlusBf</span> <span class="o">=</span> <span class="n">yPlus</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">fvPatchList</span><span class="o">&amp;</span> <span class="n">patches</span> <span class="o">=</span> <span class="n">mesh_</span><span class="p">.</span><span class="n">boundary</span><span class="p">();</span>

    <span class="n">forAll</span><span class="p">(</span><span class="n">patches</span><span class="p">,</span> <span class="n">patchi</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">fvPatch</span><span class="o">&amp;</span> <span class="n">patch</span> <span class="o">=</span> <span class="n">patches</span><span class="p">[</span><span class="n">patchi</span><span class="p">];</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">isA</span><span class="o">&lt;</span><span class="n">wallFvPatch</span><span class="o">&gt;</span><span class="p">(</span><span class="n">patch</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="k">const</span> <span class="n">scalarField</span><span class="o">&amp;</span> <span class="n">yPlusp</span> <span class="o">=</span> <span class="n">yPlusBf</span><span class="p">[</span><span class="n">patchi</span><span class="p">];</span>

            <span class="k">const</span> <span class="n">scalar</span> <span class="n">minYplus</span> <span class="o">=</span> <span class="n">gMin</span><span class="p">(</span><span class="n">yPlusp</span><span class="p">);</span>
            <span class="k">const</span> <span class="n">scalar</span> <span class="n">maxYplus</span> <span class="o">=</span> <span class="n">gMax</span><span class="p">(</span><span class="n">yPlusp</span><span class="p">);</span>
            <span class="k">const</span> <span class="n">scalar</span> <span class="n">avgYplus</span> <span class="o">=</span> <span class="n">gAverage</span><span class="p">(</span><span class="n">yPlusp</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">Pstream</span><span class="o">::</span><span class="n">master</span><span class="p">())</span>
            <span class="p">{</span>
                <span class="n">Log</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;    patch &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">patch</span><span class="p">.</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; y+ : min = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">minYplus</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, max = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">maxYplus</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, average = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">avgYplus</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span><span class="p">;</span>

                <span class="n">writeTime</span><span class="p">(</span><span class="n">file</span><span class="p">());</span>
                <span class="n">file</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">tab</span> <span class="o">&lt;&lt;</span> <span class="n">patch</span><span class="p">.</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">tab</span> <span class="o">&lt;&lt;</span> <span class="n">minYplus</span> <span class="o">&lt;&lt;</span> <span class="n">tab</span> <span class="o">&lt;&lt;</span> <span class="n">maxYplus</span> <span class="o">&lt;&lt;</span> <span class="n">tab</span> <span class="o">&lt;&lt;</span> <span class="n">avgYplus</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">Log</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id27">
<h4>场计算<a class="headerlink" href="#id27" title="永久链接至标题">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="74%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">functionObject</th>
<th class="head">作用</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CourantNo</td>
<td>输出库郎数</td>
</tr>
<tr class="row-odd"><td>Lambda2</td>
<td>输出Lambda2</td>
</tr>
<tr class="row-even"><td>MachNo</td>
<td>计算马赫数</td>
</tr>
<tr class="row-odd"><td>Peclect</td>
<td>输出Peclet数</td>
</tr>
<tr class="row-even"><td>Q</td>
<td>计算速度梯度第二不变量</td>
</tr>
<tr class="row-odd"><td>R</td>
<td>计算雷诺应力张量场</td>
</tr>
<tr class="row-even"><td>XiReactionRate</td>
<td>写入湍流火焰速度以及反应速率体标量场</td>
</tr>
<tr class="row-odd"><td>add</td>
<td>添加场</td>
</tr>
<tr class="row-even"><td>components</td>
<td>写入矢量场的分量</td>
</tr>
<tr class="row-odd"><td>ddt</td>
<td>计算场的时间导数</td>
</tr>
<tr class="row-even"><td>div</td>
<td>计算场的散度</td>
</tr>
<tr class="row-odd"><td>enstrophy</td>
<td>计算场的涡度拟能</td>
</tr>
<tr class="row-even"><td>flowType</td>
<td>输出速度场类型，-1 表示有旋流；0 表示剪切流；+1 表示其他类型流动</td>
</tr>
<tr class="row-odd"><td>grad</td>
<td>计算场的梯度</td>
</tr>
<tr class="row-even"><td>mag</td>
<td>计算场的模</td>
</tr>
<tr class="row-odd"><td>magSqr</td>
<td>计算场的模的平方</td>
</tr>
<tr class="row-even"><td>randomize</td>
<td>对场添加随机分量，扰动量可以指定</td>
</tr>
<tr class="row-odd"><td>scale</td>
<td>对场进行缩放</td>
</tr>
<tr class="row-even"><td>streamFunction</td>
<td>计算网格点的流函数；计算面通量</td>
</tr>
<tr class="row-odd"><td>substract</td>
<td>从某个场中减去某个场的值</td>
</tr>
<tr class="row-even"><td>turbulenceFields</td>
<td>计算给定的湍流场</td>
</tr>
<tr class="row-odd"><td>turbulenceIntensity</td>
<td>计算湍流强度场</td>
</tr>
<tr class="row-even"><td>vorticity</td>
<td>计算涡量场，例如速度的旋度</td>
</tr>
<tr class="row-odd"><td>wallShearStress</td>
<td>计算壁面剪切力，输出体矢量场</td>
</tr>
<tr class="row-even"><td>wallHeatFlux</td>
<td>计算壁面热通量，输出体矢量场</td>
</tr>
<tr class="row-odd"><td>wallHeatTransferCoeff</td>
<td>计算边界场的壁面换热系数</td>
</tr>
<tr class="row-even"><td>writeCellCenters</td>
<td>通过体矢量场的方式输出网格体心矢量</td>
</tr>
<tr class="row-odd"><td>writeCellVolumes</td>
<td>通过体标量场的方式输出网格单元体积</td>
</tr>
<tr class="row-even"><td>writeObjects</td>
<td>输出某些特定场</td>
</tr>
<tr class="row-odd"><td>yPlus</td>
<td>计算湍流的 y+</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id28">
<h4>流率计算<a class="headerlink" href="#id28" title="永久链接至标题">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">functionObject</th>
<th class="head">作用</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>flowRateFaceZone</td>
<td>计算patch特定面区域的流量。有可能是体积通量，也有可能是质量通量</td>
</tr>
<tr class="row-odd"><td>flowRatePatch</td>
<td>计算patch的流量。有可能是体积通量，也有可能是质量通量</td>
</tr>
<tr class="row-even"><td>volFlowRateSurface</td>
<td>计算三角面的体积通量，速度的计算采用对面表面进行插值并积分。建议三角的面积足够小</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id29">
<h4>提取制图<a class="headerlink" href="#id29" title="永久链接至标题">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="42%" />
<col width="58%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">functionObject</th>
<th class="head">作用</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>singleGraph</td>
<td>提取某一条线上的数据</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id30">
<h4>拉格朗日数据<a class="headerlink" href="#id30" title="永久链接至标题">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">functionObject</th>
<th class="head">作用</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>dsmcFields</td>
<td>从DSMC计算结果中提取UMean、translationalT、internalT以及overallT</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id31">
<h4>监控极值<a class="headerlink" href="#id31" title="永久链接至标题">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">functionObject</th>
<th class="head">作用</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>cellMax</td>
<td>对于一个或多个场，输出最大的值</td>
</tr>
<tr class="row-odd"><td>cellMin</td>
<td>对于一个或多个场，输出最小的值</td>
</tr>
<tr class="row-even"><td>faceMax</td>
<td>对于一个或多个场，输出面上最大的值</td>
</tr>
<tr class="row-odd"><td>faceMin</td>
<td>对于一个或多个场，输出面上最小的值</td>
</tr>
<tr class="row-even"><td>minMaxComponents</td>
<td>通过非标量的形式，输出最大最小值以及位置</td>
</tr>
<tr class="row-odd"><td>MinMaxMagnitude</td>
<td>通过非标量的形式，输出最大最小值的模以及位置</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id32">
<h4>数据格式<a class="headerlink" href="#id32" title="永久链接至标题">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">functionObject</th>
<th class="head">作用</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>residuals</td>
<td>对于指定场，输出每个时间步迭代的初始残差。对于矢量场，输出最大的分量</td>
</tr>
<tr class="row-odd"><td>Time</td>
<td>写入运行时间、CPU时间、钟表时间</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id33">
<h4>压力工具<a class="headerlink" href="#id33" title="永久链接至标题">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="45%" />
<col width="55%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">functionObject</th>
<th class="head">作用</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>pressureDifferencePatch</td>
<td>计算两个patch的平均压力差</td>
</tr>
<tr class="row-odd"><td>pressureDifferenceSurface</td>
<td>将压力插值在三角面并计算平均压力差</td>
</tr>
<tr class="row-even"><td>staticPressure</td>
<td>通过指定的密度计算动压</td>
</tr>
<tr class="row-odd"><td>totalPressureCompressible</td>
<td>计算可压缩求解器的总压</td>
</tr>
<tr class="row-even"><td>totalPressureIncompressible</td>
<td>计算不可压缩求解器的动力总压</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id34">
<h4>探针<a class="headerlink" href="#id34" title="永久链接至标题">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="82%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">functionObject</th>
<th class="head">作用</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>boundaryCloud</td>
<td>输出场在某 patch 上指定位置的值</td>
</tr>
<tr class="row-odd"><td>interfaceHeight</td>
<td>对于一系列的点，输出界面的高度。这个高度是在这个点上，界面和壁面的垂直距离</td>
</tr>
<tr class="row-even"><td>internalCloud</td>
<td>输出场在指定位置的值</td>
</tr>
<tr class="row-odd"><td>Probes</td>
<td>输出场在指定位置距离最近的网格单元的值</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id35">
<h4>外挂求解器<a class="headerlink" href="#id35" title="永久链接至标题">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="42%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">functionObject</th>
<th class="head">作用</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>scalarTransport</td>
<td>求解标量场传输方程</td>
</tr>
<tr class="row-odd"><td>icoUncoupledKinematicCloud</td>
<td>求解拉格朗日粒子云</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id36">
<h4>可视化工具<a class="headerlink" href="#id36" title="永久链接至标题">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">functionObject</th>
<th class="head">作用</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>streamlines</td>
<td>通过VTK格式输出流线数据</td>
</tr>
<tr class="row-odd"><td>surfaces</td>
<td>通过VTK格式输出切割面、等值面等</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="paraview">
<h3>ParaView<a class="headerlink" href="#paraview" title="永久链接至标题">¶</a></h3>
<div class="section" id="id37">
<h4>画截面上的流线<a class="headerlink" href="#id37" title="永久链接至标题">¶</a></h4>
<p>paraview的Stream Tracer无法直接作一个截面上的流线。比如，对于OpenFOAM的算例，即使是二维算例，截取一个面后，用 Stream tracer 无法得到流线。解决办法是存在的，本篇介绍如果通过一系列filter的组合来得到截面上的流线。</p>
<ol class="arabic simple">
<li>作出需要查看流线的截面Slice；</li>
<li>对上述截面添加Filters/Alphabetical/Surface Vector，让速度矢量投影到平面上；</li>
<li>对得到的Surface Vector使用Filters/Alphabetical/Mask Points，生成一系列参考点用于绘制流线。</li>
</ol>
<p>在MaskPoints中需要调节On Ratio参数以及Maximum number of points参数。其中，On Ratio控制取点的疏密，表示每多少个点中取一个；Maximum number of points控制总点数的数目；一般会勾选Random Sampling以及Generate Vertices。</p>
<ol class="arabic simple" start="4">
<li>开启Filters/Alphabetical/Stream Tracer with Custom Source，分别选择上述的SurfaceVector作为Input，选择上述的MaskPoints作为Seed Source。</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">流线的疏密可以通过MaskPoints的点数量来控制，但是点数的空间分布不容易控制。</p>
</div>
</div>
</div>
</div>
<div class="section" id="id38">
<h2>运算函数定义<a class="headerlink" href="#id38" title="永久链接至标题">¶</a></h2>
<div class="section" id="id39">
<h3>张量运算符<a class="headerlink" href="#id39" title="永久链接至标题">¶</a></h3>
<p>进入src/OpenFOAM/dimensionedTypes/dimensionedTensor/dimensionedTensor.H文件可以看到声明的张量运算符：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">dimensionedScalar</span> <span class="nf">tr</span><span class="p">(</span><span class="k">const</span> <span class="n">dimensionedTensor</span><span class="o">&amp;</span><span class="p">);</span>    <span class="c1">// 取张量的迹</span>
<span class="n">dimensionedTensor</span> <span class="nf">dev</span><span class="p">(</span><span class="k">const</span> <span class="n">dimensionedTensor</span><span class="o">&amp;</span><span class="p">);</span>
<span class="n">dimensionedTensor</span> <span class="nf">dev2</span><span class="p">(</span><span class="k">const</span> <span class="n">dimensionedTensor</span><span class="o">&amp;</span><span class="p">);</span>
<span class="n">dimensionedScalar</span> <span class="nf">det</span><span class="p">(</span><span class="k">const</span> <span class="n">dimensionedTensor</span><span class="o">&amp;</span><span class="p">);</span>    <span class="c1">// 取张量的行列式</span>
<span class="n">dimensionedTensor</span> <span class="nf">cof</span><span class="p">(</span><span class="k">const</span> <span class="n">dimensionedTensor</span><span class="o">&amp;</span><span class="p">);</span>
<span class="n">dimensionedTensor</span> <span class="nf">inv</span><span class="p">(</span><span class="k">const</span> <span class="n">dimensionedTensor</span><span class="o">&amp;</span><span class="p">);</span>
<span class="n">dimensionedSymmTensor</span> <span class="nf">symm</span><span class="p">(</span><span class="k">const</span> <span class="n">dimensionedTensor</span><span class="o">&amp;</span><span class="p">);</span>
<span class="n">dimensionedSymmTensor</span> <span class="nf">twoSymm</span><span class="p">(</span><span class="k">const</span> <span class="n">dimensionedTensor</span><span class="o">&amp;</span><span class="p">);</span>
<span class="n">dimensionedTensor</span> <span class="nf">skew</span><span class="p">(</span><span class="k">const</span> <span class="n">dimensionedTensor</span><span class="o">&amp;</span><span class="p">);</span>

<span class="n">dimensionedVector</span> <span class="nf">eigenValues</span><span class="p">(</span><span class="k">const</span> <span class="n">dimensionedTensor</span><span class="o">&amp;</span><span class="p">);</span>    <span class="c1">// 求特征值</span>
<span class="n">dimensionedTensor</span> <span class="nf">eigenVectors</span><span class="p">(</span><span class="k">const</span> <span class="n">dimensionedTensor</span><span class="o">&amp;</span><span class="p">);</span>    <span class="c1">// 求特征向量</span>

<span class="n">dimensionedVector</span> <span class="nf">eigenValues</span><span class="p">(</span><span class="k">const</span> <span class="n">dimensionedSymmTensor</span><span class="o">&amp;</span><span class="p">);</span>    <span class="c1">// 对称张量情况下求特征值</span>
<span class="n">dimensionedTensor</span> <span class="nf">eigenVectors</span><span class="p">(</span><span class="k">const</span> <span class="n">dimensionedSymmTensor</span><span class="o">&amp;</span><span class="p">);</span>    <span class="c1">// 对称张量情况下求特征向量</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id40">
<h2>求解器代码解读<a class="headerlink" href="#id40" title="永久链接至标题">¶</a></h2>
<div class="section" id="id41">
<h3>文件信息读取<a class="headerlink" href="#id41" title="永久链接至标题">¶</a></h3>
<p>位于system文件夹内的fvSchemes和fvSolution文件通过mesh对象进行获取，调用的是下面的两个函数：</p>
<div class="literal-block-wrapper docutils container" id="id92">
<div class="code-block-caption"><span class="caption-text">src/finiteVolume/fvMesh/fvMesh.C</span><a class="headerlink" href="#id92" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">Foam</span><span class="o">::</span><span class="n">fvSchemes</span><span class="o">&amp;</span> <span class="n">Foam</span><span class="o">::</span><span class="n">fvMesh</span><span class="o">::</span><span class="n">schemes</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fvSchemes_</span><span class="p">.</span><span class="n">valid</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">fvSchemes_</span> <span class="o">=</span> <span class="n">new</span> <span class="n">fvSchemes</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">fvSchemes_</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">const</span> <span class="n">Foam</span><span class="o">::</span><span class="n">fvSolution</span><span class="o">&amp;</span> <span class="n">Foam</span><span class="o">::</span><span class="n">fvMesh</span><span class="o">::</span><span class="n">solution</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fvSolution_</span><span class="p">.</span><span class="n">valid</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">fvSolution_</span> <span class="o">=</span> <span class="n">new</span> <span class="n">fvSolution</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">fvSolution_</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>位于constant文件夹内的physicalProperties文件同样通过mesh对象进行获取，最底层的调用函数为：</p>
<div class="literal-block-wrapper docutils container" id="id93">
<div class="code-block-caption"><span class="caption-text">src/physicalProperties/physicalProperties/physicalProperties.C</span><a class="headerlink" href="#id93" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Foam</span><span class="o">::</span><span class="n">IOobject</span> <span class="n">Foam</span><span class="o">::</span><span class="n">physicalProperties</span><span class="o">::</span><span class="n">findModelDict</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">objectRegistry</span><span class="o">&amp;</span> <span class="n">obr</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">word</span><span class="o">&amp;</span> <span class="n">group</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">registerObject</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">typeIOobject</span><span class="o">&lt;</span><span class="n">IOdictionary</span><span class="o">&gt;</span> <span class="n">physicalPropertiesIO</span>
    <span class="p">(</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">groupName</span><span class="p">(</span><span class="n">physicalProperties</span><span class="o">::</span><span class="n">typeName</span><span class="p">,</span> <span class="n">group</span><span class="p">),</span>
        <span class="n">obr</span><span class="p">.</span><span class="n">time</span><span class="p">().</span><span class="n">constant</span><span class="p">(),</span>
        <span class="n">obr</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">MUST_READ_IF_MODIFIED</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_WRITE</span><span class="p">,</span>
        <span class="n">registerObject</span>
    <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">physicalPropertiesIO</span><span class="p">.</span><span class="n">headerOk</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">physicalPropertiesIO</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">typeIOobject</span><span class="o">&lt;</span><span class="n">IOdictionary</span><span class="o">&gt;</span> <span class="n">thermophysicalPropertiesIO</span>
        <span class="p">(</span>
            <span class="n">IOobject</span><span class="o">::</span><span class="n">groupName</span><span class="p">(</span><span class="s">&quot;thermophysicalProperties&quot;</span><span class="p">,</span> <span class="n">group</span><span class="p">),</span>
            <span class="n">obr</span><span class="p">.</span><span class="n">time</span><span class="p">().</span><span class="n">constant</span><span class="p">(),</span>
            <span class="n">obr</span><span class="p">,</span>
            <span class="n">IOobject</span><span class="o">::</span><span class="n">MUST_READ_IF_MODIFIED</span><span class="p">,</span>
            <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_WRITE</span><span class="p">,</span>
            <span class="n">registerObject</span>
        <span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">thermophysicalPropertiesIO</span><span class="p">.</span><span class="n">headerOk</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">thermophysicalPropertiesIO</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">typeIOobject</span><span class="o">&lt;</span><span class="n">IOdictionary</span><span class="o">&gt;</span> <span class="n">transportPropertiesIO</span>
            <span class="p">(</span>
                <span class="n">IOobject</span><span class="o">::</span><span class="n">groupName</span><span class="p">(</span><span class="s">&quot;transportProperties&quot;</span><span class="p">,</span> <span class="n">group</span><span class="p">),</span>
                <span class="n">obr</span><span class="p">.</span><span class="n">time</span><span class="p">().</span><span class="n">constant</span><span class="p">(),</span>
                <span class="n">obr</span><span class="p">,</span>
                <span class="n">IOobject</span><span class="o">::</span><span class="n">MUST_READ_IF_MODIFIED</span><span class="p">,</span>
                <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_WRITE</span><span class="p">,</span>
                <span class="n">registerObject</span>
            <span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">transportPropertiesIO</span><span class="p">.</span><span class="n">headerOk</span><span class="p">())</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="n">transportPropertiesIO</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="n">physicalPropertiesIO</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="c1">// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //</span>

<span class="n">Foam</span><span class="o">::</span><span class="n">physicalProperties</span><span class="o">::</span><span class="n">physicalProperties</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">fvMesh</span><span class="o">&amp;</span> <span class="n">mesh</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">word</span><span class="o">&amp;</span> <span class="n">group</span>
<span class="p">)</span>
<span class="o">:</span>
    <span class="n">IOdictionary</span><span class="p">(</span><span class="n">findModelDict</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="nb">true</span><span class="p">))</span>
<span class="p">{</span>
    <span class="c1">// Ensure name of IOdictionary is typeName</span>
    <span class="n">rename</span><span class="p">(</span><span class="n">IOobject</span><span class="o">::</span><span class="n">groupName</span><span class="p">(</span><span class="n">physicalProperties</span><span class="o">::</span><span class="n">typeName</span><span class="p">,</span> <span class="n">group</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>不过一般会通过basicThermo以及相应选择的热物理模型库来进行调用，例如在使用psiThermo模型库的求解器中，读取physicalProperties所调用的函数如下：</p>
<div class="literal-block-wrapper docutils container" id="id94">
<div class="code-block-caption"><span class="caption-text">src/thermophysicalModels/basic/basicThermo/basicThermoTemplates.C</span><a class="headerlink" href="#id94" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Thermo</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">autoPtr</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="o">&gt;</span> <span class="n">Foam</span><span class="o">::</span><span class="n">basicThermo</span><span class="o">::</span><span class="n">New</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">fvMesh</span><span class="o">&amp;</span> <span class="n">mesh</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">word</span><span class="o">&amp;</span> <span class="n">phaseName</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">IOdictionary</span> <span class="n">thermoDict</span>
    <span class="p">(</span>
        <span class="n">physicalProperties</span><span class="o">::</span><span class="n">findModelDict</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">phaseName</span><span class="p">)</span>
    <span class="p">);</span>

    <span class="kr">typename</span> <span class="n">Thermo</span><span class="o">::</span><span class="n">fvMeshConstructorTable</span><span class="o">::</span><span class="n">iterator</span> <span class="n">cstrIter</span> <span class="o">=</span>
        <span class="n">lookupCstrIter</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="p">,</span> <span class="kr">typename</span> <span class="n">Thermo</span><span class="o">::</span><span class="n">fvMeshConstructorTable</span><span class="o">&gt;</span>
        <span class="p">(</span>
            <span class="n">thermoDict</span><span class="p">,</span>
            <span class="n">Thermo</span><span class="o">::</span><span class="n">fvMeshConstructorTablePtr_</span>
        <span class="p">);</span>

    <span class="k">return</span> <span class="n">autoPtr</span><span class="o">&lt;</span><span class="n">Thermo</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cstrIter</span><span class="p">()(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">phaseName</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id95">
<div class="code-block-caption"><span class="caption-text">src/thermophysicalModels/basic/psiThermo/psiThermo.C</span><a class="headerlink" href="#id95" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Foam</span><span class="o">::</span><span class="n">autoPtr</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">psiThermo</span><span class="o">&gt;</span> <span class="n">Foam</span><span class="o">::</span><span class="n">psiThermo</span><span class="o">::</span><span class="n">New</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">fvMesh</span><span class="o">&amp;</span> <span class="n">mesh</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">word</span><span class="o">&amp;</span> <span class="n">phaseName</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">basicThermo</span><span class="o">::</span><span class="n">New</span><span class="o">&lt;</span><span class="n">psiThermo</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">phaseName</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id96">
<div class="code-block-caption"><span class="caption-text">src/thermophysicalModels/basic/psiThermo/psiThermo.H</span><a class="headerlink" href="#id96" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">autoPtr</span><span class="o">&lt;</span><span class="n">psiThermo</span><span class="o">&gt;</span> <span class="n">New</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">fvMesh</span><span class="o">&amp;</span> <span class="n">mesh</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">word</span><span class="o">&amp;</span> <span class="n">phaseName</span><span class="o">=</span><span class="n">word</span><span class="o">::</span><span class="n">null</span>
<span class="p">);</span>
</pre></div>
</div>
</div>
<p>一个简单的应用案例如下：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">autoPtr</span><span class="o">&lt;</span><span class="n">psiThermo</span><span class="o">&gt;</span> <span class="n">pThermo</span>
<span class="p">(</span>
    <span class="n">psiThermo</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="p">);</span>
<span class="n">psiThermo</span><span class="o">&amp;</span> <span class="n">thermo</span> <span class="o">=</span> <span class="n">pThermo</span><span class="p">();</span>
</pre></div>
</div>
<p>位于constant文件夹内的momentumTransport文件同样通过mesh对象进行获取，最底层的调用函数为：</p>
<div class="literal-block-wrapper docutils container" id="id97">
<div class="code-block-caption"><span class="caption-text">src/MomentumTransportModels/momentumTransportModels/momentumTransportModel.C</span><a class="headerlink" href="#id97" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Foam</span><span class="o">::</span><span class="n">typeIOobject</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">IOdictionary</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">momentumTransportModel</span><span class="o">::</span><span class="n">readModelDict</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">objectRegistry</span><span class="o">&amp;</span> <span class="n">obr</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">word</span><span class="o">&amp;</span> <span class="n">group</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">registerObject</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">typeIOobject</span><span class="o">&lt;</span><span class="n">IOdictionary</span><span class="o">&gt;</span> <span class="n">momentumTransport</span>
    <span class="p">(</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">groupName</span><span class="p">(</span><span class="n">typeName</span><span class="p">,</span> <span class="n">group</span><span class="p">),</span>
        <span class="n">obr</span><span class="p">.</span><span class="n">time</span><span class="p">().</span><span class="n">constant</span><span class="p">(),</span>
        <span class="n">obr</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">MUST_READ_IF_MODIFIED</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_WRITE</span><span class="p">,</span>
        <span class="n">registerObject</span>
    <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">momentumTransport</span><span class="p">.</span><span class="n">headerOk</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">momentumTransport</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">typeIOobject</span><span class="o">&lt;</span><span class="n">IOdictionary</span><span class="o">&gt;</span> <span class="n">turbulenceProperties</span>
        <span class="p">(</span>
            <span class="n">IOobject</span><span class="o">::</span><span class="n">groupName</span><span class="p">(</span><span class="s">&quot;turbulenceProperties&quot;</span><span class="p">,</span> <span class="n">group</span><span class="p">),</span>
            <span class="n">obr</span><span class="p">.</span><span class="n">time</span><span class="p">().</span><span class="n">constant</span><span class="p">(),</span>
            <span class="n">obr</span><span class="p">,</span>
            <span class="n">IOobject</span><span class="o">::</span><span class="n">MUST_READ_IF_MODIFIED</span><span class="p">,</span>
            <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_WRITE</span><span class="p">,</span>
            <span class="n">registerObject</span>
        <span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">turbulenceProperties</span><span class="p">.</span><span class="n">headerOk</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">turbulenceProperties</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">momentumTransport</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="c1">// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //</span>

<span class="n">Foam</span><span class="o">::</span><span class="n">momentumTransportModel</span><span class="o">::</span><span class="n">momentumTransportModel</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">volVectorField</span><span class="o">&amp;</span> <span class="n">U</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">alphaRhoPhi</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">phi</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">viscosity</span><span class="o">&amp;</span> <span class="n">viscosity</span>
<span class="p">)</span>
<span class="o">:</span>
    <span class="n">IOdictionary</span><span class="p">(</span><span class="n">readModelDict</span><span class="p">(</span><span class="n">U</span><span class="p">.</span><span class="n">db</span><span class="p">(),</span> <span class="n">alphaRhoPhi</span><span class="p">.</span><span class="n">group</span><span class="p">(),</span> <span class="nb">true</span><span class="p">)),</span>

    <span class="n">runTime_</span><span class="p">(</span><span class="n">U</span><span class="p">.</span><span class="n">time</span><span class="p">()),</span>
    <span class="n">mesh_</span><span class="p">(</span><span class="n">U</span><span class="p">.</span><span class="n">mesh</span><span class="p">()),</span>

    <span class="n">U_</span><span class="p">(</span><span class="n">U</span><span class="p">),</span>
    <span class="n">alphaRhoPhi_</span><span class="p">(</span><span class="n">alphaRhoPhi</span><span class="p">),</span>
    <span class="n">phi_</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span>
    <span class="n">viscosity_</span><span class="p">(</span><span class="n">viscosity</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Ensure name of IOdictionary is typeName</span>
    <span class="n">rename</span><span class="p">(</span><span class="n">IOobject</span><span class="o">::</span><span class="n">groupName</span><span class="p">(</span><span class="n">typeName</span><span class="p">,</span> <span class="n">alphaRhoPhi</span><span class="p">.</span><span class="n">group</span><span class="p">()));</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id98">
<div class="code-block-caption"><span class="caption-text">src/ThermophysicalTransportModels/thermophysicalTransportModel/thermophysicalTransportModel.C</span><a class="headerlink" href="#id98" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Foam</span><span class="o">::</span><span class="n">thermophysicalTransportModel</span><span class="o">::</span><span class="n">thermophysicalTransportModel</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">compressibleMomentumTransportModel</span><span class="o">&amp;</span> <span class="n">momentumTransport</span>
<span class="p">)</span>
<span class="o">:</span>
    <span class="n">IOdictionary</span>
    <span class="p">(</span>
        <span class="n">IOobject</span>
        <span class="p">(</span>
            <span class="n">IOobject</span><span class="o">::</span><span class="n">groupName</span>
            <span class="p">(</span>
                <span class="n">typeName</span><span class="p">,</span> <span class="n">momentumTransport</span><span class="p">.</span><span class="n">alphaRhoPhi</span><span class="p">().</span><span class="n">group</span><span class="p">()</span>
            <span class="p">),</span>
            <span class="n">momentumTransport</span><span class="p">.</span><span class="n">time</span><span class="p">().</span><span class="n">constant</span><span class="p">(),</span>
            <span class="n">momentumTransport</span><span class="p">.</span><span class="n">mesh</span><span class="p">(),</span>
            <span class="n">IOobject</span><span class="o">::</span><span class="n">READ_IF_PRESENT</span><span class="p">,</span>
            <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_WRITE</span>
        <span class="p">)</span>
    <span class="p">),</span>

    <span class="n">momentumTransportModel_</span><span class="p">(</span><span class="n">momentumTransport</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Add run-time re-reading of thermophysicalTransport dictionary after construction to avoid problems if the dictionary is not present</span>
    <span class="n">readOpt</span><span class="p">()</span> <span class="o">=</span> <span class="n">IOobject</span><span class="o">::</span><span class="n">MUST_READ_IF_MODIFIED</span><span class="p">;</span>
    <span class="n">addWatch</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>一个经典的应用案例如下：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Creating turbulence model</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">autoPtr</span><span class="o">&lt;</span><span class="n">compressible</span><span class="o">::</span><span class="n">momentumTransportModel</span><span class="o">&gt;</span> <span class="n">turbulence</span>
<span class="p">(</span>
    <span class="n">compressible</span><span class="o">::</span><span class="n">momentumTransportModel</span><span class="o">::</span><span class="n">New</span>
    <span class="p">(</span>
        <span class="n">rho</span><span class="p">,</span>
        <span class="n">U</span><span class="p">,</span>
        <span class="n">phi</span><span class="p">,</span>
        <span class="n">thermo</span>
    <span class="p">)</span>
<span class="p">);</span>

<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Creating thermophysical transport model</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">autoPtr</span><span class="o">&lt;</span><span class="n">fluidThermophysicalTransportModel</span><span class="o">&gt;</span> <span class="n">thermophysicalTransport</span>
<span class="p">(</span>
    <span class="n">fluidThermophysicalTransportModel</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">turbulence</span><span class="p">(),</span> <span class="n">thermo</span><span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<p>在读取到文件内容之后，可以利用subDict()函数可以进一步读取文件中的子字典内容，调用的函数为</p>
<div class="literal-block-wrapper docutils container" id="id99">
<div class="code-block-caption"><span class="caption-text">src/OpenFOAM/db/dictionary/dictionary.C</span><a class="headerlink" href="#id99" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">Foam</span><span class="o">::</span><span class="n">dictionary</span><span class="o">&amp;</span> <span class="n">Foam</span><span class="o">::</span><span class="n">dictionary</span><span class="o">::</span><span class="n">subDict</span><span class="p">(</span><span class="k">const</span> <span class="n">word</span><span class="o">&amp;</span> <span class="n">keyword</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">entry</span><span class="o">*</span> <span class="n">entryPtr</span> <span class="o">=</span> <span class="n">lookupEntryPtr</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">entryPtr</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">FatalIOErrorInFunction</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">)</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;keyword &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">keyword</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; is undefined in dictionary &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">name</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="n">exit</span><span class="p">(</span><span class="n">FatalIOError</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">entryPtr</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">();</span>
<span class="p">}</span>


<span class="n">Foam</span><span class="o">::</span><span class="n">dictionary</span><span class="o">&amp;</span> <span class="n">Foam</span><span class="o">::</span><span class="n">dictionary</span><span class="o">::</span><span class="n">subDict</span><span class="p">(</span><span class="k">const</span> <span class="n">word</span><span class="o">&amp;</span> <span class="n">keyword</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">entry</span><span class="o">*</span> <span class="n">entryPtr</span> <span class="o">=</span> <span class="n">lookupEntryPtr</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">entryPtr</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">FatalIOErrorInFunction</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">)</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;keyword &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">keyword</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; is undefined in dictionary &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">name</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="n">exit</span><span class="p">(</span><span class="n">FatalIOError</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">entryPtr</span><span class="o">-&gt;</span><span class="n">dict</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>下面是一个简单的应用案例：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="p">.</span><span class="n">mesh</span><span class="p">().</span><span class="n">schemes</span><span class="p">().</span><span class="n">subDict</span><span class="p">(</span><span class="s">&quot;divSchemes&quot;</span><span class="p">).</span><span class="n">subDict</span><span class="p">(</span><span class="s">&quot;dbns&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>在读取到文件内子字典之后，需要使用lookup()函数来读取子字典内设置的关键词来得到其相应赋值，调用的函数为</p>
<div class="literal-block-wrapper docutils container" id="id100">
<div class="code-block-caption"><span class="caption-text">src/OpenFOAM/db/IOobjectList/IOobjectList.C</span><a class="headerlink" href="#id100" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Foam</span><span class="o">::</span><span class="n">IOobject</span><span class="o">*</span> <span class="n">Foam</span><span class="o">::</span><span class="n">IOobjectList</span><span class="o">::</span><span class="n">lookup</span><span class="p">(</span><span class="k">const</span> <span class="n">word</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">HashPtrTable</span><span class="o">&lt;</span><span class="n">IOobject</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">!=</span> <span class="n">end</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">IOobject</span><span class="o">::</span><span class="n">debug</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">InfoInFunction</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Found &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">const_cast</span><span class="o">&lt;</span><span class="n">IOobject</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">IOobject</span><span class="o">::</span><span class="n">debug</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">InfoInFunction</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Could not find &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="n">Foam</span><span class="o">::</span><span class="n">IOobjectList</span> <span class="n">Foam</span><span class="o">::</span><span class="n">IOobjectList</span><span class="o">::</span><span class="n">lookup</span><span class="p">(</span><span class="k">const</span> <span class="n">wordRe</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">IOobjectList</span> <span class="n">objectsOfName</span><span class="p">(</span><span class="n">size</span><span class="p">());</span>

    <span class="n">forAllConstIter</span><span class="p">(</span><span class="n">HashPtrTable</span><span class="o">&lt;</span><span class="n">IOobject</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="n">iter</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">name</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="n">iter</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()))</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">IOobject</span><span class="o">::</span><span class="n">debug</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">InfoInFunction</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Found &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">iter</span><span class="p">.</span><span class="n">key</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">objectsOfName</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">key</span><span class="p">(),</span> <span class="n">new</span> <span class="n">IOobject</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">()));</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">objectsOfName</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">Foam</span><span class="o">::</span><span class="n">IOobjectList</span> <span class="n">Foam</span><span class="o">::</span><span class="n">IOobjectList</span><span class="o">::</span><span class="n">lookup</span><span class="p">(</span><span class="k">const</span> <span class="n">wordReList</span><span class="o">&amp;</span> <span class="n">patterns</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">wordReListMatcher</span> <span class="n">names</span><span class="p">(</span><span class="n">patterns</span><span class="p">);</span>

    <span class="n">IOobjectList</span> <span class="nf">objectsOfName</span><span class="p">(</span><span class="n">size</span><span class="p">());</span>

    <span class="n">forAllConstIter</span><span class="p">(</span><span class="n">HashPtrTable</span><span class="o">&lt;</span><span class="n">IOobject</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="n">iter</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">names</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="n">iter</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()))</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">IOobject</span><span class="o">::</span><span class="n">debug</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">InfoInFunction</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Found &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">iter</span><span class="p">.</span><span class="n">key</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">objectsOfName</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">key</span><span class="p">(),</span> <span class="n">new</span> <span class="n">IOobject</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">()));</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">objectsOfName</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>一个简单的应用案例如下：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">dictionary</span><span class="o">&amp;</span> <span class="n">subDict</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">mesh</span><span class="p">().</span><span class="n">schemes</span><span class="p">().</span><span class="n">subDict</span><span class="p">(</span><span class="s">&quot;divSchemes&quot;</span><span class="p">).</span><span class="n">subDict</span><span class="p">(</span><span class="s">&quot;dbns&quot;</span><span class="p">);</span>
<span class="n">word</span> <span class="n">name</span> <span class="o">=</span> <span class="n">word</span><span class="p">(</span><span class="n">subDict</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="s">&quot;flux&quot;</span><span class="p">))</span> <span class="o">+</span> <span class="s">&quot;Flux&quot;</span> <span class="o">+</span> <span class="n">word</span><span class="p">(</span><span class="n">subDict</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="s">&quot;limiter&quot;</span><span class="p">))</span> <span class="o">+</span> <span class="s">&quot;Limiter&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>关于自定义文件的读取与输出可以参考 <a class="reference external" href="https://blog.csdn.net/aha_miemie/article/details/122738115">OpenFOAM编程基础(2) -数据读取与保存</a> 。例如现在要读取一个位于constant文件夹内的一个名为customProperties的文件内容，则通过如下方式创建该文件对象：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">IOdictionary</span> <span class="nf">custonProperties</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;customProperties&quot;</span><span class="p">,</span>      <span class="c1">// 目标文件名</span>
        <span class="n">runtime</span><span class="p">().</span><span class="n">constant</span><span class="p">(),</span>    <span class="c1">// 目标文件路径</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">MUST_READ</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_WRITE</span>
    <span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<p>接下来就可以对该对象进行各种读取操作：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// 读取指定关键词所赋的文字内容</span>
<span class="n">word</span> <span class="n">someWord</span><span class="p">;</span>
<span class="n">custonProperties</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="s">&quot;someWord&quot;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">someWord</span><span class="p">;</span>

<span class="c1">// 在读取时检查数据类型，并且设置默认初始值</span>
<span class="n">scalar</span> <span class="n">someScalar</span><span class="p">;</span>
<span class="n">custonProperties</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;someScalar&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">someScalar</span><span class="p">;</span>

<span class="c1">// 读取指定关键词所赋的bool值</span>
<span class="kt">bool</span> <span class="n">someBool</span><span class="p">;</span>
<span class="n">custonProperties</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">Switch</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;someBool&quot;</span><span class="p">,</span> <span class="nb">true</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">someBool</span><span class="p">;</span>

<span class="c1">// 读取指定关键词所赋的列表数据</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;</span> <span class="n">someList</span><span class="p">;</span>
<span class="n">custonProperties</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="s">&quot;someList&quot;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">someList</span><span class="p">;</span>

<span class="c1">// 读取指定关键词所赋的哈希表数据</span>
<span class="n">HashTable</span><span class="o">&lt;</span><span class="n">vector</span><span class="p">,</span> <span class="n">word</span><span class="o">&gt;</span> <span class="n">someHashTable</span><span class="p">;</span>
<span class="n">custonProperties</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="s">&quot;someHashTable&quot;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">someHashTable</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="id42">
<h3>源项处理策略<a class="headerlink" href="#id42" title="永久链接至标题">¶</a></h3>
<p>以下面关于 <span class="math notranslate nohighlight">\(\phi\)</span> 的输运方程为例：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\partial \phi}{\partial t}
+ \nabla\cdot (\mathbf{U}\phi)
- \nabla \cdot \gamma \nabla\phi
= S_{\phi}
\end{align}\]</div>
<p>源项 <span class="math notranslate nohighlight">\(S_{\phi}\)</span> 在实际情况下是比较复杂的，可能包含非线性项。为了求解稳定，通常对其线性化处理：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
S_{\phi} = S_{u} + S_{p}\phi
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(S_{u}\)</span> 和 <span class="math notranslate nohighlight">\(S_{p}\)</span> 可以与 <span class="math notranslate nohighlight">\(\phi\)</span> 有关，也可以与 <span class="math notranslate nohighlight">\(\phi\)</span> 无关。</p>
<p>将输运方程离散成 <span class="math notranslate nohighlight">\(\mathbf{A}\mathbf{x} = \mathbf{b}\)</span> ，那么 <span class="math notranslate nohighlight">\(S_{u}\)</span> 将进入 <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> ，而 <span class="math notranslate nohighlight">\(S_{p}\)</span> 将变成 <span class="math notranslate nohighlight">\(-S_{p}\)</span> 进入 <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> 的对角元素。如果 <span class="math notranslate nohighlight">\(S_{p}\)</span> 为正，则将削弱 <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> 的对角占优，很可能造成线性方程组求解发散，因此在对源项进行线性化时必须保证 <span class="math notranslate nohighlight">\(S_{p}\)</span> 为负或零。</p>
<p>进入src/finiteVolume/finiteVolume/fvm/fvmSup.C文件，对于从 <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> 中加上 <span class="math notranslate nohighlight">\(S_{u}\)</span> 的操作在OpenFOAM中通过 <code class="code docutils literal notranslate"><span class="pre">fvm::Su()</span></code> 实现：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">fvm</span><span class="o">::</span><span class="n">Su</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">DimensionedField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">su</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">vf</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">fvMesh</span><span class="o">&amp;</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">vf</span><span class="p">.</span><span class="n">mesh</span><span class="p">();</span>

    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span> <span class="n">tfvm</span>
    <span class="p">(</span>
        <span class="n">new</span> <span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span>
        <span class="p">(</span>
            <span class="n">vf</span><span class="p">,</span>
            <span class="n">dimVol</span><span class="o">*</span><span class="n">su</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()</span>
        <span class="p">)</span>
    <span class="p">);</span>
    <span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&amp;</span> <span class="n">fvm</span> <span class="o">=</span> <span class="n">tfvm</span><span class="p">.</span><span class="n">ref</span><span class="p">();</span>

    <span class="n">fvm</span><span class="p">.</span><span class="n">source</span><span class="p">()</span> <span class="o">-=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">V</span><span class="p">()</span><span class="o">*</span><span class="n">su</span><span class="p">.</span><span class="n">field</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">tfvm</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>对于在系数矩阵 <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> 对角元素减去 <span class="math notranslate nohighlight">\(S_{p}\)</span> 的操作在OpenFOAM中通过 <code class="code docutils literal notranslate"><span class="pre">fvm::Sp()</span></code> 实现：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">fvm</span><span class="o">::</span><span class="n">Sp</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">::</span><span class="n">Internal</span><span class="o">&amp;</span> <span class="n">sp</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">vf</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">fvMesh</span><span class="o">&amp;</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">vf</span><span class="p">.</span><span class="n">mesh</span><span class="p">();</span>

    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span> <span class="n">tfvm</span>
    <span class="p">(</span>
        <span class="n">new</span> <span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span>
        <span class="p">(</span>
            <span class="n">vf</span><span class="p">,</span>
            <span class="n">dimVol</span><span class="o">*</span><span class="n">sp</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()</span>
        <span class="p">)</span>
    <span class="p">);</span>
    <span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&amp;</span> <span class="n">fvm</span> <span class="o">=</span> <span class="n">tfvm</span><span class="p">.</span><span class="n">ref</span><span class="p">();</span>

    <span class="n">fvm</span><span class="p">.</span><span class="n">diag</span><span class="p">()</span> <span class="o">+=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">V</span><span class="p">()</span><span class="o">*</span><span class="n">sp</span><span class="p">.</span><span class="n">field</span><span class="p">();</span>    <span class="c1">// 在fvmB的系数矩阵对角处加上源sp，考虑==运算后即为在最终方程系数矩阵对角处减去源sp</span>

    <span class="k">return</span> <span class="n">tfvm</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>当源项为负数的时候，求解方程得到的值也可能为负值，但这对于一些不可能为负数的物理量（比如温度 <span class="math notranslate nohighlight">\(T\)</span> 、湍动能 <span class="math notranslate nohighlight">\(k\)</span> 、湍流比耗散率 <span class="math notranslate nohighlight">\(\omega\)</span> ）来说是没有意义的。为了避免这种情况发生，可以将源项做如下处理：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
S_{\phi} = S_{\text{const}} \approx S_{\text{const}}\frac{\phi_{n+1}}{\phi_{n}}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(S_{\text{const}}\)</span> 为负的源项。经过上述处理之后， <span class="math notranslate nohighlight">\(-S_{\text{const}}/\phi_{n}\)</span> 将作为正数计入到系数矩阵的对角元素中，既增强了对角占优，又可以保证 <span class="math notranslate nohighlight">\(\phi\)</span> 为非负。</p>
<p>对于复杂的源项，在不同位置的正负可能不同。为了使整个线性方程组的求解更加稳定，需要对正负源项分开处理，具体做法为：</p>
<ul class="simple">
<li>如果 <span class="math notranslate nohighlight">\(S_{\phi} &lt; 0\)</span> ，则对其采用隐式离散，即 <span class="math notranslate nohighlight">\(S_{u}=0\)</span> ， <span class="math notranslate nohighlight">\(S_{p}=S_{\phi}/\phi_{0}\)</span> ，将其贡献计入 <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> 对角上。</li>
<li>如果 <span class="math notranslate nohighlight">\(S_{\phi} &gt; 0\)</span> ，则对其采用显式离散，即 <span class="math notranslate nohighlight">\(S_{u}=S_{\phi}\)</span> ， <span class="math notranslate nohighlight">\(S_{p}=0\)</span> ，将其贡献计入 <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> 中。</li>
</ul>
<p>上面的操作通过 <code class="code docutils literal notranslate"><span class="pre">fvm::SuSp()</span></code> 来实现：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">fvm</span><span class="o">::</span><span class="n">SuSp</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">::</span><span class="n">Internal</span><span class="o">&amp;</span> <span class="n">susp</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">vf</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">fvMesh</span><span class="o">&amp;</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">vf</span><span class="p">.</span><span class="n">mesh</span><span class="p">();</span>

    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span> <span class="n">tfvm</span>
    <span class="p">(</span>
        <span class="n">new</span> <span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span>
        <span class="p">(</span>
            <span class="n">vf</span><span class="p">,</span>
            <span class="n">dimVol</span><span class="o">*</span><span class="n">susp</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()</span><span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()</span>
        <span class="p">)</span>
    <span class="p">);</span>
    <span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&amp;</span> <span class="n">fvm</span> <span class="o">=</span> <span class="n">tfvm</span><span class="p">.</span><span class="n">ref</span><span class="p">();</span>

    <span class="n">fvm</span><span class="p">.</span><span class="n">diag</span><span class="p">()</span> <span class="o">+=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">V</span><span class="p">()</span><span class="o">*</span><span class="n">max</span><span class="p">(</span><span class="n">susp</span><span class="p">.</span><span class="n">field</span><span class="p">(),</span> <span class="n">scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>    <span class="c1">// 从fvmB系数矩阵对角加上正的susp，考虑==运算即为从最终系数矩阵对角上减去正的源susp</span>

    <span class="n">fvm</span><span class="p">.</span><span class="n">source</span><span class="p">()</span> <span class="o">-=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">V</span><span class="p">()</span><span class="o">*</span><span class="n">min</span><span class="p">(</span><span class="n">susp</span><span class="p">.</span><span class="n">field</span><span class="p">(),</span> <span class="n">scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>    <span class="c1">// 从fvmB的b上减去负的susp，考虑==运算即为从最终方程b上加上负的源susp</span>
        <span class="o">*</span><span class="n">vf</span><span class="p">.</span><span class="n">primitiveField</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">tfvm</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>源项线性化的选择并不是唯一的，不同的选择有不同的精度和稳定性。例如，考虑如下形式的源项：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
S_{\phi} = 10 - 2\phi^{3}
\end{align}\]</div>
<p>上式包含非线性项 <span class="math notranslate nohighlight">\(-2\phi^{3}\)</span> ，需要对其进行线性化处理。有多种方法可以选择：</p>
<ol class="arabic simple">
<li>令 <span class="math notranslate nohighlight">\(S_{u} = 10 - 2\phi_{0}^{3}\)</span> ， <span class="math notranslate nohighlight">\(S_{p}=0\)</span> ，即</li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{align}
S_{\phi}^{n+1} = 10 - 2\phi_{n+1}^{3} \cong 10 - 2\phi_{n}^{3} + 0 \times \phi_{n+1}
\end{align}\]</div>
<ol class="arabic simple" start="2">
<li>令 <span class="math notranslate nohighlight">\(S_{u}=10\)</span> ， <span class="math notranslate nohighlight">\(-2\phi_{0}^{2}\)</span> ，即</li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{align}
S_{\phi}^{n+1} = 10 - 2\phi_{n+1}^{3} = 10 - 2\phi_{n+1}^{2}\cdot \phi_{n+1} \cong 10 - 2\phi_{n}^{2}\cdot \phi_{n+1}
\end{align}\]</div>
<ol class="arabic simple" start="3">
<li>使用Picard’s method，对 <span class="math notranslate nohighlight">\(S_{\phi}\)</span> 在 <span class="math notranslate nohighlight">\(\phi_{0}\)</span> 处进行泰勒展开，只保留一阶项：</li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{align}
S_{\phi}^{n+1} \approx S_{\phi}^{n} + \frac{\partial S_{\phi}}{\partial \phi}\Big|_{\phi=\phi_{n}}(\phi_{n+1} - \phi_{n})
= 10 - 2\phi_{n}^{3} + (-6\phi_{n}^{2})(\phi_{n+1} - \phi_{n})
= 10 + 4\phi_{n}^{3} - 6\phi_{n}^{2}\cdot \phi_{n+1}
\end{align}\]</div>
<p>也即 <span class="math notranslate nohighlight">\(S_{u}=10+4\phi_{n}^{3}\)</span> ， <span class="math notranslate nohighlight">\(S_{p}=-6\phi_{n}^{2}\)</span> 。</p>
<p class="last">在上述三种不同的线性化方法中，第三种方法精度最高，第一种方法精度最低。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>利用源项线性化处理可以实现指定某个网格单元的值。对于某一个单元P，如果需要指定该处的值为 <span class="math notranslate nohighlight">\(\phi_{P,\text{desired}}\)</span> ，则可以对该单元施加如下线性化后的源项：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
S_{P} = A_{\text{large}}\phi_{P,\text{desired}} - A_{\text{large}}\phi_{P}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(A_{\text{large}}\)</span> 为一个很大的数，比如 <span class="math notranslate nohighlight">\(10^{10}\)</span> 。对于单元P，将除源项之外的所有项离散后的方程表示为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
A_{P}\phi_{P} + \sum_{n\sim nb}^{N}A_{N}\phi_{N} = b_{P}
\end{align}\]</div>
<p>加上源项后，上式变为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
(A_{P} + A_{\text{large}})\phi_{P} + \sum_{n\sim nb}^{N}A_{N}\phi_{N} = b_{P} + A_{\text{large}}\phi_{P,\text{desired}}
\end{align}\]</div>
<p class="last">如果满足 <span class="math notranslate nohighlight">\(A_{\text{large}} \gg A_{P}\)</span> 、 <span class="math notranslate nohighlight">\(A_{\text{large}} \gg A_{N}\)</span> 且 <span class="math notranslate nohighlight">\(A_{\text{large}}\phi_{P,\text{desired}} \gg b_{P}\)</span> ，则求解得到的 <span class="math notranslate nohighlight">\(\phi_{P}\approx \phi_{P,\text{desired}}\)</span> 。在需要修改某个网格单元的值时而不影响其他单元时（比如重叠网格的插值单元赋值），这种方法格外有用。</p>
</div>
<div class="admonition attention">
<p class="first admonition-title">注意</p>
<p>在构建方程矩阵的时候会用到 <code class="code docutils literal notranslate"><span class="pre">==</span></code> 运算，该操作符已经被重载，实际进行的是两边的fvScalarMatrix对象进行相减操作。该运算的运算优先级低于+和-，因此==最后计算。方程矩阵代码执行时，先计算==左右两边的表达式，然后再将这两个对象进行==运算。也就是说，方程代码做的是类似fvmA-fvmB的操作，而源项放在fvmB中，由于fvmB是需要减去的，因此这可以解释上面的Su()、Sp()、SuSp()操作的正负号与正常理解的正负号相反的原因。</p>
<p class="last">下面是OpenFOAM重载==运算的代码。</p>
</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&gt;</span> <span class="n">Foam</span><span class="o">::</span><span class="n">operator</span><span class="o">==</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&amp;</span> <span class="n">A</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">fvMatrix</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;&amp;</span> <span class="n">B</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">checkMethod</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s">&quot;==&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">B</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="laplacianfoam">
<h3>laplacianFoam求解器<a class="headerlink" href="#laplacianfoam" title="永久链接至标题">¶</a></h3>
<div class="section" id="laplacianfoamcreatefields-h">
<h4>laplacianFoam的createFields.H<a class="headerlink" href="#laplacianfoamcreatefields-h" title="永久链接至标题">¶</a></h4>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Reading field T</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

<span class="n">volScalarField</span> <span class="n">T</span>    <span class="c1">// 定义在网格体中心的标量场T</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;T&quot;</span><span class="p">,</span>                      <span class="c1">// 场的名称(T),用于确定初始文件名称(T)以及变量名称(T)</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>       <span class="c1">// 存储位置为运行时间(文件夹)</span>
        <span class="n">mesh</span><span class="p">,</span>                     <span class="c1">// 注册于网格对象mesh中</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">MUST_READ</span><span class="p">,</span>      <span class="c1">// 该对象通过读取文件创建,必须进行读取</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">AUTO_WRITE</span>      <span class="c1">// 根据controlDict中的设置自动写入结果文件</span>
    <span class="p">),</span>
    <span class="n">mesh</span>    <span class="c1">// 新建体心标量场(T)所用的网格对象,在createMesh.H创建</span>
<span class="p">);</span>


<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Reading physicalProperties</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

<span class="c1">// IOdictionary用于新建字典文件</span>
<span class="n">IOdictionary</span> <span class="n">physicalProperties</span>    <span class="c1">// 参数控制文件声明通过文件physicalProperties读取</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;physicalProperties&quot;</span><span class="p">,</span>                <span class="c1">// 文件名</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">constant</span><span class="p">(),</span>                  <span class="c1">// 文件位置，位于$case/constant</span>
        <span class="n">mesh</span><span class="p">,</span>                                <span class="c1">// 网格对象，主要从事对象注册，以便由runTime.write()控制输出</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">MUST_READ_IF_MODIFIED</span><span class="p">,</span>     <span class="c1">// 在字典文件被更改的时候进行读取</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_WRITE</span>                   <span class="c1">// 不输出，字典文件不需要输出</span>
    <span class="p">)</span>
<span class="p">);</span>


<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Reading diffusivity DT</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

<span class="c1">// dimensionedScalar用于新建带单位标量，新建扩散率DT。因为各向同性，DT为常数</span>
<span class="n">dimensionedScalar</span> <span class="nf">DT</span>
<span class="p">(</span>
    <span class="c1">// 通过查询参数控制文件$case/constant/physicalProperties，初始化带单位标量</span>
    <span class="c1">// 查询关键字DT并读取</span>
    <span class="n">physicalProperties</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="s">&quot;DT&quot;</span><span class="p">)</span>
<span class="p">);</span>

<span class="cp">#include</span> <span class="cpf">&quot;createFvModels.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;createFvConstraints.H&quot;</span><span class="cp"></span>
</pre></div>
</div>
</div>
<div class="section" id="laplacianfoam-c">
<h4>laplacianFoam.C<a class="headerlink" href="#laplacianfoam-c" title="永久链接至标题">¶</a></h4>
<p>laplacianFoam求解器用于求解热传递温度控制方程：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\partial T}{\partial t} - \nabla^{2}(D_{T}T) = 0
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(T\)</span> 表示温度， <span class="math notranslate nohighlight">\(t\)</span> 表示时间， <span class="math notranslate nohighlight">\(D_{T}\)</span> 为热扩散系数，具体表达式为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
D_{T} = \frac{k}{\rho C_{p}}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(k\)</span> 表示热传导系数， <span class="math notranslate nohighlight">\(\rho\)</span> 为密度， <span class="math notranslate nohighlight">\(C_{p}\)</span> 为比热容。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;fvCFD.H&quot;            // 必备头文件。涉及到时间构建、矩阵组建、有限体积离散、网格组建、量纲设置等</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;fvModels.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;fvConstraints.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;simpleControl.H&quot;    // 定义SIMPLE循环，使用SIMPLE循环必备头文件</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="cp">#include</span> <span class="cpf">&quot;setRootCaseLists.H&quot;    // 必备头文件。根据输入参数argc和argv设置算例根目录rootcase</span><span class="cp"></span>

    <span class="cp">#include</span> <span class="cpf">&quot;createTime.H&quot;          // 创建时间对象，涉及到runTime控制。非定常求解器必备头文件</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createMesh.H&quot;          // 必备头文件。创建网格对象，根据$case/constant/polyMesh文件夹中的网格数据创建对象mesh</span><span class="cp"></span>

    <span class="n">simpleControl</span> <span class="n">simple</span><span class="p">(</span><span class="n">mesh</span><span class="p">);</span>      <span class="c1">// 从网格mesh对象构造类simpleControl(基类:solutionControl)的对象simple</span>

    <span class="cp">#include</span> <span class="cpf">&quot;createFields.H&quot;        // 创建场对象，位于求解器根目录</span><span class="cp"></span>

    <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Calculating temperature distribution</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">simple</span><span class="p">.</span><span class="n">loop</span><span class="p">(</span><span class="n">runTime</span><span class="p">))</span>    <span class="c1">// 开始时间循环，采用SIMPLE算法必备语句</span>
    <span class="p">{</span>
        <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Time = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">runTime</span><span class="p">.</span><span class="n">userTimeName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

        <span class="n">fvModels</span><span class="p">.</span><span class="n">correct</span><span class="p">();</span>

        <span class="c1">// 是否进行非正交修正</span>
        <span class="c1">// 如果在fvSolution字典文件中设置为0就只求解控制方程一次，如果设置为n则求解控制方程n-1次</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">simple</span><span class="p">.</span><span class="n">correctNonOrthogonal</span><span class="p">())</span>
        <span class="p">{</span>

            <span class="n">fvScalarMatrix</span> <span class="n">TEqn</span>    <span class="c1">// 定义热传递温度控制方程</span>
            <span class="p">(</span>
                <span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">DT</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>    <span class="c1">// fvm表示隐式离散,返回有限体积稀疏矩阵类fvMatrix对象</span>
             <span class="o">==</span>                                        <span class="c1">// fvMatrix的==操作符执行优先级最低。先将==左右的各项相加，最后执行==。而==操作符被重载了，实际上是-</span>
                <span class="n">fvModels</span><span class="p">.</span><span class="n">source</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>    <span class="c1">// 源项</span>
            <span class="p">);</span>

            <span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">TEqn</span><span class="p">);</span>
            <span class="n">TEqn</span><span class="p">.</span><span class="n">solve</span><span class="p">();</span>    <span class="c1">// 求解方程。solve是FOAM名称空间的全局函数,参数为矩阵fvMatrix</span>
            <span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cp">#include</span> <span class="cpf">&quot;write.H&quot;    // 额外计算grad(T)并进行输出</span><span class="cp"></span>

        <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;ExecutionTime = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">runTime</span><span class="p">.</span><span class="n">elapsedCpuTime</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; s&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;  ClockTime = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">runTime</span><span class="p">.</span><span class="n">elapsedClockTime</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; s&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">nl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;End</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="laplacianfoamwrite-h">
<h4>laplacianFoam的write.H<a class="headerlink" href="#laplacianfoamwrite-h" title="永久链接至标题">¶</a></h4>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">runTime</span><span class="p">.</span><span class="n">writeTime</span><span class="p">())</span>    <span class="c1">// 当运行时间步到达输出时间的时候执行下面的内容</span>
<span class="p">{</span>
    <span class="n">volVectorField</span> <span class="n">gradT</span><span class="p">(</span><span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">T</span><span class="p">));</span>    <span class="c1">// 计算T的梯度，结果是定义在网格体中心的向量场。fvc::grad显示离散计算能够直接得到结果</span>

    <span class="n">volScalarField</span> <span class="n">gradTx</span>    <span class="c1">// 定义在网格体中心的标量场gradTx</span>
    <span class="p">(</span>
        <span class="n">IOobject</span>
        <span class="p">(</span>
            <span class="s">&quot;gradTx&quot;</span><span class="p">,</span>
            <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>     <span class="c1">// 位于时间文件夹</span>
            <span class="n">mesh</span><span class="p">,</span>
            <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_READ</span><span class="p">,</span>      <span class="c1">// 不进行读取</span>
            <span class="n">IOobject</span><span class="o">::</span><span class="n">AUTO_WRITE</span>    <span class="c1">// 到达输出时间步时自动进行输出</span>
        <span class="p">),</span>
        <span class="n">gradT</span><span class="p">.</span><span class="n">component</span><span class="p">(</span><span class="n">vector</span><span class="o">::</span><span class="n">X</span><span class="p">)</span>    <span class="c1">// 取计算得到的gradT的x分量赋值给gradTx</span>
    <span class="p">);</span>

    <span class="n">volScalarField</span> <span class="n">gradTy</span>    <span class="c1">// 定义在网格体中心的标量场gradTy</span>
    <span class="p">(</span>
        <span class="n">IOobject</span>
        <span class="p">(</span>
            <span class="s">&quot;gradTy&quot;</span><span class="p">,</span>
            <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>     <span class="c1">// 位于时间文件夹</span>
            <span class="n">mesh</span><span class="p">,</span>
            <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_READ</span><span class="p">,</span>      <span class="c1">// 不进行读取</span>
            <span class="n">IOobject</span><span class="o">::</span><span class="n">AUTO_WRITE</span>    <span class="c1">// 到达输出时间步时自动进行输出</span>
        <span class="p">),</span>
        <span class="n">gradT</span><span class="p">.</span><span class="n">component</span><span class="p">(</span><span class="n">vector</span><span class="o">::</span><span class="n">Y</span><span class="p">)</span>    <span class="c1">// 取计算得到的gradT的y分量赋值给gradTy</span>
    <span class="p">);</span>

    <span class="n">volScalarField</span> <span class="n">gradTz</span>    <span class="c1">// 定义在网格体中心的标量场gradTz</span>
    <span class="p">(</span>
        <span class="n">IOobject</span>
        <span class="p">(</span>
            <span class="s">&quot;gradTz&quot;</span><span class="p">,</span>
            <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>     <span class="c1">// 位于时间文件夹</span>
            <span class="n">mesh</span><span class="p">,</span>
            <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_READ</span><span class="p">,</span>      <span class="c1">// 不进行读取</span>
            <span class="n">IOobject</span><span class="o">::</span><span class="n">AUTO_WRITE</span>    <span class="c1">// 到达输出时间步时自动进行输出</span>
        <span class="p">),</span>
        <span class="n">gradT</span><span class="p">.</span><span class="n">component</span><span class="p">(</span><span class="n">vector</span><span class="o">::</span><span class="n">Z</span><span class="p">)</span>    <span class="c1">// 取计算得到的gradT的z分量赋值给gradTz</span>
    <span class="p">);</span>


    <span class="n">runTime</span><span class="p">.</span><span class="n">write</span><span class="p">();</span>    <span class="c1">// 输出计算结果</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="scalartransportfoam">
<h3>scalarTransportFoam求解器<a class="headerlink" href="#scalartransportfoam" title="永久链接至标题">¶</a></h3>
<div class="section" id="scalartransportfoamcreatefields-h">
<h4>scalarTransportFoam的createFields.H<a class="headerlink" href="#scalartransportfoamcreatefields-h" title="永久链接至标题">¶</a></h4>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Reading field T</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

<span class="n">volScalarField</span> <span class="n">T</span>    <span class="c1">// 定义在网格体中心的标量场T</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;T&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>     <span class="c1">// 位于时间文件夹</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">MUST_READ</span><span class="p">,</span>    <span class="c1">// 必须读取</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">AUTO_WRITE</span>    <span class="c1">// 根据controlDict设置自动输出</span>
    <span class="p">),</span>
    <span class="n">mesh</span>
<span class="p">);</span>


<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Reading field U</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

<span class="n">volVectorField</span> <span class="nf">U</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;U&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>     <span class="c1">// 位于时间文件夹</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">MUST_READ</span><span class="p">,</span>    <span class="c1">// 必须读取</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">AUTO_WRITE</span>    <span class="c1">// 根据controlDict设置自动输出</span>
    <span class="p">),</span>
    <span class="n">mesh</span>
<span class="p">);</span>


<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Reading physicalProperties</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

<span class="n">IOdictionary</span> <span class="n">physicalProperties</span>    <span class="c1">// 创建physicalProperties</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;physicalProperties&quot;</span><span class="p">,</span>               <span class="c1">// 读取physicalProperties文件</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">constant</span><span class="p">(),</span>                 <span class="c1">// 位于constant文件夹</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">MUST_READ_IF_MODIFIED</span><span class="p">,</span>    <span class="c1">// 修改后必须读取</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_WRITE</span>                  <span class="c1">// 不进行输出</span>
    <span class="p">)</span>
<span class="p">);</span>


<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Reading diffusivity DT</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

<span class="n">dimensionedScalar</span> <span class="n">DT</span>    <span class="c1">// 创建标量DT</span>
<span class="p">(</span>
    <span class="n">physicalProperties</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="s">&quot;DT&quot;</span><span class="p">)</span>    <span class="c1">// 从physicalProperties文件中读取DT关键词的值</span>
<span class="p">);</span>

<span class="cp">#include</span> <span class="cpf">&quot;createPhi.H&quot;    // 创建通量场</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&quot;createFvModels.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;createFvConstraints.H&quot;</span><span class="cp"></span>
</pre></div>
</div>
</div>
<div class="section" id="scalartransportfoam-c">
<h4>scalarTransportFoam.C<a class="headerlink" href="#scalartransportfoam-c" title="永久链接至标题">¶</a></h4>
<p>最基本的控制方程为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
    \frac{\partial (\rho T)}{\partial t}
  + \nabla \cdot (\rho \mathbf{U}T)
=   \nabla \cdot (\Gamma \nabla T)
  + Q
\end{align}\]</div>
<p>scalarTransportFoam处理的是 <span class="math notranslate nohighlight">\(\rho\)</span> 和 <span class="math notranslate nohighlight">\(\Gamma\)</span> 为常量的情况，因此上述方程可以简化为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\partial T}{\partial T} + \nabla \cdot (\mathbf{U}T) = \nabla \cdot (D_{T}\nabla T) + q
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(D_{T}=\frac{\Gamma}{\rho}\)</span> ， <span class="math notranslate nohighlight">\(q = \frac{Q}{\rho}\)</span> 。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;fvCFD.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;fvModels.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;fvConstraints.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;simpleControl.H&quot;    // 使用SIMPLE算法必备头文件</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="cp">#include</span> <span class="cpf">&quot;setRootCaseLists.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createTime.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createMesh.H&quot;</span><span class="cp"></span>

    <span class="n">simpleControl</span> <span class="n">simple</span><span class="p">(</span><span class="n">mesh</span><span class="p">);</span>

    <span class="cp">#include</span> <span class="cpf">&quot;createFields.H&quot;    // 创建场信息</span><span class="cp"></span>

    <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Calculating scalar transport</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="cp">#include</span> <span class="cpf">&quot;CourantNo.H&quot;</span><span class="cp"></span>

    <span class="k">while</span> <span class="p">(</span><span class="n">simple</span><span class="p">.</span><span class="n">loop</span><span class="p">(</span><span class="n">runTime</span><span class="p">))</span>    <span class="c1">// 开始SIMPLE算法循环</span>
    <span class="p">{</span>
        <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Time = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">runTime</span><span class="p">.</span><span class="n">userTimeName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

        <span class="n">fvModels</span><span class="p">.</span><span class="n">correct</span><span class="p">();</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">simple</span><span class="p">.</span><span class="n">correctNonOrthogonal</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="n">fvScalarMatrix</span> <span class="n">TEqn</span>    <span class="c1">// 标量传输方程</span>
            <span class="p">(</span>
                <span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>              <span class="c1">// 非稳态项</span>
              <span class="o">+</span> <span class="n">fvm</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>         <span class="c1">// 对流项</span>
              <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">DT</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>    <span class="c1">// 扩散项</span>
             <span class="o">==</span>
                <span class="n">fvModels</span><span class="p">.</span><span class="n">source</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>       <span class="c1">// 源项</span>
            <span class="p">);</span>

            <span class="n">TEqn</span><span class="p">.</span><span class="n">relax</span><span class="p">();</span>
            <span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">TEqn</span><span class="p">);</span>
            <span class="n">TEqn</span><span class="p">.</span><span class="n">solve</span><span class="p">();</span>    <span class="c1">// 求解标量传输方程</span>
            <span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">runTime</span><span class="p">.</span><span class="n">write</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;End</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="potentialfoam">
<h3>potentialFoam求解器<a class="headerlink" href="#potentialfoam" title="永久链接至标题">¶</a></h3>
<div class="section" id="potentialfoamcreatefields-h">
<h4>potentialFoam的createFields.H<a class="headerlink" href="#potentialfoamcreatefields-h" title="永久链接至标题">¶</a></h4>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Reading velocity field U</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">volVectorField</span> <span class="n">U</span>    <span class="c1">// 定义在网格体中心的矢量场U</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;U&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>     <span class="c1">// 位于时间文件夹</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">MUST_READ</span><span class="p">,</span>    <span class="c1">// 必须读取</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">AUTO_WRITE</span>    <span class="c1">// 根据controlDict设置自动输出</span>
    <span class="p">),</span>
    <span class="n">mesh</span>
<span class="p">);</span>

<span class="n">U</span> <span class="o">=</span> <span class="n">Zero</span><span class="p">;</span>

<span class="n">surfaceScalarField</span> <span class="n">phi</span>    <span class="c1">// 定义在网格面中心的标量场phi</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;phi&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>     <span class="c1">// 位于时间文件夹</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_READ</span><span class="p">,</span>      <span class="c1">// 不进行读取</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">AUTO_WRITE</span>    <span class="c1">// 根据controlDict设置自动输出</span>
    <span class="p">),</span>
    <span class="n">fvc</span><span class="o">::</span><span class="n">flux</span><span class="p">(</span><span class="n">U</span><span class="p">)</span>    <span class="c1">// 速度场插值到网格面上后点乘面矢量得到通量</span>
<span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">optionFound</span><span class="p">(</span><span class="s">&quot;initialiseUBCs&quot;</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">U</span><span class="p">.</span><span class="n">correctBoundaryConditions</span><span class="p">();</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">fvc</span><span class="o">::</span><span class="n">flux</span><span class="p">(</span><span class="n">U</span><span class="p">);</span>
<span class="p">}</span>


<span class="c1">// Default name for the pressure field</span>
<span class="n">word</span> <span class="n">pName</span><span class="p">(</span><span class="s">&quot;p&quot;</span><span class="p">);</span>    <span class="c1">// 使用pName关键字来表示p，只起到替换作用</span>

<span class="c1">// Update name of the pressure field from the command-line option</span>
<span class="n">args</span><span class="p">.</span><span class="n">optionReadIfPresent</span><span class="p">(</span><span class="s">&quot;pName&quot;</span><span class="p">,</span> <span class="n">pName</span><span class="p">);</span>

<span class="c1">// Infer the pressure BCs from the velocity</span>
<span class="n">wordList</span> <span class="nf">pBCTypes</span>
<span class="p">(</span>
    <span class="n">U</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">().</span><span class="n">size</span><span class="p">(),</span>
    <span class="n">fixedValueFvPatchScalarField</span><span class="o">::</span><span class="n">typeName</span>
<span class="p">);</span>

<span class="n">forAll</span><span class="p">(</span><span class="n">U</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">(),</span> <span class="n">patchi</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">U</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">].</span><span class="n">fixesValue</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">pBCTypes</span><span class="p">[</span><span class="n">patchi</span><span class="p">]</span> <span class="o">=</span> <span class="n">zeroGradientFvPatchScalarField</span><span class="o">::</span><span class="n">typeName</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Constructing pressure field &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">pName</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">volScalarField</span> <span class="n">p</span>    <span class="c1">// 定义在体中心的标量场p</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="n">pName</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>           <span class="c1">// 处于时间文件夹</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">READ_IF_PRESENT</span><span class="p">,</span>    <span class="c1">// 如果存在则进行读取</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_WRITE</span>            <span class="c1">// 不进行输出</span>
    <span class="p">),</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">dimensionedScalar</span><span class="p">(</span><span class="n">pName</span><span class="p">,</span> <span class="n">sqr</span><span class="p">(</span><span class="n">dimVelocity</span><span class="p">),</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">pBCTypes</span>
<span class="p">);</span>

<span class="c1">// Infer the velocity potential BCs from the pressure</span>
<span class="n">wordList</span> <span class="nf">PhiBCTypes</span>
<span class="p">(</span>
    <span class="n">p</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">().</span><span class="n">size</span><span class="p">(),</span>
    <span class="n">zeroGradientFvPatchScalarField</span><span class="o">::</span><span class="n">typeName</span>
<span class="p">);</span>

<span class="n">forAll</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">(),</span> <span class="n">patchi</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()[</span><span class="n">patchi</span><span class="p">].</span><span class="n">fixesValue</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">PhiBCTypes</span><span class="p">[</span><span class="n">patchi</span><span class="p">]</span> <span class="o">=</span> <span class="n">fixedValueFvPatchScalarField</span><span class="o">::</span><span class="n">typeName</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Constructing velocity potential field Phi</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">volScalarField</span> <span class="n">Phi</span>    <span class="c1">// 定义在网格体中心的标量场，速度势场Phi</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;Phi&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>           <span class="c1">// 处于时间文件夹</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">READ_IF_PRESENT</span><span class="p">,</span>    <span class="c1">// 如果存在则读取</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_WRITE</span>            <span class="c1">// 不进行读取</span>
    <span class="p">),</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">dimensionedScalar</span><span class="p">(</span><span class="n">dimLength</span><span class="o">*</span><span class="n">dimVelocity</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">PhiBCTypes</span>
<span class="p">);</span>

<span class="n">label</span> <span class="n">PhiRefCell</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>      <span class="c1">// 初始化速度势流参考网格标签</span>
<span class="n">scalar</span> <span class="n">PhiRefValue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="c1">// 初始化速度势流参考值</span>
<span class="n">setRefCell</span>
<span class="p">(</span>
    <span class="n">Phi</span><span class="p">,</span>
    <span class="n">potentialFlow</span><span class="p">.</span><span class="n">dict</span><span class="p">(),</span>    <span class="c1">// 读取potentialFlow子字典</span>
    <span class="n">PhiRefCell</span><span class="p">,</span>              <span class="c1">// 设置速度势流参考网格标签</span>
    <span class="n">PhiRefValue</span>              <span class="c1">// 设置速度势流参考值</span>
<span class="p">);</span>
<span class="n">mesh</span><span class="p">.</span><span class="n">schemes</span><span class="p">().</span><span class="n">setFluxRequired</span><span class="p">(</span><span class="n">Phi</span><span class="p">.</span><span class="n">name</span><span class="p">());</span>

<span class="cp">#include</span> <span class="cpf">&quot;createMRF.H&quot;</span><span class="cp"></span>
</pre></div>
</div>
</div>
<div class="section" id="potentialfoam-c">
<h4>potentialFoam.C<a class="headerlink" href="#potentialfoam-c" title="永久链接至标题">¶</a></h4>
<p>首先有稳态不可压缩流体连续性方程：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\nabla \cdot \mathbf{U} = 0
\end{align}\]</div>
<p>对于无粘无旋流，则必定存在一个势函数 <span class="math notranslate nohighlight">\(\Phi\)</span> 使得(速度势与压力同向)</p>
<div class="math notranslate nohighlight">
\[\begin{align}
-\nabla \cdot \Phi = \mathbf{U}
\end{align}\]</div>
<p>将上式代入连续性方程得到</p>
<div class="math notranslate nohighlight">
\[\begin{align}
-\nabla \cdot (\nabla \Phi) = \nabla \cdot \mathbf{U}
\end{align}\]</div>
<p>该方程的离散形式为：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
-\sum(\nabla \Phi)_{f}\cdot \mathbf{S}_{f} = \sum\mathbf{U}_{f}\cdot \mathbf{S}_{f} = \sum\phi_{f}
\end{align}\]</div>
<div class="admonition attention">
<p class="first admonition-title">注意</p>
<p class="last">之所以没有直接考虑 <span class="math notranslate nohighlight">\(-\nabla \cdot (\nabla \Phi)=0\)</span> 是因为这个方程离散后得到 <span class="math notranslate nohighlight">\(-\sum(\nabla \Phi)_{f}\cdot \mathbf{S}_{f}=0\)</span> ，无法考虑速度边界条件的影响。而由于速度边界条件很可能不等于零，所以不能采用这个方程。</p>
</div>
<p>求解流程可以分为以下几步：</p>
<ul class="simple">
<li>首先针对计算域，将初始化的 <span class="math notranslate nohighlight">\(\mathbf{U}\)</span> 内部场设置为0，保证 <span class="math notranslate nohighlight">\(\sum\phi_{f}\)</span> 在内部场为零。 <span class="math notranslate nohighlight">\(\mathbf{U}\)</span> 的边界场需要自己给定，且不为零。</li>
<li>求解一次所离散的方程，获得 <span class="math notranslate nohighlight">\(\Phi\)</span> 场。</li>
<li>对于内部场，由于 <span class="math notranslate nohighlight">\(\sum\phi_{f}=0\)</span> ，因此在内部场有 <span class="math notranslate nohighlight">\(\phi_{f} = -(\nabla \Phi)_{f}\cdot \mathbf{S}_{f}\)</span> 。</li>
<li>对于边界场，如果是固定值边界条件，那么 <span class="math notranslate nohighlight">\(\sum\phi_{f}\)</span> 通过速度计算而来，为一个固定值；如果是零法向梯度边界，边界处有 <span class="math notranslate nohighlight">\(\phi_{f} = -(\nabla \Phi)_{f}\cdot \mathbf{S}_{f}\)</span> 。</li>
<li>获得 <span class="math notranslate nohighlight">\(\phi_{f}\)</span> 场后可以重组得到速度场 <span class="math notranslate nohighlight">\(\mathbf{U}\)</span> 。</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">同时，在求解所离散的方程的时候，需要边界条件。速度的边界条件通常自行给定。 <span class="math notranslate nohighlight">\(\Phi\)</span> 的边界条件在进口，因为已经给定速度，因此要给定零法向梯度边界条件。</p>
</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;fvCFD.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;nonOrthogonalSolutionControl.H&quot;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">argList</span><span class="o">::</span><span class="n">addOption</span>
    <span class="p">(</span>
        <span class="s">&quot;pName&quot;</span><span class="p">,</span>
        <span class="s">&quot;pName&quot;</span><span class="p">,</span>
        <span class="s">&quot;Name of the pressure field&quot;</span>
    <span class="p">);</span>

    <span class="n">argList</span><span class="o">::</span><span class="n">addBoolOption</span>
    <span class="p">(</span>
        <span class="s">&quot;initialiseUBCs&quot;</span><span class="p">,</span>
        <span class="s">&quot;Initialise U boundary conditions&quot;</span>
    <span class="p">);</span>

    <span class="n">argList</span><span class="o">::</span><span class="n">addBoolOption</span>
    <span class="p">(</span>
        <span class="s">&quot;writePhi&quot;</span><span class="p">,</span>
        <span class="s">&quot;Write the velocity potential field&quot;</span>
    <span class="p">);</span>

    <span class="n">argList</span><span class="o">::</span><span class="n">addBoolOption</span>
    <span class="p">(</span>
        <span class="s">&quot;writep&quot;</span><span class="p">,</span>
        <span class="s">&quot;Calculate and write the pressure field&quot;</span>
    <span class="p">);</span>

    <span class="n">argList</span><span class="o">::</span><span class="n">addBoolOption</span>
    <span class="p">(</span>
        <span class="s">&quot;withFunctionObjects&quot;</span><span class="p">,</span>
        <span class="s">&quot;execute functionObjects&quot;</span>
    <span class="p">);</span>

    <span class="cp">#include</span> <span class="cpf">&quot;setRootCaseLists.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createTime.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createMesh.H&quot;</span><span class="cp"></span>

    <span class="n">nonOrthogonalSolutionControl</span> <span class="n">potentialFlow</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s">&quot;potentialFlow&quot;</span><span class="p">);</span>

    <span class="cp">#include</span> <span class="cpf">&quot;createFields.H&quot;    // 创建场信息</span><span class="cp"></span>

    <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="n">nl</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Calculating potential flow&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="c1">// Since solver contains no time loop it would never execute</span>
    <span class="c1">// function objects so do it ourselves</span>
    <span class="n">runTime</span><span class="p">.</span><span class="n">functionObjects</span><span class="p">().</span><span class="n">start</span><span class="p">();</span>    <span class="c1">// 启动求解</span>

    <span class="n">MRF</span><span class="p">.</span><span class="n">makeRelative</span><span class="p">(</span><span class="n">phi</span><span class="p">);</span>
    <span class="n">adjustPhi</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

    <span class="c1">// Non-orthogonal velocity potential corrector loop</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">potentialFlow</span><span class="p">.</span><span class="n">correctNonOrthogonal</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">fvScalarMatrix</span> <span class="n">PhiEqn</span>    <span class="c1">// 势流方程</span>
        <span class="p">(</span>
            <span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">dimensionedScalar</span><span class="p">(</span><span class="n">dimless</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Phi</span><span class="p">)</span>    <span class="c1">// 势流拉普拉斯项</span>
         <span class="o">==</span>
            <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>    <span class="c1">// 速度梯度项</span>
        <span class="p">);</span>

        <span class="n">PhiEqn</span><span class="p">.</span><span class="n">setReference</span><span class="p">(</span><span class="n">PhiRefCell</span><span class="p">,</span> <span class="n">PhiRefValue</span><span class="p">);</span>    <span class="c1">// 设置势流参考网格和参考值</span>
        <span class="n">PhiEqn</span><span class="p">.</span><span class="n">solve</span><span class="p">();</span>    <span class="c1">// 求解势流方程得到Phi</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">potentialFlow</span><span class="p">.</span><span class="n">finalNonOrthogonalIter</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="n">phi</span> <span class="o">-=</span> <span class="n">PhiEqn</span><span class="p">.</span><span class="n">flux</span><span class="p">();</span>    <span class="c1">// 通过速度势流得到通量</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Continuity error = &quot;</span>
        <span class="o">&lt;&lt;</span> <span class="n">mag</span><span class="p">(</span><span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phi</span><span class="p">))().</span><span class="n">weightedAverage</span><span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">V</span><span class="p">()).</span><span class="n">value</span><span class="p">()</span>
        <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="n">U</span> <span class="o">=</span> <span class="n">fvc</span><span class="o">::</span><span class="n">reconstruct</span><span class="p">(</span><span class="n">MRF</span><span class="p">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">phi</span><span class="p">));</span>    <span class="c1">// 通过通量重组出速度场</span>
    <span class="n">U</span><span class="p">.</span><span class="n">correctBoundaryConditions</span><span class="p">();</span>

    <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Interpolated velocity error = &quot;</span>
        <span class="o">&lt;&lt;</span> <span class="p">(</span>
                <span class="n">sqrt</span><span class="p">(</span><span class="n">sum</span><span class="p">(</span><span class="n">sqr</span><span class="p">(</span><span class="n">fvc</span><span class="o">::</span><span class="n">flux</span><span class="p">(</span><span class="n">U</span><span class="p">)</span> <span class="o">-</span> <span class="n">MRF</span><span class="p">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">phi</span><span class="p">))))</span>
               <span class="o">/</span><span class="n">sum</span><span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">magSf</span><span class="p">())</span>
           <span class="p">).</span><span class="n">value</span><span class="p">()</span>
        <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="c1">// Write U and phi</span>
    <span class="n">U</span><span class="p">.</span><span class="n">write</span><span class="p">();</span>      <span class="c1">// 输出速度场</span>
    <span class="n">phi</span><span class="p">.</span><span class="n">write</span><span class="p">();</span>    <span class="c1">// 输出通量场</span>

    <span class="c1">// Optionally write Phi</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">optionFound</span><span class="p">(</span><span class="s">&quot;writePhi&quot;</span><span class="p">))</span>    <span class="c1">// 如果设置了writePhi</span>
    <span class="p">{</span>
        <span class="n">Phi</span><span class="p">.</span><span class="n">write</span><span class="p">();</span>    <span class="c1">// 输出速度势流场</span>
    <span class="p">}</span>

    <span class="c1">// Calculate the pressure field</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">optionFound</span><span class="p">(</span><span class="s">&quot;writep&quot;</span><span class="p">))</span>    <span class="c1">// 如果设置了writep则要计算压力场</span>
    <span class="p">{</span>
        <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="n">nl</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Calculating approximate pressure field&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

        <span class="n">label</span> <span class="n">pRefCell</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>        <span class="c1">// 初始化压力参考网格标签</span>
        <span class="n">scalar</span> <span class="n">pRefValue</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>    <span class="c1">// 初始化压力参考值</span>
        <span class="n">setRefCell</span>
        <span class="p">(</span>
            <span class="n">p</span><span class="p">,</span>
            <span class="n">potentialFlow</span><span class="p">.</span><span class="n">dict</span><span class="p">(),</span>    <span class="c1">// 读取potentialFlow子字典</span>
            <span class="n">pRefCell</span><span class="p">,</span>                <span class="c1">// 设置压力参考网格标签</span>
            <span class="n">pRefValue</span>                <span class="c1">// 设置压力参考值</span>
        <span class="p">);</span>

        <span class="c1">// Calculate the flow-direction filter tensor</span>
        <span class="cm">/* 计算速度场模长的平方值 |U|^{2} ，是定义在网格体中心的标量场 */</span>
        <span class="n">volScalarField</span> <span class="n">magSqrU</span><span class="p">(</span><span class="n">magSqr</span><span class="p">(</span><span class="n">U</span><span class="p">));</span>

        <span class="cm">/* 定义在网格体中心的对称张量场</span>
<span class="cm">           F为流向滤波张量，表示为 U^{2} / |U|^{2}</span>
<span class="cm">           small是一个极小数1.0e-6，用来避免除数为零 */</span>
        <span class="n">volSymmTensorField</span> <span class="n">F</span><span class="p">(</span><span class="n">sqr</span><span class="p">(</span><span class="n">U</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">magSqrU</span> <span class="o">+</span> <span class="n">small</span><span class="o">*</span><span class="n">average</span><span class="p">(</span><span class="n">magSqrU</span><span class="p">)));</span>

        <span class="c1">// Calculate the divergence of the flow-direction filtered div(U*U)</span>
        <span class="c1">// Filtering with the flow-direction generates a more reasonable</span>
        <span class="c1">// pressure distribution in regions of high velocity gradient in the</span>
        <span class="c1">// direction of the flow</span>
        <span class="cm">/*</span>
<span class="cm">           在流动方向的高速度梯度区域，按流动方向进行过滤，可使压力分布更加合理</span>
<span class="cm">        */</span>
        <span class="n">volScalarField</span> <span class="n">divDivUU</span>    <span class="c1">// 滤波后流向的散度，是定义在网格体中心的标量场</span>
        <span class="p">(</span>
            <span class="cm">/*</span>
<span class="cm">               \nabla \cdot (\frac{U^{2}}{|U|^{2}} \cdot \nabla \cdot (UU))</span>
<span class="cm">            */</span>
            <span class="n">fvc</span><span class="o">::</span><span class="n">div</span>
            <span class="p">(</span>
                <span class="n">F</span> <span class="o">&amp;</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">U</span><span class="p">),</span>
                <span class="s">&quot;div(div(phi,U))&quot;</span>
            <span class="p">)</span>
        <span class="p">);</span>

        <span class="c1">// Solve a Poisson equation for the approximate pressure</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">potentialFlow</span><span class="p">.</span><span class="n">correctNonOrthogonal</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="n">fvScalarMatrix</span> <span class="n">pEqn</span>    <span class="c1">// 压力泊松方程，属于标量方程</span>
            <span class="p">(</span>
                <span class="cm">/*</span>
<span class="cm">                   \nabla^{2} p + \nabla \cdot (\frac{U^{2}}{|U|^{2}} \cdot \nabla \cdot (UU))</span>
<span class="cm">                */</span>
                <span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="n">divDivUU</span>
            <span class="p">);</span>

            <span class="n">pEqn</span><span class="p">.</span><span class="n">setReference</span><span class="p">(</span><span class="n">pRefCell</span><span class="p">,</span> <span class="n">pRefValue</span><span class="p">);</span>    <span class="c1">// 设置压力参考网格和参考值</span>
            <span class="n">pEqn</span><span class="p">.</span><span class="n">solve</span><span class="p">();</span>    <span class="c1">// 求解压力泊松方程得到估计压力场</span>
        <span class="p">}</span>

        <span class="n">p</span><span class="p">.</span><span class="n">write</span><span class="p">();</span>    <span class="c1">// 输出压力场</span>
    <span class="p">}</span>

    <span class="n">runTime</span><span class="p">.</span><span class="n">functionObjects</span><span class="p">().</span><span class="n">end</span><span class="p">();</span>    <span class="c1">// 结束求解</span>

    <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;ExecutionTime = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">runTime</span><span class="p">.</span><span class="n">elapsedCpuTime</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; s&quot;</span>
        <span class="o">&lt;&lt;</span> <span class="s">&quot;  ClockTime = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">runTime</span><span class="p">.</span><span class="n">elapsedClockTime</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; s&quot;</span>
        <span class="o">&lt;&lt;</span> <span class="n">nl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;End</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="potentialfoamcreatecontrols-h">
<h4>potentialFoam的createControls.H<a class="headerlink" href="#potentialfoamcreatecontrols-h" title="永久链接至标题">¶</a></h4>
<p>在求解器目录中还存在这个头文件，但是在potentialFoam.C中并没有调用。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">dictionary</span><span class="o">&amp;</span> <span class="n">potentialFlow</span>
<span class="p">(</span>
    <span class="n">mesh</span><span class="p">.</span><span class="n">solution</span><span class="p">().</span><span class="n">dict</span><span class="p">().</span><span class="n">subDict</span><span class="p">(</span><span class="s">&quot;potentialFlow&quot;</span><span class="p">)</span>
<span class="p">);</span>

<span class="k">const</span> <span class="kt">int</span> <span class="nf">nNonOrthCorr</span>
<span class="p">(</span>
    <span class="n">potentialFlow</span><span class="p">.</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;nNonOrthogonalCorrectors&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="icofoam">
<h3>icoFoam求解器<a class="headerlink" href="#icofoam" title="永久链接至标题">¶</a></h3>
<div class="section" id="icofoamcreatefields-h">
<h4>icoFoam的createFields.H<a class="headerlink" href="#icofoamcreatefields-h" title="永久链接至标题">¶</a></h4>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// 在此之前已经创建了runTime和mesh对象，可以直接使用runTime和mesh进行操作</span>
<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Reading physicalProperties</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>      <span class="c1">// 打印信息，提示要读取physicalProperties这个文件</span>

<span class="n">IOdictionary</span> <span class="n">physicalProperties</span>    <span class="c1">// 创建physicalProperties对象</span>
<span class="p">(</span>
    <span class="n">IOobject</span>     <span class="c1">// 通过IOobject读取physicalProperties文件内的信息</span>
    <span class="p">(</span>
        <span class="s">&quot;physicalProperties&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">constant</span><span class="p">(),</span>                   <span class="c1">// 存在于constant文件夹下</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">MUST_READ_IF_MODIFIED</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_WRITE</span>                    <span class="c1">// 位于constant文件夹内的属性不进行输出</span>
    <span class="p">)</span>
<span class="p">);</span>

<span class="n">dimensionedScalar</span> <span class="n">nu</span>    <span class="c1">// 创建有量纲标量场-动力粘度场nu</span>
<span class="p">(</span>
    <span class="s">&quot;nu&quot;</span><span class="p">,</span>
    <span class="n">dimViscosity</span><span class="p">,</span>
    <span class="n">physicalProperties</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="s">&quot;nu&quot;</span><span class="p">)</span>    <span class="c1">// 通过读取关键词nu的值进行创建</span>
<span class="p">);</span>

<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Reading field p</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">volScalarField</span> <span class="n">p</span>    <span class="c1">// 创建定义在网格体中心的标量场-压力场p</span>
<span class="p">(</span>
    <span class="n">IOobject</span>    <span class="c1">// 通过IOobject读取p文件内的信息</span>
    <span class="p">(</span>
        <span class="s">&quot;p&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>     <span class="c1">// 存在于时间文件夹下</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">MUST_READ</span><span class="p">,</span>    <span class="c1">// 必须进行读取</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">AUTO_WRITE</span>    <span class="c1">// 会自动进行输出</span>
    <span class="p">),</span>
    <span class="n">mesh</span>
<span class="p">);</span>


<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Reading field U</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">volVectorField</span> <span class="n">U</span>    <span class="c1">// 创建定义在网格体中心的矢量场-速度场U</span>
<span class="p">(</span>
    <span class="n">IOobject</span>    <span class="c1">// 通过IOobject读取U文件内的信息</span>
    <span class="p">(</span>
        <span class="s">&quot;U&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>     <span class="c1">// 存在于时间文件夹下</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">MUST_READ</span><span class="p">,</span>    <span class="c1">// 必须进行读取</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">AUTO_WRITE</span>    <span class="c1">// 会自动进行输出</span>
    <span class="p">),</span>
    <span class="n">mesh</span>
<span class="p">);</span>


<span class="cp">#include</span> <span class="cpf">&quot;createPhi.H&quot;    // 创建面通量场phi</span><span class="cp"></span>


<span class="n">label</span> <span class="n">pRefCell</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>         <span class="c1">// 标定网格参考的编号，首先初始化为了0</span>
<span class="n">scalar</span> <span class="n">pRefValue</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>     <span class="c1">// 标定网格的参考值，首先初始化为了0。不可压缩流有意义的是参考压力值</span>
<span class="c1">// 进入fvSolution文件查找PISP子字典，读取其中的pRefCell与pRefValue的值并进行更新</span>
<span class="n">setRefCell</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">mesh</span><span class="p">.</span><span class="n">solution</span><span class="p">().</span><span class="n">dict</span><span class="p">().</span><span class="n">subDict</span><span class="p">(</span><span class="s">&quot;PISO&quot;</span><span class="p">),</span> <span class="n">pRefCell</span><span class="p">,</span> <span class="n">pRefValue</span><span class="p">);</span>
<span class="n">mesh</span><span class="p">.</span><span class="n">schemes</span><span class="p">().</span><span class="n">setFluxRequired</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">name</span><span class="p">());</span>
</pre></div>
</div>
</div>
<div class="section" id="icofoam-c">
<h4>icoFoam.C<a class="headerlink" href="#icofoam-c" title="永久链接至标题">¶</a></h4>
<p>icoFoam求解不可压缩流体，控制方程有两个：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\nabla \cdot \mathbf{U} = 0
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\partial \mathbf{U}}{\partial t}
+ \nabla\cdot(\mathbf{U}\mathbf{U})
=
-\nabla \frac{p}{\rho}
+ \nabla \cdot (\nu \nabla \mathbf{U})
\end{align}\]</div>
<p>使用有限体积法处理动量方程得到</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{1}{\Delta t}\iint \bigg(
\frac{\partial \mathbf{U}}{\partial t}
+ \nabla\cdot(\mathbf{U}\mathbf{U})
\bigg) \mathrm{d}V\mathrm{d}t
=
\frac{1}{\Delta t}\iint \bigg(
-\nabla \frac{p}{\rho}
+ \nabla \cdot (\nu \nabla \mathbf{U})
\bigg) \mathrm{d}V\mathrm{d}t
\end{align}\]</div>
<p>接下来对各项进行离散处理。首先是时间项欧拉全隐式离散：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{1}{\Delta t}\iint \frac{\partial \mathbf{U}}{\partial t} \mathrm{d}V\mathrm{d}t = \frac{(\mathbf{U}_{P}^{*} - \mathbf{U}_{P}^{t})}{\Delta t}V_{P}
\end{align}\]</div>
<p>其中下标P表示当前网格，上标t表示当前时间步(已知)，上标*表示预测步。</p>
<p>对流项隐式离散利用了高斯定理：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{1}{\Delta t}\iint \nabla \cdot (\mathbf{U}\mathbf{U}) \mathrm{d}V\mathrm{d}t
= \frac{1}{\Delta t}\iint (\mathbf{U}\mathbf{U}) \cdot \mathrm{d}\mathbf{S}\mathrm{d}t
= \frac{1}{\Delta t}\sum (\mathbf{U}^{*}\mathbf{U}^{t})_{f} \cdot \mathbf{S}_{f} \Delta t
= \sum \phi_{f}^{t} \mathbf{U}_{f}^{*}
\end{align}\]</div>
<p>其中下标f表示插值到网格面上， <span class="math notranslate nohighlight">\(\mathbf{S}_{f}\)</span> 为网格面矢量， <span class="math notranslate nohighlight">\(\phi_{f}^{t}\)</span> 为网格面上当前时间步的通量。</p>
<p>扩散项隐式离散：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{1}{\Delta t}\iint \nabla \cdot (\nu \nabla \mathbf{U}) \mathrm{d}V\mathrm{d}t
= \frac{1}{\Delta t}\iint \nu \nabla \mathbf{U} \cdot \mathrm{d}\mathbf{S}\mathrm{d}t
= \sum (\nu \nabla \mathbf{U}^{*})_{f} \cdot \mathbf{S}_{f}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\nabla \mathbf{U}^{*}\)</span> 定义在网格体中心， <span class="math notranslate nohighlight">\((\nabla \mathbf{U}^{*})_{f}\)</span> 定义在网格面中心。</p>
<p>为了方便，重新定义 <span class="math notranslate nohighlight">\(p = \frac{p}{\rho}\)</span> 去掉密度，于是压力项显式离散为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{1}{\Delta t} \iint - \nabla p~\mathrm{d}V\mathrm{d}t
= \frac{1}{\Delta t}\iint - p ~\mathrm{d}\mathbf{S}\mathrm{d}t
= -\sum (p_{f}^{t}\mathbf{S}_{f})
\end{align}\]</div>
<p>将上面的离散结果全部应用到动量方程并将所有速度相关的项移到左边则得到</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{(\mathbf{U}_{P}^{*} - \mathbf{U}_{P}^{t})}{\Delta t}V_{P}
+ \sum \phi_{f}^{t} \mathbf{U}_{f}^{*}
- \sum (\nu \nabla \mathbf{U}^{*})_{f} \cdot \mathbf{S}_{f}
=
- \sum (p_{f}^{t}\mathbf{S}_{f})
\end{align}\]</div>
<p>左侧与速度相关的方程在icoFoam中通过如下方式组建：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">fvVectorMatrix</span> <span class="nf">UEqn</span>
<span class="p">(</span>
    <span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">U</span><span class="p">)</span>
    <span class="o">+</span> <span class="n">fvm</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>
    <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<p>右侧显式离散的压力梯度项则如下进行组建：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="o">-</span><span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
<p>上述方程中 <span class="math notranslate nohighlight">\(\mathbf{U}_{P}^{*}\)</span> 作为未知数保留下来， <span class="math notranslate nohighlight">\(\phi_{f}^{t}\)</span> 通过 <span class="math notranslate nohighlight">\(\mathbf{U}_{P}^{t}\)</span> 插值计算得到。插值到面的过程需要自行选择格式，以均一网格上的中心线性格式为例则有</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\mathbf{U}_{f}^{*} = \frac{\mathbf{U}_{P}^{*} + \mathbf{U}_{N}^{*}}{2}, \qquad p_{f}^{t} = \frac{p_{P}^{t} + p_{N}^{t}}{2}
\end{align}\]</div>
<p>其中下标P表示定义在当前网格的体中心，下标N表示定义在相邻网格的体中心。</p>
<p>为了使用紧致基架点防止数值振荡， <span class="math notranslate nohighlight">\((\nabla \mathbf{U}^{*})_{f} \cdot \mathbf{S}_{f}\)</span> 需要重新表示为面法向梯度乘以面矢量的模，即</p>
<div class="math notranslate nohighlight">
\[\begin{array}{c}
(\nabla \mathbf{U}^{*})_{f} \cdot \mathbf{S}_{f}
= \bigg( (\nabla \mathbf{U}^{*})_{f} \cdot \frac{\mathbf{S}_{f}}{|\mathbf{S}_{f}|} \bigg) \cdot |\mathbf{S}_{f}|
\end{array}\]</div>
<p>上面的面法向梯度可以离散为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
(\nabla \mathbf{U}^{*})_{f} \cdot \frac{\mathbf{S}_{f}}{|\mathbf{S}_{f}|}
= \frac{\mathbf{U}_{N}^{*} - \mathbf{U}_{P}^{*}}{|\mathbf{d}|}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\mathbf{d}\)</span> 表示相邻网格体中心之间的距离矢量。</p>
<p>将这些进一步的离散形式应用于动量方程则得到</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\mathbf{U}_{P}^{*} - \mathbf{U}_{P}^{t}}{\Delta t}V_{P}
+ \sum \phi_{f}^{t} \frac{\mathbf{U}_{P}^{*} + \mathbf{U}_{N}^{*}}{2}
- \sum \nu \frac{\mathbf{U}_{N}^{*} - \mathbf{U}_{P}^{*}}{|\mathbf{d}|} |\mathbf{S}_{f}|
=
- \sum \frac{p_{P}^{t} + p_{N}^{t}}{2} \mathbf{S}_{f}
\end{align}\]</div>
<p>按各速度项提取系数进行整理得到</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\bigg( \frac{V_{P}}{\Delta t} + \sum\frac{\phi_{f}^{t}}{2} + \sum \nu\frac{|\mathbf{S}_{f}|}{|\mathbf{d}|} \bigg) \mathbf{U}_{P}^{*}
+ \sum \bigg( \frac{\phi_{f}^{t}}{2} - \nu \frac{|\mathbf{S}_{f}|}{|\mathbf{d}|} \bigg) \mathbf{U}_{N}^{*}
- \frac{V_{P}}{\Delta t} \mathbf{U}_{P}^{t}
=
- \sum \frac{p_{P}^{t} + p_{N}^{t}}{2}\mathbf{S}_{f}
\end{align}\]</div>
<p>各系数记为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
A_{P} &amp;= \frac{V_{P}}{\Delta t} + \sum\frac{\phi_{f}^{t}}{2} + \sum \nu\frac{|\mathbf{S}_{f}|}{|\mathbf{d}|}  \\
A_{N} &amp;= \frac{\phi_{f}^{t}}{2} - \nu \frac{|\mathbf{S}_{f}|}{|\mathbf{d}|}  \\
\end{align}\end{split}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(A_{P}\)</span> 通过 <code class="code docutils literal notranslate"><span class="pre">UEqn.A()</span></code> 来得到，实际操作则是提取了关于U的线性方程组的系数矩阵的对角元素， <code class="code docutils literal notranslate"><span class="pre">A()</span></code> 操作定义于src/finiteVolume/fvMatrices/fvMatrix/fvMatrix.C文件当中的809行。在后续常以 <span class="math notranslate nohighlight">\(1/A_{P}\)</span> 的形式出现，因此icoFoam如下进行定义：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">volScalarField</span> <span class="nf">rAU</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">UEqn</span><span class="p">.</span><span class="n">A</span><span class="p">());</span>
</pre></div>
</div>
<p>于是上式简写为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
A_{P}\mathbf{U}_{P}^{*} + \sum A_{N}\mathbf{U}_{N}^{*} - \frac{V_{P}}{\Delta t} \mathbf{U}_{P}^{t} = - \sum \frac{p_{P}^{t} + p_{N}^{t}}{2}\mathbf{S}_{f}
\end{align}\]</div>
<p>该方程称为 <strong>动量预测方程</strong> ，求解它就能够获得预测速度 <span class="math notranslate nohighlight">\(\mathbf{U}_{P}^{*}\)</span> ：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">piso</span><span class="p">.</span><span class="n">momentumPredictor</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">UEqn</span> <span class="o">==</span> <span class="o">-</span><span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">不过动量预测步骤并不是必须的，如果不调用动量预测，则 <span class="math notranslate nohighlight">\(\mathbf{U}_{P}^{*}=\mathbf{U}_{P}^{t}\)</span> 。</p>
</div>
<p>对连续性方程进行离散得到</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\sum (\mathbf{U}_{P,f}^{t+\Delta t} \cdot \mathbf{S}_{f}) = 0
\end{align}\]</div>
<p>其中上标 <span class="math notranslate nohighlight">\(t+\Delta t\)</span> 表示下一时间步达到收敛状态的情况。下面要尝试使用压力来表示 <span class="math notranslate nohighlight">\(\mathbf{U}_{P,f}^{t+\Delta t}\)</span> 。</p>
<p>重新来看动量预测方程，考虑 <strong>达到收敛情况的动量预测方程</strong> 则有</p>
<div class="math notranslate nohighlight">
\[\begin{align}
A_{P}\mathbf{U}_{P}^{t+\Delta t} + \sum A_{N}\mathbf{U}_{N}^{t+\Delta t} - \frac{V_{P}}{\Delta t} \mathbf{U}_{P}^{t} = - \sum p_{f}^{t+\Delta t}\mathbf{S}_{f}
\end{align}\]</div>
<p>收敛情况下的动量预测方程和原始动量预测方程做减法则得到</p>
<div class="math notranslate nohighlight">
\[\begin{align}
A_{P}(\mathbf{U}_{P}^{t+\Delta t} - \mathbf{U}_{P}^{*})
+ \sum A_{N}(\mathbf{U}_{N}^{t+\Delta t} - \mathbf{U}_{N}^{*})
= - \sum (p_{f}^{t+\Delta t} - p_{f}^{t}) \mathbf{S}_{f}
\end{align}\]</div>
<p>对收敛情况下的动量预测方程做移项得到 <span class="math notranslate nohighlight">\(\mathbf{U}_{P}^{t+\Delta t}\)</span> 的表达式：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\mathbf{U}_{P}^{t+\Delta t}
=
\mathbf{HbyA}_{P}^{t+\Delta t}
- \frac{1}{A_{P}} \sum p_{f}^{t+\Delta t}\mathbf{S}_{f}
\end{align}\]</div>
<p>其中</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\mathbf{HbyA}_{P}^{t+\Delta t} = \frac{1}{A_{P}} \Big( -\sum A_{N}\mathbf{U}_{N}^{t+\Delta t} + \frac{V_{P}}{\Delta t} \mathbf{U}_{P}^{t} \Big)
\end{align}\]</div>
<p>类似的，面上的速度则可以表示为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\mathbf{U}_{P,f}^{t+\Delta t}
=
\mathbf{HbyA}_{f}^{t+\Delta t}
-\Big(\frac{1}{A_{P}}\Big)_{f} \Big( \sum p_{f}^{t+\Delta t}\mathbf{S}_{f} \Big)_{f}
\end{align}\]</div>
<p>上式就成功将 <span class="math notranslate nohighlight">\(\mathbf{U}_{P,f}^{t+\Delta t}\)</span> 表示为与压力有关的式子，代入到离散的连续性方程则得到</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\sum \bigg( \mathbf{HbyA}_{f}^{t+\Delta t} -\Big(\frac{1}{A_{P}}\Big)_{f} \Big( \sum p_{f}^{t+\Delta t}\mathbf{S}_{f} \Big)_{f} \bigg) \cdot \mathbf{S}_{f} = 0
\end{align}\]</div>
<p>将面矢量点乘乘进去并移项就得到了压力泊松方程的离散形式：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\sum \mathbf{HbyA}_{f}^{t+\Delta t} \cdot \mathbf{S}_{f} = \sum \Big(\frac{1}{A_{P}}\Big)_{f}\Big( \sum p_{f}^{t+\Delta t}\mathbf{S}_{f} \Big)_{f} \cdot \mathbf{S}_{f}
\end{align}\]</div>
<p>其所表达的原始压力泊松方程的形式为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\nabla \cdot \mathbf{HbyA}^{t+\Delta t} = \nabla \cdot \Big( \frac{1}{A_{P}}\nabla p^{t+\Delta t} \Big)
\end{align}\]</div>
<div class="admonition attention">
<p class="first admonition-title">注意</p>
<p class="last">上述压力泊松方程的离散形式对 <span class="math notranslate nohighlight">\(\nabla \cdot \Big( \frac{1}{A}\nabla p^{t+\Delta t} \Big)\)</span> 的处理是先求梯度再求散度，但是这样会引起数值振荡。为了调用紧致格式防止数值振荡，应当从原始压力泊松方程形式考虑，通过拉普拉斯并进行高斯积分进行离散。</p>
</div>
<p>目前我们只有通过动量预测方程求解出来的 <span class="math notranslate nohighlight">\(\mathbf{U}_{P}^{*}\)</span> ，而 <span class="math notranslate nohighlight">\(\mathbf{HbyA}_{P}^{t+\Delta t}\)</span> 和 <span class="math notranslate nohighlight">\(p^{t+\Delta t}\)</span> 均未知，因此压力泊松方程尚不能求解。为了解决这个问题，Issa提出了PISO算法。依据PISO算法，重新考虑收敛情况下的动量预测方程和原始动量预测方程作差后的方程，引入忽略相邻点影响的假定，则有</p>
<div class="math notranslate nohighlight">
\[\begin{align}
A_{P}(\mathbf{U}_{P}^{t+\Delta t} - \mathbf{U}_{P}^{*}) = -\sum (p_{f}^{t+\Delta t} - p_{f}^{t}) \mathbf{S}_{f}
\end{align}\]</div>
<p>将上式与原始动量方程相加得到</p>
<div class="math notranslate nohighlight">
\[\begin{align}
A_{P}\mathbf{U}_{P}^{**} + \sum A_{N}\mathbf{U}_{N}^{*} - \frac{V_{P}}{\Delta t} \mathbf{U}_{P}^{t} = - \sum p_{f}^{*}\mathbf{S}_{f}
\end{align}\]</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">因为忽略了相邻点的影响，方程求解的结果将不会是准确的，也即两个方程相加将不会产生 <span class="math notranslate nohighlight">\(\mathbf{U}_{P}^{t+\Delta t}\)</span> 和 <span class="math notranslate nohighlight">\(p_{f}^{t+\Delta t}\)</span> ，而是预测值 <span class="math notranslate nohighlight">\(\mathbf{U}_{P}^{**}\)</span> 和 <span class="math notranslate nohighlight">\(p_{f}^{*}\)</span> 。</p>
</div>
<p>对上式进行移项得到 <span class="math notranslate nohighlight">\(\mathbf{U}_{P}^{**}\)</span> 的表达式：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\mathbf{U}_{P}^{**} = \mathbf{HbyA}_{P}^{*} - \frac{1}{A_{P}}\sum p_{f}^{*}\mathbf{S}_{f}
\end{align}\]</div>
<p>其中</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\mathbf{HbyA}_{P}^{*} = \frac{1}{A_{P}} \Big( -\sum A_{N}\mathbf{U}_{N}^{*} + \frac{V_{P}}{\Delta t} \mathbf{U}_{P}^{t} \Big)
\end{align}\]</div>
<p>使用 <code class="code docutils literal notranslate"><span class="pre">UEqn.H()</span></code> 来得到 <span class="math notranslate nohighlight">\(-\sum A_{N}\mathbf{U}_{N}^{*} + \frac{V_{P}}{\Delta t} \mathbf{U}_{P}^{t}\)</span> ，实际操作内容的讨论见 <a class="reference external" href="https://www.cfd-online.com/Forums/openfoam/75661-whats-meaning-ueqn.html">what’s the meaning of UEqn().A()</a>  ， <code class="code docutils literal notranslate"><span class="pre">H()</span></code> 操作定义于src/finiteVolume/fvMatrices/fvMatrix/fvMatrix.C文件当中的831行。在icoFoam通过如下方式进行定义：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">volVectorField</span> <span class="nf">HbyA</span><span class="p">(</span><span class="n">constrainHbyA</span><span class="p">(</span><span class="n">rAU</span><span class="o">*</span><span class="n">UEqn</span><span class="p">.</span><span class="n">H</span><span class="p">(),</span> <span class="n">U</span><span class="p">,</span> <span class="n">p</span><span class="p">));</span>
</pre></div>
</div>
<p>类似的可以得到插值在面上的形式：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\mathbf{U}_{P,f}^{**} = \mathbf{HbyA}_{f}^{*} - \Big(\frac{1}{A_{P}}\Big)_{f} \Big(\sum p_{f}^{*}\mathbf{S}_{f}\Big)_{f}
\end{align}\]</div>
<p>上式代入到离散的连续性方程则得到</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\sum \bigg( \mathbf{HbyA}_{f}^{*} - \Big(\frac{1}{A_{P}}\Big)_{f} \Big(\sum p_{f}^{*}\mathbf{S}_{f}\Big)_{f} \bigg) \cdot \mathbf{S}_{f} = 0
\end{align}\]</div>
<p>将面矢量点乘乘进去并移项则得到</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\sum \mathbf{HbyA}_{f}^{*} \cdot \mathbf{S}_{f} =  \sum \Big(\frac{1}{A_{P}}\Big)_{f} \Big( \sum p_{f}^{*}\mathbf{S}_{f} \Big)_{f} \cdot \mathbf{S}_{f}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\mathbf{HbyA}_{f}^{*} \cdot \mathbf{S}_{f}\)</span> 用了一个定义在网格面中心的标量场来表示：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">surfaceScalarField</span> <span class="nf">phiHbyA</span>
<span class="p">(</span>
    <span class="s">&quot;phiHbyA&quot;</span><span class="p">,</span>
    <span class="n">fvc</span><span class="o">::</span><span class="n">flux</span><span class="p">(</span><span class="n">HbyA</span><span class="p">)</span>
    <span class="o">+</span> <span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">rAU</span><span class="p">)</span><span class="o">*</span><span class="n">fvc</span><span class="o">::</span><span class="n">ddtCorr</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>    <span class="c1">// 保证速度通量的全局守恒，以确保压力方程有解</span>
<span class="p">);</span>
</pre></div>
</div>
<p>如此也就成功组建得到了压力泊松方程：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\nabla \cdot \Big( \frac{1}{A_{P}}\nabla p^{*} \Big) = \nabla \cdot \mathbf{HbyA}^{*}
\end{align}\]</div>
<p>该压力泊松方程在icoFoam当中通过如下方式进行组建：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">fvScalarMatrix</span> <span class="nf">pEqn</span>
<span class="p">(</span>
    <span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">rAU</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phiHbyA</span><span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<div class="admonition attention">
<p class="first admonition-title">注意</p>
<p class="last"><code class="code docutils literal notranslate"><span class="pre">fvc::div</span></code> 操作实际上进行的是加和操作。因此在进行这个操作之前总是要自行先计算出所需的通量。</p>
</div>
<p>求解该压力泊松方程后可以得到 <span class="math notranslate nohighlight">\(p^{*}\)</span> ，回代到 <span class="math notranslate nohighlight">\(\mathbf{U}_{P}^{**}\)</span> 的表达式就可以得到满足连续性方程的 <span class="math notranslate nohighlight">\(\mathbf{U}_{P}^{**}\)</span> ：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">U</span> <span class="o">=</span> <span class="n">HbyA</span> <span class="o">-</span> <span class="n">rAU</span><span class="o">*</span><span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</pre></div>
</div>
<p>但是，由于忽略了相邻点的影响，此时求解得到的 <span class="math notranslate nohighlight">\(p^{*}\)</span> 和 <span class="math notranslate nohighlight">\(\mathbf{U}_{P}^{**}\)</span> 并不严格满足动量方程，因此还需要继续使用这两个量进行时间步内的循环迭代，即 <code class="code docutils literal notranslate"><span class="pre">while</span> <span class="pre">(piso.correct())</span></code> 循环。PISO算法在时间步内的迭代一般只需要3步即可。</p>
<p>除此之外，在每次求解出预测压力与预测速度之后，还会使用最新压力校正速度通量，以保证速度通量场严格守恒：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">piso</span><span class="p">.</span><span class="n">finalNonOrthogonalIter</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">phiHbyA</span> <span class="o">-</span> <span class="n">pEqn</span><span class="p">.</span><span class="n">flux</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>其中 <code class="code docutils literal notranslate"><span class="pre">pEqn.flux()</span></code> 返回的内容是</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">rUA</span><span class="p">)</span><span class="o">*</span><span class="n">fvc</span><span class="o">::</span><span class="n">snGrad</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">*</span><span class="n">mag</span><span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">Sf</span><span class="p">())</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>在OpenFOAM中的通量计算有一点不同，主要差别在于 <span class="math notranslate nohighlight">\(\phi^{*}\)</span> 被定义为了 <span class="math notranslate nohighlight">\(\left ( \frac{A_{H}}{A_{D}} \right )_{f} \cdot \mathbf{S}_{f} + \phi_{e}\)</span> ，其中添加的 <span class="math notranslate nohighlight">\(\phi_{e}\)</span> 为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\phi_{e} = \frac{\gamma \rho}{A_{D}\Delta t}(\phi_{0}-\mathbf{S}_{f}\cdot\mathbf{U}_{f,0})
\end{align}\]</div>
<p>而 <span class="math notranslate nohighlight">\(\gamma\)</span> 参数具体含义为</p>
<div class="last math notranslate nohighlight">
\[\begin{align}
\gamma = 1- \min\left ( \frac{|\phi_{0}-\mathbf{U}_{f,0}|\cdot\mathbf{S}_{f}}{|\phi_{0}|+\varepsilon},1  \right )
\end{align}\]</div>
</div>
<p>icoFoam使用PISO算法求解NS方程，基本的步骤如下：</p>
<ol class="arabic simple">
<li>根据初始条件(压力场、速度场等)求解预测速度场；</li>
<li>根据预测速度求无压力梯度项的速度场；</li>
<li>根据无压力梯度项的速度场求解压力(泊松)方程，得到压力场；</li>
<li>根据压力场修正预测速度场以满足连续性方程；</li>
<li>返回第二步，循环直到满足收敛要求。</li>
</ol>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;fvCFD.H&quot;    // 有限体积库头文件的集合</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;pisoControl.H&quot;    //定义PISO循环,使用PISO循环必备头文件</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="cp">#include</span> <span class="cpf">&quot;setRootCaseLists.H&quot;     // 用于检查算例文件的结构是否正确</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createTime.H&quot;           // 创建runTime时间对象</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createMesh.H&quot;           // 创建mesh网格对象</span><span class="cp"></span>

    <span class="n">pisoControl</span> <span class="n">piso</span><span class="p">(</span><span class="n">mesh</span><span class="p">);</span>    <span class="c1">// 从网格mesh对象构造类pisoControl(基类:solutionControl)的对象piso</span>

    <span class="cp">#include</span> <span class="cpf">&quot;createFields.H&quot;          // 对场量进行初始化</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;initContinuityErrs.H&quot;    // 初始化连续误差</span><span class="cp"></span>


    <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Starting time loop</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">runTime</span><span class="p">.</span><span class="n">loop</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Time = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">runTime</span><span class="p">.</span><span class="n">userTimeName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

        <span class="cp">#include</span> <span class="cpf">&quot;CourantNo.H&quot;    // 计算库朗数并输出至屏幕</span><span class="cp"></span>

        <span class="c1">// Momentum predictor</span>

        <span class="n">fvVectorMatrix</span> <span class="n">UEqn</span>    <span class="c1">// 创建了一个关于U的式子(U方程)，即动量方程等号左边的部分</span>
        <span class="p">(</span>
            <span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">U</span><span class="p">)</span>              <span class="c1">// 隐式离散时间导数项</span>
          <span class="o">+</span> <span class="n">fvm</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>         <span class="c1">// 隐式离散对流项</span>
          <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>    <span class="c1">// 隐式离散扩散项</span>
        <span class="p">);</span>

        <span class="c1">// 动量预测求解开关，对于多相流以及低雷诺数一般设置为off</span>
        <span class="c1">// 通过fvSolution中momentumPredictor进行赋值</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">piso</span><span class="p">.</span><span class="n">momentumPredictor</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="c1">// 求解动量方程，使用上一步的压力场，得到预测速度场</span>
            <span class="n">solve</span><span class="p">(</span><span class="n">UEqn</span> <span class="o">==</span> <span class="o">-</span><span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>    <span class="c1">// 显式离散压强梯度项</span>
        <span class="p">}</span>

        <span class="c1">// --- PISO loop</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">piso</span><span class="p">.</span><span class="n">correct</span><span class="p">())</span>    <span class="c1">// 通过system/fvSolution中PISO字典中的nCorrectors关键词来指定循环次数</span>
        <span class="p">{</span>
            <span class="n">volScalarField</span> <span class="n">rAU</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">UEqn</span><span class="p">.</span><span class="n">A</span><span class="p">());</span>    <span class="c1">// 创建一个定义在体中心的标量场rAU</span>

            <span class="n">volVectorField</span> <span class="n">HbyA</span><span class="p">(</span><span class="n">constrainHbyA</span><span class="p">(</span><span class="n">rAU</span><span class="o">*</span><span class="n">UEqn</span><span class="p">.</span><span class="n">H</span><span class="p">(),</span> <span class="n">U</span><span class="p">,</span> <span class="n">p</span><span class="p">));</span>    <span class="c1">// 创建一个定义在体中心的向量场HbyA</span>

            <span class="n">surfaceScalarField</span> <span class="n">phiHbyA</span>    <span class="c1">// 创建一个定义在面中心的标量场</span>
            <span class="p">(</span>
                <span class="s">&quot;phiHbyA&quot;</span><span class="p">,</span>
                <span class="n">fvc</span><span class="o">::</span><span class="n">flux</span><span class="p">(</span><span class="n">HbyA</span><span class="p">)</span>                               <span class="c1">// 将HbyA差分到面上，并点乘面矢量</span>
              <span class="o">+</span> <span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">rAU</span><span class="p">)</span><span class="o">*</span><span class="n">fvc</span><span class="o">::</span><span class="n">ddtCorr</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>    <span class="c1">// 这一项是OpenFOAM自己添加的项，保证速度通量的全局守恒以确保压力方程有解</span>
            <span class="p">);</span>

            <span class="cm">/* 确保整个区域的净通量为0，即流入等于流出，</span>
<span class="cm">               函数先统计流入和流出的量，如果两者不相等，那么调整速度assignable边界，</span>
<span class="cm">               通过改动边界上的值使得整个体系通量守恒。</span>
<span class="cm">               也就是要修正压力边界（梯度为0）上的phi，使其满足连续性方程。 */</span>
            <span class="n">adjustPhi</span><span class="p">(</span><span class="n">phiHbyA</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

            <span class="c1">// Update the pressure BCs to ensure flux consistency</span>
            <span class="n">constrainPressure</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">phiHbyA</span><span class="p">,</span> <span class="n">rAU</span><span class="p">);</span>    <span class="c1">// //更正压力边界条件，保证通量守恒，用于修正fixedFluxPressure类压力边界条件</span>

            <span class="c1">// Non-orthogonal pressure corrector loop</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">piso</span><span class="p">.</span><span class="n">correctNonOrthogonal</span><span class="p">())</span>    <span class="c1">// 网格非正交压力修正循环，需要指定nNonOrthogonalCorrectors的值来确定循环次数</span>
            <span class="p">{</span>
                <span class="c1">// Pressure corrector</span>
                <span class="c1">// 构造泊松压力方程进行求解</span>
                <span class="n">fvScalarMatrix</span> <span class="n">pEqn</span>
                <span class="p">(</span>
                    <span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">rAU</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phiHbyA</span><span class="p">)</span>
                <span class="p">);</span>

                <span class="c1">// 在不可压缩流动中，只有相对压力才起作用。除非存在边界压力</span>
                <span class="c1">// 一个网格的压力可以任意设定，以产生独特的压力解决方案</span>
                <span class="n">pEqn</span><span class="p">.</span><span class="n">setReference</span><span class="p">(</span><span class="n">pRefCell</span><span class="p">,</span> <span class="n">pRefValue</span><span class="p">);</span>    <span class="c1">// 设置压力参考值</span>

                <span class="n">pEqn</span><span class="p">.</span><span class="n">solve</span><span class="p">();</span>    <span class="c1">// 求解上述p方程，可以得到p的值</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">piso</span><span class="p">.</span><span class="n">finalNonOrthogonalIter</span><span class="p">())</span>    <span class="c1">// 使用求解的压力场修正通量场，即在最后一次修正的时候使通量守恒</span>
                <span class="p">{</span>
                    <span class="n">phi</span> <span class="o">=</span> <span class="n">phiHbyA</span> <span class="o">-</span> <span class="n">pEqn</span><span class="p">.</span><span class="n">flux</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="cp">#include</span> <span class="cpf">&quot;continuityErrs.H&quot;    // 计算连续性方程误差</span><span class="cp"></span>

            <span class="c1">// 校正速度，满足边界条件(主要针对第二类边界条件）</span>
            <span class="n">U</span> <span class="o">=</span> <span class="n">HbyA</span> <span class="o">-</span> <span class="n">rAU</span><span class="o">*</span><span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

            <span class="cm">/* 上述隐式求解过程中U的边界条件不会参与，调用该函数之后才得到边界值，</span>
<span class="cm">               该函数的主要作用是将GeometricField中的变量及时更新，</span>
<span class="cm">               通常会在每一时间步的结束时刻调用一次，多次调用也不会出错。 */</span>
            <span class="n">U</span><span class="p">.</span><span class="n">correctBoundaryConditions</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">runTime</span><span class="p">.</span><span class="n">write</span><span class="p">();</span>    <span class="c1">// 输出时间</span>

        <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;ExecutionTime = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">runTime</span><span class="p">.</span><span class="n">elapsedCpuTime</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; s&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;  ClockTime = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">runTime</span><span class="p">.</span><span class="n">elapsedClockTime</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; s&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">nl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;End</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">更新通量phi采用 <code class="code docutils literal notranslate"><span class="pre">phi</span> <span class="pre">=</span> <span class="pre">phiHbyA</span> <span class="pre">-</span> <span class="pre">pEqn.flux()</span></code> 的方法，而不是在求解出正确速度场之后通过 <code class="code docutils literal notranslate"><span class="pre">phi</span> <span class="pre">=</span> <span class="pre">fvc::flux(U)</span></code> 来更新，这样可以保证通量phi是严格守恒的。由于U不存在守恒的概念，即使是通过正确的U插值求解通量也不能保证一定守恒。</p>
</div>
</div>
</div>
<div class="section" id="pisofoam">
<h3>pisoFoam求解器<a class="headerlink" href="#pisofoam" title="永久链接至标题">¶</a></h3>
<div class="section" id="pisofoamcreatefields-h">
<h4>pisoFoam的createFields.H<a class="headerlink" href="#pisofoamcreatefields-h" title="永久链接至标题">¶</a></h4>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Reading field p</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">volScalarField</span> <span class="n">p</span>    <span class="c1">// 创建定义在网格体中心的标量场-压力场p</span>
<span class="p">(</span>
    <span class="n">IOobject</span>    <span class="c1">// 通过IOobject读取p文件内的信息</span>
    <span class="p">(</span>
        <span class="s">&quot;p&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>     <span class="c1">// 存在于时间文件夹下</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">MUST_READ</span><span class="p">,</span>    <span class="c1">// 必须进行读取</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">AUTO_WRITE</span>    <span class="c1">// 会自动进行输出</span>
    <span class="p">),</span>
    <span class="n">mesh</span>
<span class="p">);</span>

<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Reading field U</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">volVectorField</span> <span class="n">U</span>    <span class="c1">// 创建定义在网格体中心的矢量场-速度场U</span>
<span class="p">(</span>
    <span class="n">IOobject</span>    <span class="c1">// 通过IOobject读取U文件内的信息</span>
    <span class="p">(</span>
        <span class="s">&quot;U&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>     <span class="c1">// 存在于时间文件夹下</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">MUST_READ</span><span class="p">,</span>    <span class="c1">// 必须读取</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">AUTO_WRITE</span>    <span class="c1">// 会自动进行输出</span>
    <span class="p">),</span>
    <span class="n">mesh</span>
<span class="p">);</span>

<span class="cp">#include</span> <span class="cpf">&quot;createPhi.H&quot;    // 创建面通量场phi</span><span class="cp"></span>


<span class="n">pressureReference</span> <span class="nf">pressureReference</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">piso</span><span class="p">.</span><span class="n">dict</span><span class="p">());</span>

<span class="n">mesh</span><span class="p">.</span><span class="n">schemes</span><span class="p">().</span><span class="n">setFluxRequired</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">name</span><span class="p">());</span>

<span class="c1">// autoPtr是一个智能指针，不需要用户考虑内存释放等问题</span>
<span class="n">autoPtr</span><span class="o">&lt;</span><span class="n">viscosityModel</span><span class="o">&gt;</span> <span class="n">viscosity</span><span class="p">(</span><span class="n">viscosityModel</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">mesh</span><span class="p">));</span>    <span class="c1">// 创建一个viscosity指针</span>

<span class="n">autoPtr</span><span class="o">&lt;</span><span class="n">incompressible</span><span class="o">::</span><span class="n">momentumTransportModel</span><span class="o">&gt;</span> <span class="n">turbulence</span>    <span class="c1">// 创建一个turbulence指针</span>
<span class="p">(</span>
    <span class="n">incompressible</span><span class="o">::</span><span class="n">momentumTransportModel</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">viscosity</span><span class="p">)</span>
<span class="p">);</span>

<span class="cp">#include</span> <span class="cpf">&quot;createMRF.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;createFvModels.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;createFvConstraints.H&quot;</span><span class="cp"></span>
</pre></div>
</div>
</div>
<div class="section" id="pisofoam-c">
<h4>pisoFoam.C<a class="headerlink" href="#pisofoam-c" title="永久链接至标题">¶</a></h4>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;fvCFD.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;viscosityModel.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;incompressibleMomentumTransportModels.H&quot;   // 引入湍流模型</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;pisoControl.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;pressureReference.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;fvModels.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;fvConstraints.H&quot;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="cp">#include</span> <span class="cpf">&quot;postProcess.H&quot;</span><span class="cp"></span>

    <span class="cp">#include</span> <span class="cpf">&quot;setRootCaseLists.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createTime.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createMesh.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createControl.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createFields.H&quot;          // 创建场信息与粘度湍流指针</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;initContinuityErrs.H&quot;    //定义标量的连续性误差为0</span><span class="cp"></span>

    <span class="n">turbulence</span><span class="o">-&gt;</span><span class="n">validate</span><span class="p">();</span>

    <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Starting time loop</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">runTime</span><span class="p">.</span><span class="n">loop</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Time = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">runTime</span><span class="p">.</span><span class="n">userTimeName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

        <span class="cp">#include</span> <span class="cpf">&quot;CourantNo.H&quot;</span><span class="cp"></span>

        <span class="c1">// Pressure-velocity PISO corrector</span>
        <span class="p">{</span>
            <span class="n">fvModels</span><span class="p">.</span><span class="n">correct</span><span class="p">();</span>

            <span class="cp">#include</span> <span class="cpf">&quot;UEqn.H&quot;    // 求解速度场</span><span class="cp"></span>

            <span class="c1">// --- PISO loop</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">piso</span><span class="p">.</span><span class="n">correct</span><span class="p">())</span>
            <span class="p">{</span>
                <span class="cp">#include</span> <span class="cpf">&quot;pEqn.H&quot;    // 求解压力场</span><span class="cp"></span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">viscosity</span><span class="o">-&gt;</span><span class="n">correct</span><span class="p">();</span>     <span class="c1">// 更新与粘度有关的量，涉及非牛顿流体系数</span>
        <span class="n">turbulence</span><span class="o">-&gt;</span><span class="n">correct</span><span class="p">();</span>    <span class="c1">// 更新与所选湍流模型有关的量</span>

        <span class="n">runTime</span><span class="p">.</span><span class="n">write</span><span class="p">();</span>    <span class="c1">// 输出时间</span>

        <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;ExecutionTime = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">runTime</span><span class="p">.</span><span class="n">elapsedCpuTime</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; s&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;  ClockTime = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">runTime</span><span class="p">.</span><span class="n">elapsedClockTime</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; s&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">nl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;End</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="pisofoamueqn-h">
<h4>pisoFoam的UEqn.H<a class="headerlink" href="#pisofoamueqn-h" title="永久链接至标题">¶</a></h4>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>MRF.correctBoundaryVelocity(U);

fvVectorMatrix UEqn
(
    fvm::ddt(U) + fvm::div(phi, U)    // 隐式离散时间导数项和隐式离散对流项
  + MRF.DDt(U)                        // MRF方法旋转坐标系的额外项，用于动网格系统，
                                      // 这里表示\mathbf{\Omega } \times \mathbf{U}_{I} 。
  + turbulence-&gt;divDevSigma(U)        // 考虑湍流扩散效应的拉普拉斯项，
                                      // 不仅有基于分子间的粘性mu还有基于湍流的粘性mu_t 。
 ==
    fvModels.source(U)    // 动量方程的源项
);

UEqn.relax();    // 松弛技术，
                 // 对方程进行隐形松弛，用来提高矩阵的对角占优有利解；
                 // 对场进行显性松弛。

fvConstraints.constrain(UEqn);

if (piso.momentumPredictor())
{
    // 求解动量方程
    // p是上一个时间步的压强，求解将会更新U，下面所有的U都将是这一步求解出来的U
    solve(UEqn == -fvc::grad(p));    // 显式离散压强梯度项

    fvConstraints.constrain(U);
}

//到了这里就得到了预测速度
</pre></div>
</div>
</div>
<div class="section" id="pisofoampeqn-h">
<h4>pisoFoam的pEqn.H<a class="headerlink" href="#pisofoampeqn-h" title="永久链接至标题">¶</a></h4>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cm">/* 创建一个定义在体中心的标量场rAU，</span>
<span class="cm">   UEqn.A()进行了A运算，返回的是A_{D}，</span>
<span class="cm">   因此rAU实际上是1/A_{D}。 */</span>
<span class="n">volScalarField</span> <span class="nf">rAU</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">UEqn</span><span class="p">.</span><span class="n">A</span><span class="p">());</span>

<span class="cm">/* 创建一个定义在体中心的向量场HbyA，UEqn.H()进行了H运算返回的是A_{H}，</span>
<span class="cm">   因此HbyA实际上是A_{H}/A_{D}，constrainHbyA函数将U固定值边界条件赋给HbyA。 */</span>
<span class="n">volVectorField</span> <span class="nf">HbyA</span><span class="p">(</span><span class="n">constrainHbyA</span><span class="p">(</span><span class="n">rAU</span><span class="o">*</span><span class="n">UEqn</span><span class="p">.</span><span class="n">H</span><span class="p">(),</span> <span class="n">U</span><span class="p">,</span> <span class="n">p</span><span class="p">));</span>

<span class="n">surfaceScalarField</span> <span class="n">phiHbyA</span>    <span class="c1">// 创建一个定义在面中心的标量场，这是一个中间通量\phi^{*}</span>
<span class="p">(</span>
    <span class="s">&quot;phiHbyA&quot;</span><span class="p">,</span>
    <span class="n">fvc</span><span class="o">::</span><span class="n">flux</span><span class="p">(</span><span class="n">HbyA</span><span class="p">)</span>    <span class="c1">// 将HbyA差分到面上，并点乘面矢量</span>
  <span class="o">+</span> <span class="n">MRF</span><span class="p">.</span><span class="n">zeroFilter</span><span class="p">(</span><span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">rAU</span><span class="p">)</span><span class="o">*</span><span class="n">fvc</span><span class="o">::</span><span class="n">ddtCorr</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">phi</span><span class="p">))</span>
<span class="p">);</span>

<span class="n">MRF</span><span class="p">.</span><span class="n">makeRelative</span><span class="p">(</span><span class="n">phiHbyA</span><span class="p">);</span>

<span class="n">adjustPhi</span><span class="p">(</span><span class="n">phiHbyA</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

<span class="c1">// Update the pressure BCs to ensure flux consistency</span>
<span class="n">constrainPressure</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">phiHbyA</span><span class="p">,</span> <span class="n">rAU</span><span class="p">,</span> <span class="n">MRF</span><span class="p">);</span>    <span class="c1">// 用于修正fixedFluxPressure类压力边界条件</span>

<span class="c1">// Non-orthogonal pressure corrector loop</span>
<span class="k">while</span> <span class="p">(</span><span class="n">piso</span><span class="p">.</span><span class="n">correctNonOrthogonal</span><span class="p">())</span>    <span class="c1">// 默认非正交修正为0</span>
<span class="p">{</span>
    <span class="c1">// Pressure corrector</span>

    <span class="n">fvScalarMatrix</span> <span class="n">pEqn</span>
    <span class="p">(</span>
        <span class="c1">// 方程等号左边使用隐式离散，方程等号右边使用显式离散</span>
        <span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">rAU</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phiHbyA</span><span class="p">)</span>
    <span class="p">);</span>

    <span class="n">pEqn</span><span class="p">.</span><span class="n">setReference</span>    <span class="c1">// 设置压力参考值</span>
    <span class="p">(</span>
        <span class="n">pressureReference</span><span class="p">.</span><span class="n">refCell</span><span class="p">(),</span>
        <span class="n">pressureReference</span><span class="p">.</span><span class="n">refValue</span><span class="p">()</span>
    <span class="p">);</span>

    <span class="n">pEqn</span><span class="p">.</span><span class="n">solve</span><span class="p">();</span>     <span class="c1">// 求解上述p方程，可以得到p的值</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">piso</span><span class="p">.</span><span class="n">finalNonOrthogonalIter</span><span class="p">())</span>    <span class="c1">// 非正交修正的总迭代残差</span>
    <span class="p">{</span>
        <span class="cm">/* 即 \phi = \phi^{*} - \phi^{**}，其中pEqn.flux()返回的\phi^{**}</span>
<span class="cm">           最终得到统一的、能够满足连续性方程的通量 */</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">phiHbyA</span> <span class="o">-</span> <span class="n">pEqn</span><span class="p">.</span><span class="n">flux</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#include</span> <span class="cpf">&quot;continuityErrs.H&quot;</span><span class="cp"></span>

<span class="cm">/* 使用修正后的压力场求解出正确的速度场，即</span>
<span class="cm">   \mathbf{U} = \frac{A_{H}}{A_{D}} - \frac{\nabla p}{A_{D}}</span>
<span class="cm">*/</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">HbyA</span> <span class="o">-</span> <span class="n">rAU</span><span class="o">*</span><span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="n">U</span><span class="p">.</span><span class="n">correctBoundaryConditions</span><span class="p">();</span>
<span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">U</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="rhopimplefoam">
<h3>rhoPimpleFoam求解器<a class="headerlink" href="#rhopimplefoam" title="永久链接至标题">¶</a></h3>
<div class="section" id="rhopimplefoamcreatefields-h">
<h4>rhoPimpleFoam的createFields.H<a class="headerlink" href="#rhopimplefoamcreatefields-h" title="永久链接至标题">¶</a></h4>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;createRDeltaT.H&quot;</span><span class="cp"></span>
<span class="cm">/* 位于src/finiteVolume/cfdTools/general/include文件夹中，与local Euler格式相关，执行内容为</span>
<span class="cm">    bool LTS = fv::localEulerDdt::enabled(mesh);</span>

<span class="cm">    tmp&lt;volScalarField&gt; trDeltaT;</span>

<span class="cm">    if (LTS)</span>
<span class="cm">    {</span>
<span class="cm">        Info&lt;&lt; &quot;Using LTS&quot; &lt;&lt; endl;</span>

<span class="cm">        trDeltaT = tmp&lt;volScalarField&gt;</span>
<span class="cm">        (</span>
<span class="cm">            new volScalarField</span>
<span class="cm">            (</span>
<span class="cm">                IOobject</span>
<span class="cm">                (</span>
<span class="cm">                    fv::localEulerDdt::rDeltaTName,</span>
<span class="cm">                    runTime.timeName(),</span>
<span class="cm">                    mesh,</span>
<span class="cm">                    IOobject::READ_IF_PRESENT,</span>
<span class="cm">                    IOobject::AUTO_WRITE</span>
<span class="cm">                ),</span>
<span class="cm">                mesh,</span>
<span class="cm">                dimensionedScalar(dimless/dimTime, 1),</span>
<span class="cm">                extrapolatedCalculatedFvPatchScalarField::typeName</span>
<span class="cm">            )</span>
<span class="cm">        );</span>
<span class="cm">    }</span>
<span class="cm">*/</span>

<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Reading thermophysical properties</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

<span class="n">autoPtr</span><span class="o">&lt;</span><span class="n">fluidThermo</span><span class="o">&gt;</span> <span class="n">pThermo</span>
<span class="p">(</span>
    <span class="n">fluidThermo</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="p">);</span>
<span class="n">fluidThermo</span><span class="o">&amp;</span> <span class="n">thermo</span> <span class="o">=</span> <span class="n">pThermo</span><span class="p">();</span>
<span class="n">thermo</span><span class="p">.</span><span class="n">validate</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">executable</span><span class="p">(),</span> <span class="s">&quot;h&quot;</span><span class="p">,</span> <span class="s">&quot;e&quot;</span><span class="p">);</span>

<span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">thermo</span><span class="p">.</span><span class="n">p</span><span class="p">();</span>    <span class="c1">// 创建压力场</span>

<span class="n">volScalarField</span> <span class="n">rho</span>    <span class="c1">// 创建密度场</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;rho&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">READ_IF_PRESENT</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">AUTO_WRITE</span>
    <span class="p">),</span>
    <span class="n">thermo</span><span class="p">.</span><span class="n">rho</span><span class="p">()</span>
<span class="p">);</span>

<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Reading field U</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">volVectorField</span> <span class="n">U</span>    <span class="c1">// 创建速度场</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;U&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">MUST_READ</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">AUTO_WRITE</span>
    <span class="p">),</span>
    <span class="n">mesh</span>
<span class="p">);</span>

<span class="cp">#include</span> <span class="cpf">&quot;compressibleCreatePhi.H&quot;</span><span class="cp"></span>
<span class="cm">/* 位于src/fininteVolume/cfdTools/compressible文件夹，所执行代码如下</span>
<span class="cm">    Info&lt;&lt; &quot;Reading/calculating face flux field phi\n&quot; &lt;&lt; endl;</span>

<span class="cm">    surfaceScalarField phi    // 创建质量通量场phi</span>
<span class="cm">    (</span>
<span class="cm">        IOobject</span>
<span class="cm">        (</span>
<span class="cm">            &quot;phi&quot;,</span>
<span class="cm">            runTime.timeName(),</span>
<span class="cm">            mesh,</span>
<span class="cm">            IOobject::READ_IF_PRESENT,</span>
<span class="cm">            IOobject::AUTO_WRITE</span>
<span class="cm">        ),</span>
<span class="cm">        linearInterpolate(rho*U) &amp; mesh.Sf()</span>
<span class="cm">    );</span>
<span class="cm">*/</span>

<span class="n">pressureReference</span> <span class="n">pressureReference</span>    <span class="c1">// PIMPLE算法程序结构要求pref，但是由于是可压缩流，实际会返回false而不执行任何内容</span>
<span class="p">(</span>
    <span class="n">p</span><span class="p">,</span>
    <span class="n">pimple</span><span class="p">.</span><span class="n">dict</span><span class="p">(),</span>
    <span class="n">thermo</span><span class="p">.</span><span class="n">incompressible</span><span class="p">()</span>    <span class="c1">// 可压缩流返回false</span>
<span class="p">);</span>

<span class="n">mesh</span><span class="p">.</span><span class="n">schemes</span><span class="p">().</span><span class="n">setFluxRequired</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">name</span><span class="p">());</span>    <span class="c1">// 将压力场设置为需要计算通量</span>

<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Creating turbulence model</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">autoPtr</span><span class="o">&lt;</span><span class="n">compressible</span><span class="o">::</span><span class="n">momentumTransportModel</span><span class="o">&gt;</span> <span class="n">turbulence</span>    <span class="c1">// 创建湍流指针</span>
<span class="p">(</span>
    <span class="n">compressible</span><span class="o">::</span><span class="n">momentumTransportModel</span><span class="o">::</span><span class="n">New</span>
    <span class="p">(</span>
        <span class="n">rho</span><span class="p">,</span>
        <span class="n">U</span><span class="p">,</span>
        <span class="n">phi</span><span class="p">,</span>
        <span class="n">thermo</span>
    <span class="p">)</span>
<span class="p">);</span>

<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Creating thermophysical transport model</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">autoPtr</span><span class="o">&lt;</span><span class="n">fluidThermophysicalTransportModel</span><span class="o">&gt;</span> <span class="n">thermophysicalTransport</span>
<span class="p">(</span>
    <span class="n">fluidThermophysicalTransportModel</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">turbulence</span><span class="p">(),</span> <span class="n">thermo</span><span class="p">)</span>
<span class="p">);</span>

<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Creating field dpdt</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">volScalarField</span> <span class="n">dpdt</span>    <span class="c1">// 创建dpdt场</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;dpdt&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>
        <span class="n">mesh</span>
    <span class="p">),</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">dimensionedScalar</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">dimensions</span><span class="p">()</span><span class="o">/</span><span class="n">dimTime</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">);</span>

<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Creating field kinetic energy K</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">volScalarField</span> <span class="nf">K</span><span class="p">(</span><span class="s">&quot;K&quot;</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">U</span><span class="p">));</span>    <span class="c1">// 创建动能场</span>

<span class="n">dimensionedScalar</span> <span class="n">initialMass</span> <span class="o">=</span> <span class="n">fvc</span><span class="o">::</span><span class="n">domainIntegrate</span><span class="p">(</span><span class="n">rho</span><span class="p">);</span>    <span class="c1">// 通过密度计算算域内总质量</span>

<span class="cp">#include</span> <span class="cpf">&quot;createMRF.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;createFvModels.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;createFvConstraints.H&quot;</span><span class="cp"></span>
</pre></div>
</div>
</div>
<div class="section" id="rhopimplefoam-c">
<h4>rhoPimpleFoam.C<a class="headerlink" href="#rhopimplefoam-c" title="永久链接至标题">¶</a></h4>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;fvCFD.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;fluidThermo.H&quot;                            // 引入热物理物料模型</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;compressibleMomentumTransportModels.H&quot;    // 引入可压缩流体湍流模型</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;fluidThermophysicalTransportModel.H&quot;      // 引入热物理能量模型</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;pimpleControl.H&quot;                          // PIMPLE算法必要头文件</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;pressureReference.H&quot;                      // 为封闭体积模拟中的压力参考提供控制，可压缩流情况实际不起作用，这里是由于程序结构缘故引用</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;CorrectPhi.H&quot;</span><span class="cp"></span>
<span class="cm">/* 执行内容如下</span>
<span class="cm">    // Calculate absolute flux from the mapped surface velocity</span>
<span class="cm">    phi = mesh.Sf() &amp; rhoUf();</span>

<span class="cm">    correctUphiBCs(rho, U, phi, true);</span>

<span class="cm">    CorrectPhi</span>
<span class="cm">    (</span>
<span class="cm">        phi,</span>
<span class="cm">        p,</span>
<span class="cm">        rho,</span>
<span class="cm">        psi,</span>
<span class="cm">        dimensionedScalar(&quot;rAUf&quot;, dimTime, 1),</span>
<span class="cm">        divrhoU(),</span>
<span class="cm">        pimple</span>
<span class="cm">    );</span>

<span class="cm">    // Make the fluxes relative to the mesh-motion</span>
<span class="cm">    fvc::makeRelative(phi, rho, U);</span>
<span class="cm">*/</span>
<span class="cp">#include</span> <span class="cpf">&quot;fvModels.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;fvConstraints.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;localEulerDdtScheme.H&quot;    // local Euler格式必备头文件</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;fvcSmooth.H&quot;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="cp">#include</span> <span class="cpf">&quot;postProcess.H&quot;</span><span class="cp"></span>

    <span class="cp">#include</span> <span class="cpf">&quot;setRootCaseLists.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createTime.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createMesh.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createDyMControls.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;initContinuityErrs.H&quot;   // 声明并初始化累积连续性错误，执行语句为 scalar cumulativeContErr = 0;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createFields.H&quot;         // 创建场信息与热物理模型</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createFieldRefs.H&quot;      // 创建可压缩性场psi，执行语句为 const volScalarField&amp; psi = thermo.psi();</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createRhoUfIfPresent.H&quot;</span><span class="cp"></span>

    <span class="n">turbulence</span><span class="o">-&gt;</span><span class="n">validate</span><span class="p">();</span>    <span class="c1">// 初始化湍流场，主要是计算nut</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LTS</span><span class="p">)</span>    <span class="c1">// 如果没有使用local Euler格式</span>
    <span class="p">{</span>
        <span class="cp">#include</span> <span class="cpf">&quot;compressibleCourantNo.H&quot;</span><span class="cp"></span>
        <span class="cp">#include</span> <span class="cpf">&quot;setInitialDeltaT.H&quot;</span><span class="cp"></span>
    <span class="p">}</span>

    <span class="c1">// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //</span>

    <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Starting time loop</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">pimple</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">runTime</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="cp">#include</span> <span class="cpf">&quot;readDyMControls.H&quot;</span><span class="cp"></span>

        <span class="c1">// Store divrhoU from the previous mesh so that it can be mapped and used in correctPhi to ensure the corrected phi has the same divergence</span>
        <span class="n">autoPtr</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">divrhoU</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">correctPhi</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">divrhoU</span> <span class="o">=</span> <span class="n">new</span> <span class="n">volScalarField</span>
            <span class="p">(</span>
                <span class="s">&quot;divrhoU&quot;</span><span class="p">,</span>
                <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">fvc</span><span class="o">::</span><span class="n">absolute</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">U</span><span class="p">))</span>
            <span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">LTS</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="cp">#include</span> <span class="cpf">&quot;setRDeltaT.H&quot;</span><span class="cp"></span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="cp">#include</span> <span class="cpf">&quot;compressibleCourantNo.H&quot;</span><span class="cp"></span>
            <span class="cp">#include</span> <span class="cpf">&quot;setDeltaT.H&quot;</span><span class="cp"></span>
        <span class="p">}</span>

        <span class="n">fvModels</span><span class="p">.</span><span class="n">preUpdateMesh</span><span class="p">();</span>

        <span class="c1">// Store momentum to set rhoUf for introduced faces.</span>
        <span class="n">autoPtr</span><span class="o">&lt;</span><span class="n">volVectorField</span><span class="o">&gt;</span> <span class="n">rhoU</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rhoUf</span><span class="p">.</span><span class="n">valid</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="n">rhoU</span> <span class="o">=</span> <span class="n">new</span> <span class="n">volVectorField</span><span class="p">(</span><span class="s">&quot;rhoU&quot;</span><span class="p">,</span> <span class="n">rho</span><span class="o">*</span><span class="n">U</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Update the mesh for topology change, mesh to mesh mapping</span>
        <span class="n">mesh</span><span class="p">.</span><span class="n">update</span><span class="p">();</span>

        <span class="n">runTime</span><span class="o">++</span><span class="p">;</span>

        <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Time = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">runTime</span><span class="p">.</span><span class="n">userTimeName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

        <span class="c1">// --- Pressure-velocity PIMPLE corrector loop</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">pimple</span><span class="p">.</span><span class="n">loop</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pimple</span><span class="p">.</span><span class="n">firstPimpleIter</span><span class="p">()</span> <span class="o">||</span> <span class="n">moveMeshOuterCorrectors</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">// Move the mesh</span>
                <span class="n">mesh</span><span class="p">.</span><span class="n">move</span><span class="p">();</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">changing</span><span class="p">())</span>    <span class="c1">// 动网格的情况</span>
                <span class="p">{</span>
                    <span class="n">MRF</span><span class="p">.</span><span class="n">update</span><span class="p">();</span>

                    <span class="k">if</span> <span class="p">(</span><span class="n">correctPhi</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="cp">#include</span> <span class="cpf">&quot;correctPhi.H&quot;</span><span class="cp"></span>
                        <span class="cm">/* 执行内容如下</span>
<span class="cm">                            // Calculate absolute flux from the mapped surface velocity</span>
<span class="cm">                            phi = mesh.Sf() &amp; rhoUf();</span>
<span class="cm">                            correctUphiBCs(rho, U, phi, true);</span>

<span class="cm">                            CorrectPhi</span>
<span class="cm">                            (</span>
<span class="cm">                                phi,</span>
<span class="cm">                                p,</span>
<span class="cm">                                rho,</span>
<span class="cm">                                psi,</span>
<span class="cm">                                dimensionedScalar(&quot;rAUf&quot;, dimTime, 1),</span>
<span class="cm">                                divrhoU(),</span>
<span class="cm">                                pimple</span>
<span class="cm">                            );</span>

<span class="cm">                            // Make the fluxes relative to the mesh-motion</span>
<span class="cm">                            fvc::makeRelative(phi, rho, U);</span>
<span class="cm">                        */</span>

                    <span class="p">}</span>

                    <span class="k">if</span> <span class="p">(</span><span class="n">checkMeshCourantNo</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="cp">#include</span> <span class="cpf">&quot;meshCourantNo.H&quot;</span><span class="cp"></span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mesh</span><span class="p">.</span><span class="n">schemes</span><span class="p">().</span><span class="n">steady</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pimple</span><span class="p">.</span><span class="n">simpleRho</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">pimple</span><span class="p">.</span><span class="n">firstPimpleIter</span><span class="p">())</span>
            <span class="p">{</span>
                <span class="cp">#include</span> <span class="cpf">&quot;rhoEqn.H&quot;</span><span class="cp"></span>
                <span class="cm">/* 位于src/finiteVolume/cfdTools/compressible文件夹，执行内容为</span>
<span class="cm">                    fvScalarMatrix rhoEqn</span>
<span class="cm">                    (</span>
<span class="cm">                        fvm::ddt(rho)</span>
<span class="cm">                      + fvc::div(phi)</span>
<span class="cm">                      ==</span>
<span class="cm">                        fvModels.source(rho)</span>
<span class="cm">                    );</span>

<span class="cm">                    fvConstraints.constrain(rhoEqn);</span>
<span class="cm">                    rhoEqn.solve();</span>
<span class="cm">                    fvConstraints.constrain(rho);</span>
<span class="cm">                */</span>
            <span class="p">}</span>

            <span class="n">fvModels</span><span class="p">.</span><span class="n">correct</span><span class="p">();</span>

            <span class="cp">#include</span> <span class="cpf">&quot;UEqn.H&quot;    // 求解动量方程</span><span class="cp"></span>
            <span class="cp">#include</span> <span class="cpf">&quot;EEqn.H&quot;    // 求解能量方程</span><span class="cp"></span>

            <span class="c1">// --- Pressure corrector loop</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">pimple</span><span class="p">.</span><span class="n">correct</span><span class="p">())</span>
            <span class="p">{</span>
                <span class="cp">#include</span> <span class="cpf">&quot;pEqn.H&quot;    // 求解压力方程</span><span class="cp"></span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">pimple</span><span class="p">.</span><span class="n">turbCorr</span><span class="p">())</span>
            <span class="p">{</span>
                <span class="n">turbulence</span><span class="o">-&gt;</span><span class="n">correct</span><span class="p">();</span>                 <span class="c1">// 更新湍流模型相关参数</span>
                <span class="n">thermophysicalTransport</span><span class="o">-&gt;</span><span class="n">correct</span><span class="p">();</span>    <span class="c1">// 更新热物理模型相关参数</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mesh</span><span class="p">.</span><span class="n">schemes</span><span class="p">().</span><span class="n">steady</span><span class="p">())</span>    <span class="c1">// 如果不是稳态问题</span>
        <span class="p">{</span>
            <span class="n">rho</span> <span class="o">=</span> <span class="n">thermo</span><span class="p">.</span><span class="n">rho</span><span class="p">();</span>    <span class="c1">// 更新密度场</span>
        <span class="p">}</span>

        <span class="n">runTime</span><span class="p">.</span><span class="n">write</span><span class="p">();</span>

        <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;ExecutionTime = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">runTime</span><span class="p">.</span><span class="n">elapsedCpuTime</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; s&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;  ClockTime = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">runTime</span><span class="p">.</span><span class="n">elapsedClockTime</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; s&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">nl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;End</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="rhopimplefoamueqn-h">
<h4>rhoPimpleFoam的UEqn.H<a class="headerlink" href="#rhopimplefoamueqn-h" title="永久链接至标题">¶</a></h4>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// Solve the Momentum equation</span>

<span class="n">MRF</span><span class="p">.</span><span class="n">correctBoundaryVelocity</span><span class="p">(</span><span class="n">U</span><span class="p">);</span>

<span class="n">tmp</span><span class="o">&lt;</span><span class="n">fvVectorMatrix</span><span class="o">&gt;</span> <span class="n">tUEqn</span>
<span class="p">(</span>
    <span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span> <span class="o">+</span> <span class="n">fvm</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>
  <span class="o">+</span> <span class="n">MRF</span><span class="p">.</span><span class="n">DDt</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>
  <span class="o">+</span> <span class="n">turbulence</span><span class="o">-&gt;</span><span class="n">divDevTau</span><span class="p">(</span><span class="n">U</span><span class="p">)</span>
 <span class="o">==</span>
    <span class="n">fvModels</span><span class="p">.</span><span class="n">source</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>
<span class="p">);</span>
<span class="n">fvVectorMatrix</span><span class="o">&amp;</span> <span class="n">UEqn</span> <span class="o">=</span> <span class="n">tUEqn</span><span class="p">.</span><span class="n">ref</span><span class="p">();</span>
<span class="n">UEqn</span><span class="p">.</span><span class="n">relax</span><span class="p">();</span>
<span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">UEqn</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">pimple</span><span class="p">.</span><span class="n">momentumPredictor</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">UEqn</span> <span class="o">==</span> <span class="o">-</span><span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>

    <span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">U</span><span class="p">);</span>
    <span class="n">K</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">U</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="rhopimplefoameeqn-h">
<h4>rhoPimpleFoam的EEqn.H<a class="headerlink" href="#rhopimplefoameeqn-h" title="永久链接至标题">¶</a></h4>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">he</span> <span class="o">=</span> <span class="n">thermo</span><span class="p">.</span><span class="n">he</span><span class="p">();</span>

<span class="n">fvScalarMatrix</span> <span class="nf">EEqn</span>
<span class="p">(</span>
    <span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">he</span><span class="p">)</span> <span class="o">+</span> <span class="n">fvm</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">he</span><span class="p">)</span>
  <span class="o">+</span> <span class="n">fvc</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span> <span class="o">+</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span>
  <span class="o">+</span> <span class="p">(</span>
        <span class="n">he</span><span class="p">.</span><span class="n">name</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;e&quot;</span>
      <span class="o">?</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">fvc</span><span class="o">::</span><span class="n">absolute</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">U</span><span class="p">),</span> <span class="n">p</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span>
      <span class="o">:</span> <span class="o">-</span><span class="n">dpdt</span>
    <span class="p">)</span>
  <span class="o">+</span> <span class="n">thermophysicalTransport</span><span class="o">-&gt;</span><span class="n">divq</span><span class="p">(</span><span class="n">he</span><span class="p">)</span>
 <span class="o">==</span>
    <span class="n">fvModels</span><span class="p">.</span><span class="n">source</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">he</span><span class="p">)</span>
<span class="p">);</span>

<span class="n">EEqn</span><span class="p">.</span><span class="n">relax</span><span class="p">();</span>
<span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">EEqn</span><span class="p">);</span>
<span class="n">EEqn</span><span class="p">.</span><span class="n">solve</span><span class="p">();</span>
<span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">he</span><span class="p">);</span>
<span class="n">thermo</span><span class="p">.</span><span class="n">correct</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="rhopimplefoampeqn-h">
<h4>rhoPimpleFoam的pEqn.H<a class="headerlink" href="#rhopimplefoampeqn-h" title="永久链接至标题">¶</a></h4>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">rho</span> <span class="o">=</span> <span class="n">thermo</span><span class="p">.</span><span class="n">rho</span><span class="p">();</span>
<span class="n">rho</span><span class="p">.</span><span class="n">relax</span><span class="p">();</span>

<span class="c1">// Thermodynamic density needs to be updated by psi*d(p) after the pressure solution</span>
<span class="k">const</span> <span class="n">volScalarField</span> <span class="nf">psip0</span><span class="p">(</span><span class="n">psi</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>

<span class="k">const</span> <span class="n">volScalarField</span> <span class="nf">rAU</span><span class="p">(</span><span class="s">&quot;rAU&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">UEqn</span><span class="p">.</span><span class="n">A</span><span class="p">());</span>
<span class="k">const</span> <span class="n">surfaceScalarField</span> <span class="nf">rhorAUf</span><span class="p">(</span><span class="s">&quot;rhorAUf&quot;</span><span class="p">,</span> <span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">rho</span><span class="o">*</span><span class="n">rAU</span><span class="p">));</span>

<span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">rAtU</span>
<span class="p">(</span>
    <span class="n">pimple</span><span class="p">.</span><span class="n">consistent</span><span class="p">()</span>
  <span class="o">?</span> <span class="n">volScalarField</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="s">&quot;rAtU&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">rAU</span> <span class="o">-</span> <span class="n">UEqn</span><span class="p">.</span><span class="n">H1</span><span class="p">()))</span>
  <span class="o">:</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span><span class="p">(</span><span class="n">nullptr</span><span class="p">)</span>
<span class="p">);</span>
<span class="n">tmp</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="o">&gt;</span> <span class="n">rhorAtUf</span>
<span class="p">(</span>
    <span class="n">pimple</span><span class="p">.</span><span class="n">consistent</span><span class="p">()</span>
  <span class="o">?</span> <span class="n">surfaceScalarField</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="s">&quot;rhoRAtUf&quot;</span><span class="p">,</span> <span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">rho</span><span class="o">*</span><span class="n">rAtU</span><span class="p">()))</span>
  <span class="o">:</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="o">&gt;</span><span class="p">(</span><span class="n">nullptr</span><span class="p">)</span>
<span class="p">);</span>

<span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">rAAtU</span> <span class="o">=</span> <span class="n">pimple</span><span class="p">.</span><span class="n">consistent</span><span class="p">()</span> <span class="o">?</span> <span class="n">rAtU</span><span class="p">()</span> <span class="o">:</span> <span class="n">rAU</span><span class="p">;</span>
<span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">rhorAAtUf</span> <span class="o">=</span> <span class="n">pimple</span><span class="p">.</span><span class="n">consistent</span><span class="p">()</span> <span class="o">?</span> <span class="n">rhorAtUf</span><span class="p">()</span> <span class="o">:</span> <span class="n">rhorAUf</span><span class="p">;</span>

<span class="n">volVectorField</span> <span class="nf">HbyA</span><span class="p">(</span><span class="n">constrainHbyA</span><span class="p">(</span><span class="n">rAU</span><span class="o">*</span><span class="n">UEqn</span><span class="p">.</span><span class="n">H</span><span class="p">(),</span> <span class="n">U</span><span class="p">,</span> <span class="n">p</span><span class="p">));</span>

<span class="k">if</span> <span class="p">(</span><span class="n">pimple</span><span class="p">.</span><span class="n">nCorrPiso</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">tUEqn</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">surfaceScalarField</span> <span class="n">phiHbyA</span>
<span class="p">(</span>
    <span class="s">&quot;phiHbyA&quot;</span><span class="p">,</span>
    <span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">fvc</span><span class="o">::</span><span class="n">flux</span><span class="p">(</span><span class="n">HbyA</span><span class="p">)</span>
  <span class="o">+</span> <span class="n">MRF</span><span class="p">.</span><span class="n">zeroFilter</span><span class="p">(</span><span class="n">rhorAUf</span><span class="o">*</span><span class="n">fvc</span><span class="o">::</span><span class="n">ddtCorr</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">rhoUf</span><span class="p">))</span>
<span class="p">);</span>

<span class="n">MRF</span><span class="p">.</span><span class="n">makeRelative</span><span class="p">(</span><span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">rho</span><span class="p">),</span> <span class="n">phiHbyA</span><span class="p">);</span>

<span class="c1">// Update the pressure BCs to ensure flux consistency</span>
<span class="n">constrainPressure</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">phiHbyA</span><span class="p">,</span> <span class="n">rhorAAtUf</span><span class="p">,</span> <span class="n">MRF</span><span class="p">);</span>

<span class="n">fvc</span><span class="o">::</span><span class="n">makeRelative</span><span class="p">(</span><span class="n">phiHbyA</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">U</span><span class="p">);</span>

<span class="kt">bool</span> <span class="n">adjustMass</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">pimple</span><span class="p">.</span><span class="n">transonic</span><span class="p">())</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">surfaceScalarField</span> <span class="n">phid</span>
    <span class="p">(</span>
        <span class="s">&quot;phid&quot;</span><span class="p">,</span>
        <span class="p">(</span><span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span><span class="o">/</span><span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">rho</span><span class="p">))</span><span class="o">*</span><span class="n">phiHbyA</span>
    <span class="p">);</span>

    <span class="k">const</span> <span class="n">fvScalarMatrix</span> <span class="nf">divPhidp</span><span class="p">(</span><span class="n">fvm</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phid</span><span class="p">,</span> <span class="n">p</span><span class="p">));</span>
    <span class="n">phiHbyA</span> <span class="o">-=</span> <span class="n">divPhidp</span><span class="p">.</span><span class="n">flux</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">pimple</span><span class="p">.</span><span class="n">consistent</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">phiHbyA</span> <span class="o">+=</span> <span class="p">(</span><span class="n">rhorAAtUf</span> <span class="o">-</span> <span class="n">rhorAUf</span><span class="p">)</span><span class="o">*</span><span class="n">fvc</span><span class="o">::</span><span class="n">snGrad</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">*</span><span class="n">mesh</span><span class="p">.</span><span class="n">magSf</span><span class="p">();</span>
        <span class="n">HbyA</span> <span class="o">+=</span> <span class="p">(</span><span class="n">rAAtU</span> <span class="o">-</span> <span class="n">rAU</span><span class="p">)</span><span class="o">*</span><span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">fvScalarMatrix</span> <span class="n">pDDtEqn</span>
    <span class="p">(</span>
        <span class="n">fvc</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span> <span class="o">+</span> <span class="n">psi</span><span class="o">*</span><span class="n">correction</span><span class="p">(</span><span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
      <span class="o">+</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phiHbyA</span><span class="p">)</span> <span class="o">+</span> <span class="n">divPhidp</span>
     <span class="o">==</span>
        <span class="n">fvModels</span><span class="p">.</span><span class="n">source</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rho</span><span class="p">.</span><span class="n">name</span><span class="p">())</span>
    <span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">pimple</span><span class="p">.</span><span class="n">correctNonOrthogonal</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">fvScalarMatrix</span> <span class="n">pEqn</span><span class="p">(</span><span class="n">pDDtEqn</span> <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">rhorAAtUf</span><span class="p">,</span> <span class="n">p</span><span class="p">));</span>

        <span class="c1">// Relax the pressure equation to ensure diagonal-dominance</span>
        <span class="n">pEqn</span><span class="p">.</span><span class="n">relax</span><span class="p">();</span>

        <span class="n">pEqn</span><span class="p">.</span><span class="n">setReference</span>
        <span class="p">(</span>
            <span class="n">pressureReference</span><span class="p">.</span><span class="n">refCell</span><span class="p">(),</span>
            <span class="n">pressureReference</span><span class="p">.</span><span class="n">refValue</span><span class="p">()</span>
        <span class="p">);</span>

        <span class="n">pEqn</span><span class="p">.</span><span class="n">solve</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">pimple</span><span class="p">.</span><span class="n">finalNonOrthogonalIter</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="n">phiHbyA</span> <span class="o">+</span> <span class="n">pEqn</span><span class="p">.</span><span class="n">flux</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">schemes</span><span class="p">().</span><span class="n">steady</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">adjustMass</span> <span class="o">=</span> <span class="n">adjustPhi</span><span class="p">(</span><span class="n">phiHbyA</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">pimple</span><span class="p">.</span><span class="n">consistent</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">phiHbyA</span> <span class="o">+=</span> <span class="p">(</span><span class="n">rhorAAtUf</span> <span class="o">-</span> <span class="n">rhorAUf</span><span class="p">)</span><span class="o">*</span><span class="n">fvc</span><span class="o">::</span><span class="n">snGrad</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">*</span><span class="n">mesh</span><span class="p">.</span><span class="n">magSf</span><span class="p">();</span>
        <span class="n">HbyA</span> <span class="o">+=</span> <span class="p">(</span><span class="n">rAAtU</span> <span class="o">-</span> <span class="n">rAU</span><span class="p">)</span><span class="o">*</span><span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">fvScalarMatrix</span> <span class="n">pDDtEqn</span>
    <span class="p">(</span>
        <span class="n">fvc</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span> <span class="o">+</span> <span class="n">psi</span><span class="o">*</span><span class="n">correction</span><span class="p">(</span><span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
      <span class="o">+</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phiHbyA</span><span class="p">)</span>
     <span class="o">==</span>
        <span class="n">fvModels</span><span class="p">.</span><span class="n">source</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rho</span><span class="p">.</span><span class="n">name</span><span class="p">())</span>
    <span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">pimple</span><span class="p">.</span><span class="n">correctNonOrthogonal</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">fvScalarMatrix</span> <span class="n">pEqn</span><span class="p">(</span><span class="n">pDDtEqn</span> <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">rhorAAtUf</span><span class="p">,</span> <span class="n">p</span><span class="p">));</span>

        <span class="n">pEqn</span><span class="p">.</span><span class="n">setReference</span>
        <span class="p">(</span>
            <span class="n">pressureReference</span><span class="p">.</span><span class="n">refCell</span><span class="p">(),</span>
            <span class="n">pressureReference</span><span class="p">.</span><span class="n">refValue</span><span class="p">()</span>
        <span class="p">);</span>

        <span class="n">pEqn</span><span class="p">.</span><span class="n">solve</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">pimple</span><span class="p">.</span><span class="n">finalNonOrthogonalIter</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="n">phiHbyA</span> <span class="o">+</span> <span class="n">pEqn</span><span class="p">.</span><span class="n">flux</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">schemes</span><span class="p">().</span><span class="n">steady</span><span class="p">())</span>
<span class="p">{</span>
    <span class="cp">#include</span> <span class="cpf">&quot;incompressible/continuityErrs.H&quot;</span><span class="cp"></span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">bool</span> <span class="n">constrained</span> <span class="o">=</span> <span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

    <span class="c1">// Thermodynamic density update</span>
    <span class="n">thermo</span><span class="p">.</span><span class="n">correctRho</span><span class="p">(</span><span class="n">psi</span><span class="o">*</span><span class="n">p</span> <span class="o">-</span> <span class="n">psip0</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">constrained</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">thermo</span><span class="p">.</span><span class="n">rho</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="cp">#include</span> <span class="cpf">&quot;rhoEqn.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;compressibleContinuityErrs.H&quot;</span><span class="cp"></span>
<span class="p">}</span>

<span class="c1">// Explicitly relax pressure for momentum corrector</span>
<span class="n">p</span><span class="p">.</span><span class="n">relax</span><span class="p">();</span>

<span class="n">U</span> <span class="o">=</span> <span class="n">HbyA</span> <span class="o">-</span> <span class="n">rAAtU</span><span class="o">*</span><span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="n">U</span><span class="p">.</span><span class="n">correctBoundaryConditions</span><span class="p">();</span>
<span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">U</span><span class="p">);</span>
<span class="n">K</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">U</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">schemes</span><span class="p">().</span><span class="n">steady</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// For steady compressible closed-volume cases adjust the pressure level to obey overall mass continuity</span>
<span class="k">if</span> <span class="p">(</span><span class="n">adjustMass</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">thermo</span><span class="p">.</span><span class="n">incompressible</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">p</span> <span class="o">+=</span> <span class="p">(</span><span class="n">initialMass</span> <span class="o">-</span> <span class="n">fvc</span><span class="o">::</span><span class="n">domainIntegrate</span><span class="p">(</span><span class="n">thermo</span><span class="p">.</span><span class="n">rho</span><span class="p">()))</span> <span class="o">/</span> <span class="n">fvc</span><span class="o">::</span><span class="n">domainIntegrate</span><span class="p">(</span><span class="n">psi</span><span class="p">);</span>
    <span class="n">p</span><span class="p">.</span><span class="n">correctBoundaryConditions</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">schemes</span><span class="p">().</span><span class="n">steady</span><span class="p">()</span> <span class="o">||</span> <span class="n">pimple</span><span class="p">.</span><span class="n">simpleRho</span><span class="p">()</span> <span class="o">||</span> <span class="n">adjustMass</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="n">thermo</span><span class="p">.</span><span class="n">rho</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Correct rhoUf if the mesh is moving</span>
<span class="n">fvc</span><span class="o">::</span><span class="n">correctRhoUf</span><span class="p">(</span><span class="n">rhoUf</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">MRF</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">schemes</span><span class="p">().</span><span class="n">steady</span><span class="p">()</span> <span class="o">||</span> <span class="n">pimple</span><span class="p">.</span><span class="n">simpleRho</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">rho</span><span class="p">.</span><span class="n">relax</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">thermo</span><span class="p">.</span><span class="n">dpdt</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">dpdt</span> <span class="o">=</span> <span class="n">fvc</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">moving</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">dpdt</span> <span class="o">-=</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">fvc</span><span class="o">::</span><span class="n">meshPhi</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">U</span><span class="p">),</span> <span class="n">p</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="rhosimplefoam">
<h3>rhoSimpleFoam求解器<a class="headerlink" href="#rhosimplefoam" title="永久链接至标题">¶</a></h3>
<div class="section" id="rhosimplefoamcreatefields-h">
<h4>rhoSimpleFoam的createFields.H<a class="headerlink" href="#rhosimplefoamcreatefields-h" title="永久链接至标题">¶</a></h4>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Reading thermophysical properties</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

<span class="n">autoPtr</span><span class="o">&lt;</span><span class="n">fluidThermo</span><span class="o">&gt;</span> <span class="n">pThermo</span>
<span class="p">(</span>
    <span class="n">fluidThermo</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="p">);</span>
<span class="n">fluidThermo</span><span class="o">&amp;</span> <span class="n">thermo</span> <span class="o">=</span> <span class="n">pThermo</span><span class="p">();</span>
<span class="n">thermo</span><span class="p">.</span><span class="n">validate</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">executable</span><span class="p">(),</span> <span class="s">&quot;h&quot;</span><span class="p">,</span> <span class="s">&quot;e&quot;</span><span class="p">);</span>

<span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">thermo</span><span class="p">.</span><span class="n">p</span><span class="p">();</span>    <span class="c1">// 创建定义在网格体中心的压力场p</span>

<span class="n">volScalarField</span> <span class="n">rho</span>    <span class="c1">// 定义在网格体中心的标量场，密度场rho</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;rho&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>           <span class="c1">// 位于时间文件夹</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">READ_IF_PRESENT</span><span class="p">,</span>    <span class="c1">// 如果存在则读取</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">AUTO_WRITE</span>          <span class="c1">// 自动输出</span>
    <span class="p">),</span>
    <span class="n">thermo</span><span class="p">.</span><span class="n">rho</span><span class="p">()</span>    <span class="c1">// 依据thermo设置计算rho</span>
<span class="p">);</span>

<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Reading field U</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">volVectorField</span> <span class="n">U</span>    <span class="c1">// 定义在网格体中心的矢量场，速度场U</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;U&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>     <span class="c1">// 位于时间文件夹</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">MUST_READ</span><span class="p">,</span>    <span class="c1">// 必须读取</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">AUTO_WRITE</span>    <span class="c1">// 自动输出</span>
    <span class="p">),</span>
    <span class="n">mesh</span>
<span class="p">);</span>

<span class="cp">#include</span> <span class="cpf">&quot;compressibleCreatePhi.H&quot;</span><span class="cp"></span>
<span class="cm">/* 位于src/fininteVolume/cfdTools/compressible文件夹，所执行代码如下</span>
<span class="cm">    Info&lt;&lt; &quot;Reading/calculating face flux field phi\n&quot; &lt;&lt; endl;</span>

<span class="cm">    surfaceScalarField phi    // 创建质量通量场phi</span>
<span class="cm">    (</span>
<span class="cm">        IOobject</span>
<span class="cm">        (</span>
<span class="cm">            &quot;phi&quot;,</span>
<span class="cm">            runTime.timeName(),</span>
<span class="cm">            mesh,</span>
<span class="cm">            IOobject::READ_IF_PRESENT,</span>
<span class="cm">            IOobject::AUTO_WRITE</span>
<span class="cm">        ),</span>
<span class="cm">        linearInterpolate(rho*U) &amp; mesh.Sf()</span>
<span class="cm">    );</span>
<span class="cm">*/</span>


<span class="n">pressureReference</span> <span class="n">pressureReference</span>    <span class="c1">// SIMPLE算法程序结构要求pref，但是由于是可压缩流，实际会返回false而不执行任何内容</span>
<span class="p">(</span>
    <span class="n">p</span><span class="p">,</span>
    <span class="n">simple</span><span class="p">.</span><span class="n">dict</span><span class="p">(),</span>
    <span class="n">thermo</span><span class="p">.</span><span class="n">incompressible</span><span class="p">()</span>    <span class="c1">// 可压缩流返回false</span>
<span class="p">);</span>

<span class="n">mesh</span><span class="p">.</span><span class="n">schemes</span><span class="p">().</span><span class="n">setFluxRequired</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">name</span><span class="p">());</span>    <span class="c1">// 将压力场设置为需要计算通量</span>

<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Creating turbulence model</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">autoPtr</span><span class="o">&lt;</span><span class="n">compressible</span><span class="o">::</span><span class="n">momentumTransportModel</span><span class="o">&gt;</span> <span class="n">turbulence</span>    <span class="c1">// 创建湍流指针</span>
<span class="p">(</span>
    <span class="n">compressible</span><span class="o">::</span><span class="n">momentumTransportModel</span><span class="o">::</span><span class="n">New</span>
    <span class="p">(</span>
        <span class="n">rho</span><span class="p">,</span>
        <span class="n">U</span><span class="p">,</span>
        <span class="n">phi</span><span class="p">,</span>
        <span class="n">thermo</span>
    <span class="p">)</span>
<span class="p">);</span>

<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Creating thermophysical transport model</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">autoPtr</span><span class="o">&lt;</span><span class="n">fluidThermophysicalTransportModel</span><span class="o">&gt;</span> <span class="n">thermophysicalTransport</span>
<span class="p">(</span>
    <span class="n">fluidThermophysicalTransportModel</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">turbulence</span><span class="p">(),</span> <span class="n">thermo</span><span class="p">)</span>
<span class="p">);</span>

<span class="n">dimensionedScalar</span> <span class="n">initialMass</span> <span class="o">=</span> <span class="n">fvc</span><span class="o">::</span><span class="n">domainIntegrate</span><span class="p">(</span><span class="n">rho</span><span class="p">);</span>    <span class="c1">// 通过密度计算算域内总质量</span>

<span class="cp">#include</span> <span class="cpf">&quot;createMRF.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;createFvModels.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;createFvConstraints.H&quot;</span><span class="cp"></span>
</pre></div>
</div>
</div>
<div class="section" id="rhosimplefoam-c">
<h4>rhoSimpleFoam.C<a class="headerlink" href="#rhosimplefoam-c" title="永久链接至标题">¶</a></h4>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;fvCFD.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;fluidThermo.H&quot;                            // 引入热物理物料模型</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;compressibleMomentumTransportModels.H&quot;    // 引入可压缩流体湍流模型</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;fluidThermophysicalTransportModel.H&quot;      // 引入热物理能量模型</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;simpleControl.H&quot;                          // SIMPLE算法必要头文件</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;pressureReference.H&quot;                      // 为封闭体积模拟中的压力参考提供控制，可压缩流情况实际不起作用，这里是由于程序结构缘故引用</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;fvModels.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;fvConstraints.H&quot;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="cp">#include</span> <span class="cpf">&quot;postProcess.H&quot;</span><span class="cp"></span>

    <span class="cp">#include</span> <span class="cpf">&quot;setRootCaseLists.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createTime.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createMesh.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createControl.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createFields.H&quot;         // 创建场信息与热物理模型</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createFieldRefs.H&quot;      // 创建可压缩性场psi，执行语句为 const volScalarField&amp; psi = thermo.psi();</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;initContinuityErrs.H&quot;   // 声明并初始化累积连续性错误，执行语句为 scalar cumulativeContErr = 0;</span><span class="cp"></span>

    <span class="n">turbulence</span><span class="o">-&gt;</span><span class="n">validate</span><span class="p">();</span>    <span class="c1">// 初始化湍流场，主要是计算nut</span>

    <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Starting time loop</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">simple</span><span class="p">.</span><span class="n">loop</span><span class="p">(</span><span class="n">runTime</span><span class="p">))</span>    <span class="c1">// 开始SIMPLE循环</span>
    <span class="p">{</span>
        <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Time = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">runTime</span><span class="p">.</span><span class="n">userTimeName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

        <span class="n">fvModels</span><span class="p">.</span><span class="n">correct</span><span class="p">();</span>

        <span class="c1">// Pressure-velocity SIMPLE corrector</span>
        <span class="cp">#include</span> <span class="cpf">&quot;UEqn.H&quot;    // 求解U方程，得到速度场</span><span class="cp"></span>
        <span class="cp">#include</span> <span class="cpf">&quot;EEqn.H&quot;    // 求解能量方程</span><span class="cp"></span>
        <span class="cp">#include</span> <span class="cpf">&quot;pEqn.H&quot;    // 求解压力方程，得到压力场</span><span class="cp"></span>

        <span class="n">turbulence</span><span class="o">-&gt;</span><span class="n">correct</span><span class="p">();</span>                 <span class="c1">// 更新湍流模型相关参数</span>
        <span class="n">thermophysicalTransport</span><span class="o">-&gt;</span><span class="n">correct</span><span class="p">();</span>    <span class="c1">// 更新热物理模型相关参数</span>

        <span class="n">runTime</span><span class="p">.</span><span class="n">write</span><span class="p">();</span>    <span class="c1">// 输出场文件</span>

        <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;ExecutionTime = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">runTime</span><span class="p">.</span><span class="n">elapsedCpuTime</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; s&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;  ClockTime = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">runTime</span><span class="p">.</span><span class="n">elapsedClockTime</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; s&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">nl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;End</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="rhosimplefoamueqn-h">
<h4>rhoSimpleFoam的UEqn.H<a class="headerlink" href="#rhosimplefoamueqn-h" title="永久链接至标题">¶</a></h4>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// Solve the Momentum equation</span>

<span class="n">MRF</span><span class="p">.</span><span class="n">correctBoundaryVelocity</span><span class="p">(</span><span class="n">U</span><span class="p">);</span>

<span class="n">tmp</span><span class="o">&lt;</span><span class="n">fvVectorMatrix</span><span class="o">&gt;</span> <span class="n">tUEqn</span>
<span class="p">(</span>
    <span class="n">fvm</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>            <span class="c1">// 对流项</span>
  <span class="o">+</span> <span class="n">MRF</span><span class="p">.</span><span class="n">DDt</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>             <span class="c1">// 科里奥利加速度</span>
  <span class="o">+</span> <span class="n">turbulence</span><span class="o">-&gt;</span><span class="n">divDevTau</span><span class="p">(</span><span class="n">U</span><span class="p">)</span>    <span class="c1">// 雷诺应力项</span>
 <span class="o">==</span>
    <span class="n">fvModels</span><span class="p">.</span><span class="n">source</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>    <span class="c1">// 源项</span>
<span class="p">);</span>
<span class="n">fvVectorMatrix</span><span class="o">&amp;</span> <span class="n">UEqn</span> <span class="o">=</span> <span class="n">tUEqn</span><span class="p">.</span><span class="n">ref</span><span class="p">();</span>    <span class="c1">// 通过tmp创建之后要先引用再使用</span>

<span class="n">UEqn</span><span class="p">.</span><span class="n">relax</span><span class="p">();</span>

<span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">UEqn</span><span class="p">);</span>

<span class="n">solve</span><span class="p">(</span><span class="n">UEqn</span> <span class="o">==</span> <span class="o">-</span><span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>    <span class="c1">// 求解动量方程</span>

<span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">U</span><span class="p">);</span>
</pre></div>
</div>
<p>其中MRF.DDt(rho, U)执行的内容为如下，它返回科里奥利加速度：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// 位于src/finiteVolume/cfdTools/general/MRF/MRFZoneList.C</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">tmp</span><span class="o">&lt;</span><span class="n">Foam</span><span class="o">::</span><span class="n">volVectorField</span><span class="o">&gt;</span> <span class="n">Foam</span><span class="o">::</span><span class="n">MRFZoneList</span><span class="o">::</span><span class="n">DDt</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">rho</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">volVectorField</span><span class="o">&amp;</span> <span class="n">U</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">rho</span><span class="o">*</span><span class="n">DDt</span><span class="p">(</span><span class="n">U</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// 位于src/finiteVolume/finiteVolume/fvc/fvcDDt.C</span>
<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">tmp</span><span class="o">&lt;</span><span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&gt;</span>
<span class="n">DDt</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">phi</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">psi</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&gt;</span> <span class="n">ddtDivPhiPsi</span>
        <span class="o">=</span> <span class="n">fvc</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span> <span class="o">+</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">psi</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">phi</span><span class="p">.</span><span class="n">mesh</span><span class="p">().</span><span class="n">moving</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">ddtDivPhiPsi</span> <span class="o">-</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phi</span> <span class="o">+</span> <span class="n">phi</span><span class="p">.</span><span class="n">mesh</span><span class="p">().</span><span class="n">phi</span><span class="p">())</span><span class="o">*</span><span class="n">psi</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">ddtDivPhiPsi</span> <span class="o">-</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">psi</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>参考 <a class="reference external" href="https://blog.csdn.net/hanbingchegu/article/details/107326376">MRF.DDt(U)—MRF模型简介</a>  ，MRF涉及旋转机械等的动网格技术，如果不使用MRF，则MRF.DDt(rho, U)可以忽略，因此求解的动量方程为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\nabla\cdot(\rho\mathbf{UU})
+ \nabla \cdot (\rho\mathbf{R}_{\text{eff}})
- \nabla \cdot (\nu_{\text{eff}}\rho\nabla \mathbf{U})
= -\nabla p
\end{align}\]</div>
</div>
<div class="section" id="rhosimplefoameeqn-h">
<h4>rhoSimpleFoam的EEqn.H<a class="headerlink" href="#rhosimplefoameeqn-h" title="永久链接至标题">¶</a></h4>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">he</span> <span class="o">=</span> <span class="n">thermo</span><span class="p">.</span><span class="n">he</span><span class="p">();</span>    <span class="c1">// 创建能量场，根据设置可能是e或h</span>

<span class="n">fvScalarMatrix</span> <span class="n">EEqn</span>    <span class="c1">// 组建能量方程</span>
<span class="p">(</span>
    <span class="n">fvm</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">he</span><span class="p">)</span>
  <span class="o">+</span> <span class="p">(</span>
        <span class="n">he</span><span class="p">.</span><span class="n">name</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;e&quot;</span>
      <span class="o">?</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">volScalarField</span><span class="p">(</span><span class="s">&quot;Ekp&quot;</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">U</span><span class="p">)</span> <span class="o">+</span> <span class="n">p</span><span class="o">/</span><span class="n">rho</span><span class="p">))</span>
      <span class="o">:</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">volScalarField</span><span class="p">(</span><span class="s">&quot;K&quot;</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">U</span><span class="p">)))</span>
    <span class="p">)</span>
  <span class="o">+</span> <span class="n">thermophysicalTransport</span><span class="o">-&gt;</span><span class="n">divq</span><span class="p">(</span><span class="n">he</span><span class="p">)</span>
 <span class="o">==</span>
    <span class="n">fvModels</span><span class="p">.</span><span class="n">source</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">he</span><span class="p">)</span>
<span class="p">);</span>

<span class="n">EEqn</span><span class="p">.</span><span class="n">relax</span><span class="p">();</span>

<span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">EEqn</span><span class="p">);</span>

<span class="n">EEqn</span><span class="p">.</span><span class="n">solve</span><span class="p">();</span>    <span class="c1">// 求解能量方程</span>

<span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">he</span><span class="p">);</span>

<span class="n">thermo</span><span class="p">.</span><span class="n">correct</span><span class="p">();</span>
</pre></div>
</div>
<p>可以看到，针对热物理模型设置的不同，能量方程的表现形式也不同。如果能量场设置为内能e，则求解的能量方程为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\nabla \cdot (\rho \mathbf{U}e)
+ \nabla \cdot \Big(\rho\mathbf{U} (\frac{1}{2}|\mathbf{U}|^{2} + \frac{p}{\rho})\Big)
+ \nabla \cdot \mathbf{q}
= S_{e}
\end{align}\]</div>
<p>如果能量场设置为焓h，则求解的能量方程为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\nabla \cdot (\rho\mathbf{U}h)
+ \nabla\cdot (\rho\mathbf{U}\frac{1}{2}|\mathbf{U}|^{2})
+ \nabla \cdot \mathbf{q}
= S_{h}
\end{align}\]</div>
</div>
<div class="section" id="rhosimplefoampeqn-h">
<h4>rhoSimpleFoam的pEqn.H<a class="headerlink" href="#rhosimplefoampeqn-h" title="永久链接至标题">¶</a></h4>
<p>压力方程在高速流(transonic)和低速流两种情况下会有所不同。</p>
<p>对于 <strong>低速流</strong> 的情况，可以认为密度的变化并不是特别的大，那么在收敛的情况下可以认为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\mathbf{U}^{n+1} = \Big(\frac{\mathbf{H}}{A}\Big)^{n+1} - \frac{\nabla p^{n+1}}{A^{n+1}}
\end{align}\]</div>
<p>从而速度修正量可以写成</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\mathbf{U}' = \Big(\frac{\mathbf{H}}{A}\Big)' - \frac{\nabla p^{n+1}}{A^{n+1}} + \frac{\nabla p^{n}}{A^{n}}
\end{align}\]</div>
<p>假定忽略相邻点影响，上式改写为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\mathbf{U}' = - \frac{\nabla p^{n+1}}{A^{n+1}} + \frac{\nabla p^{n}}{A^{n}}
\end{align}\]</div>
<p>继续假定 <span class="math notranslate nohighlight">\(A\)</span> 的变化较小，即 <span class="math notranslate nohighlight">\(A^{n+1} = A^{n}\)</span> ，则</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\mathbf{U}' = - \frac{\nabla p'}{A^{n}}
\end{align}\]</div>
<p>将上式与考虑了相邻点影响的已知速度表示方程相加，得到</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\mathbf{U}^{n+1} = \mathbf{U}^{n} + \mathbf{U}'
= \Big(\frac{\mathbf{H}}{A}\Big)^{n} - \frac{\nabla p^{n+1}}{A^{n}}
,\quad
\mathbf{U}^{n+1}_{f} = \mathbf{U}^{n}_{f} + \mathbf{U}'_{f}
= \Big(\frac{\mathbf{H}}{A}\Big)^{n}_{f} - \frac{(\nabla p^{n+1})_{f}}{A_{f}^{n}}
\end{align}\]</div>
<p>考虑连续性方程（认为密度变化足够小）：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\sum \rho_{f}^{n}\mathbf{U}_{f}^{n+1} \cdot \mathbf{S}_{f} = 0
\end{align}\]</div>
<p>将速度的表达式代入连续性方程，即可得到所求解的压力方程：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\sum \rho_{f}^{n} \Big(\frac{\mathbf{H}}{A}\Big)_{f}^{n} \cdot \mathbf{S}_{f}
= \sum \rho_{f}^{n}\frac{(\nabla p^{n+1})_{f}}{A_{f}^{n}} \cdot \mathbf{S}_{f}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\rho_{f}^{n} \Big(\frac{\mathbf{H}}{A}\Big)_{f}^{n} \cdot \mathbf{S}_{f}\)</span> 通过phiHbyA来表示：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">volScalarField</span> <span class="nf">rAU</span><span class="p">(</span><span class="s">&quot;rAU&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">UEqn</span><span class="p">.</span><span class="n">A</span><span class="p">());</span>

<span class="n">volVectorField</span> <span class="nf">HbyA</span><span class="p">(</span><span class="n">constrainHbyA</span><span class="p">(</span><span class="n">rAU</span><span class="o">*</span><span class="n">UEqn</span><span class="p">.</span><span class="n">H</span><span class="p">(),</span> <span class="n">U</span><span class="p">,</span> <span class="n">p</span><span class="p">));</span>

<span class="n">surfaceScalarField</span> <span class="nf">phiHbyA</span>
<span class="p">(</span>
    <span class="s">&quot;phiHbyA&quot;</span><span class="p">,</span>
    <span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">fvc</span><span class="o">::</span><span class="n">flux</span><span class="p">(</span><span class="n">HbyA</span><span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<p>而方程等号右侧是一个laplacian项，表示为</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">surfaceScalarField</span> <span class="nf">rhorAUf</span><span class="p">(</span><span class="s">&quot;rhorAUf&quot;</span><span class="p">,</span> <span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">rho</span><span class="o">*</span><span class="n">rAU</span><span class="p">));</span>

<span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">rhorAAtUf</span> <span class="o">=</span> <span class="n">simple</span><span class="p">.</span><span class="n">consistent</span><span class="p">()</span> <span class="o">?</span> <span class="n">rhorAtUf</span><span class="p">()</span> <span class="o">:</span> <span class="n">rhorAUf</span><span class="p">;</span>

<span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">rhorAAtUf</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
<p>因此，低速流情况组建的压力方程表示为</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">fvScalarMatrix</span> <span class="nf">pEqn</span>
<span class="p">(</span>
    <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phiHbyA</span><span class="p">)</span>
  <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">rhorAAtUf</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
  <span class="o">==</span>
    <span class="n">fvModels</span><span class="p">.</span><span class="n">source</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rho</span><span class="p">.</span><span class="n">name</span><span class="p">())</span>
<span class="p">);</span>
</pre></div>
</div>
<p>对于 <strong>高速流</strong> 的情况，连续性方程满足</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\sum(\rho_{f}^{n} + \rho_{f}')(\mathbf{U}_{f}^{n} + \mathbf{U}_{f}')\cdot\mathbf{S}_{f} = 0
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(p_{f}'\)</span> 和 <span class="math notranslate nohighlight">\(\mathbf{U}_{f}'\)</span> 表示修正量。进一步展开可以得到</p>
<div class="math notranslate nohighlight">
\[\begin{align}
0 = \sum\Big[(\rho_{f}^{n} + \rho_{f}')\mathbf{U}_{f}^{n} + \rho_{f}^{n}\mathbf{U}_{f}' + \rho_{f}'\mathbf{U}_{f}' \Big]
\approx \sum\Big[(\rho_{f}^{n} + \rho_{f}')\mathbf{U}_{f}^{n} + \rho_{f}^{n}\mathbf{U}_{f}' \Big]
\end{align}\]</div>
<p>引入略去相邻点影响的假定：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
A\mathbf{U}' = \mathbf{H}(\mathbf{U}') - \nabla p' \approx - \nabla p'
\quad \Rightarrow \quad
\mathbf{U}' = - \frac{\nabla p'}{A^{n}}
,\quad \mathbf{U}'_{f} = - \frac{(\nabla p')_{f}}{A^{n}_{f}}
\end{align}\]</div>
<p>同时还有考虑相邻点影响的已知速度场关系：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\mathbf{U}_{f}^{n} = \Big(\frac{\mathbf{H}}{A}\Big)_{f}^{n} - \frac{(\nabla p^{n})_{f}}{A_{f}^{n}}
\end{align}\]</div>
<p>将它们代入到连续性方程中，得到</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\sum(\rho_{f}^{n} + \rho_{f}')\Big(\frac{\mathbf{H}}{A}\Big)^{n}_{f}\cdot \mathbf{S}_{f}
- \sum(\rho_{f}^{n} + \rho_{f}')\frac{(\nabla p^{n})_{f}}{A_{f}^{n}} \cdot \mathbf{S}_{f}
- \sum \rho_{f}^{n}\frac{(\nabla p')_{f}}{A_{f}^{n}} \cdot \mathbf{S}_{f}
= 0
\end{align}\]</div>
<p>由于 <span class="math notranslate nohighlight">\(\nabla p' = \nabla p^{n+1} - \nabla p^{n}\)</span> ，从而上式中含有该式的项满足</p>
<div class="math notranslate nohighlight">
\[\begin{align}
- \sum\rho_{f}^{n}\frac{(\nabla p')_{f}}{A_{f}^{n}} \cdot \mathbf{S}_{f}
= - \sum\rho_{f}^{n}\frac{(\nabla p^{n+1})_{f}}{A_{f}^{n}} \cdot \mathbf{S}_{f}
+ \sum\rho_{f}^{n}\frac{(\nabla p^{n})_{f}}{A_{f}^{n}} \cdot \mathbf{S}_{f}
\end{align}\]</div>
<p>进而将上式代入前式，并进行化简与移项合并，得到</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\sum\rho_{f}^{n}\Big(\frac{\mathbf{H}}{A}\Big)^{n}_{f}\cdot \mathbf{S}_{f}
+ \sum\rho_{f}' \bigg[ \Big(\frac{\mathbf{H}}{A}\Big)^{n}_{f} - \frac{(\nabla p^{n})_{f}}{A_{f}^{n}} \bigg] \cdot \mathbf{S}_{f}
= \sum \rho_{f}^{n} \frac{(\nabla p^{n+1})_{f}}{A_{f}^{n}} \cdot \mathbf{S}_{f}
\end{align}\]</div>
<p>再根据 <span class="math notranslate nohighlight">\(\rho_{f}' = \psi p_{f}^{n+1} - \psi p_{f}^{n}\)</span> ，代入上式，进行化简与移项合并，得到</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\sum (\rho_{f}^{n} - \psi p_{f}^{n})\Big(\frac{\mathbf{H}}{A}\Big)_{f}^{n} \cdot \mathbf{S}_{f}
+ \sum \psi p_{f}^{n+1}\Big(\frac{\mathbf{H}}{A}\Big)_{f}^{n} \cdot \mathbf{S}_{f}
+ \sum \psi (p_{f}^{n} - p_{f}^{n+1})\frac{(\nabla p^{n})_{f}}{A_{f}^{n}} \cdot \mathbf{S}_{f}
= \sum \rho_{f}^{n}\frac{(\nabla p^{n+1})_{f}}{A_{f}^{n}} \cdot \mathbf{S}_{f}
\end{align}\]</div>
<p>上式中等号左侧第三项被省略，因此最终求解的压力方程为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\sum (\rho_{f}^{n} - \psi p_{f}^{n})\Big(\frac{\mathbf{H}}{A}\Big)_{f}^{n} \cdot \mathbf{S}_{f}
+ \sum \psi p_{f}^{n+1}\Big(\frac{\mathbf{H}}{A}\Big)_{f}^{n} \cdot \mathbf{S}_{f}
= \sum \rho_{f}^{n}\frac{(\nabla p^{n+1})_{f}}{A_{f}^{n}} \cdot \mathbf{S}_{f}
\end{align}\]</div>
<p>上式等号左侧的两项分别用phiHbyA和divPhidp表示：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">surfaceScalarField</span> <span class="nf">phiHbyA</span>
<span class="p">(</span>
    <span class="s">&quot;phiHbyA&quot;</span><span class="p">,</span>
    <span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">fvc</span><span class="o">::</span><span class="n">flux</span><span class="p">(</span><span class="n">HbyA</span><span class="p">)</span>
<span class="p">);</span>

<span class="k">const</span> <span class="n">surfaceScalarField</span> <span class="nf">phid</span>
<span class="p">(</span>
    <span class="s">&quot;phid&quot;</span><span class="p">,</span>
    <span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span><span class="o">*</span><span class="n">phiHbyA</span><span class="o">/</span><span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
<span class="p">);</span>

<span class="k">const</span> <span class="n">fvScalarMatrix</span> <span class="nf">divPhidp</span><span class="p">(</span><span class="n">fvm</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phid</span><span class="p">,</span> <span class="n">p</span><span class="p">));</span>
<span class="n">phiHbyA</span> <span class="o">-=</span> <span class="n">divPhidp</span><span class="p">.</span><span class="n">flux</span><span class="p">();</span>
</pre></div>
</div>
<p>等号右侧是一个laplacian项，表示为</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">surfaceScalarField</span> <span class="nf">rhorAUf</span><span class="p">(</span><span class="s">&quot;rhorAUf&quot;</span><span class="p">,</span> <span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">rho</span><span class="o">*</span><span class="n">rAU</span><span class="p">));</span>

<span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">rhorAAtUf</span> <span class="o">=</span> <span class="n">simple</span><span class="p">.</span><span class="n">consistent</span><span class="p">()</span> <span class="o">?</span> <span class="n">rhorAtUf</span><span class="p">()</span> <span class="o">:</span> <span class="n">rhorAUf</span><span class="p">;</span>

<span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">rhorAAtUf</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
<p>因此，高速流组建的压力方程表示为</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">fvScalarMatrix</span> <span class="nf">pEqn</span>
<span class="p">(</span>
    <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phiHbyA</span><span class="p">)</span> <span class="o">+</span> <span class="n">divPhidp</span>
  <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">rhorAAtUf</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
  <span class="o">==</span>
    <span class="n">fvModels</span><span class="p">.</span><span class="n">source</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rho</span><span class="p">.</span><span class="n">name</span><span class="p">())</span>
<span class="p">);</span>
</pre></div>
</div>
<p>在求解出压力场之后，还要继续修正速度场，根据下式可以得到符合通量守恒的速度场：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\mathbf{U}^{n+1} = \mathbf{U}' + \mathbf{U}^{n}
= -\frac{\nabla p'}{A^{n}} + \Big(\frac{\mathbf{H}}{A}\Big)^{n} - \frac{\nabla p^{n}}{A^{n}}
= \Big(\frac{\mathbf{H}}{A}\Big)^{n} - \frac{\nabla p^{n+1}}{A^{n}}
\end{align}\]</div>
<p>代码表示为</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">volScalarField</span> <span class="nf">rAU</span><span class="p">(</span><span class="s">&quot;rAU&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">UEqn</span><span class="p">.</span><span class="n">A</span><span class="p">());</span>
<span class="n">volVectorField</span> <span class="nf">HbyA</span><span class="p">(</span><span class="n">constrainHbyA</span><span class="p">(</span><span class="n">rAU</span><span class="o">*</span><span class="n">UEqn</span><span class="p">.</span><span class="n">H</span><span class="p">(),</span> <span class="n">U</span><span class="p">,</span> <span class="n">p</span><span class="p">));</span>
<span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">rAAtU</span> <span class="o">=</span> <span class="n">simple</span><span class="p">.</span><span class="n">consistent</span><span class="p">()</span> <span class="o">?</span> <span class="n">rAtU</span><span class="p">()</span> <span class="o">:</span> <span class="n">rAU</span><span class="p">;</span>

<span class="n">U</span> <span class="o">=</span> <span class="n">HbyA</span> <span class="o">-</span> <span class="n">rAAtU</span><span class="o">*</span><span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</pre></div>
</div>
<p>完整的压力场求解策略以及速度场、密度场修正策略如下所示：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">rho</span> <span class="o">=</span> <span class="n">thermo</span><span class="p">.</span><span class="n">rho</span><span class="p">();</span>    <span class="c1">// 计算密度场</span>
<span class="n">rho</span><span class="p">.</span><span class="n">relax</span><span class="p">();</span>

<span class="k">const</span> <span class="n">volScalarField</span> <span class="nf">rAU</span><span class="p">(</span><span class="s">&quot;rAU&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">UEqn</span><span class="p">.</span><span class="n">A</span><span class="p">());</span>
<span class="k">const</span> <span class="n">surfaceScalarField</span> <span class="nf">rhorAUf</span><span class="p">(</span><span class="s">&quot;rhorAUf&quot;</span><span class="p">,</span> <span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">rho</span><span class="o">*</span><span class="n">rAU</span><span class="p">));</span>

<span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">rAtU</span>
<span class="p">(</span>
    <span class="n">simple</span><span class="p">.</span><span class="n">consistent</span><span class="p">()</span>
  <span class="o">?</span> <span class="n">volScalarField</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="s">&quot;rAtU&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">rAU</span> <span class="o">-</span> <span class="n">UEqn</span><span class="p">.</span><span class="n">H1</span><span class="p">()))</span>
  <span class="o">:</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span><span class="p">(</span><span class="n">nullptr</span><span class="p">)</span>
<span class="p">);</span>
<span class="n">tmp</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="o">&gt;</span> <span class="n">rhorAtUf</span>
<span class="p">(</span>
    <span class="n">simple</span><span class="p">.</span><span class="n">consistent</span><span class="p">()</span>
  <span class="o">?</span> <span class="n">surfaceScalarField</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="s">&quot;rhoRAtUf&quot;</span><span class="p">,</span> <span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">rho</span><span class="o">*</span><span class="n">rAtU</span><span class="p">()))</span>
  <span class="o">:</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">surfaceScalarField</span><span class="o">&gt;</span><span class="p">(</span><span class="n">nullptr</span><span class="p">)</span>
<span class="p">);</span>

<span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">rAAtU</span> <span class="o">=</span> <span class="n">simple</span><span class="p">.</span><span class="n">consistent</span><span class="p">()</span> <span class="o">?</span> <span class="n">rAtU</span><span class="p">()</span> <span class="o">:</span> <span class="n">rAU</span><span class="p">;</span>
<span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">rhorAAtUf</span> <span class="o">=</span> <span class="n">simple</span><span class="p">.</span><span class="n">consistent</span><span class="p">()</span> <span class="o">?</span> <span class="n">rhorAtUf</span><span class="p">()</span> <span class="o">:</span> <span class="n">rhorAUf</span><span class="p">;</span>

<span class="n">volVectorField</span> <span class="nf">HbyA</span><span class="p">(</span><span class="n">constrainHbyA</span><span class="p">(</span><span class="n">rAU</span><span class="o">*</span><span class="n">UEqn</span><span class="p">.</span><span class="n">H</span><span class="p">(),</span> <span class="n">U</span><span class="p">,</span> <span class="n">p</span><span class="p">));</span>

<span class="n">tUEqn</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>

<span class="n">surfaceScalarField</span> <span class="nf">phiHbyA</span>
<span class="p">(</span>
    <span class="s">&quot;phiHbyA&quot;</span><span class="p">,</span>
    <span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span><span class="o">*</span><span class="n">fvc</span><span class="o">::</span><span class="n">flux</span><span class="p">(</span><span class="n">HbyA</span><span class="p">)</span>
<span class="p">);</span>

<span class="n">MRF</span><span class="p">.</span><span class="n">makeRelative</span><span class="p">(</span><span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">rho</span><span class="p">),</span> <span class="n">phiHbyA</span><span class="p">);</span>

<span class="kt">bool</span> <span class="n">closedVolume</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="c1">// Update the pressure BCs to ensure flux consistency</span>
<span class="n">constrainPressure</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">phiHbyA</span><span class="p">,</span> <span class="n">rhorAAtUf</span><span class="p">,</span> <span class="n">MRF</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">simple</span><span class="p">.</span><span class="n">transonic</span><span class="p">())</span>    <span class="c1">// 高速流情况</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">surfaceScalarField</span> <span class="n">phid</span>
    <span class="p">(</span>
        <span class="s">&quot;phid&quot;</span><span class="p">,</span>
        <span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span><span class="o">*</span><span class="n">phiHbyA</span><span class="o">/</span><span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
    <span class="p">);</span>

    <span class="k">const</span> <span class="n">fvScalarMatrix</span> <span class="nf">divPhidp</span><span class="p">(</span><span class="n">fvm</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phid</span><span class="p">,</span> <span class="n">p</span><span class="p">));</span>
    <span class="n">phiHbyA</span> <span class="o">-=</span> <span class="n">divPhidp</span><span class="p">.</span><span class="n">flux</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">simple</span><span class="p">.</span><span class="n">consistent</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">phiHbyA</span> <span class="o">+=</span> <span class="p">(</span><span class="n">rhorAAtUf</span> <span class="o">-</span> <span class="n">rhorAUf</span><span class="p">)</span><span class="o">*</span><span class="n">fvc</span><span class="o">::</span><span class="n">snGrad</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">*</span><span class="n">mesh</span><span class="p">.</span><span class="n">magSf</span><span class="p">();</span>
        <span class="n">HbyA</span> <span class="o">+=</span> <span class="p">(</span><span class="n">rAAtU</span> <span class="o">-</span> <span class="n">rAU</span><span class="p">)</span><span class="o">*</span><span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">simple</span><span class="p">.</span><span class="n">correctNonOrthogonal</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">fvScalarMatrix</span> <span class="n">pEqn</span>    <span class="c1">// 组建高速流的压力方程</span>
        <span class="p">(</span>
            <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phiHbyA</span><span class="p">)</span> <span class="o">+</span> <span class="n">divPhidp</span>
          <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">rhorAAtUf</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
          <span class="o">==</span>
            <span class="n">fvModels</span><span class="p">.</span><span class="n">source</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rho</span><span class="p">.</span><span class="n">name</span><span class="p">())</span>
        <span class="p">);</span>

        <span class="c1">// Relax the pressure equation to ensure diagonal-dominance</span>
        <span class="n">pEqn</span><span class="p">.</span><span class="n">relax</span><span class="p">();</span>

        <span class="n">pEqn</span><span class="p">.</span><span class="n">setReference</span>
        <span class="p">(</span>
            <span class="n">pressureReference</span><span class="p">.</span><span class="n">refCell</span><span class="p">(),</span>
            <span class="n">pressureReference</span><span class="p">.</span><span class="n">refValue</span><span class="p">()</span>
        <span class="p">);</span>

        <span class="n">pEqn</span><span class="p">.</span><span class="n">solve</span><span class="p">();</span>    <span class="c1">// 求解压力方程得到压力场</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">simple</span><span class="p">.</span><span class="n">finalNonOrthogonalIter</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="n">phiHbyA</span> <span class="o">+</span> <span class="n">pEqn</span><span class="p">.</span><span class="n">flux</span><span class="p">();</span>    <span class="c1">// 计算出符合质量守恒的质量通量</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">else</span>    <span class="c1">// 低速流情况</span>
<span class="p">{</span>
    <span class="n">closedVolume</span> <span class="o">=</span> <span class="n">adjustPhi</span><span class="p">(</span><span class="n">phiHbyA</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">simple</span><span class="p">.</span><span class="n">consistent</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">phiHbyA</span> <span class="o">+=</span> <span class="p">(</span><span class="n">rhorAAtUf</span> <span class="o">-</span> <span class="n">rhorAUf</span><span class="p">)</span><span class="o">*</span><span class="n">fvc</span><span class="o">::</span><span class="n">snGrad</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">*</span><span class="n">mesh</span><span class="p">.</span><span class="n">magSf</span><span class="p">();</span>
        <span class="n">HbyA</span> <span class="o">+=</span> <span class="p">(</span><span class="n">rAAtU</span> <span class="o">-</span> <span class="n">rAU</span><span class="p">)</span><span class="o">*</span><span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">simple</span><span class="p">.</span><span class="n">correctNonOrthogonal</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">fvScalarMatrix</span> <span class="n">pEqn</span>    <span class="c1">// 组建低速流的压力方程</span>
        <span class="p">(</span>
            <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phiHbyA</span><span class="p">)</span>
          <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">rhorAAtUf</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
          <span class="o">==</span>
            <span class="n">fvModels</span><span class="p">.</span><span class="n">source</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">rho</span><span class="p">.</span><span class="n">name</span><span class="p">())</span>
        <span class="p">);</span>

        <span class="n">pEqn</span><span class="p">.</span><span class="n">setReference</span>
        <span class="p">(</span>
            <span class="n">pressureReference</span><span class="p">.</span><span class="n">refCell</span><span class="p">(),</span>
            <span class="n">pressureReference</span><span class="p">.</span><span class="n">refValue</span><span class="p">()</span>
        <span class="p">);</span>

        <span class="n">pEqn</span><span class="p">.</span><span class="n">solve</span><span class="p">();</span>    <span class="c1">// 求解压力方程得到压力场</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">simple</span><span class="p">.</span><span class="n">finalNonOrthogonalIter</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="n">phiHbyA</span> <span class="o">+</span> <span class="n">pEqn</span><span class="p">.</span><span class="n">flux</span><span class="p">();</span>    <span class="c1">// 计算出符合质量守恒的质量通量</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#include</span> <span class="cpf">&quot;incompressible/continuityErrs.H&quot;</span><span class="cp"></span>
<span class="cm">/* 计算连续性误差，文件位于src/finiteVolume/cfdTools/incompressible，所执行代码如下</span>
<span class="cm">    volScalarField contErr(fvc::div(phi));</span>

<span class="cm">    scalar sumLocalContErr = runTime.deltaTValue()*</span>
<span class="cm">        mag(contErr)().weightedAverage(mesh.V()).value();</span>

<span class="cm">    scalar globalContErr = runTime.deltaTValue()*</span>
<span class="cm">        contErr.weightedAverage(mesh.V()).value();</span>
<span class="cm">    cumulativeContErr += globalContErr;</span>

<span class="cm">    Info&lt;&lt; &quot;time step continuity errors : sum local = &quot; &lt;&lt; sumLocalContErr</span>
<span class="cm">        &lt;&lt; &quot;, global = &quot; &lt;&lt; globalContErr</span>
<span class="cm">        &lt;&lt; &quot;, cumulative = &quot; &lt;&lt; cumulativeContErr</span>
<span class="cm">        &lt;&lt; endl;</span>
<span class="cm">*/</span>


<span class="c1">// Explicitly relax pressure for momentum corrector</span>
<span class="n">p</span><span class="p">.</span><span class="n">relax</span><span class="p">();</span>

<span class="n">U</span> <span class="o">=</span> <span class="n">HbyA</span> <span class="o">-</span> <span class="n">rAAtU</span><span class="o">*</span><span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>    <span class="c1">// 求解最终的速度场</span>
<span class="n">U</span><span class="p">.</span><span class="n">correctBoundaryConditions</span><span class="p">();</span>
<span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">U</span><span class="p">);</span>

<span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

<span class="c1">// For closed-volume cases adjust the pressure and density levels</span>
<span class="c1">// to obey overall mass continuity</span>
<span class="k">if</span> <span class="p">(</span><span class="n">closedVolume</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">thermo</span><span class="p">.</span><span class="n">incompressible</span><span class="p">())</span>    <span class="c1">// 对于封闭体积的算例，进行修正以满足质量守恒</span>
<span class="p">{</span>
    <span class="n">p</span> <span class="o">+=</span> <span class="p">(</span><span class="n">initialMass</span> <span class="o">-</span> <span class="n">fvc</span><span class="o">::</span><span class="n">domainIntegrate</span><span class="p">(</span><span class="n">psi</span><span class="o">*</span><span class="n">p</span><span class="p">))</span>
        <span class="o">/</span><span class="n">fvc</span><span class="o">::</span><span class="n">domainIntegrate</span><span class="p">(</span><span class="n">psi</span><span class="p">);</span>
    <span class="n">p</span><span class="p">.</span><span class="n">correctBoundaryConditions</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">rho</span> <span class="o">=</span> <span class="n">thermo</span><span class="p">.</span><span class="n">rho</span><span class="p">();</span>    <span class="c1">// 使用求解出来的压力场更新密度场</span>
<span class="n">rho</span><span class="p">.</span><span class="n">relax</span><span class="p">();</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="rhocentralfoam">
<h3>rhoCentralFoam求解器<a class="headerlink" href="#rhocentralfoam" title="永久链接至标题">¶</a></h3>
<div class="section" id="rhocentralfoamdirectioninterpolate-h">
<h4>rhoCentralFoam的directionInterpolate.H<a class="headerlink" href="#rhocentralfoamdirectioninterpolate-h" title="永久链接至标题">¶</a></h4>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">namespace</span> <span class="n">Foam</span>
<span class="p">{</span>

<span class="c1">//- Interpolate field vf according to direction dir 根据方向dir来对场vf进行插值</span>
<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">tmp</span><span class="o">&lt;</span><span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvsPatchField</span><span class="p">,</span> <span class="n">surfaceMesh</span><span class="o">&gt;&gt;</span> <span class="n">interpolate</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvPatchField</span><span class="p">,</span> <span class="n">volMesh</span><span class="o">&gt;&amp;</span> <span class="n">vf</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">dir</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">word</span><span class="o">&amp;</span> <span class="n">reconFieldName</span> <span class="o">=</span> <span class="n">word</span><span class="o">::</span><span class="n">null</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">tmp</span><span class="o">&lt;</span><span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvsPatchField</span><span class="p">,</span> <span class="n">surfaceMesh</span><span class="o">&gt;&gt;</span> <span class="n">tsf</span>
    <span class="p">(</span>
        <span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span>    <span class="c1">// 将插值场的变量和方向作为自变量</span>
        <span class="p">(</span>
            <span class="n">vf</span><span class="p">,</span>
            <span class="n">dir</span><span class="p">,</span>
            <span class="s">&quot;reconstruct(&quot;</span>
          <span class="o">+</span> <span class="p">(</span><span class="n">reconFieldName</span> <span class="o">!=</span> <span class="n">word</span><span class="o">::</span><span class="n">null</span> <span class="o">?</span> <span class="nl">reconFieldName</span> <span class="p">:</span> <span class="n">vf</span><span class="p">.</span><span class="n">name</span><span class="p">())</span>
          <span class="o">+</span> <span class="sc">&#39;)&#39;</span>
        <span class="p">)</span>
    <span class="p">);</span>

    <span class="n">GeometricField</span><span class="o">&lt;</span><span class="n">Type</span><span class="p">,</span> <span class="n">fvsPatchField</span><span class="p">,</span> <span class="n">surfaceMesh</span><span class="o">&gt;&amp;</span> <span class="n">sf</span> <span class="o">=</span> <span class="n">tsf</span><span class="p">.</span><span class="n">ref</span><span class="p">();</span>

    <span class="n">sf</span><span class="p">.</span><span class="n">rename</span><span class="p">(</span><span class="n">vf</span><span class="p">.</span><span class="n">name</span><span class="p">()</span> <span class="o">+</span> <span class="sc">&#39;_&#39;</span> <span class="o">+</span> <span class="n">dir</span><span class="p">.</span><span class="n">name</span><span class="p">());</span>

    <span class="k">return</span> <span class="n">tsf</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="rhocentralfoamcreatefields-h">
<h4>rhoCentralFoam的createFields.H<a class="headerlink" href="#rhocentralfoamcreatefields-h" title="永久链接至标题">¶</a></h4>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;createRDeltaT.H&quot;</span><span class="cp"></span>

<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Reading thermophysical properties</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

<span class="n">autoPtr</span><span class="o">&lt;</span><span class="n">psiThermo</span><span class="o">&gt;</span> <span class="n">pThermo</span>
<span class="p">(</span>
    <span class="n">psiThermo</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="p">);</span>
<span class="n">psiThermo</span><span class="o">&amp;</span> <span class="n">thermo</span> <span class="o">=</span> <span class="n">pThermo</span><span class="p">();</span>

<span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">thermo</span><span class="p">.</span><span class="n">he</span><span class="p">();</span>      <span class="c1">// 创建能量场，这里是内能场</span>

<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Reading field U</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">volVectorField</span> <span class="n">U</span>    <span class="c1">// 创建定义在网格体中心的速度场U</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;U&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">MUST_READ</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">AUTO_WRITE</span>
    <span class="p">),</span>
    <span class="n">mesh</span>
<span class="p">);</span>

<span class="n">volScalarField</span> <span class="n">rho</span>    <span class="c1">// 创建定义在网格体中心的密度场rho</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;rho&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_READ</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">AUTO_WRITE</span>
    <span class="p">),</span>
    <span class="n">thermo</span><span class="p">.</span><span class="n">rho</span><span class="p">()</span>    <span class="c1">// 通过热物理模型定义方式求解rho</span>
<span class="p">);</span>

<span class="n">volVectorField</span> <span class="n">rhoU</span>    <span class="c1">// 创建定义在网格体中心的rhoU场</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;rhoU&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_READ</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_WRITE</span>
    <span class="p">),</span>
    <span class="n">rho</span><span class="o">*</span><span class="n">U</span>    <span class="c1">// 通过密度场与速度场直接相乘得到</span>
<span class="p">);</span>

<span class="n">volScalarField</span> <span class="n">rhoE</span>    <span class="c1">// 创建定义在网格体中心的rhoE场，由于加上了动能这里的E表示总能量</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;rhoE&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_READ</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_WRITE</span>
    <span class="p">),</span>
    <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">e</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">U</span><span class="p">))</span>    <span class="c1">// 计算方法为 \rho \cdot (e + \frac{1}{2}|U|^{2})</span>
<span class="p">);</span>

<span class="n">surfaceScalarField</span> <span class="n">pos</span>    <span class="c1">// 定义在网格面中心的场pos</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;pos&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>
        <span class="n">mesh</span>
    <span class="p">),</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">dimensionedScalar</span><span class="p">(</span><span class="n">dimless</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>    <span class="c1">// 该场是一个无量纲的1.0</span>
<span class="p">);</span>

<span class="n">surfaceScalarField</span> <span class="n">neg</span>    <span class="c1">// 定义在网格面中心的场neg</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;neg&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>
        <span class="n">mesh</span>
    <span class="p">),</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">dimensionedScalar</span><span class="p">(</span><span class="n">dimless</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>    <span class="c1">// 该场是无量纲的-1.0</span>
<span class="p">);</span>

<span class="n">surfaceScalarField</span> <span class="nf">phi</span><span class="p">(</span><span class="s">&quot;phi&quot;</span><span class="p">,</span> <span class="n">fvc</span><span class="o">::</span><span class="n">flux</span><span class="p">(</span><span class="n">rhoU</span><span class="p">));</span>    <span class="c1">// 定义在网格面中心的质量通量场phi，通过 (\rho U)_{f} \cdot S_{f} 得到</span>

<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Creating turbulence model</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">autoPtr</span><span class="o">&lt;</span><span class="n">compressible</span><span class="o">::</span><span class="n">momentumTransportModel</span><span class="o">&gt;</span> <span class="n">turbulence</span>
<span class="p">(</span>
    <span class="n">compressible</span><span class="o">::</span><span class="n">momentumTransportModel</span><span class="o">::</span><span class="n">New</span>
    <span class="p">(</span>
        <span class="n">rho</span><span class="p">,</span>
        <span class="n">U</span><span class="p">,</span>
        <span class="n">phi</span><span class="p">,</span>
        <span class="n">thermo</span>
    <span class="p">)</span>
<span class="p">);</span>

<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Creating thermophysical transport model</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">autoPtr</span><span class="o">&lt;</span><span class="n">fluidThermophysicalTransportModel</span><span class="o">&gt;</span> <span class="n">thermophysicalTransport</span>
<span class="p">(</span>
    <span class="n">fluidThermophysicalTransportModel</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">turbulence</span><span class="p">(),</span> <span class="n">thermo</span><span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="rhocentralfoamcreatefieldrefs-h">
<h4>rhoCentralFoam的createFieldRefs.H<a class="headerlink" href="#rhocentralfoamcreatefieldrefs-h" title="永久链接至标题">¶</a></h4>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">thermo</span><span class="p">.</span><span class="n">p</span><span class="p">();</span>             <span class="c1">// 根据热物理模型定义的方式获取定义在网格体中心的压力场p</span>
<span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">T</span> <span class="o">=</span> <span class="n">thermo</span><span class="p">.</span><span class="n">T</span><span class="p">();</span>       <span class="c1">// 根据热物理模型定义的方式获取定义在网格体中心的温度场T</span>
<span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">psi</span> <span class="o">=</span> <span class="n">thermo</span><span class="p">.</span><span class="n">psi</span><span class="p">();</span>   <span class="c1">// 根据热物理模型定义的方式获取定义在网格体中心的可压缩性场psi</span>
<span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">mu</span> <span class="o">=</span> <span class="n">thermo</span><span class="p">.</span><span class="n">mu</span><span class="p">();</span>     <span class="c1">// 根据热物理模型定义的方式获取定义在网格体中心的动力粘度场mu</span>

<span class="kt">bool</span> <span class="nf">inviscid</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>    <span class="c1">// 初始化inviscid为true</span>
<span class="k">if</span> <span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">mu</span><span class="p">.</span><span class="n">primitiveField</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>    <span class="c1">// 如果场中动力粘度最大值大于零则设置inviscid为false</span>
<span class="p">{</span>
    <span class="n">inviscid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="rhocentralfoamreadfluxscheme-h">
<h4>rhoCentralFoam的readFluxScheme.H<a class="headerlink" href="#rhocentralfoamreadfluxscheme-h" title="永久链接至标题">¶</a></h4>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">word</span> <span class="nf">fluxScheme</span><span class="p">(</span><span class="s">&quot;Kurganov&quot;</span><span class="p">);</span>    <span class="c1">// 初始化fluxScheme为Kurganov</span>
<span class="k">if</span> <span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">schemes</span><span class="p">().</span><span class="n">dict</span><span class="p">().</span><span class="n">readIfPresent</span><span class="p">(</span><span class="s">&quot;fluxScheme&quot;</span><span class="p">,</span> <span class="n">fluxScheme</span><span class="p">))</span>    <span class="c1">// 读取fvScheme文件中的fluxScheme字典设置</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">fluxScheme</span> <span class="o">==</span> <span class="s">&quot;Tadmor&quot;</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">fluxScheme</span> <span class="o">==</span> <span class="s">&quot;Kurganov&quot;</span><span class="p">))</span>    <span class="c1">// 有两种设置，分别为Tadmor和Kurganov</span>
    <span class="p">{</span>
        <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;fluxScheme: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">fluxScheme</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>    <span class="c1">// 其他设置都是不合法的，将报错</span>
    <span class="p">{</span>
        <span class="n">FatalErrorInFunction</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;fluxScheme: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">fluxScheme</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot; is not a valid choice. &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;Options are: Tadmor, Kurganov&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">abort</span><span class="p">(</span><span class="n">FatalError</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="rhocentralfoamresetdeltat-h">
<h4>rhoCentralFoam的resetDeltaT.H<a class="headerlink" href="#rhocentralfoamresetdeltat-h" title="永久链接至标题">¶</a></h4>
<p>该文件在controlDict文件中设置为了adjustTimeStep模式时会使用到。首先定义了参数deltaT的初始化计算方式为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\text{deltaT} = \frac{\text{maxCo} \times \Delta t}{\text{CoNum} + \text{small}}
\end{align}\]</div>
<p>之后根据库朗数更新deltaT的办法为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\text{deltaT} = \min\Big(\min(\text{deltaT}, \Delta t + 0.1\times \text{deltaT}),1.2\Delta t\Big)
\end{align}\]</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">adjustTimeStep</span><span class="p">)</span>    <span class="c1">// 如果在controlDict文件中设置为了adjustTimeStep模式</span>
<span class="p">{</span>
    <span class="n">scalar</span> <span class="n">deltaT</span> <span class="o">=</span> <span class="n">maxCo</span><span class="o">*</span><span class="n">runTime</span><span class="p">.</span><span class="n">deltaTValue</span><span class="p">()</span><span class="o">/</span><span class="p">(</span><span class="n">CoNum</span> <span class="o">+</span> <span class="n">small</span><span class="p">);</span>    <span class="c1">// 定义并初始化参数deltaT</span>
    <span class="n">deltaT</span> <span class="o">=</span> <span class="n">min</span>  <span class="c1">// 更新deltaT的值</span>
    <span class="p">(</span>
        <span class="n">min</span><span class="p">(</span><span class="n">deltaT</span><span class="p">,</span> <span class="n">runTime</span><span class="p">.</span><span class="n">deltaTValue</span><span class="p">()</span> <span class="o">+</span> <span class="mf">0.1</span><span class="o">*</span><span class="n">deltaT</span><span class="p">),</span>
        <span class="mf">1.2</span><span class="o">*</span><span class="n">runTime</span><span class="p">.</span><span class="n">deltaTValue</span><span class="p">()</span>
    <span class="p">);</span>
    <span class="n">runTime</span><span class="p">.</span><span class="n">setDeltaT</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">deltaT</span><span class="p">,</span> <span class="n">maxDeltaT</span><span class="p">));</span>    <span class="c1">// 重新设置时间步进长度为deltaT和maxDeltaT中的最小值</span>

    <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;deltaT = &quot;</span> <span class="o">&lt;&lt;</span>  <span class="n">runTime</span><span class="p">.</span><span class="n">deltaTValue</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="rhocentralfoamcentralcourantno-h">
<h4>rhoCentralFoam的CentralCourantNo.H<a class="headerlink" href="#rhocentralfoamcentralcourantno-h" title="永久链接至标题">¶</a></h4>
<p>该文件基于库朗数计算平均波速和最大波速。计算方法为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; \text{CoNum} = 0.5 \times \max_{\text{global}}\Big(\frac{\sum_{f}\text{amaxSf}}{V}\cdot \Delta t\Big)  \\
&amp; \text{meanCoNum} = 0.5 \times \Big(\frac{\sum_{\text{global}}(\sum_{f}\text{amaxSf})}{\sum_{\text{global}}V} \Big) \cdot \Delta t
\end{align}\end{split}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\sum_{f}\text{amaxSf}\)</span> 表示在每个网格单元中对其各面上的amaxSf值进行求和，得到的是与网格单元数同维的标量场。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">nInternalFaces</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">scalarField</span> <span class="n">sumAmaxSf</span><span class="p">(</span><span class="n">fvc</span><span class="o">::</span><span class="n">surfaceSum</span><span class="p">(</span><span class="n">amaxSf</span><span class="p">)().</span><span class="n">primitiveField</span><span class="p">());</span>    <span class="c1">// 将amaxSf按面求和得到sumAmaxSf</span>

    <span class="n">CoNum</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">gMax</span><span class="p">(</span><span class="n">sumAmaxSf</span><span class="o">/</span><span class="n">mesh</span><span class="p">.</span><span class="n">V</span><span class="p">().</span><span class="n">field</span><span class="p">())</span><span class="o">*</span><span class="n">runTime</span><span class="p">.</span><span class="n">deltaTValue</span><span class="p">();</span>    <span class="c1">// gMax表示全局最大值，涉及到并行</span>

    <span class="n">meanCoNum</span> <span class="o">=</span>
        <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">gSum</span><span class="p">(</span><span class="n">sumAmaxSf</span><span class="p">)</span><span class="o">/</span><span class="n">gSum</span><span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">V</span><span class="p">().</span><span class="n">field</span><span class="p">()))</span><span class="o">*</span><span class="n">runTime</span><span class="p">.</span><span class="n">deltaTValue</span><span class="p">();</span>    <span class="c1">// gSum表示全局求和，涉及到并行</span>
<span class="p">}</span>

<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Mean and max Courant Numbers = &quot;</span>
    <span class="o">&lt;&lt;</span> <span class="n">meanCoNum</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">CoNum</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="rhocentralfoamsetrdeltat-h">
<h4>rhoCentralFoam的setRDeltaT.H<a class="headerlink" href="#rhocentralfoamsetrdeltat-h" title="永久链接至标题">¶</a></h4>
<p>当使用当地局部时间步方法时会使用这个文件。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">rDeltaT</span> <span class="o">=</span> <span class="n">trDeltaT</span><span class="p">.</span><span class="n">ref</span><span class="p">();</span>

    <span class="n">scalar</span> <span class="nf">rDeltaTSmoothingCoeff</span>
    <span class="p">(</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">controlDict</span><span class="p">().</span><span class="n">lookupOrDefault</span><span class="o">&lt;</span><span class="n">scalar</span><span class="o">&gt;</span>
        <span class="p">(</span>
            <span class="s">&quot;rDeltaTSmoothingCoeff&quot;</span><span class="p">,</span>
            <span class="mf">0.02</span>
        <span class="p">)</span>
    <span class="p">);</span>

    <span class="c1">// Set the reciprocal time-step from the local Courant number</span>
    <span class="n">rDeltaT</span><span class="p">.</span><span class="n">ref</span><span class="p">()</span> <span class="o">=</span> <span class="n">max</span>
    <span class="p">(</span>
        <span class="mi">1</span><span class="o">/</span><span class="n">dimensionedScalar</span><span class="p">(</span><span class="n">dimTime</span><span class="p">,</span> <span class="n">maxDeltaT</span><span class="p">),</span>
        <span class="n">fvc</span><span class="o">::</span><span class="n">surfaceSum</span><span class="p">(</span><span class="n">amaxSf</span><span class="p">)()()</span>
       <span class="o">/</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">maxCo</span><span class="p">)</span><span class="o">*</span><span class="n">mesh</span><span class="p">.</span><span class="n">V</span><span class="p">())</span>
    <span class="p">);</span>

    <span class="c1">// Update the boundary values of the reciprocal time-step</span>
    <span class="n">rDeltaT</span><span class="p">.</span><span class="n">correctBoundaryConditions</span><span class="p">();</span>

    <span class="n">fvc</span><span class="o">::</span><span class="n">smooth</span><span class="p">(</span><span class="n">rDeltaT</span><span class="p">,</span> <span class="n">rDeltaTSmoothingCoeff</span><span class="p">);</span>

    <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Flow time scale min/max = &quot;</span>
        <span class="o">&lt;&lt;</span> <span class="n">gMin</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">rDeltaT</span><span class="p">.</span><span class="n">primitiveField</span><span class="p">())</span>
        <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">gMax</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">rDeltaT</span><span class="p">.</span><span class="n">primitiveField</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="rhocentralfoam-c">
<h4>rhoCentralFoam.C<a class="headerlink" href="#rhocentralfoam-c" title="永久链接至标题">¶</a></h4>
<p>理论算法参考 <a class="reference external" href="http://dyfluid.com/rhocentralfoam.html">rhoCentralFoam解析</a> 、 <a class="reference external" href="https://blog.csdn.net/lusongno1/article/details/78708667">间断初值双曲守恒问题的Lax-Friedrichs和后向欧拉数值解法</a></p>
<p>rhoCentralFoam求解的连续性方程为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\partial \rho}{\partial t} + \nabla \cdot (\rho\mathbf{U}) = 0
\end{align}\]</div>
<p>rhoCentralFoam求解的动量方程为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\partial \rho\mathbf{U}}{\partial t}
+ \nabla \cdot (\rho\mathbf{UU})
+ \nabla p
- \nabla \cdot (\mu_{\text{Eff}} \nabla \mathbf{U})
- \nabla \cdot \Big[ \mu_{\text{Eff}} \Big( (\nabla \mathbf{U})^{T} - \frac{2}{3}(\nabla \cdot \mathbf{U})\mathbf{I} \Big) \Big]
= 0
\end{align}\]</div>
<p>rhoCentralFoam求解的能量方程为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\partial \rho(e+\frac{1}{2}|\mathbf{U}|^{2})}{\partial t}
+ \nabla \cdot \big(\rho\mathbf{U}(e+\frac{1}{2}|\mathbf{U}|^{2})\big)
+ \nabla \cdot (p \mathbf{U})
- \nabla \cdot (\alpha_{\text{Eff}}\nabla e)
- \nabla \cdot (\boldsymbol{\tau} \cdot \mathbf{U})
= 0
\end{align}\]</div>
<p>在该求解器中所采用的中心差分算法引入了许多系数，包括</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; c = \sqrt{\frac{c_{p}}{c_{v}}\frac{1}{\psi}} \\
&amp; a_{p} = \max\Big( \max(\mathbf{U}_{+}\cdot \mathbf{S}_{f}  + c_{+}|\mathbf{S}_{f}|, \mathbf{U}_{-}\cdot \mathbf{S}_{f}  + c_{-}|\mathbf{S}_{f}|) , 0.0\Big)  \\
&amp; a_{m} = \min\Big( \min(\mathbf{U}_{+}\cdot \mathbf{S}_{f}  - c_{+}|\mathbf{S}_{f}|, \mathbf{U}_{-}\cdot \mathbf{S}_{f}  - c_{-}|\mathbf{S}_{f}|) , 0.0\Big)  \\
&amp; a_{+} = \frac{a_{p}}{a_{p} - a_{m}}  \\
&amp; a_{-} = 1.0 - a_{+}
\end{align}\end{split}\]</div>
<p>其中下标 <span class="math notranslate nohighlight">\(+,-\)</span> 表示定向插值到网格面。</p>
<p>质量通量项的计算方法为 <code class="code docutils literal notranslate"><span class="pre">phi</span> <span class="pre">=</span> <span class="pre">aphiv_pos*rho_pos</span> <span class="pre">+</span> <span class="pre">aphiv_neg*rho_neg;</span></code> ，即</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\int_{V} \nabla \cdot (\rho \mathbf{U}) ~\mathrm{d}V
= \sum_{f}(\rho \mathbf{U})_{f}\cdot\mathbf{S}_{f}
= \sum_{f}\Big( \rho_{+}(\mathbf{U}_{+}\cdot \mathbf{S}_{f})a_{+} + \rho_{-}(\mathbf{U}_{-}\cdot\mathbf{S}_{f})a_{-} \Big)
\end{align}\]</div>
<p>动量方程的中间项如下进行计算：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp;\int_{V} \Big( \nabla \cdot (\rho\mathbf{UU}) + \nabla p \Big)~\mathrm{d}V
= \sum_{f}(\rho\mathbf{UU})_{f} \cdot \mathbf{S}_{f} + \sum_{f}p_{f}\mathbf{S}_{f}  \\
&amp;= \sum_{f}\Big(
  (\mathbf{U}_{+}\cdot\mathbf{S}_{f}a_{+} - a_{m}a_{+})(\rho\mathbf{U})_{+}
  + (\mathbf{U}_{-}\cdot\mathbf{S}_{f}a_{-} + a_{m}a_{+})(\rho\mathbf{U})_{-}
  + (a_{+}p_{+} + a_{-}p_{-})\mathbf{S}_{f}
  \Big)
\end{align}\end{split}\]</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">surfaceVectorField</span> <span class="nf">phiUp</span>
<span class="p">(</span>
    <span class="p">(</span><span class="n">aphiv_pos</span><span class="o">*</span><span class="n">rhoU_pos</span> <span class="o">+</span> <span class="n">aphiv_neg</span><span class="o">*</span><span class="n">rhoU_neg</span><span class="p">)</span>
  <span class="o">+</span> <span class="p">(</span><span class="n">a_pos</span><span class="o">*</span><span class="n">p_pos</span> <span class="o">+</span> <span class="n">a_neg</span><span class="o">*</span><span class="n">p_neg</span><span class="p">)</span><span class="o">*</span><span class="n">mesh</span><span class="p">.</span><span class="n">Sf</span><span class="p">()</span>
<span class="p">);</span>
</pre></div>
</div>
<p>能量方程的中间项如下进行计算：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp;\int_{V}\Big( \nabla \cdot (\rho\mathbf{U}E) + \nabla \cdot (p\mathbf{U}) \Big)~\mathrm{d}V
= \sum_{f}(\rho\mathbf{U}E)_{f}\cdot\mathbf{S}_{f} + \sum_{f}(p\mathbf{U})_{f}\cdot\mathbf{S}_{f}  \\
&amp;= \sum_{f}\Big(
  (\mathbf{U}_{+}\cdot\mathbf{S}_{f}a_{+} - a_{m}a_{+})(\rho_{+}E_{+} + p_{+})
  + (\mathbf{U}_{-}\cdot\mathbf{S}_{f}a_{-} + a_{m}a_{+})(\rho_{e}E_{-} + p_{-})
  + a_{m}a_{+}p_{+} - a_{m}a_{+}p_{-}
  \Big)
\end{align}\end{split}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(E_{+} = e_{+} + \frac{1}{2}|\mathbf{U}_{+}|^{2}\)</span> ， <span class="math notranslate nohighlight">\(E_{-} = e_{-} + \frac{1}{2}|\mathbf{U}_{-}|^{2}\)</span> 。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">surfaceScalarField</span> <span class="nf">phiEp</span>
<span class="p">(</span>
    <span class="s">&quot;phiEp&quot;</span><span class="p">,</span>
    <span class="n">aphiv_pos</span><span class="o">*</span><span class="p">(</span><span class="n">rho_pos</span><span class="o">*</span><span class="p">(</span><span class="n">e_pos</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">U_pos</span><span class="p">))</span> <span class="o">+</span> <span class="n">p_pos</span><span class="p">)</span>
  <span class="o">+</span> <span class="n">aphiv_neg</span><span class="o">*</span><span class="p">(</span><span class="n">rho_neg</span><span class="o">*</span><span class="p">(</span><span class="n">e_neg</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">U_neg</span><span class="p">))</span> <span class="o">+</span> <span class="n">p_neg</span><span class="p">)</span>
  <span class="o">+</span> <span class="n">aSf</span><span class="o">*</span><span class="n">p_pos</span> <span class="o">-</span> <span class="n">aSf</span><span class="o">*</span><span class="n">p_neg</span>
<span class="p">);</span>
</pre></div>
</div>
<p>有效动力粘度系数利用湍流模型的有效运动粘度系数来计算，为 <code class="code docutils literal notranslate"><span class="pre">volScalarField</span> <span class="pre">muEff(&quot;muEff&quot;,</span> <span class="pre">rho*turbulence-&gt;nuEff());</span></code> ，即 <span class="math notranslate nohighlight">\(\mu_{\text{Eff}} = \rho \nu_{\text{Eff}}\)</span> 。动量方程粘性项的一部分如此进行计算 <code class="code docutils literal notranslate"><span class="pre">volTensorField</span> <span class="pre">tauMC(&quot;tauMC&quot;,</span> <span class="pre">muEff*dev2(Foam::T(fvc::grad(U))));</span></code> ，即</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\int_{V}\nabla \cdot \Big[ \mu_{\text{Eff}} \Big( (\nabla \mathbf{U})^{T} - \frac{2}{3}(\nabla \cdot \mathbf{U})\mathbf{I} \Big) \Big]~\mathrm{d}V
= \sum_{f} \Big[ \mu_{\text{Eff}} \Big( (\nabla \mathbf{U})_{\text{fvc}}^{T} - \frac{2}{3}\operatorname{tr}\big((\nabla\mathbf{U})_{\text{fvc}}^{T}\big) \mathbf{I} \Big) \Big]_{f}
\end{align}\]</div>
<p>现在可以求解连续性方程得到密度场：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\Big(\frac{\partial \rho}{\partial t}\Big)_{\text{fvm}} + \sum_{f,\text{fvc}}(\rho \mathbf{U})_{f}\cdot\mathbf{S}_{f} = 0
\quad \Rightarrow \quad
\Big(\frac{\partial \rho}{\partial t}\Big)_{\text{fvm}} + \sum_{f,\text{fvc}}\Big(\rho_{+}(\mathbf{U}_{+}\cdot \mathbf{S}_{f})a_{+} + \rho_{-}(\mathbf{U}_{-}\cdot\mathbf{S}_{f})a_{-}\Big) = 0
\end{align}\]</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">solve</span><span class="p">(</span><span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span> <span class="o">+</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phi</span><span class="p">));</span>
</pre></div>
</div>
<p>在rhoCentralFoam中首先求解了一次不考虑粘性的动量方程，即</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\Big(\frac{\partial \rho\mathbf{U}}{\partial t} \Big)_{\text{fvm}}
+ \sum_{f,\text{fvc}}\Big( (\rho\mathbf{UU})_{f}\cdot\mathbf{S}_{f} + p_{f}\mathbf{S}_{f} \Big)
= 0
\quad \Rightarrow \quad
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
\Big(\frac{\partial \rho\mathbf{U}}{\partial t} \Big)_{\text{fvm}}
+ \sum_{f,\text{fvc}}\Big(
      (\mathbf{U}_{+}\cdot\mathbf{S}_{f}a_{+} - a_{m}a_{+})(\rho_{+}E_{+} + p_{+})
      + (\mathbf{U}_{-}\cdot\mathbf{S}_{f}a_{-} + a_{m}a_{+})(\rho_{e}E_{-} + p_{-})
      + a_{m}a_{+}p_{+} - a_{m}a_{+}p_{-}
      \Big)
= 0
\end{align}\]</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">solve</span><span class="p">(</span><span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">rhoU</span><span class="p">)</span> <span class="o">+</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phiUp</span><span class="p">));</span>
</pre></div>
</div>
<p>通过求解上式可以得到更新后的动量密度场 <span class="math notranslate nohighlight">\(\rho\mathbf{U}\)</span> ，然后通过 <span class="math notranslate nohighlight">\(\rho\mathbf{U}/\rho\)</span> 的方式得到参考速度场。接下来考虑上粘性项的影响再求解一次动量方程：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\Big( \frac{\partial \rho\mathbf{U}}{\partial t} \Big)_{\text{fvm}}
- \Big( \frac{\partial \rho\mathbf{U}}{\partial t} \Big)_{\text{fvc}}
- \sum_{f,\text{fvm}}\Big( \mu_{\text{Eff}} \nabla\mathbf{U} \Big)_{f}
- \sum_{f,\text{fvc}}\Big[ \mu_{\text{Eff}} \Big( (\nabla \mathbf{U})_{\text{fvc}}^{T} - \frac{2}{3}\operatorname{tr}\big((\nabla\mathbf{U})_{\text{fvc}}^{T}\big) \mathbf{I} \Big) \Big]_{f}
= 0
\end{align}\]</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inviscid</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">solve</span>
    <span class="p">(</span>
        <span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span> <span class="o">-</span> <span class="n">fvc</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>
      <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">muEff</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>
      <span class="o">-</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">tauMC</span><span class="p">)</span>
    <span class="p">);</span>
    <span class="n">rhoU</span> <span class="o">=</span> <span class="n">rho</span><span class="o">*</span><span class="n">U</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如此就能得到求解出的速度场 <span class="math notranslate nohighlight">\(\mathbf{U}\)</span> ，利用它更新一次动量密度场 <span class="math notranslate nohighlight">\(\rho\mathbf{U}\)</span> 。</p>
<p>能量场中的应力张量做功项如下进行计算：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\int_{V} \nabla \cdot (\boldsymbol{\tau} \cdot \mathbf{U}) ~\mathrm{d}V
= \sum_{f}\Big( (\mu_{\text{Eff}})_{f,\text{fvc}}|\mathbf{S}_{f}| (\nabla\mathbf{U})_{\text{fvc}} + \Big[ \mu_{\text{Eff}} \Big( (\nabla \mathbf{U})_{\text{fvc}}^{T} - \frac{2}{3}\operatorname{tr}\big((\nabla\mathbf{U})_{\text{fvc}}^{T}\big) \mathbf{I} \Big) \Big]_{f} \cdot \mathbf{S}_{f} \Big)
  \cdot (a_{+}\mathbf{U}_{+} + a_{-}\mathbf{U}_{-})
\end{align}\]</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">surfaceScalarField</span> <span class="nf">sigmaDotU</span>
<span class="p">(</span>
    <span class="s">&quot;sigmaDotU&quot;</span><span class="p">,</span>
    <span class="p">(</span>
        <span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">muEff</span><span class="p">)</span><span class="o">*</span><span class="n">mesh</span><span class="p">.</span><span class="n">magSf</span><span class="p">()</span><span class="o">*</span><span class="n">fvc</span><span class="o">::</span><span class="n">snGrad</span><span class="p">(</span><span class="n">U</span><span class="p">)</span>
      <span class="o">+</span> <span class="n">fvc</span><span class="o">::</span><span class="n">dotInterpolate</span><span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">Sf</span><span class="p">(),</span> <span class="n">tauMC</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="o">&amp;</span> <span class="p">(</span><span class="n">a_pos</span><span class="o">*</span><span class="n">U_pos</span> <span class="o">+</span> <span class="n">a_neg</span><span class="o">*</span><span class="n">U_neg</span><span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<p>于是能量方程可以进行求解：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\Big(\frac{\partial \rho E}{\partial t} \Big)_{\text{fvm}}
+ \sum_{f,\text{fvc}}\Big( (\rho\mathbf{U}E)_{f}\cdot\mathbf{S}_{f} + (p\mathbf{U})_{f}\cdot\mathbf{S}_{f} \Big)
- \sum_{f,\text{fvc}}\Big( \boldsymbol{\tau} \cdot \mathbf{U} \Big)_{f}
= 0
\quad \Rightarrow \quad
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\Big(\frac{\partial \rho E}{\partial t} \Big)_{\text{fvm}}
&amp;+ \sum_{f,\text{fvc}}\Big(
      (\mathbf{U}_{+}\cdot\mathbf{S}_{f}a_{+} - a_{m}a_{+})(\rho_{+}E_{+} + p_{+})
      + (\mathbf{U}_{-}\cdot\mathbf{S}_{f}a_{-} + a_{m}a_{+})(\rho_{e}E_{-} + p_{-})
      + a_{m}a_{+}p_{+} - a_{m}a_{+}p_{-}
      \Big)  \\
&amp;- \sum_{f,\text{fvc}}\Big( (\mu_{\text{Eff}})_{f,\text{fvc}}|\mathbf{S}_{f}| (\nabla\mathbf{U})_{\text{fvc}} + \Big[ \mu_{\text{Eff}} \Big( (\nabla \mathbf{U})_{\text{fvc}}^{T} - \frac{2}{3}\operatorname{tr}\big((\nabla\mathbf{U})_{\text{fvc}}^{T}\big) \mathbf{I} \Big) \Big]_{f} \cdot \mathbf{S}_{f} \Big)
      \cdot (a_{+}\mathbf{U}_{+} + a_{-}\mathbf{U}_{-})
= 0
\end{align}\end{split}\]</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">solve</span>    <span class="c1">// 求解能量方程，得到rhoE</span>
<span class="p">(</span>
    <span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">rhoE</span><span class="p">)</span>
  <span class="o">+</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phiEp</span><span class="p">)</span>
  <span class="o">-</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">sigmaDotU</span><span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<p>由此计算得到 <span class="math notranslate nohighlight">\(\rho E\)</span> 后据此更新内能场 <span class="math notranslate nohighlight">\(e = \rho E / \rho - \frac{1}{2}|\mathbf{U}|^{2}\)</span> 。</p>
<p>但是上式没有考虑热通量项，对于有粘场则还会再求解一次考虑了热通量贡献的能量方程：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\Big(\frac{\partial \rho e}{\partial t} \Big)_{\text{fvm}}
- \Big( \frac{\partial \rho e}{\partial t} \Big)_{\text{fvc}}
- \sum_{f,\text{fvc}} \Big( \alpha_{\text{Eff}} \nabla e \Big)_{f}
= 0
\end{align}\]</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inviscid</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">solve</span>
    <span class="p">(</span>
        <span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="o">-</span> <span class="n">fvc</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
      <span class="o">+</span> <span class="n">thermophysicalTransport</span><span class="o">-&gt;</span><span class="n">divq</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="p">);</span>
    <span class="n">thermo</span><span class="p">.</span><span class="n">correct</span><span class="p">();</span>
    <span class="n">rhoE</span> <span class="o">=</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">e</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">U</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>由此求解出新的内能场 <span class="math notranslate nohighlight">\(e\)</span> ，据此更新 <span class="math notranslate nohighlight">\(\rho E = \rho (e + \frac{1}{2}|\mathbf{U}|^{2})\)</span> 的值。</p>
<p>最后通过密度场和可压缩性场求解出压力场 <code class="code docutils literal notranslate"><span class="pre">p.ref()</span> <span class="pre">=</span> <span class="pre">rho()/psi();</span></code> ，即 <span class="math notranslate nohighlight">\(p = \frac{\rho}{\psi}\)</span> 就完成了本次时间步的内容，开始下一个时间步的循环。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;fvCFD.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;psiThermo.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;compressibleMomentumTransportModels.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;fluidThermophysicalTransportModel.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;fixedRhoFvPatchScalarField.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;directionInterpolate.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;localEulerDdtScheme.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;fvcSmooth.H&quot;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="cp">#define NO_CONTROL</span>
    <span class="cp">#include</span> <span class="cpf">&quot;postProcess.H&quot;</span><span class="cp"></span>

    <span class="cp">#include</span> <span class="cpf">&quot;setRootCaseLists.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createTime.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createMesh.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createFields.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createFieldRefs.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createTimeControls.H&quot;</span><span class="cp"></span>

    <span class="n">turbulence</span><span class="o">-&gt;</span><span class="n">validate</span><span class="p">();</span>

    <span class="cp">#include</span> <span class="cpf">&quot;readFluxScheme.H&quot;</span><span class="cp"></span>

    <span class="n">dimensionedScalar</span> <span class="n">v_zero</span><span class="p">(</span><span class="s">&quot;v_zero&quot;</span><span class="p">,</span> <span class="n">dimVolume</span><span class="o">/</span><span class="n">dimTime</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>    <span class="c1">// 定义一个有量纲标量场v_zero，值为0.0，量纲为 m^{3}/t</span>

    <span class="c1">// Courant numbers used to adjust the time-step</span>
    <span class="n">scalar</span> <span class="n">CoNum</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>        <span class="c1">// 初始化参数CoNum为0.0</span>
    <span class="n">scalar</span> <span class="n">meanCoNum</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>    <span class="c1">// 初始化参数meanCoNum为0.0</span>

    <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Starting time loop</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">runTime</span><span class="p">.</span><span class="n">run</span><span class="p">())</span>    <span class="c1">// 开始时间步迭代步进</span>
    <span class="p">{</span>
        <span class="cp">#include</span> <span class="cpf">&quot;readTimeControls.H&quot;</span><span class="cp"></span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LTS</span><span class="p">)</span>    <span class="c1">// 如果不采用当地时间步方法</span>
        <span class="p">{</span>
            <span class="cp">#include</span> <span class="cpf">&quot;setDeltaT.H&quot;    // 关于adjustTimeStep模式</span><span class="cp"></span>

            <span class="c1">// Update the mesh for topology change, mesh to mesh mapping</span>
            <span class="n">mesh</span><span class="p">.</span><span class="n">update</span><span class="p">();</span>

            <span class="n">runTime</span><span class="o">++</span><span class="p">;</span>

            <span class="c1">// Move the mesh</span>
            <span class="n">mesh</span><span class="p">.</span><span class="n">move</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="c1">// --- Directed interpolation of primitive fields onto faces 将原始场定向插值到面上</span>

        <span class="n">surfaceScalarField</span> <span class="n">rho_pos</span><span class="p">(</span><span class="n">interpolate</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">pos</span><span class="p">));</span>    <span class="c1">// 密度场正向插值得到rho_pos</span>
        <span class="n">surfaceScalarField</span> <span class="n">rho_neg</span><span class="p">(</span><span class="n">interpolate</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">neg</span><span class="p">));</span>    <span class="c1">// 密度场反向插值得到rho_neg</span>

        <span class="n">surfaceVectorField</span> <span class="n">rhoU_pos</span><span class="p">(</span><span class="n">interpolate</span><span class="p">(</span><span class="n">rhoU</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">U</span><span class="p">.</span><span class="n">name</span><span class="p">()));</span>    <span class="c1">// rhoU场正向插值得到rhoU_pos</span>
        <span class="n">surfaceVectorField</span> <span class="n">rhoU_neg</span><span class="p">(</span><span class="n">interpolate</span><span class="p">(</span><span class="n">rhoU</span><span class="p">,</span> <span class="n">neg</span><span class="p">,</span> <span class="n">U</span><span class="p">.</span><span class="n">name</span><span class="p">()));</span>    <span class="c1">// rhoU场反向插值得到rhoU_neg</span>

        <span class="n">volScalarField</span> <span class="n">rPsi</span><span class="p">(</span><span class="s">&quot;rPsi&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">psi</span><span class="p">);</span>    <span class="c1">// 创建一个定义在网格体中心的标量场rPsi，它是可压缩性场的倒数</span>
        <span class="n">surfaceScalarField</span> <span class="n">rPsi_pos</span><span class="p">(</span><span class="n">interpolate</span><span class="p">(</span><span class="n">rPsi</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">T</span><span class="p">.</span><span class="n">name</span><span class="p">()));</span>    <span class="c1">// rPsi场正向插值得到rPsi_pos</span>
        <span class="n">surfaceScalarField</span> <span class="n">rPsi_neg</span><span class="p">(</span><span class="n">interpolate</span><span class="p">(</span><span class="n">rPsi</span><span class="p">,</span> <span class="n">neg</span><span class="p">,</span> <span class="n">T</span><span class="p">.</span><span class="n">name</span><span class="p">()));</span>    <span class="c1">// rPsi场反向插值得到rPsi_neg</span>

        <span class="n">surfaceScalarField</span> <span class="n">e_pos</span><span class="p">(</span><span class="n">interpolate</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">T</span><span class="p">.</span><span class="n">name</span><span class="p">()));</span>    <span class="c1">// 能量场正向插值得到e_pos</span>
        <span class="n">surfaceScalarField</span> <span class="n">e_neg</span><span class="p">(</span><span class="n">interpolate</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">neg</span><span class="p">,</span> <span class="n">T</span><span class="p">.</span><span class="n">name</span><span class="p">()));</span>    <span class="c1">// 能量场反向插值得到e_neg</span>

        <span class="n">surfaceVectorField</span> <span class="n">U_pos</span><span class="p">(</span><span class="s">&quot;U_pos&quot;</span><span class="p">,</span> <span class="n">rhoU_pos</span><span class="o">/</span><span class="n">rho_pos</span><span class="p">);</span>    <span class="c1">// 速度场正向插值通过计算得到，即 U_{+} = \frac{(\rho U)_{+}}{\rho_{+}}</span>
        <span class="n">surfaceVectorField</span> <span class="n">U_neg</span><span class="p">(</span><span class="s">&quot;U_neg&quot;</span><span class="p">,</span> <span class="n">rhoU_neg</span><span class="o">/</span><span class="n">rho_neg</span><span class="p">);</span>    <span class="c1">// 速度场反向插值通过计算得到，即 U_{-} = \frac{(\rho U)_{-}}{\rho_{-}}</span>

        <span class="n">surfaceScalarField</span> <span class="n">p_pos</span><span class="p">(</span><span class="s">&quot;p_pos&quot;</span><span class="p">,</span> <span class="n">rho_pos</span><span class="o">*</span><span class="n">rPsi_pos</span><span class="p">);</span>    <span class="c1">// 压力场正向插值通过计算得到，即 p_{+} = \rho_{+} \cdot (\frac{1}{\psi})_{+}</span>
        <span class="n">surfaceScalarField</span> <span class="n">p_neg</span><span class="p">(</span><span class="s">&quot;p_neg&quot;</span><span class="p">,</span> <span class="n">rho_neg</span><span class="o">*</span><span class="n">rPsi_neg</span><span class="p">);</span>    <span class="c1">// 压力场反向插值通过计算得到，即 p_{-} = \rho_{-} \cdot (\frac{1}{\psi})_{-}</span>

        <span class="n">surfaceScalarField</span> <span class="n">phiv_pos</span><span class="p">(</span><span class="s">&quot;phiv_pos&quot;</span><span class="p">,</span> <span class="n">U_pos</span> <span class="o">&amp;</span> <span class="n">mesh</span><span class="p">.</span><span class="n">Sf</span><span class="p">());</span>    <span class="c1">// 定义正向插值速度通量为 phiv_{+} = U_{+} \cdot S_{f}</span>
        <span class="n">surfaceScalarField</span> <span class="n">phiv_neg</span><span class="p">(</span><span class="s">&quot;phiv_neg&quot;</span><span class="p">,</span> <span class="n">U_neg</span> <span class="o">&amp;</span> <span class="n">mesh</span><span class="p">.</span><span class="n">Sf</span><span class="p">());</span>    <span class="c1">// 定义反向插值速度通量为 phiv_{-} = U_{-} \cdot S_{f}</span>

        <span class="c1">// Make fluxes relative to mesh-motion</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">moving</span><span class="p">())</span>    <span class="c1">// 如果是动网格系统</span>
        <span class="p">{</span>
            <span class="n">phiv_pos</span> <span class="o">-=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">phi</span><span class="p">();</span>
            <span class="n">phiv_neg</span> <span class="o">-=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">phi</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">volScalarField</span> <span class="n">c</span><span class="p">(</span><span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">thermo</span><span class="p">.</span><span class="n">Cp</span><span class="p">()</span><span class="o">/</span><span class="n">thermo</span><span class="p">.</span><span class="n">Cv</span><span class="p">()</span><span class="o">*</span><span class="n">rPsi</span><span class="p">));</span>    <span class="c1">// 定义在网格体中心的标量场c，为 \sqrt{\frac{c_{p}}{c_{v}} \cdot \frac{1}{\psi}}</span>
        <span class="n">surfaceScalarField</span> <span class="n">cSf_pos</span>    <span class="c1">// 定义cSf的正向插值</span>
        <span class="p">(</span>
            <span class="s">&quot;cSf_pos&quot;</span><span class="p">,</span>
            <span class="n">interpolate</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">T</span><span class="p">.</span><span class="n">name</span><span class="p">())</span><span class="o">*</span><span class="n">mesh</span><span class="p">.</span><span class="n">magSf</span><span class="p">()</span>    <span class="c1">// 通过 c_{+} \cdot |S_{f}| 计算</span>
        <span class="p">);</span>
        <span class="n">surfaceScalarField</span> <span class="n">cSf_neg</span>    <span class="c1">// 定义cSf的反向插值</span>
        <span class="p">(</span>
            <span class="s">&quot;cSf_neg&quot;</span><span class="p">,</span>
            <span class="n">interpolate</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">neg</span><span class="p">,</span> <span class="n">T</span><span class="p">.</span><span class="n">name</span><span class="p">())</span><span class="o">*</span><span class="n">mesh</span><span class="p">.</span><span class="n">magSf</span><span class="p">()</span>    <span class="c1">// 通过 c_{-} \cdot |S_{f}| 计算</span>
        <span class="p">);</span>

        <span class="n">surfaceScalarField</span> <span class="n">ap</span>
        <span class="p">(</span>
            <span class="s">&quot;ap&quot;</span><span class="p">,</span>
            <span class="n">max</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">phiv_pos</span> <span class="o">+</span> <span class="n">cSf_pos</span><span class="p">,</span> <span class="n">phiv_neg</span> <span class="o">+</span> <span class="n">cSf_neg</span><span class="p">),</span> <span class="n">v_zero</span><span class="p">)</span>
        <span class="p">);</span>
        <span class="n">surfaceScalarField</span> <span class="n">am</span>
        <span class="p">(</span>
            <span class="s">&quot;am&quot;</span><span class="p">,</span>
            <span class="n">min</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">phiv_pos</span> <span class="o">-</span> <span class="n">cSf_pos</span><span class="p">,</span> <span class="n">phiv_neg</span> <span class="o">-</span> <span class="n">cSf_neg</span><span class="p">),</span> <span class="n">v_zero</span><span class="p">)</span>
        <span class="p">);</span>

        <span class="n">surfaceScalarField</span> <span class="n">a_pos</span><span class="p">(</span><span class="s">&quot;a_pos&quot;</span><span class="p">,</span> <span class="n">ap</span><span class="o">/</span><span class="p">(</span><span class="n">ap</span> <span class="o">-</span> <span class="n">am</span><span class="p">));</span>

        <span class="n">surfaceScalarField</span> <span class="n">amaxSf</span><span class="p">(</span><span class="s">&quot;amaxSf&quot;</span><span class="p">,</span> <span class="n">max</span><span class="p">(</span><span class="n">mag</span><span class="p">(</span><span class="n">am</span><span class="p">),</span> <span class="n">mag</span><span class="p">(</span><span class="n">ap</span><span class="p">)));</span>

        <span class="n">surfaceScalarField</span> <span class="n">aSf</span><span class="p">(</span><span class="s">&quot;aSf&quot;</span><span class="p">,</span> <span class="n">am</span><span class="o">*</span><span class="n">a_pos</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">fluxScheme</span> <span class="o">==</span> <span class="s">&quot;Tadmor&quot;</span><span class="p">)</span>    <span class="c1">// 如果通量计算方法选择为Tadmor，则aSf和a_pos的值将有所不同</span>
        <span class="p">{</span>
            <span class="n">aSf</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">amaxSf</span><span class="p">;</span>
            <span class="n">a_pos</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">surfaceScalarField</span> <span class="n">a_neg</span><span class="p">(</span><span class="s">&quot;a_neg&quot;</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">a_pos</span><span class="p">);</span>

        <span class="n">phiv_pos</span> <span class="o">*=</span> <span class="n">a_pos</span><span class="p">;</span>
        <span class="n">phiv_neg</span> <span class="o">*=</span> <span class="n">a_neg</span><span class="p">;</span>

        <span class="n">surfaceScalarField</span> <span class="n">aphiv_pos</span><span class="p">(</span><span class="s">&quot;aphiv_pos&quot;</span><span class="p">,</span> <span class="n">phiv_pos</span> <span class="o">-</span> <span class="n">aSf</span><span class="p">);</span>
        <span class="n">surfaceScalarField</span> <span class="n">aphiv_neg</span><span class="p">(</span><span class="s">&quot;aphiv_neg&quot;</span><span class="p">,</span> <span class="n">phiv_neg</span> <span class="o">+</span> <span class="n">aSf</span><span class="p">);</span>

        <span class="c1">// Reuse amaxSf for the maximum positive and negative fluxes estimated by the central scheme</span>
        <span class="n">amaxSf</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">mag</span><span class="p">(</span><span class="n">aphiv_pos</span><span class="p">),</span> <span class="n">mag</span><span class="p">(</span><span class="n">aphiv_neg</span><span class="p">));</span>

        <span class="cp">#include</span> <span class="cpf">&quot;centralCourantNo.H&quot;    // 计算库朗数</span><span class="cp"></span>

        <span class="k">if</span> <span class="p">(</span><span class="n">LTS</span><span class="p">)</span>    <span class="c1">// 如果使用当地局部时间步方法</span>
        <span class="p">{</span>
            <span class="cp">#include</span> <span class="cpf">&quot;setRDeltaT.H&quot;</span><span class="cp"></span>
            <span class="n">runTime</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Time = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">runTime</span><span class="p">.</span><span class="n">userTimeName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

        <span class="n">phi</span> <span class="o">=</span> <span class="n">aphiv_pos</span><span class="o">*</span><span class="n">rho_pos</span> <span class="o">+</span> <span class="n">aphiv_neg</span><span class="o">*</span><span class="n">rho_neg</span><span class="p">;</span>    <span class="c1">// 计算质量通量</span>

        <span class="n">surfaceVectorField</span> <span class="n">phiUp</span>    <span class="c1">// 定义在网格面中心的矢量场phiUp</span>
        <span class="p">(</span>
            <span class="p">(</span><span class="n">aphiv_pos</span><span class="o">*</span><span class="n">rhoU_pos</span> <span class="o">+</span> <span class="n">aphiv_neg</span><span class="o">*</span><span class="n">rhoU_neg</span><span class="p">)</span>
          <span class="o">+</span> <span class="p">(</span><span class="n">a_pos</span><span class="o">*</span><span class="n">p_pos</span> <span class="o">+</span> <span class="n">a_neg</span><span class="o">*</span><span class="n">p_neg</span><span class="p">)</span><span class="o">*</span><span class="n">mesh</span><span class="p">.</span><span class="n">Sf</span><span class="p">()</span>
        <span class="p">);</span>

        <span class="n">surfaceScalarField</span> <span class="n">phiEp</span>    <span class="c1">// 定义在网格面中心的标量场phiEp</span>
        <span class="p">(</span>
            <span class="s">&quot;phiEp&quot;</span><span class="p">,</span>
            <span class="n">aphiv_pos</span><span class="o">*</span><span class="p">(</span><span class="n">rho_pos</span><span class="o">*</span><span class="p">(</span><span class="n">e_pos</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">U_pos</span><span class="p">))</span> <span class="o">+</span> <span class="n">p_pos</span><span class="p">)</span>
          <span class="o">+</span> <span class="n">aphiv_neg</span><span class="o">*</span><span class="p">(</span><span class="n">rho_neg</span><span class="o">*</span><span class="p">(</span><span class="n">e_neg</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">U_neg</span><span class="p">))</span> <span class="o">+</span> <span class="n">p_neg</span><span class="p">)</span>
          <span class="o">+</span> <span class="n">aSf</span><span class="o">*</span><span class="n">p_pos</span> <span class="o">-</span> <span class="n">aSf</span><span class="o">*</span><span class="n">p_neg</span>
        <span class="p">);</span>

        <span class="c1">// Make flux for pressure-work absolute</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">moving</span><span class="p">())</span>    <span class="c1">// 如果是动网格系统还需要对phiEp进行修正</span>
        <span class="p">{</span>
            <span class="n">phiEp</span> <span class="o">+=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">phi</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="n">a_pos</span><span class="o">*</span><span class="n">p_pos</span> <span class="o">+</span> <span class="n">a_neg</span><span class="o">*</span><span class="n">p_neg</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">volScalarField</span> <span class="n">muEff</span><span class="p">(</span><span class="s">&quot;muEff&quot;</span><span class="p">,</span> <span class="n">rho</span><span class="o">*</span><span class="n">turbulence</span><span class="o">-&gt;</span><span class="n">nuEff</span><span class="p">());</span>    <span class="c1">// 定义在网格体中心的标量场muEff有效动力粘度场，通过密度乘以有效运动粘度场得到</span>
        <span class="n">volTensorField</span> <span class="n">tauMC</span><span class="p">(</span><span class="s">&quot;tauMC&quot;</span><span class="p">,</span> <span class="n">muEff</span><span class="o">*</span><span class="n">dev2</span><span class="p">(</span><span class="n">Foam</span><span class="o">::</span><span class="n">T</span><span class="p">(</span><span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">U</span><span class="p">))));</span>    <span class="c1">// 定义在网格体中心的张量场tauMC</span>

        <span class="c1">// --- Solve density</span>
        <span class="n">solve</span><span class="p">(</span><span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span> <span class="o">+</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phi</span><span class="p">));</span>    <span class="c1">// 通过连续性方程求解密度场</span>

        <span class="c1">// --- Solve momentum</span>
        <span class="n">solve</span><span class="p">(</span><span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">rhoU</span><span class="p">)</span> <span class="o">+</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phiUp</span><span class="p">));</span>    <span class="c1">// 通过动量方程求解rhoU，此时还没有考虑粘性</span>

        <span class="n">U</span><span class="p">.</span><span class="n">ref</span><span class="p">()</span> <span class="o">=</span> <span class="n">rhoU</span><span class="p">()</span><span class="o">/</span><span class="n">rho</span><span class="p">();</span>    <span class="c1">// 通过求解得到的rhoU和rho相除得到速度场参考值</span>
        <span class="n">U</span><span class="p">.</span><span class="n">correctBoundaryConditions</span><span class="p">();</span>
        <span class="n">rhoU</span><span class="p">.</span><span class="n">boundaryFieldRef</span><span class="p">()</span> <span class="o">==</span> <span class="n">rho</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()</span><span class="o">*</span><span class="n">U</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inviscid</span><span class="p">)</span>    <span class="c1">// 如果是有粘场，即具有动力粘度</span>
        <span class="p">{</span>
            <span class="n">solve</span>    <span class="c1">// 求解含有粘性项的动量方程</span>
            <span class="p">(</span>
                <span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span> <span class="o">-</span> <span class="n">fvc</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>
              <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">muEff</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>
              <span class="o">-</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">tauMC</span><span class="p">)</span>
            <span class="p">);</span>
            <span class="n">rhoU</span> <span class="o">=</span> <span class="n">rho</span><span class="o">*</span><span class="n">U</span><span class="p">;</span>    <span class="c1">// 更新rhoU场的值</span>
        <span class="p">}</span>

        <span class="c1">// --- Solve energy</span>
        <span class="n">surfaceScalarField</span> <span class="n">sigmaDotU</span>    <span class="c1">// 应力张量做功项</span>
        <span class="p">(</span>
            <span class="s">&quot;sigmaDotU&quot;</span><span class="p">,</span>
            <span class="p">(</span>
                <span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">muEff</span><span class="p">)</span><span class="o">*</span><span class="n">mesh</span><span class="p">.</span><span class="n">magSf</span><span class="p">()</span><span class="o">*</span><span class="n">fvc</span><span class="o">::</span><span class="n">snGrad</span><span class="p">(</span><span class="n">U</span><span class="p">)</span>
              <span class="o">+</span> <span class="n">fvc</span><span class="o">::</span><span class="n">dotInterpolate</span><span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">Sf</span><span class="p">(),</span> <span class="n">tauMC</span><span class="p">)</span>
            <span class="p">)</span>
          <span class="o">&amp;</span> <span class="p">(</span><span class="n">a_pos</span><span class="o">*</span><span class="n">U_pos</span> <span class="o">+</span> <span class="n">a_neg</span><span class="o">*</span><span class="n">U_neg</span><span class="p">)</span>
        <span class="p">);</span>

        <span class="n">solve</span>    <span class="c1">// 求解能量方程，得到rhoE</span>
        <span class="p">(</span>
            <span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">rhoE</span><span class="p">)</span>
          <span class="o">+</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phiEp</span><span class="p">)</span>
          <span class="o">-</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">sigmaDotU</span><span class="p">)</span>
        <span class="p">);</span>

        <span class="n">e</span> <span class="o">=</span> <span class="n">rhoE</span><span class="o">/</span><span class="n">rho</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">U</span><span class="p">);</span>    <span class="c1">// 通过上面得到的rhoE更新内能场e的值，采用总能量减去动能的方式计算</span>
        <span class="n">e</span><span class="p">.</span><span class="n">correctBoundaryConditions</span><span class="p">();</span>
        <span class="n">thermo</span><span class="p">.</span><span class="n">correct</span><span class="p">();</span>    <span class="c1">// 更新热物理模型中相关的参数</span>
        <span class="n">rhoE</span><span class="p">.</span><span class="n">boundaryFieldRef</span><span class="p">()</span> <span class="o">==</span> <span class="n">rho</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">U</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()));</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inviscid</span><span class="p">)</span>    <span class="c1">// 如果是有粘场，即具有动力粘度</span>
        <span class="p">{</span>
            <span class="n">solve</span>    <span class="c1">// 求解带有湍流粘度项的能量方程，得到能量场e</span>
            <span class="p">(</span>
                <span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="o">-</span> <span class="n">fvc</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
              <span class="o">+</span> <span class="n">thermophysicalTransport</span><span class="o">-&gt;</span><span class="n">divq</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>    <span class="c1">// 表示的是热通量项</span>
            <span class="p">);</span>
            <span class="n">thermo</span><span class="p">.</span><span class="n">correct</span><span class="p">();</span>                  <span class="c1">// 更新热物理模型中相关的参数</span>
            <span class="n">rhoE</span> <span class="o">=</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">e</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">U</span><span class="p">));</span>    <span class="c1">// 通过新计算得到的e更新rhoE的值</span>
        <span class="p">}</span>

        <span class="n">p</span><span class="p">.</span><span class="n">ref</span><span class="p">()</span> <span class="o">=</span> <span class="n">rho</span><span class="p">()</span><span class="o">/</span><span class="n">psi</span><span class="p">();</span>    <span class="c1">// 通过求解得到的密度场rho和可压缩性场psi相除得到压力场p</span>
        <span class="n">p</span><span class="p">.</span><span class="n">correctBoundaryConditions</span><span class="p">();</span>
        <span class="n">rho</span><span class="p">.</span><span class="n">boundaryFieldRef</span><span class="p">()</span> <span class="o">==</span> <span class="n">psi</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">()</span><span class="o">*</span><span class="n">p</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">();</span>

        <span class="n">turbulence</span><span class="o">-&gt;</span><span class="n">correct</span><span class="p">();</span>                 <span class="c1">// 更新湍流模型相关参数</span>
        <span class="n">thermophysicalTransport</span><span class="o">-&gt;</span><span class="n">correct</span><span class="p">();</span>    <span class="c1">// 更新热物理模型相关参数</span>

        <span class="n">runTime</span><span class="p">.</span><span class="n">write</span><span class="p">();</span>

        <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;ExecutionTime = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">runTime</span><span class="p">.</span><span class="n">elapsedCpuTime</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; s&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;  ClockTime = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">runTime</span><span class="p">.</span><span class="n">elapsedClockTime</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; s&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">nl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;End</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id44">
<h4>rhoCentralFoam的设置方法<a class="headerlink" href="#id44" title="永久链接至标题">¶</a></h4>
<p>根据其求解代码内容可知，当使用rhoCentralFoam求解器时，fvSchemes文件的内容为（使用laminar层流模型）：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>fluxScheme      Kurganov;

ddtSchemes
{
    default         none;
    general         Euler;
    ddt(rho)        $general;
    ddt(rhoU)       $general;
    U               $general;
    ddt(rho,U)      $general;
    ddt(rhoE)       $general;
    T               $general;
    ddt(rho,e)      $general;
    p               $general;
}

gradSchemes
{
    default         none;
    general         Gauss linear;
    grad(rho)       $general;
    grad(rhoU)      $general;
    grad(rPsi)      $general;
    grad(e)         $general;
    grad(c)         $general;
    grad(U)         $general;
}

divSchemes
{
    default         none;
    general         Gauss linear;
    div(tauMC)      $general;
}

laplacianSchemes
{
    default                 none;
    general                 Gauss linear limited corrected 0.5;
    laplacian(muEff,U)      $general;
    laplacian(alphahe,e)    $general;
}

interpolationSchemes
{
    default                     none;
    general                     linear;
    flux(rhoU)                  $general;
    reconstruct(rho)            vanLeer;
    reconstruct(U)              vanLeerV;
    reconstruct(T)              vanLeer;
    dotInterpolate(Sf,tauMC)    $general;
    interpolate(muEff)          $general;
}

snGradSchemes
{
    default         none;
    general         limited corrected 0.5;
    snGrad(U)       $general;
}
</pre></div>
</div>
<p>fvSolution文件的内容为（使用laminar层流模型）：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">solvers</span>
<span class="p">{</span>
    <span class="s">&quot;(rho|rhoU|rhoE)&quot;</span>
    <span class="p">{</span>
        <span class="n">solver</span>          <span class="n">smoothSolver</span><span class="p">;</span>
        <span class="n">smoother</span>        <span class="n">GaussSeidel</span><span class="p">;</span>
        <span class="n">nSweeps</span>         <span class="mi">2</span><span class="p">;</span>
        <span class="n">tolerance</span>       <span class="mf">1e-10</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">U</span>
    <span class="p">{</span>
        <span class="n">solver</span>          <span class="n">smoothSolver</span><span class="p">;</span>
        <span class="n">smoother</span>        <span class="n">GaussSeidel</span><span class="p">;</span>
        <span class="n">nSweeps</span>         <span class="mi">2</span><span class="p">;</span>
        <span class="n">tolerance</span>       <span class="mf">1e-09</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">e</span>
    <span class="p">{</span>
        <span class="n">solver</span>          <span class="n">smoothSolver</span><span class="p">;</span>
        <span class="n">smoother</span>        <span class="n">GaussSeidel</span><span class="p">;</span>
        <span class="n">nSweeps</span>         <span class="mi">2</span><span class="p">;</span>
        <span class="n">tolerance</span>       <span class="mf">1e-09</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="interfoam">
<h3>interFoam求解器<a class="headerlink" href="#interfoam" title="永久链接至标题">¶</a></h3>
<p>interFoam涉及的控制方程有：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\nabla \cdot \mathbf{U} = 0
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
  \frac{\partial \rho\mathbf{U}}{\partial t}
  + \nabla \cdot (\rho\mathbf{U})\mathbf{U}
  - \nabla \cdot [ \mu (\nabla\mathbf{U}) ]
= - \nabla p
  -  (\mathbf{g} \cdot \mathbf{x})\nabla\rho
  + \sigma_{T}\kappa_{\alpha}\nabla\alpha
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
  \frac{\partial \alpha }{\partial t}
  + \nabla \cdot \mathbf{U}\alpha
= 0
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; \rho = \alpha \rho_{1} + (1 - \alpha )\rho_{2}  \\
&amp; \mu = \alpha \mu_{1} + (1 - \alpha )\mu_{2}
\end{align}\end{split}\]</div>
<p>两相流系统被当成一个混合系统，它的密度场和粘度系数场都不再是常数，两相交界面也必须足够尖锐与足够大才能通过网格捕捉到，同时假设了两相交界面处速度场是连续的。可以看到，方程中考虑了重力场和表面张力的作用。</p>
<p>实际上，上面给出的第二个方程与平常看到的有所不同。一般看到的形式为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
  \frac{\partial \rho\mathbf{U}}{\partial t}
  + \nabla \cdot (\rho\mathbf{U})\mathbf{U}
  - \nabla \cdot [ \mu (\nabla\mathbf{U}) ]
= - \nabla P
  + \rho\mathbf{g}
  + \sigma_{T}\kappa_{\alpha}\nabla\alpha
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(P\)</span> 是总压(total pressure)，而在OpenFOAM中采用的压强 <span class="math notranslate nohighlight">\(p\)</span> 表示为总压减去液体静压：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
p = P - \rho \mathbf{g}\cdot\mathbf{x}
\end{align}\]</div>
<p>使用动压 <span class="math notranslate nohighlight">\(p\)</span> 的表达形式改写上面的方程：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
- \nabla P = - \nabla p - \nabla [\rho(\mathbf{g}\cdot\mathbf{x})]
           = - \nabla p - (\mathbf{g}\cdot\mathbf{x})\nabla \rho - \rho \nabla (\mathbf{g}\cdot\mathbf{x})
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
\nabla (\mathbf{g}\cdot\mathbf{x})
= \mathbf{g} \times (\nabla \times \mathbf{x})
  + \mathbf{x} \times (\nabla \times \mathbf{g})
  + (\mathbf{g} \cdot \nabla )\mathbf{x}
  + (\mathbf{x} \cdot \nabla )\mathbf{g}
\end{align}\]</div>
<p>根据 <span class="math notranslate nohighlight">\(\mathbf{g} \times (\nabla \times \mathbf{x})=0\)</span> ， <span class="math notranslate nohighlight">\(\mathbf{x} \times (\nabla \times \mathbf{g})=0\)</span> ， <span class="math notranslate nohighlight">\((\mathbf{g} \cdot \nabla )\mathbf{x}=\mathbf{g}\)</span> ， <span class="math notranslate nohighlight">\((\mathbf{x} \cdot \nabla )\mathbf{g}=0\)</span> 可知 <span class="math notranslate nohighlight">\(\nabla (\mathbf{g}\cdot\mathbf{x}) = \mathbf{g}\)</span> ，从而</p>
<div class="math notranslate nohighlight">
\[\begin{align}
-\nabla P = -\nabla p - \nabla [\rho(\mathbf{g}\cdot \mathbf{x})]
          = -\nabla p - (\mathbf{g}\cdot \mathbf{x}) \nabla \rho - \rho\mathbf{g}
\end{align}\]</div>
<p>最终就得到了OpenFOAM中所采用的方程形式。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">正因为使用了 <span class="math notranslate nohighlight">\(\nabla \rho\)</span> 的形式来描述重力项，在遇到水气界面等密度剧烈变化的情况时，会产生非常明显的数值耗散和误差。除此之外，在表面张力项，由于曲率 <span class="math notranslate nohighlight">\(\kappa_{\alpha}\)</span> 的评估有时会有较大的误差，从而导致有时会在周边产生额外的速度场来平衡表面曲率误差。</p>
</div>
<p>interFoam求解器求解的步骤可以概括为：</p>
<ol class="arabic simple">
<li>求解输运方程得到体积相分数 <span class="math notranslate nohighlight">\(\alpha\)</span> ，不过在实现的时候方程额外添加了一项，修改成了</li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{align}
  \frac{\partial \alpha }{\partial t}
+ \nabla \cdot \mathbf{U}\alpha
+ \nabla \cdot (\mathbf{U}_{r}\alpha (1-\alpha ) )
= 0
\end{align}\]</div>
<ol class="arabic simple" start="2">
<li>修正流体和界面的参数，即计算 <span class="math notranslate nohighlight">\(\rho\)</span> 和 <span class="math notranslate nohighlight">\(\mu\)</span> 。</li>
<li>使用PISO算法求解速度场和压力场，但与icoFoam不同的是添加了体积力。</li>
</ol>
<div class="section" id="interfoam-c">
<h4>interFoam.C<a class="headerlink" href="#interfoam-c" title="永久链接至标题">¶</a></h4>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;fvCFD.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;interfaceCompression.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;CMULES.H&quot;                    // MULS算法</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;EulerDdtScheme.H&quot;            // 欧拉离散格式</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;localEulerDdtScheme.H&quot;       // 局部欧拉离散格式</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;CrankNicolsonDdtScheme.H&quot;    // CrankNicolson离散格式</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;subCycle.H&quot;                  // 亚循环。由于alpha是显式离散的，为了减少计算时间而引入</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;immiscibleIncompressibleTwoPhaseMixture.H&quot;    // 物理模型</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;noPhaseChange.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;incompressibleInterPhaseTransportModel.H&quot;     // 湍流头文件</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;pimpleControl.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;pressureReference.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;fvModels.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;fvConstraints.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;CorrectPhi.H&quot;          // 动量修正</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;fvcSmooth.H&quot;</span><span class="cp"></span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="cp">#include</span> <span class="cpf">&quot;postProcess.H&quot;</span><span class="cp"></span>

    <span class="cp">#include</span> <span class="cpf">&quot;setRootCaseLists.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createTime.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createMesh.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;initContinuityErrs.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createDyMControls.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createFields.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createFieldRefs.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;initCorrectPhi.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createUfIfPresent.H&quot;</span><span class="cp"></span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LTS</span><span class="p">)</span>    <span class="c1">// 如果不采用局部欧拉格式</span>
    <span class="p">{</span>
        <span class="cp">#include</span> <span class="cpf">&quot;CourantNo.H&quot;           // 读取库朗数</span><span class="cp"></span>
        <span class="cp">#include</span> <span class="cpf">&quot;setInitialDeltaT.H&quot;    // 设置初始的DeltaT</span><span class="cp"></span>
    <span class="p">}</span>

    <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Starting time loop</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">pimple</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">runTime</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="cp">#include</span> <span class="cpf">&quot;readDyMControls.H&quot;</span><span class="cp"></span>

        <span class="k">if</span> <span class="p">(</span><span class="n">LTS</span><span class="p">)</span>    <span class="c1">// 如果使用局部欧拉格式</span>
        <span class="p">{</span>
            <span class="cp">#include</span> <span class="cpf">&quot;setRDeltaT.H&quot;</span><span class="cp"></span>
        <span class="p">}</span>
        <span class="k">else</span>        <span class="c1">// 如果不使用局部欧拉格式</span>
        <span class="p">{</span>
            <span class="cp">#include</span> <span class="cpf">&quot;CourantNo.H&quot;</span><span class="cp"></span>
            <span class="cp">#include</span> <span class="cpf">&quot;alphaCourantNo.H&quot;</span><span class="cp"></span>
            <span class="cp">#include</span> <span class="cpf">&quot;setDeltaT.H&quot;</span><span class="cp"></span>
        <span class="p">}</span>

        <span class="n">fvModels</span><span class="p">.</span><span class="n">preUpdateMesh</span><span class="p">();</span>

        <span class="c1">// Store divU from the previous mesh so that it can be mapped</span>
        <span class="c1">// and used in correctPhi to ensure the corrected phi has the</span>
        <span class="c1">// same divergence</span>
        <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volScalarField</span><span class="o">&gt;</span> <span class="n">divU</span><span class="p">;</span>

        <span class="k">if</span>
        <span class="p">(</span>
            <span class="n">correctPhi</span>
         <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isType</span><span class="o">&lt;</span><span class="n">twoPhaseChangeModels</span><span class="o">::</span><span class="n">noPhaseChange</span><span class="o">&gt;</span><span class="p">(</span><span class="n">phaseChange</span><span class="p">)</span>
         <span class="o">&amp;&amp;</span> <span class="n">mesh</span><span class="p">.</span><span class="n">topoChanged</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// Construct and register divU for correctPhi</span>
            <span class="n">divU</span> <span class="o">=</span> <span class="n">new</span> <span class="n">volScalarField</span>
            <span class="p">(</span>
                <span class="s">&quot;divU0&quot;</span><span class="p">,</span>
                <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">fvc</span><span class="o">::</span><span class="n">absolute</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">U</span><span class="p">))</span>
            <span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Update the mesh for topology change, mesh to mesh mapping</span>
        <span class="kt">bool</span> <span class="n">topoChanged</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">update</span><span class="p">();</span>

        <span class="c1">// Do not apply previous time-step mesh compression flux</span>
        <span class="c1">// if the mesh topology changed</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">topoChanged</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">talphaPhi1Corr0</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">runTime</span><span class="o">++</span><span class="p">;</span>

        <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Time = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">runTime</span><span class="p">.</span><span class="n">userTimeName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

        <span class="c1">// --- Pressure-velocity PIMPLE corrector loop</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">pimple</span><span class="p">.</span><span class="n">loop</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pimple</span><span class="p">.</span><span class="n">firstPimpleIter</span><span class="p">()</span> <span class="o">||</span> <span class="n">moveMeshOuterCorrectors</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span>
                <span class="p">(</span>
                    <span class="n">correctPhi</span>
                 <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isType</span><span class="o">&lt;</span><span class="n">twoPhaseChangeModels</span><span class="o">::</span><span class="n">noPhaseChange</span><span class="o">&gt;</span><span class="p">(</span><span class="n">phaseChange</span><span class="p">)</span>
                 <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">divU</span><span class="p">.</span><span class="n">valid</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="p">{</span>
                    <span class="c1">// Construct and register divU for correctPhi</span>
                    <span class="n">divU</span> <span class="o">=</span> <span class="n">new</span> <span class="n">volScalarField</span>
                    <span class="p">(</span>
                        <span class="s">&quot;divU0&quot;</span><span class="p">,</span>
                        <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">fvc</span><span class="o">::</span><span class="n">absolute</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">U</span><span class="p">))</span>
                    <span class="p">);</span>
                <span class="p">}</span>

                <span class="c1">// Move the mesh</span>
                <span class="n">mesh</span><span class="p">.</span><span class="n">move</span><span class="p">();</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">changing</span><span class="p">())</span>
                <span class="p">{</span>
                    <span class="n">gh</span> <span class="o">=</span> <span class="p">(</span><span class="n">g</span> <span class="o">&amp;</span> <span class="n">mesh</span><span class="p">.</span><span class="n">C</span><span class="p">())</span> <span class="o">-</span> <span class="n">ghRef</span><span class="p">;</span>
                    <span class="n">ghf</span> <span class="o">=</span> <span class="p">(</span><span class="n">g</span> <span class="o">&amp;</span> <span class="n">mesh</span><span class="p">.</span><span class="n">Cf</span><span class="p">())</span> <span class="o">-</span> <span class="n">ghRef</span><span class="p">;</span>

                    <span class="n">MRF</span><span class="p">.</span><span class="n">update</span><span class="p">();</span>

                    <span class="k">if</span> <span class="p">(</span><span class="n">correctPhi</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="cp">#include</span> <span class="cpf">&quot;correctPhi.H&quot;</span><span class="cp"></span>
                    <span class="p">}</span>

                    <span class="n">mixture</span><span class="p">.</span><span class="n">correct</span><span class="p">();</span>

                    <span class="k">if</span> <span class="p">(</span><span class="n">checkMeshCourantNo</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="cp">#include</span> <span class="cpf">&quot;meshCourantNo.H&quot;</span><span class="cp"></span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="n">divU</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="n">fvModels</span><span class="p">.</span><span class="n">correct</span><span class="p">();</span>

            <span class="n">surfaceScalarField</span> <span class="n">rhoPhi</span>
            <span class="p">(</span>
                <span class="n">IOobject</span>
                <span class="p">(</span>
                    <span class="s">&quot;rhoPhi&quot;</span><span class="p">,</span>
                    <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>
                    <span class="n">mesh</span>
                <span class="p">),</span>
                <span class="n">mesh</span><span class="p">,</span>
                <span class="n">dimensionedScalar</span><span class="p">(</span><span class="n">dimMass</span><span class="o">/</span><span class="n">dimTime</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">);</span>

            <span class="cp">#include</span> <span class="cpf">&quot;alphaControls.H&quot;</span><span class="cp"></span>
            <span class="cp">#include</span> <span class="cpf">&quot;alphaEqnSubCycle.H&quot;    // 求解alpha</span><span class="cp"></span>

            <span class="n">turbulence</span><span class="p">.</span><span class="n">correctPhasePhi</span><span class="p">();</span>

            <span class="n">mixture</span><span class="p">.</span><span class="n">correct</span><span class="p">();</span>

            <span class="cp">#include</span> <span class="cpf">&quot;UEqn.H&quot;    // 求解U</span><span class="cp"></span>

            <span class="c1">// --- Pressure corrector loop</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">pimple</span><span class="p">.</span><span class="n">correct</span><span class="p">())</span>
            <span class="p">{</span>
                <span class="cp">#include</span> <span class="cpf">&quot;pEqn.H&quot;    // 求解p</span><span class="cp"></span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">pimple</span><span class="p">.</span><span class="n">turbCorr</span><span class="p">())</span>
            <span class="p">{</span>
                <span class="n">turbulence</span><span class="p">.</span><span class="n">correct</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">runTime</span><span class="p">.</span><span class="n">write</span><span class="p">();</span>

        <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;ExecutionTime = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">runTime</span><span class="p">.</span><span class="n">elapsedCpuTime</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; s&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;  ClockTime = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">runTime</span><span class="p">.</span><span class="n">elapsedClockTime</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; s&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">nl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;End</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="interfoamueqn-h">
<h4>interFoam的UEqn.H<a class="headerlink" href="#interfoamueqn-h" title="永久链接至标题">¶</a></h4>
<p>动量预测步中，考虑线性方程组：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
A := \frac{\partial \rho[\mathbf{U}]}{\partial t}
     + \nabla \cdot (\phi [\mathbf{U}]_{f})
     - \nabla \cdot (\mu \nabla [\mathbf{U}])
\end{align}\]</div>
<p>于是动量方程可以离散成</p>
<div class="math notranslate nohighlight">
\[\begin{align}
A_{D}\mathbf{U} = A_{H} + \text{reconstruct}\bigg [ |\mathbf{S}_{f}| \Big( (\sigma_{T}\kappa_{\alpha })_{f}\nabla _{f}^{\perp}\alpha -(\mathbf{g}\cdot\mathbf{x})_{f}\nabla _{f}^{\perp}\rho -\nabla _{f}^{\perp}\rho  \Big) \bigg ]
\end{align}\]</div>
<p>可以看到，为了避免两相密度差距大造成速度场的奇怪振荡，使用了reconstruct操作。这个操作显式地通过面通量 <span class="math notranslate nohighlight">\(a_{f}\)</span> 建立了网格面中心的场 <span class="math notranslate nohighlight">\(\mathbf{a}\)</span> ，具体计算方法为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\mathbf{a} = \left ( \sum_{f}\mathbf{n}_{f} \otimes \mathbf{S}_{f} \right )^{-1}\cdot \left ( \sum_{f}\mathbf{n}_{f}(\mathbf{S}_{f}\cdot \mathbf{a}_{f} ) \right )
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\mathbf{n}_{f}\)</span> 是网格面的单位矢量， <span class="math notranslate nohighlight">\(\otimes\)</span> 表示外积。</p>
<p>上面的式子是基于这样的假设：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\sum_{f}\mathbf{n}_{f}(\mathbf{S}_{f}\cdot\mathbf{a})
=  \sum_{f}\mathbf{n}_{f}(\mathbf{S}_{f}\cdot\mathbf{a}_{f})
\end{align}\]</div>
<p>结合关系 <span class="math notranslate nohighlight">\(\mathbf{n}_{f}(\mathbf{S}_{f}\cdot\mathbf{a}) = (\mathbf{n}_{f}\otimes\mathbf{S}_{f})\cdot\mathbf{a}\)</span> ，从而上面这个方程可以写成</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\sum_{f}(\mathbf{n}_{f}\otimes\mathbf{S}_{f})\cdot\mathbf{a}
=  \sum_{f}\mathbf{n}_{f}(\mathbf{S}_{f}\cdot\mathbf{a}_{f})
\end{align}\]</div>
<p>根据外积与内积的性质，可以将求和符号放到括号内部：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\sum_{f}\big( (\mathbf{n}_{f} \otimes \mathbf{S}_{f})\cdot \mathbf{a} \big)
= \left ( \sum_{f}(\mathbf{n}_{f} \otimes \mathbf{S}_{f}) \right ) \cdot \mathbf{a}
\end{align}\]</div>
<p>求逆矩阵移项就得到了 <span class="math notranslate nohighlight">\(\mathbf{a}\)</span> 的表达式。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">MRF</span><span class="p">.</span><span class="n">correctBoundaryVelocity</span><span class="p">(</span><span class="n">U</span><span class="p">);</span>

<span class="n">fvVectorMatrix</span> <span class="nf">UEqn</span>
<span class="p">(</span>
    <span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span> <span class="o">+</span> <span class="n">fvm</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">rhoPhi</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>
  <span class="o">+</span> <span class="n">MRF</span><span class="p">.</span><span class="n">DDt</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>
  <span class="o">+</span> <span class="n">turbulence</span><span class="p">.</span><span class="n">divDevTau</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>
 <span class="o">==</span>
   <span class="n">phaseChange</span><span class="p">.</span><span class="n">SU</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">rhoPhi</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>
 <span class="o">+</span> <span class="n">fvModels</span><span class="p">.</span><span class="n">source</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>
<span class="p">);</span>

<span class="n">UEqn</span><span class="p">.</span><span class="n">relax</span><span class="p">();</span>

<span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">UEqn</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">pimple</span><span class="p">.</span><span class="n">momentumPredictor</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">solve</span>
    <span class="p">(</span>
        <span class="n">UEqn</span>
     <span class="o">==</span>
        <span class="n">fvc</span><span class="o">::</span><span class="n">reconstruct</span>
        <span class="p">(</span>
            <span class="p">(</span>
                <span class="n">mixture</span><span class="p">.</span><span class="n">surfaceTensionForce</span><span class="p">()</span>    <span class="c1">// 表面张力项</span>
              <span class="o">-</span> <span class="n">ghf</span><span class="o">*</span><span class="n">fvc</span><span class="o">::</span><span class="n">snGrad</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>             <span class="c1">// 重力项</span>
              <span class="o">-</span> <span class="n">fvc</span><span class="o">::</span><span class="n">snGrad</span><span class="p">(</span><span class="n">p_rgh</span><span class="p">)</span>               <span class="c1">// 压强梯度项</span>
            <span class="p">)</span> <span class="o">*</span> <span class="n">mesh</span><span class="p">.</span><span class="n">magSf</span><span class="p">()</span>                     <span class="c1">// 面矢量绝对值</span>
        <span class="p">)</span>
    <span class="p">);</span>

    <span class="n">fvConstraints</span><span class="p">.</span><span class="n">constrain</span><span class="p">(</span><span class="n">U</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="interfoampeqn-h">
<h4>interFoam的pEqn.H<a class="headerlink" href="#interfoampeqn-h" title="永久链接至标题">¶</a></h4>
<p>压力方程离散成了</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\nabla \cdot \left ( \frac{1}{A_{D}} \big(\nabla p + (\mathbf{g}\cdot\mathbf{x})\nabla \rho - \sigma_{T}\kappa_{\alpha}\nabla \alpha \big)\right )
= \nabla \cdot \left ( \frac{A_{H}}{A_{D}} \right )
\end{align}\]</div>
<p>在求解动量方程时先不考虑压强的贡献得到通量：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\phi^{*} = \left ( \frac{A_{H}}{A_{D}}\right )_{f}\cdot \mathbf{S}_{f}
+ \phi_{g}
+ \phi_{e}
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
\phi_{g}=\left ( \frac{1}{A_{D}}\right )_{f}|\mathbf{S}_{f}| \bigg( (\sigma _{T}\kappa_{\alpha})_{f} \nabla _{f}^{\perp}\alpha - (\mathbf{g}\cdot\mathbf{x})_{f}\nabla_{f}^{\perp}\rho \bigg)
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
\phi_{e} = \frac{\gamma \rho}{A_{D}\Delta t}(\phi_{o}-\mathbf{S}_{f}\cdot\mathbf{U}_{f,o} )
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
\gamma = 1 - \min\left ( \frac{|\phi_{o}-\mathbf{U}_{f,o}\cdot\mathbf{S}_{f}|}{|\phi_{o}|+\varepsilon } ,1 \right )
\end{align}\]</div>
<p>此时的 <span class="math notranslate nohighlight">\(\phi^{*}\)</span> 还不满足连续性方程，接下来需要进行压力修正，也就需要求解压力方程：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\nabla \cdot \left ( \frac{\nabla [p]}{A_{D}}\right )
= \nabla \cdot \left ( \frac{A_{H}}{A_{D}} - (\mathbf{g} \cdot \mathbf{x})\nabla \rho +\sigma_{T}\kappa_{\alpha}\nabla \alpha  \right )
\end{align}\]</div>
<p>于是可以修正通量为 <span class="math notranslate nohighlight">\(\phi=\phi^{*}+\phi^{**}\)</span> ，其中</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\phi^{**}=-|\mathbf{S}_{f}|\cdot \bigg( \big( \frac{1}{A_{D}}\big)_{f}\nabla _{f}^{\perp}p \bigg)
\end{align}\]</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<ul class="last simple">
<li>使用 <code class="code docutils literal notranslate"><span class="pre">rAU</span></code> 表示 <span class="math notranslate nohighlight">\(\frac{1}{A_{D}}\)</span> ；</li>
<li>使用 <code class="code docutils literal notranslate"><span class="pre">rAUf</span></code> 表示 <span class="math notranslate nohighlight">\(\left ( \frac{1}{A_{D}}\right )_{f}\)</span> ；</li>
<li>使用 <code class="code docutils literal notranslate"><span class="pre">HbyA</span></code> 表示 <span class="math notranslate nohighlight">\(\frac{A_{H}}{A_{D}}\)</span> ；</li>
<li>使用 <code class="code docutils literal notranslate"><span class="pre">phiHbyA</span></code> 表示 <span class="math notranslate nohighlight">\(\left ( \frac{A_{H}}{A_{D}}\right )_{f}\cdot \mathbf{S}_{f} + \phi_{e}\)</span> ；</li>
<li>使用 <code class="code docutils literal notranslate"><span class="pre">phig</span></code> 表示 <span class="math notranslate nohighlight">\(\phi_{g}\)</span> ；</li>
<li>使用 <code class="code docutils literal notranslate"><span class="pre">p_rghEqn</span></code> 表示 <span class="math notranslate nohighlight">\(\nabla \cdot \left ( \frac{A_{H}}{A_{D}} - (\mathbf{g} \cdot \mathbf{x})\nabla \rho +\sigma_{T}\kappa_{\alpha}\nabla \alpha  \right ) - \nabla \cdot \left ( \frac{\nabla [p]}{A_{D}}\right ) = S_{p}\)</span> ，注意这里添加了额外项 <code class="code docutils literal notranslate"><span class="pre">Sp_rgh</span></code> ；</li>
<li>使用 <code class="code docutils literal notranslate"><span class="pre">p_rghEqn.flux()</span></code> 表示 <span class="math notranslate nohighlight">\(\phi^{**}\)</span> ；</li>
</ul>
</div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span>{
    if (rAU.valid())
    {
        rAU.ref() = 1.0/UEqn.A();
    }
    else
    {
        rAU = 1.0/UEqn.A();
    }

    surfaceScalarField rAUf(&quot;rAUf&quot;, fvc::interpolate(rAU()));
    volVectorField HbyA(constrainHbyA(rAU()*UEqn.H(), U, p_rgh));
    surfaceScalarField phiHbyA
    (
        &quot;phiHbyA&quot;,
        fvc::flux(HbyA)    // phi^{*}的第一项
      + MRF.zeroFilter(fvc::interpolate(rho*rAU())*fvc::ddtCorr(U, phi, Uf))    // 表示的是\phi_{e}
    );
    MRF.makeRelative(phiHbyA);

    if (p_rgh.needReference())
    {
        fvc::makeRelative(phiHbyA, U);
        adjustPhi(phiHbyA, U, p_rgh);
        fvc::makeAbsolute(phiHbyA, U);
    }

    surfaceScalarField phig
    (
        (
            mixture.surfaceTensionForce()
          - ghf*fvc::snGrad(rho)
        )*rAUf*mesh.magSf()
    );

    phiHbyA += phig;    // 此时phiHbyA就表示成了完整的phi^{*}

    // Update the pressure BCs to ensure flux consistency
    constrainPressure(p_rgh, U, phiHbyA, rAUf, MRF);

    // Cache the phase change pressure source
    fvScalarMatrix Sp_rgh(phaseChange.Sp_rgh(rho, gh, p_rgh));

    while (pimple.correctNonOrthogonal())
    {
        fvScalarMatrix p_rghEqn    // 构建压力方程
        (
            fvc::div(phiHbyA) - fvm::laplacian(rAUf, p_rgh)
         == Sp_rgh
        );

        p_rghEqn.setReference
        (
            pressureReference.refCell(),
            getRefCellValue(p_rgh, pressureReference.refCell())
        );

        p_rghEqn.solve();    // 求解出压力p_rgh

        if (pimple.finalNonOrthogonalIter())
        {
            phi = phiHbyA + p_rghEqn.flux();    // 得到最终修正后的满足连续性方程的通量

            p_rgh.relax();

            U = HbyA + rAU()*fvc::reconstruct((phig + p_rghEqn.flux())/rAUf);    // 求解最终的速度场
            U.correctBoundaryConditions();
            fvConstraints.constrain(U);
        }
    }

    #include &quot;continuityErrs.H&quot;

    // Correct Uf if the mesh is moving
    fvc::correctUf(Uf, U, phi, MRF);

    // Make the fluxes relative to the mesh motion
    fvc::makeRelative(phi, U);

    p == p_rgh + rho*gh;

    if (p_rgh.needReference())
    {
        p += dimensionedScalar
        (
            &quot;p&quot;,
            p.dimensions(),
            pressureReference.refValue()
          - getRefCellValue(p, pressureReference.refCell())
        );
        p_rgh = p - rho*gh;
    }

    if (!correctPhi)
    {
        rAU.clear();
    }
}
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id45">
<h2>自定义求解器<a class="headerlink" href="#id45" title="永久链接至标题">¶</a></h2>
<div class="section" id="passivescalarfoam">
<h3>passiveScalarFoam<a class="headerlink" href="#passivescalarfoam" title="永久链接至标题">¶</a></h3>
<p>该求解器基于icoFoam进行修改。icoFoam求解器涉及的控制方程如下：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\nabla \cdot \mathbf{U} = 0
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\partial \mathbf{U}}{\partial t}
+ \nabla \mathbf{U}\mathbf{U}
- \nabla \cdot [ \nu (\nabla\mathbf{U}) ]
= - \nabla p
\end{align}\]</div>
<p>现在额外添加一个基于求解出的速度场的无源标量传输方程：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\partial s}{\partial t} + \nabla \cdot (\mathbf{U}s) = 0
\end{align}\]</div>
<p>为了不污染OpenFOAM源程序，需要在自己的run文件夹内建立与OpenFOAM相同的求解器文件结构。在run文件夹内，建立applications/solvers/incompressible文件结构，然后将icoFoam文件夹复制到自己建立的该结构当中。</p>
<p>接下来修改各文件名字：修改该文件夹的名字为passiveScalarFoam，修改icoFoam.C为passiveScalarFoam.C，然后进入Make/files进行修改，其中第一句指定所需编译文件，第二句指定求解器存放位置：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>passiveScalarFoam.C

<span class="nv">EXE</span> <span class="o">=</span> <span class="k">$(</span>FOAM_USER_APPBIN<span class="k">)</span>/passiveScalarFoam
</pre></div>
</div>
<p>此时进入终端运行wclean和wmake验证更改名字没有导致编译错误。</p>
<p>接下来进入createFields.H添加定义在体中心的标量场 <span class="math notranslate nohighlight">\(s\)</span> 。由于定义在体中心的标量场与压力场p是类似的，所以可以直接复制p的内容并修改名字为s作为标量场s的信息(直接放到原文件所有内容的最后即可)：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Reading field s</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">volScalarField</span> <span class="nf">s</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;s&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">MUST_READ</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">AUTO_WRITE</span>
    <span class="p">),</span>
    <span class="n">mesh</span>
<span class="p">);</span>
</pre></div>
</div>
<p>保险起见可以再次运行wmake进行编译验证没有任何错误发生。</p>
<p>接下来进入passiveScalarFoam.C进行求解方程的修改。在原PISO算法求解完U和p之后，进行runTime.write()之前，添加下面所需求解的方程：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">solve</span><span class="p">(</span><span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="n">fvm</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span><span class="n">s</span><span class="p">));</span>
</pre></div>
</div>
<p>然后运行wmake进行编译，如此就完成了求解器的修改。接下来可以使用cavity算例来验证一下求解情况。</p>
<p>修改cavity的名字为passiveCavity以区分原本用于icoFoam的算例。进入0文件建立s文件，因为s和p相似，可以直接复制p文件并修改其相应的名字，而量纲可以修改为无量纲，初始条件与边界条件保持相同：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">FoamFile</span>
<span class="p">{</span>
    <span class="n">format</span>      <span class="n">ascii</span><span class="p">;</span>
    <span class="n">class</span>       <span class="n">volScalarField</span><span class="p">;</span>
    <span class="n">object</span>      <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">dimensions</span>      <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">];</span>

<span class="n">internalField</span>   <span class="n">uniform</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">boundaryField</span>
<span class="p">{</span>
    <span class="n">movingWall</span>
    <span class="p">{</span>
        <span class="n">type</span>            <span class="n">zeroGradient</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">fixedWalls</span>
    <span class="p">{</span>
        <span class="n">type</span>            <span class="n">zeroGradient</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">frontAndBack</span>
    <span class="p">{</span>
        <span class="n">type</span>            <span class="n">empty</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>接下来进入fvSchemes设置额外添加方程的离散格式：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">divSchemes</span>
<span class="p">{</span>
    <span class="k">default</span>         <span class="n">none</span><span class="p">;</span>
    <span class="n">div</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span><span class="n">U</span><span class="p">)</span>      <span class="n">Gauss</span> <span class="n">linear</span><span class="p">;</span>
    <span class="n">div</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>      <span class="n">Gauss</span> <span class="n">linearUpwind</span> <span class="n">grad</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>然后进入fvSolution设置所添加方程离散后线性方程组的求解方法：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">s</span>
<span class="p">{</span>
    <span class="n">solver</span>          <span class="n">smoothSolver</span><span class="p">;</span>
    <span class="n">smoother</span>        <span class="n">symGaussSeidel</span><span class="p">;</span>
    <span class="n">tolerance</span>       <span class="mf">1e-05</span><span class="p">;</span>
    <span class="n">relTol</span>          <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>同时修改controlDict的相关内容，然后运行blockMesh和passiveScalarFoam即可。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">在后处理过程中可以发现，虽然所添加方程只有对流项，但是结果却呈现出扩散项的现象。这其实是数值耗散的问题。针对这一问题可以参考interFoam求解器是如何应对数值耗散问题的。</p>
</div>
</div>
<div class="section" id="teminterfoam">
<h3>temInterFoam<a class="headerlink" href="#teminterfoam" title="永久链接至标题">¶</a></h3>
<p>该求解基于interFoam进行修改。interFoam涉及的控制方程有：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\nabla \cdot \mathbf{U} = 0
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
  \frac{\partial \rho\mathbf{U}}{\partial t}
  + \nabla \cdot (\rho\mathbf{U})\mathbf{U}
  - \nabla \cdot [ \mu (\nabla\mathbf{U}) ]
= - \nabla p
  -  (\mathbf{g} \cdot \mathbf{x})\nabla\rho
  + \sigma_{T}\kappa_{\alpha}\nabla\alpha
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
  \frac{\partial \alpha }{\partial t}
  + \nabla \cdot \mathbf{U}\alpha
= 0
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp; \rho = \alpha \rho_{1} + (1 - \alpha )\rho_{2}  \\
&amp; \mu = \alpha \mu_{1} + (1 - \alpha )\mu_{2}
\end{align}\end{split}\]</div>
<p>将要添加的控制方程需要求解温度的输运过程：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
  \frac{\partial \rho T}{\partial t}
  + \nabla \cdot (\rho \mathbf{U} T)
  - \nabla \cdot (D_{\text{eff}} \nabla T)
= 0
\end{align}\]</div>
<p>有效扩散系数 <span class="math notranslate nohighlight">\(D_{\text{eff}}\)</span> 表示为</p>
<div class="math notranslate nohighlight">
\[\begin{align}
  D_{\text{eff}}
= \frac{\alpha k_{1}}{C_{\text{v1}}}
  + \frac{(1 - \alpha )k_{2}}{C_{\text{v2}}}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(k_{1},k_{2},C_{v1},C_{v2}\)</span> 代表传导系数和两种流相的热容量。</p>
<p>新建文件结构applications/solvers/multiphase，将OpenFOAM的interFoam文件夹复制到该处，并修改名字为temInterFoam。进入该文件夹，修改interFoam.C名字为temInterFoam.C，并修改Make/files文件的内容为：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>temInterFoam.C

<span class="nv">EXE</span> <span class="o">=</span> <span class="k">$(</span>FOAM_USER_APPBIN<span class="k">)</span>/temInterFoam
</pre></div>
</div>
<p>然后运行wclean和wmake验证更改名字没有造成编译错误。</p>
<p>进入createFields.H文件，在最后添加传导系数的内容：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">dimensionedScalar</span> <span class="nf">k1</span>
<span class="p">(</span>
    <span class="s">&quot;k&quot;</span><span class="p">,</span>
    <span class="n">dimensionSet</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>
    <span class="n">mixture</span><span class="p">.</span><span class="n">subDict</span>
    <span class="p">(</span>
        <span class="n">mixture</span><span class="p">.</span><span class="n">phase1Name</span><span class="p">()</span>
    <span class="p">).</span><span class="n">lookup</span><span class="p">(</span><span class="s">&quot;k&quot;</span><span class="p">)</span>
<span class="p">);</span>

<span class="n">dimensionedScalar</span> <span class="nf">k2</span>
<span class="p">(</span>
    <span class="s">&quot;k&quot;</span><span class="p">,</span>
    <span class="n">dimensionSet</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>
    <span class="n">mixture</span><span class="p">.</span><span class="n">subDict</span>
    <span class="p">(</span>
        <span class="n">mixture</span><span class="p">.</span><span class="n">phase2Name</span><span class="p">()</span>
    <span class="p">).</span><span class="n">lookup</span><span class="p">(</span><span class="s">&quot;k&quot;</span><span class="p">)</span>
<span class="p">);</span>

<span class="n">dimensionedScalar</span> <span class="nf">Cv1</span>
<span class="p">(</span>
    <span class="s">&quot;Cv&quot;</span><span class="p">,</span>
    <span class="n">dimensionSet</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>
    <span class="n">mixture</span><span class="p">.</span><span class="n">subDict</span>
    <span class="p">(</span>
        <span class="n">mixture</span><span class="p">.</span><span class="n">phase1Name</span><span class="p">()</span>
    <span class="p">).</span><span class="n">lookup</span><span class="p">(</span><span class="s">&quot;Cv&quot;</span><span class="p">)</span>
<span class="p">);</span>

<span class="n">dimensionedScalar</span> <span class="nf">Cv2</span>
<span class="p">(</span>
    <span class="s">&quot;Cv&quot;</span><span class="p">,</span>
    <span class="n">dimensionSet</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>
    <span class="n">mixture</span><span class="p">.</span><span class="n">subDict</span>
    <span class="p">(</span>
        <span class="n">mixture</span><span class="p">.</span><span class="n">phase2Name</span><span class="p">()</span>
    <span class="p">).</span><span class="n">lookup</span><span class="p">(</span><span class="s">&quot;Cv&quot;</span><span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">这里可以运行wmake验证没有编译错误。如果只书写了phase1的信息就编译则会提示与phase2相关的错误。</p>
</div>
<p>同时复制p_rgh的内容修改得到T的信息：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Reading field T</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">volScalarField</span> <span class="nf">T</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;T&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">MUST_READ</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">AUTO_WRITE</span>
    <span class="p">),</span>
    <span class="n">mesh</span>
<span class="p">);</span>
</pre></div>
</div>
<p>运行wmake验证没有编译错误。</p>
<p>为了更好地组织代码，我们将与T相关的方程求解提取到TEqn.H当中。复制UEqn.H并清除其内容改名为TEqn.H，书写其内容：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">volScalarField</span> <span class="nf">Deff</span>
<span class="p">(</span>
    <span class="s">&quot;Deff&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="n">alpha1</span><span class="o">*</span><span class="n">k1</span><span class="o">/</span><span class="n">Cv1</span> <span class="o">+</span> <span class="p">(</span><span class="n">scalar</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">alpha1</span><span class="p">)</span><span class="o">*</span><span class="n">k2</span><span class="o">/</span><span class="n">Cv2</span><span class="p">)</span>
<span class="p">);</span>

<span class="n">solve</span>
<span class="p">(</span>
      <span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="o">+</span> <span class="n">fvm</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">rhoPhi</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="o">-</span> <span class="n">fvm</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">Deff</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<p>然后需要将TEqn.H添加到temInterFoam.C里面。需要注意的是，添加位置在pimple loop内部但是在piso loop后面：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;TEqn.H&quot;</span><span class="cp"></span>
</pre></div>
</div>
<p>进行wmake编译成功后就完成了temInterFoam求解器的编写，后续可以设置算例进行验证。</p>
</div>
<div class="section" id="rhosonicfoam">
<h3>rhoSonicFoam<a class="headerlink" href="#rhosonicfoam" title="永久链接至标题">¶</a></h3>
<p>该求解器基于 <a class="reference external" href="https://sourceforge.net/p/openfoam-extend/foam-extend-3.1/ci/v3.2/tree/applications/solvers/compressible/rhoSonicFoam/">foam-extend3.1中的rhoSonicFoam</a>  进行修改以适配OpenFOAM-10环境。</p>
<p>编译准备文件的内容如下：</p>
<div class="literal-block-wrapper docutils container" id="id101">
<div class="code-block-caption"><span class="caption-text">rhoSonicFoam/Make/files</span><a class="headerlink" href="#id101" title="永久链接至代码">¶</a></div>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>rhoSonicFoam.C

<span class="nv">EXE</span> <span class="o">=</span> <span class="k">$(</span>FOAM_USER_APPBIN<span class="k">)</span>/rhoSonicFoam
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id102">
<div class="code-block-caption"><span class="caption-text">rhoSonicFoam/Make/options</span><a class="headerlink" href="#id102" title="永久链接至代码">¶</a></div>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nv">EXE_INC</span> <span class="o">=</span> <span class="se">\</span>
    -IBCs/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/finiteVolume/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/physicalProperties/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/thermophysicalModels/basic/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/thermophysicalModels/specie/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/MomentumTransportModels/momentumTransportModels/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/MomentumTransportModels/compressible/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/ThermophysicalTransportModels/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/meshTools/lnInclude

<span class="nv">EXE_LIBS</span> <span class="o">=</span> <span class="se">\</span>
    -lfiniteVolume <span class="se">\</span>
    -lfvModels <span class="se">\</span>
    -lfvConstraints <span class="se">\</span>
    -lfluidThermophysicalModels <span class="se">\</span>
    -lspecie <span class="se">\</span>
    -lmomentumTransportModels <span class="se">\</span>
    -lcompressibleMomentumTransportModels <span class="se">\</span>
    -lthermophysicalTransportModels <span class="se">\</span>
    -lmeshTools
</pre></div>
</div>
</div>
<p>rhoSonicFoam求解的方程组如下所示：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\partial \rho}{\partial t}
+ \nabla \cdot (\rho\mathbf{U})
= 0
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\partial (\rho\mathbf{U})}{\partial t}
+ \nabla \cdot (\rho\mathbf{UU})
= -\nabla p
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\partial (\rho E)}{\partial t}
+ \nabla \cdot (\rho \mathbf{U}E)
= -\nabla \cdot (p\mathbf{U})
\end{align}\]</div>
<p>求解器的求解步骤为：</p>
<p><strong>Step 1</strong> 初始化压强场 <span class="math notranslate nohighlight">\(p\)</span> 、内能场 <span class="math notranslate nohighlight">\(e\)</span> 、可压缩性 <span class="math notranslate nohighlight">\(\psi\)</span> 、密度场 <span class="math notranslate nohighlight">\(\rho\)</span> 、速度场 <span class="math notranslate nohighlight">\(\mathbf{U}\)</span> 以及 <span class="math notranslate nohighlight">\(\rho\mathbf{U}\)</span> 场与 <span class="math notranslate nohighlight">\(\rho E\)</span> 场；</p>
<p><strong>Step 2</strong> 计算质量通量场 <span class="math notranslate nohighlight">\(\phi^{n}\)</span> 和体积通量场 <span class="math notranslate nohighlight">\(\phi_{v}^{n}\)</span> ；</p>
<p><strong>Step 3</strong> 求解连续性方程 <span class="math notranslate nohighlight">\(\frac{\partial \rho^{n+1}}{\partial t} + \sum \phi_{v}^{n}\rho^{n+1} = 0\)</span> ，得到新的密度场 <span class="math notranslate nohighlight">\(\rho^{n+1}\)</span> ，并更新压强场 <span class="math notranslate nohighlight">\(p^{n+1} = \rho^{n+1}/\psi^{n}\)</span> ；</p>
<p><strong>Step 4</strong> 求解动量方程 <span class="math notranslate nohighlight">\(\frac{\partial (\rho\mathbf{U})^{n+1}}{\partial t} + \sum \phi_{v}^{n}(\rho\mathbf{U})^{n+1} = -\nabla p^{n+1}\)</span> ，得到新的 <span class="math notranslate nohighlight">\((\rho\mathbf{U})^{n+1}\)</span> ，据此更新速度场 <span class="math notranslate nohighlight">\(\mathbf{U}^{n+1} = (\rho\mathbf{U})^{n+1}/\rho^{n+1}\)</span> ，同时计算新的体积通量场 <span class="math notranslate nohighlight">\(\phi_{v}^{n+1}\)</span> ；</p>
<p><strong>Step 5</strong> 求解能量方程 <span class="math notranslate nohighlight">\(\frac{\partial (\rho E)^{n+1}}{\partial t} + \sum \phi_{v}^{n}(\rho E)^{n+1} = - \sum \phi_{v}^{n+1}p^{n+1}\)</span> ，得到新的 <span class="math notranslate nohighlight">\((\rho E)^{n+1}\)</span> ，据此得到 <span class="math notranslate nohighlight">\(e^{n+1} = \Big[(\rho E)^{n+1} - \frac{1}{2}\rho^{n+1}\Big|\mathbf{U}^{n+1}\Big|^{2}\Big]/\rho^{n+1}\)</span> ，并通过thermo.correct()更新温度场 <span class="math notranslate nohighlight">\(T^{n+1}\)</span> 、可压缩性场 <span class="math notranslate nohighlight">\(\psi^{n+1}\)</span> 等；</p>
<p><strong>Step 6</strong> 该时间步求解完成，回到Step2开始循环进入下一时间步求解。</p>
<div class="literal-block-wrapper docutils container" id="id103">
<div class="code-block-caption"><span class="caption-text">rhoSonicFoam/createFields.H</span><a class="headerlink" href="#id103" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Reading thermodynamicProperties</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

<span class="n">autoPtr</span><span class="o">&lt;</span><span class="n">fluidThermo</span><span class="o">&gt;</span> <span class="n">pThermo</span>
<span class="p">(</span>
    <span class="n">fluidThermo</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="p">);</span>
<span class="n">fluidThermo</span><span class="o">&amp;</span> <span class="n">thermo</span> <span class="o">=</span> <span class="n">pThermo</span><span class="p">();</span>
<span class="n">thermo</span><span class="p">.</span><span class="n">validate</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">executable</span><span class="p">(),</span> <span class="s">&quot;h&quot;</span><span class="p">,</span> <span class="s">&quot;e&quot;</span><span class="p">);</span>

<span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">thermo</span><span class="p">.</span><span class="n">p</span><span class="p">();</span>
<span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">thermo</span><span class="p">.</span><span class="n">he</span><span class="p">();</span>
<span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">psi</span> <span class="o">=</span> <span class="n">thermo</span><span class="p">.</span><span class="n">psi</span><span class="p">();</span>
<span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">T</span> <span class="o">=</span> <span class="n">thermo</span><span class="p">.</span><span class="n">T</span><span class="p">();</span>

<span class="n">volScalarField</span> <span class="nf">rho</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;rho&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">READ_IF_PRESENT</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">AUTO_WRITE</span>
    <span class="p">),</span>
    <span class="n">thermo</span><span class="p">.</span><span class="n">rho</span><span class="p">(),</span>
    <span class="n">p</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">().</span><span class="n">types</span><span class="p">()</span>
<span class="p">);</span>

<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Reading field U</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">volVectorField</span> <span class="nf">U</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;U&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">MUST_READ</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">AUTO_WRITE</span>
    <span class="p">),</span>
    <span class="n">mesh</span>
<span class="p">);</span>

<span class="n">volVectorField</span> <span class="nf">rhoU</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;rhoU&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_READ</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_WRITE</span>
    <span class="p">),</span>
    <span class="n">rho</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
    <span class="n">U</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">().</span><span class="n">types</span><span class="p">()</span>
<span class="p">);</span>

<span class="n">volScalarField</span> <span class="nf">rhoE</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;rhoE&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_READ</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_WRITE</span>
    <span class="p">),</span>
    <span class="n">rho</span><span class="o">*</span><span class="n">e</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">U</span><span class="p">),</span>
    <span class="n">T</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">().</span><span class="n">types</span><span class="p">()</span>
<span class="p">);</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id104">
<div class="code-block-caption"><span class="caption-text">rhoSonicFoam/rhoSonicFoam.C</span><a class="headerlink" href="#id104" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;fvCFD.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;psiThermo.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;compressibleMomentumTransportModels.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;fluidThermophysicalTransportModel.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;fvcSmooth.H&quot;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="cp">#include</span> <span class="cpf">&quot;postProcess.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;setRootCaseLists.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createTime.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createMesh.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createFields.H&quot;</span><span class="cp"></span>

    <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Starting time loop</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">runTime</span><span class="p">.</span><span class="n">loop</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Time = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

        <span class="n">surfaceScalarField</span> <span class="n">phi</span><span class="p">(</span><span class="s">&quot;phi&quot;</span><span class="p">,</span> <span class="n">fvc</span><span class="o">::</span><span class="n">flux</span><span class="p">(</span><span class="n">rhoU</span><span class="p">));</span>

        <span class="n">surfaceScalarField</span> <span class="n">phiv</span>
        <span class="p">(</span>
            <span class="n">IOobject</span>
            <span class="p">(</span>
                <span class="s">&quot;phiv&quot;</span><span class="p">,</span>
                <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>
                <span class="n">mesh</span><span class="p">,</span>
                <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_READ</span><span class="p">,</span>
                <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_WRITE</span>
            <span class="p">),</span>
            <span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">rhoU</span><span class="p">)</span><span class="o">/</span><span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mesh</span><span class="p">.</span><span class="n">Sf</span><span class="p">()</span>
        <span class="p">);</span>

        <span class="n">scalar</span> <span class="n">CoNum</span> <span class="o">=</span> <span class="n">max</span>
        <span class="p">(</span>
            <span class="n">mesh</span><span class="p">.</span><span class="n">surfaceInterpolation</span><span class="o">::</span><span class="n">deltaCoeffs</span><span class="p">()</span>
           <span class="o">*</span><span class="n">mag</span><span class="p">(</span><span class="n">phiv</span><span class="p">)</span><span class="o">/</span><span class="n">mesh</span><span class="p">.</span><span class="n">magSf</span><span class="p">()</span>
        <span class="p">).</span><span class="n">value</span><span class="p">()</span><span class="o">*</span><span class="n">runTime</span><span class="p">.</span><span class="n">deltaT</span><span class="p">().</span><span class="n">value</span><span class="p">();</span>

        <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Max Courant Number = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">CoNum</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

        <span class="n">solve</span>
        <span class="p">(</span>
            <span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
          <span class="o">+</span> <span class="n">fvm</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phiv</span><span class="p">,</span> <span class="n">rho</span><span class="p">)</span>
        <span class="p">);</span>

        <span class="n">p</span> <span class="o">=</span> <span class="n">rho</span><span class="o">/</span><span class="n">psi</span><span class="p">;</span>

        <span class="n">solve</span>
        <span class="p">(</span>
            <span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">rhoU</span><span class="p">)</span>
          <span class="o">+</span> <span class="n">fvm</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phiv</span><span class="p">,</span> <span class="n">rhoU</span><span class="p">)</span>
         <span class="o">==</span>
          <span class="o">-</span> <span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="p">);</span>

        <span class="n">U</span> <span class="o">==</span> <span class="n">rhoU</span><span class="o">/</span><span class="n">rho</span><span class="p">;</span>

        <span class="n">surfaceScalarField</span> <span class="n">phiv2</span>
        <span class="p">(</span>
            <span class="n">IOobject</span>
            <span class="p">(</span>
                <span class="s">&quot;phiv2&quot;</span><span class="p">,</span>
                <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>
                <span class="n">mesh</span><span class="p">,</span>
                <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_READ</span><span class="p">,</span>
                <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_WRITE</span>
            <span class="p">),</span>
            <span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">rhoU</span><span class="p">)</span><span class="o">/</span><span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mesh</span><span class="p">.</span><span class="n">Sf</span><span class="p">()</span>
        <span class="p">);</span>

        <span class="n">solve</span>
        <span class="p">(</span>
            <span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">rhoE</span><span class="p">)</span>
          <span class="o">+</span> <span class="n">fvm</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phiv</span><span class="p">,</span> <span class="n">rhoE</span><span class="p">)</span>
         <span class="o">==</span>
          <span class="o">-</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phiv2</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="p">);</span>
        <span class="n">e</span> <span class="o">==</span> <span class="p">(</span><span class="n">rhoE</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">rhoU</span><span class="o">/</span><span class="n">rho</span><span class="p">))</span><span class="o">/</span><span class="n">rho</span><span class="p">;</span>
        <span class="n">thermo</span><span class="p">.</span><span class="n">correct</span><span class="p">();</span>

        <span class="n">runTime</span><span class="p">.</span><span class="n">write</span><span class="p">();</span>

        <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;ExecutionTime = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">runTime</span><span class="p">.</span><span class="n">elapsedCpuTime</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; s&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;  ClockTime = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">runTime</span><span class="p">.</span><span class="n">elapsedClockTime</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; s&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">nl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;End</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="rhosonicturbfoam">
<h3>rhoSonicTurbFoam<a class="headerlink" href="#rhosonicturbfoam" title="永久链接至标题">¶</a></h3>
<p>该求解器在rhoSonicFoam的基础上添加湍流模型以及能量方程的热通量项。编译准备文件的内容如下：</p>
<div class="literal-block-wrapper docutils container" id="id105">
<div class="code-block-caption"><span class="caption-text">rhoSonicTurbFoam/Make/files</span><a class="headerlink" href="#id105" title="永久链接至代码">¶</a></div>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>rhoSonicTurbFoam.C

<span class="nv">EXE</span> <span class="o">=</span> <span class="k">$(</span>FOAM_USER_APPBIN<span class="k">)</span>/rhoSonicTurbFoam
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id106">
<div class="code-block-caption"><span class="caption-text">rhoSonicTurbFoam/Make/options</span><a class="headerlink" href="#id106" title="永久链接至代码">¶</a></div>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nv">EXE_INC</span> <span class="o">=</span> <span class="se">\</span>
    -IBCs/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/finiteVolume/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/physicalProperties/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/thermophysicalModels/basic/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/thermophysicalModels/specie/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/MomentumTransportModels/momentumTransportModels/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/MomentumTransportModels/compressible/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/ThermophysicalTransportModels/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/meshTools/lnInclude

<span class="nv">EXE_LIBS</span> <span class="o">=</span> <span class="se">\</span>
    -lfiniteVolume <span class="se">\</span>
    -lfvModels <span class="se">\</span>
    -lfvConstraints <span class="se">\</span>
    -lfluidThermophysicalModels <span class="se">\</span>
    -lspecie <span class="se">\</span>
    -lmomentumTransportModels <span class="se">\</span>
    -lcompressibleMomentumTransportModels <span class="se">\</span>
    -lthermophysicalTransportModels <span class="se">\</span>
    -lmeshTools
</pre></div>
</div>
</div>
<p>rhoSonicTurbFoam求解的方程组如下所示：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\partial \rho}{\partial t} + \nabla \cdot (\rho\mathbf{U}) = 0
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\partial (\rho\mathbf{U})}{\partial t}
+ \nabla \cdot (\rho\mathbf{UU})
- \rho\mathbf{R}_{\text{eff}}
= - \nabla p
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
\frac{\partial (\rho e)}{\partial t}
+ \frac{\partial (\rho K)}{\partial t}
+ \nabla \cdot (\rho\mathbf{U}e)
+ \nabla \cdot (\rho\mathbf{U}K)
+ \nabla \cdot (p\mathbf{U})
+ \nabla \cdot \mathbf{q}
= 0
\end{align}\]</div>
<p>求解器的求解步骤为：</p>
<p><strong>Step 1</strong> 初始化压力场 <span class="math notranslate nohighlight">\(p^{n}\)</span> 、能量场 <span class="math notranslate nohighlight">\(e\)</span> 、可压缩性场 <span class="math notranslate nohighlight">\(\psi^{n}\)</span> 、密度场 <span class="math notranslate nohighlight">\(\rho^{n}\)</span> 、速度场 <span class="math notranslate nohighlight">\(\mathbf{U}^{n}\)</span> ，建立动能场 <span class="math notranslate nohighlight">\(K^{n} = \frac{1}{2}|\mathbf{U}^{n}|^{2}\)</span> 、质量通量场 <span class="math notranslate nohighlight">\(\phi^{n} = (\rho^{n}\mathbf{U}^{n})_{f}\cdot \mathbf{S}_{f}\)</span> 和体积通量场 <span class="math notranslate nohighlight">\(\phi_{v}^{n} = \mathbf{U}_{f}^{n}\cdot\mathbf{S}_{f}\)</span> ；</p>
<p><strong>Step 2</strong> 求解连续性方程 <span class="math notranslate nohighlight">\(\frac{\partial \rho^{n+1}}{\partial t} + \sum \phi_{v}^{n}\rho^{n+1} = 0\)</span> ，得到新的密度场 <span class="math notranslate nohighlight">\(\rho^{n+1}\)</span> ，据此更新压力场 <span class="math notranslate nohighlight">\(p^{n+1} = \rho^{n+1}/\psi^{n}\)</span> ；</p>
<p><strong>Step 3</strong> 求解动量方程 <span class="math notranslate nohighlight">\(\frac{\partial \rho^{n+1}\mathbf{U}^{n+1}}{\partial t} + \sum \phi^{n}\mathbf{U}^{n+1} - \rho^{n+1}\mathbf{R}_{\text{eff}} = - \nabla p^{n+1}\)</span> ，得到新的速度场 <span class="math notranslate nohighlight">\(\mathbf{U}^{n+1}\)</span> ，并据此更新质量通量场 <span class="math notranslate nohighlight">\(\phi^{n+1} = (\rho^{n+1}\mathbf{U}^{n+1})_{f}\cdot \mathbf{S}_{f}\)</span> 、体积通量场 <span class="math notranslate nohighlight">\(\phi_{v}^{n+1} = \mathbf{U}_{f}^{n+1}\cdot\mathbf{S}_{f}\)</span> 和动能场 <span class="math notranslate nohighlight">\(K^{n+1}=\frac{1}{2}|\mathbf{U}^{n+1}|^{2}\)</span> ；</p>
<p><strong>Step 4</strong> 求解能量方程 <span class="math notranslate nohighlight">\(\frac{\partial \rho^{n+1}e^{n+1}}{\partial t} + \frac{\partial \rho^{n+1}K^{n+1}}{\partial t} + \sum\phi^{n+1}e^{n+1} + \sum \phi^{n+1}K^{n+1} + \sum\phi^{n+1}\frac{p^{n+1}}{\rho^{n+1}} + \nabla\cdot\mathbf{q} = 0\)</span> ，得到新的能量场 <span class="math notranslate nohighlight">\(e^{n+1}\)</span> ，据此通过thermo.correct()更新温度场 <span class="math notranslate nohighlight">\(T^{n+1}\)</span> 、可压缩性场 <span class="math notranslate nohighlight">\(\psi^{n+1}\)</span> 等；</p>
<p><strong>Step 5</strong> 更新湍流模型参数turbulence-&gt;correct()和热物理输运模型参数thermophysicalTransport-&gt;correct()；</p>
<p><strong>Step 6</strong> 该时间步求解完毕，回到Step 2进入下一个时间步的循环。</p>
<div class="literal-block-wrapper docutils container" id="id107">
<div class="code-block-caption"><span class="caption-text">rhoSonicTurbFoam/createFields.H</span><a class="headerlink" href="#id107" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Reading thermodynamicProperties</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

<span class="n">autoPtr</span><span class="o">&lt;</span><span class="n">fluidThermo</span><span class="o">&gt;</span> <span class="n">pThermo</span>
<span class="p">(</span>
    <span class="n">fluidThermo</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="p">);</span>
<span class="n">fluidThermo</span><span class="o">&amp;</span> <span class="n">thermo</span> <span class="o">=</span> <span class="n">pThermo</span><span class="p">();</span>
<span class="n">thermo</span><span class="p">.</span><span class="n">validate</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">executable</span><span class="p">(),</span> <span class="s">&quot;h&quot;</span><span class="p">,</span> <span class="s">&quot;e&quot;</span><span class="p">);</span>

<span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">thermo</span><span class="p">.</span><span class="n">p</span><span class="p">();</span>
<span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">he</span> <span class="o">=</span> <span class="n">thermo</span><span class="p">.</span><span class="n">he</span><span class="p">();</span>
<span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">psi</span> <span class="o">=</span> <span class="n">thermo</span><span class="p">.</span><span class="n">psi</span><span class="p">();</span>

<span class="n">volScalarField</span> <span class="nf">rho</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;rho&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">READ_IF_PRESENT</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">AUTO_WRITE</span>
    <span class="p">),</span>
    <span class="n">thermo</span><span class="p">.</span><span class="n">rho</span><span class="p">(),</span>
    <span class="n">p</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">().</span><span class="n">types</span><span class="p">()</span>
<span class="p">);</span>

<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Reading field U</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">volVectorField</span> <span class="nf">U</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;U&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">MUST_READ</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">AUTO_WRITE</span>
    <span class="p">),</span>
    <span class="n">mesh</span>
<span class="p">);</span>

<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Creating field kinetic energy K</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">volScalarField</span> <span class="nf">K</span><span class="p">(</span><span class="s">&quot;K&quot;</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">U</span><span class="p">));</span>

<span class="n">surfaceScalarField</span> <span class="nf">phi</span><span class="p">(</span><span class="s">&quot;phi&quot;</span><span class="p">,</span> <span class="n">fvc</span><span class="o">::</span><span class="n">flux</span><span class="p">(</span><span class="n">rho</span><span class="o">*</span><span class="n">U</span><span class="p">));</span>
<span class="n">surfaceScalarField</span> <span class="nf">phiv</span><span class="p">(</span><span class="s">&quot;phiv&quot;</span><span class="p">,</span> <span class="n">fvc</span><span class="o">::</span><span class="n">flux</span><span class="p">(</span><span class="n">U</span><span class="p">));</span>

<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Creating turbulence model</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">autoPtr</span><span class="o">&lt;</span><span class="n">compressible</span><span class="o">::</span><span class="n">momentumTransportModel</span><span class="o">&gt;</span> <span class="n">turbulence</span>
<span class="p">(</span>
    <span class="n">compressible</span><span class="o">::</span><span class="n">momentumTransportModel</span><span class="o">::</span><span class="n">New</span>
    <span class="p">(</span>
        <span class="n">rho</span><span class="p">,</span>
        <span class="n">U</span><span class="p">,</span>
        <span class="n">phi</span><span class="p">,</span>
        <span class="n">thermo</span>
    <span class="p">)</span>
<span class="p">);</span>

<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Creating thermophysical transport model</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">autoPtr</span><span class="o">&lt;</span><span class="n">fluidThermophysicalTransportModel</span><span class="o">&gt;</span> <span class="n">thermophysicalTransport</span>
<span class="p">(</span>
    <span class="n">fluidThermophysicalTransportModel</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">turbulence</span><span class="p">(),</span> <span class="n">thermo</span><span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id108">
<div class="code-block-caption"><span class="caption-text">rhoSonicTurbFoam/rhoSonicTurbFoam.C</span><a class="headerlink" href="#id108" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;fvCFD.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;psiThermo.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;compressibleMomentumTransportModels.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;fluidThermophysicalTransportModel.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;fvcSmooth.H&quot;</span><span class="cp"></span>

<span class="c1">// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="cp">#include</span> <span class="cpf">&quot;postProcess.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;setRootCaseLists.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createTime.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createMesh.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createFields.H&quot;</span><span class="cp"></span>

<span class="c1">// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //</span>

    <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Starting time loop</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">runTime</span><span class="p">.</span><span class="n">loop</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Time = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

        <span class="n">scalar</span> <span class="n">CoNum</span> <span class="o">=</span> <span class="n">max</span>
        <span class="p">(</span>
            <span class="n">mesh</span><span class="p">.</span><span class="n">surfaceInterpolation</span><span class="o">::</span><span class="n">deltaCoeffs</span><span class="p">()</span>
           <span class="o">*</span><span class="n">mag</span><span class="p">(</span><span class="n">phiv</span><span class="p">)</span><span class="o">/</span><span class="n">mesh</span><span class="p">.</span><span class="n">magSf</span><span class="p">()</span>
        <span class="p">).</span><span class="n">value</span><span class="p">()</span><span class="o">*</span><span class="n">runTime</span><span class="p">.</span><span class="n">deltaT</span><span class="p">().</span><span class="n">value</span><span class="p">();</span>

        <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Max Courant Number = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">CoNum</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

        <span class="n">fvScalarMatrix</span> <span class="n">rhoEqn</span>
        <span class="p">(</span>
                <span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
              <span class="o">+</span> <span class="n">fvm</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phiv</span><span class="p">,</span> <span class="n">rho</span><span class="p">)</span>
        <span class="p">);</span>

        <span class="n">rhoEqn</span><span class="p">.</span><span class="n">relax</span><span class="p">();</span>
        <span class="n">rhoEqn</span><span class="p">.</span><span class="n">solve</span><span class="p">();</span>

        <span class="n">p</span> <span class="o">=</span> <span class="n">rho</span><span class="o">/</span><span class="n">psi</span><span class="p">;</span>


        <span class="n">fvVectorMatrix</span> <span class="n">UEqn</span>
        <span class="p">(</span>
            <span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>
          <span class="o">+</span> <span class="n">fvm</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>
          <span class="o">+</span> <span class="n">turbulence</span><span class="o">-&gt;</span><span class="n">divDevTau</span><span class="p">(</span><span class="n">U</span><span class="p">)</span>
         <span class="o">==</span>
          <span class="o">-</span> <span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="p">);</span>

        <span class="n">UEqn</span><span class="p">.</span><span class="n">relax</span><span class="p">();</span>
        <span class="n">UEqn</span><span class="p">.</span><span class="n">solve</span><span class="p">();</span>

        <span class="n">phi</span> <span class="o">=</span> <span class="n">fvc</span><span class="o">::</span><span class="n">flux</span><span class="p">(</span><span class="n">rho</span><span class="o">*</span><span class="n">U</span><span class="p">);</span>
        <span class="n">phiv</span> <span class="o">=</span> <span class="n">fvc</span><span class="o">::</span><span class="n">flux</span><span class="p">(</span><span class="n">U</span><span class="p">);</span>
        <span class="n">K</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">U</span><span class="p">);</span>

        <span class="n">fvScalarMatrix</span> <span class="n">EEqn</span>
        <span class="p">(</span>
            <span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">he</span><span class="p">)</span> <span class="o">+</span> <span class="n">fvm</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">he</span><span class="p">)</span>
          <span class="o">+</span> <span class="n">fvc</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span> <span class="o">+</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span>
          <span class="o">+</span> <span class="p">(</span>
            <span class="n">he</span><span class="p">.</span><span class="n">name</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;e&quot;</span>
              <span class="o">?</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">p</span><span class="o">/</span><span class="n">rho</span><span class="p">)</span>
              <span class="o">:</span> <span class="o">-</span> <span class="n">fvc</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="p">)</span>
          <span class="o">+</span> <span class="n">thermophysicalTransport</span><span class="o">-&gt;</span><span class="n">divq</span><span class="p">(</span><span class="n">he</span><span class="p">)</span>
        <span class="p">);</span>

        <span class="n">EEqn</span><span class="p">.</span><span class="n">relax</span><span class="p">();</span>
        <span class="n">EEqn</span><span class="p">.</span><span class="n">solve</span><span class="p">();</span>
        <span class="n">thermo</span><span class="p">.</span><span class="n">correct</span><span class="p">();</span>



        <span class="n">turbulence</span><span class="o">-&gt;</span><span class="n">correct</span><span class="p">();</span>
        <span class="n">thermophysicalTransport</span><span class="o">-&gt;</span><span class="n">correct</span><span class="p">();</span>

        <span class="n">runTime</span><span class="p">.</span><span class="n">write</span><span class="p">();</span>


        <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;ExecutionTime = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">runTime</span><span class="p">.</span><span class="n">elapsedCpuTime</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; s&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;  ClockTime = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">runTime</span><span class="p">.</span><span class="n">elapsedClockTime</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; s&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">nl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;End</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="dbns">
<h3>dbns<a class="headerlink" href="#dbns" title="永久链接至标题">¶</a></h3>
<p>这是foam-extend中的密度基求解器模型库，通过对代码进行部分修改以适配OpenFOAM-10的环境。在Make文件夹中的files和options文件需要添加如下内容</p>
<div class="literal-block-wrapper docutils container" id="id109">
<div class="code-block-caption"><span class="caption-text">src/dbns/Make/files</span><a class="headerlink" href="#id109" title="永久链接至代码">¶</a></div>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>dbnsFlux/roeFlux/roeFlux.C
dbnsFlux/rusanovFlux/rusanovFlux.C
dbnsFlux/betaFlux/betaFlux.C
dbnsFlux/hllcFlux/hllcFlux.C
dbnsFlux/hllcALEFlux/hllcALEFlux.C

basicNumericFlux/basicNumericFlux.C
basicNumericFlux/newBasicNumericFlux.C
numericFlux/numericFluxes.C

multigrid/mgMeshLevel/mgMeshLevel.C
multigrid/mgMeshLevel/fineMgMeshLevel.C
multigrid/mgMeshLevel/coarseMgMeshLevel.C

multigrid/mgFieldLevel/mgFieldLevel.C
multigrid/mgFieldLevel/fineMgFieldLevel.C
multigrid/mgFieldLevel/coarseMgFieldLevel.C

timeStepping/localTimeStep/localTimeStep.C
timeStepping/backwardDualDdtScheme/backwardDualDdtSchemes.C
timeStepping/EulerLocalDdtScheme/EulerLocalDdtSchemes.C

<span class="nv">LIB</span> <span class="o">=</span> <span class="k">$(</span>FOAM_USER_LIBBIN<span class="k">)</span>/libdbns
</pre></div>
</div>
</div>
<div class="admonition attention">
<p class="first admonition-title">注意</p>
<p class="last">其中的多重网格和时间步进功能还没有修改完成。</p>
</div>
<div class="literal-block-wrapper docutils container" id="id110">
<div class="code-block-caption"><span class="caption-text">src/dbns/Make/options</span><a class="headerlink" href="#id110" title="永久链接至代码">¶</a></div>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nv">EXE_INC</span> <span class="o">=</span> <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/finiteVolume/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/meshTools/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/physicalProperties/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/thermophysicalModels/basic/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/MomentumTransportModels/momentumTransportModels/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/MomentumTransportModels/compressible/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/ThermophysicalTransportModels/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/dummyThirdParty/MGridGen/lnInclude

<span class="nv">LIB_LIBS</span> <span class="o">=</span> <span class="se">\</span>
    -lfiniteVolume <span class="se">\</span>
    -lmeshTools
</pre></div>
</div>
</div>
<div class="section" id="dbnsfoam">
<h4>dbnsFoam<a class="headerlink" href="#dbnsfoam" title="永久链接至标题">¶</a></h4>
<p>使用dbnsFoam求解器时，fvSchemes文件内需要修改成</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">ddtSchemes</span>
<span class="p">{</span>
    <span class="k">default</span>         <span class="n">none</span><span class="p">;</span>
    <span class="n">ddt</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>        <span class="n">Euler</span><span class="p">;</span>
    <span class="n">ddt</span><span class="p">(</span><span class="n">rhoU</span><span class="p">)</span>       <span class="n">Euler</span><span class="p">;</span>
    <span class="n">ddt</span><span class="p">(</span><span class="n">rhoE</span><span class="p">)</span>       <span class="n">Euler</span><span class="p">;</span>
    <span class="n">p</span>               <span class="n">Euler</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">gradSchemes</span>
<span class="p">{</span>
    <span class="k">default</span>         <span class="n">none</span><span class="p">;</span>
    <span class="n">grad</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>    <span class="n">Gauss</span> <span class="n">linear</span><span class="p">;</span>
    <span class="n">grad</span><span class="p">(</span><span class="n">U</span><span class="p">)</span>    <span class="n">Gauss</span> <span class="n">linear</span><span class="p">;</span>
    <span class="n">grad</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>    <span class="n">Gauss</span> <span class="n">linear</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">divSchemes</span>
<span class="p">{</span>
    <span class="k">default</span>         <span class="n">none</span><span class="p">;</span>
    <span class="n">dbns</span>
    <span class="p">{</span>
        <span class="n">limiter</span>    <span class="n">firstOrder</span><span class="p">;</span>
        <span class="n">flux</span>       <span class="n">hllc</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">laplacianSchemes</span>
<span class="p">{</span>
    <span class="k">default</span>         <span class="n">none</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">interpolationSchemes</span>
<span class="p">{</span>
    <span class="k">default</span>           <span class="n">none</span><span class="p">;</span>
    <span class="n">interpolate</span><span class="p">(</span><span class="n">sqrt</span><span class="p">((((</span><span class="n">Cp</span><span class="o">|</span><span class="n">Cv</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">Cp</span><span class="o">-</span><span class="n">Cv</span><span class="p">))</span><span class="o">*</span><span class="n">T</span><span class="p">)))</span>    <span class="n">linear</span><span class="p">;</span>
    <span class="n">interpolate</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>    <span class="n">linear</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">snGradSchemes</span>
<span class="p">{</span>
    <span class="k">default</span>         <span class="n">none</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>fvSolution文件需要修改成</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">solvers</span>
<span class="p">{</span>
    <span class="n">rho</span>
    <span class="p">{</span>
        <span class="n">solver</span>          <span class="n">smoothSolver</span><span class="p">;</span>
        <span class="n">smoother</span>        <span class="n">GaussSeidel</span><span class="p">;</span>
        <span class="n">nSweeps</span>         <span class="mi">2</span><span class="p">;</span>
        <span class="n">tolerance</span>       <span class="mf">1e-09</span><span class="p">;</span>
        <span class="n">relTol</span>          <span class="mf">0.01</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">rhoU</span>
    <span class="p">{</span>
        <span class="n">solver</span>          <span class="n">smoothSolver</span><span class="p">;</span>
        <span class="n">smoother</span>        <span class="n">GaussSeidel</span><span class="p">;</span>
        <span class="n">nSweeps</span>         <span class="mi">2</span><span class="p">;</span>
        <span class="n">tolerance</span>       <span class="mf">1e-09</span><span class="p">;</span>
        <span class="n">relTol</span>          <span class="mf">0.01</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">rhoE</span>
    <span class="p">{</span>
        <span class="n">solver</span>          <span class="n">smoothSolver</span><span class="p">;</span>
        <span class="n">smoother</span>        <span class="n">GaussSeidel</span><span class="p">;</span>
        <span class="n">nSweeps</span>         <span class="mi">2</span><span class="p">;</span>
        <span class="n">tolerance</span>       <span class="mf">1e-09</span><span class="p">;</span>
        <span class="n">relTol</span>          <span class="mf">0.01</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">fieldBounds</span>
<span class="p">{</span>
    <span class="n">p</span>    <span class="mi">0</span>    <span class="mf">1e16</span><span class="p">;</span>
    <span class="n">T</span>    <span class="mi">10</span>   <span class="mf">1e16</span><span class="p">;</span>
    <span class="n">rho</span>  <span class="mi">0</span>    <span class="mf">1e16</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在编译该求解器时，Make文件夹内的files和options分别需要写入以下内容：</p>
<div class="literal-block-wrapper docutils container" id="id111">
<div class="code-block-caption"><span class="caption-text">applications/solvers/compressible/dbnsFoam/Make/files</span><a class="headerlink" href="#id111" title="永久链接至代码">¶</a></div>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>dbnsFoam.C

<span class="nv">EXE</span> <span class="o">=</span> <span class="k">$(</span>FOAM_USER_APPBIN<span class="k">)</span>/dbnsFoam
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id112">
<div class="code-block-caption"><span class="caption-text">applications/solvers/compressible/dbnsFoam/Make/options</span><a class="headerlink" href="#id112" title="永久链接至代码">¶</a></div>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nv">EXE_INC</span> <span class="o">=</span> <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/finiteVolume/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/physicalProperties/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/thermophysicalModels/basic/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/thermophysicalModels/specie/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/MomentumTransportModels/momentumTransportModels/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/MomentumTransportModels/compressible/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/ThermophysicalTransportModels/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/meshTools/lnInclude <span class="se">\</span>
    -I../../../../src/dbns/lnInclude

<span class="nv">EXE_LIBS</span> <span class="o">=</span> <span class="se">\</span>
    -lfiniteVolume <span class="se">\</span>
    -lfvModels <span class="se">\</span>
    -lfvConstraints <span class="se">\</span>
    -lfluidThermophysicalModels <span class="se">\</span>
    -lspecie <span class="se">\</span>
    -lmomentumTransportModels <span class="se">\</span>
    -lcompressibleMomentumTransportModels <span class="se">\</span>
    -lthermophysicalTransportModels <span class="se">\</span>
    -lmeshTools <span class="se">\</span>
    -L<span class="k">$(</span>FOAM_USER_LIBBIN<span class="k">)</span> -ldbns
</pre></div>
</div>
</div>
<p>该求解器初始化场和湍流模型、热物理模型的createFields.H文件如下：</p>
<div class="literal-block-wrapper docutils container" id="id113">
<div class="code-block-caption"><span class="caption-text">applications/solvers/compressible/dbnsFoam/createFields.H</span><a class="headerlink" href="#id113" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Reading thermodynamicProperties</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

<span class="n">autoPtr</span><span class="o">&lt;</span><span class="n">fluidThermo</span><span class="o">&gt;</span> <span class="n">pThermo</span>
<span class="p">(</span>
    <span class="n">fluidThermo</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="p">);</span>
<span class="n">fluidThermo</span><span class="o">&amp;</span> <span class="n">thermo</span> <span class="o">=</span> <span class="n">pThermo</span><span class="p">();</span>
<span class="n">thermo</span><span class="p">.</span><span class="n">validate</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">executable</span><span class="p">(),</span> <span class="s">&quot;h&quot;</span><span class="p">,</span> <span class="s">&quot;e&quot;</span><span class="p">);</span>


<span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">thermo</span><span class="p">.</span><span class="n">p</span><span class="p">();</span>
<span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">h</span> <span class="o">=</span> <span class="n">thermo</span><span class="p">.</span><span class="n">he</span><span class="p">();</span>    <span class="c1">// should be enthalpy</span>
<span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">T</span> <span class="o">=</span> <span class="n">thermo</span><span class="p">.</span><span class="n">T</span><span class="p">();</span>

<span class="n">volScalarField</span> <span class="nf">rho</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;rho&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">READ_IF_PRESENT</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">AUTO_WRITE</span>
    <span class="p">),</span>
    <span class="n">thermo</span><span class="p">.</span><span class="n">rho</span><span class="p">(),</span>
    <span class="n">p</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">().</span><span class="n">types</span><span class="p">()</span>
<span class="p">);</span>

<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Reading field U</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">volVectorField</span> <span class="nf">U</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;U&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">MUST_READ</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">AUTO_WRITE</span>
    <span class="p">),</span>
    <span class="n">mesh</span>
<span class="p">);</span>

<span class="n">volVectorField</span> <span class="nf">rhoU</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;rhoU&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_READ</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_WRITE</span>
    <span class="p">),</span>
    <span class="n">rho</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
    <span class="n">U</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">().</span><span class="n">types</span><span class="p">()</span>
<span class="p">);</span>

<span class="n">volScalarField</span> <span class="nf">rhoE</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;rhoE&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_READ</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_WRITE</span>
    <span class="p">),</span>
    <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">h</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">U</span><span class="p">))</span> <span class="o">-</span> <span class="n">p</span><span class="p">,</span>
    <span class="n">T</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">().</span><span class="n">types</span><span class="p">()</span>
<span class="p">);</span>

<span class="c1">// Create numeric flux</span>
<span class="n">autoPtr</span><span class="o">&lt;</span><span class="n">basicNumericFlux</span><span class="o">&gt;</span> <span class="n">dbnsFluxPtr</span> <span class="o">=</span> <span class="n">basicNumericFlux</span><span class="o">::</span><span class="n">New</span>
<span class="p">(</span>
    <span class="n">p</span><span class="p">,</span>
    <span class="n">U</span><span class="p">,</span>
    <span class="n">T</span><span class="p">,</span>
    <span class="n">pThermo</span><span class="p">()</span>
<span class="p">);</span>
<span class="n">basicNumericFlux</span><span class="o">&amp;</span> <span class="n">dbnsFlux</span> <span class="o">=</span> <span class="n">dbnsFluxPtr</span><span class="p">();</span>

<span class="c1">// Create mass flux alias for easier coupling with other code components</span>
<span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">phi</span> <span class="o">=</span> <span class="n">dbnsFlux</span><span class="p">.</span><span class="n">rhoFlux</span><span class="p">();</span>
</pre></div>
</div>
</div>
<p>dbnsFoam求解器的主体结构代码如下：</p>
<div class="literal-block-wrapper docutils container" id="id114">
<div class="code-block-caption"><span class="caption-text">applications/solvers/compressible/dbnsFoam/dbnsFoam.C</span><a class="headerlink" href="#id114" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;fvCFD.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;psiThermo.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;bound.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;hllcFlux.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;roeFlux.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;rusanovFlux.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;betaFlux.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;MDLimiter.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;firstOrderLimiter.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;BarthJespersenLimiter.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;VenkatakrishnanLimiter.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;numericFlux.H&quot;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&quot;compressibleMomentumTransportModels.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;fluidThermophysicalTransportModel.H&quot;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="cp">#include</span> <span class="cpf">&quot;setRootCaseLists.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createTime.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createMesh.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createFields.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createTimeControls.H&quot;</span><span class="cp"></span>

    <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Starting time loop</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="c1">// Runge-Kutta coefficient</span>
    <span class="n">scalarList</span> <span class="n">beta</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
    <span class="n">beta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.1100</span><span class="p">;</span>
    <span class="n">beta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.2766</span><span class="p">;</span>
    <span class="n">beta</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5000</span><span class="p">;</span>
    <span class="n">beta</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0000</span><span class="p">;</span>

    <span class="c1">// Switch off solver messages</span>
    <span class="n">lduMatrix</span><span class="o">::</span><span class="n">debug</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">runTime</span><span class="p">.</span><span class="n">loop</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="cp">#include</span> <span class="cpf">&quot;readTimeControls.H&quot;</span><span class="cp"></span>
        <span class="cp">#include</span> <span class="cpf">&quot;readFieldBounds.H&quot;</span><span class="cp"></span>
        <span class="cp">#include</span> <span class="cpf">&quot;acousticCourantNo.H&quot;</span><span class="cp"></span>
        <span class="c1">//#include &quot;setDeltaT.H&quot;  replace it by the following codes</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">adjustTimeStep</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">scalar</span> <span class="n">maxDeltaTFact</span> <span class="o">=</span> <span class="n">maxCo</span><span class="o">/</span><span class="p">(</span><span class="n">CoNum</span> <span class="o">+</span> <span class="n">SMALL</span><span class="p">);</span>
            <span class="n">scalar</span> <span class="n">deltaTFact</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">maxDeltaTFact</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="mf">0.1</span><span class="o">*</span><span class="n">maxDeltaTFact</span><span class="p">),</span> <span class="mf">1.2</span><span class="p">);</span>

            <span class="n">runTime</span><span class="p">.</span><span class="n">setDeltaT</span>
            <span class="p">(</span>
            <span class="n">min</span>
            <span class="p">(</span>
                <span class="n">deltaTFact</span><span class="o">*</span><span class="n">runTime</span><span class="p">.</span><span class="n">deltaT</span><span class="p">().</span><span class="n">value</span><span class="p">(),</span>
                <span class="n">maxDeltaT</span>
            <span class="p">)</span>
            <span class="p">);</span>

            <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;deltaT = &quot;</span> <span class="o">&lt;&lt;</span>  <span class="n">runTime</span><span class="p">.</span><span class="n">deltaT</span><span class="p">().</span><span class="n">value</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">runTime</span><span class="o">++</span><span class="p">;</span>

        <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Time = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

        <span class="c1">// Low storage Runge-Kutta time integration</span>
        <span class="n">forAll</span> <span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// Solve the approximate Riemann problem for this time step</span>
            <span class="n">dbnsFlux</span><span class="p">.</span><span class="n">computeFlux</span><span class="p">();</span>

            <span class="c1">// Time integration</span>
            <span class="n">solve</span>
            <span class="p">(</span>
                <span class="mf">1.0</span><span class="o">/</span><span class="n">beta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
              <span class="o">+</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">dbnsFlux</span><span class="p">.</span><span class="n">rhoFlux</span><span class="p">())</span>
            <span class="p">);</span>

            <span class="n">solve</span>
            <span class="p">(</span>
                <span class="mf">1.0</span><span class="o">/</span><span class="n">beta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">rhoU</span><span class="p">)</span>
              <span class="o">+</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">dbnsFlux</span><span class="p">.</span><span class="n">rhoUFlux</span><span class="p">())</span>
            <span class="p">);</span>

            <span class="n">solve</span>
            <span class="p">(</span>
                <span class="mf">1.0</span><span class="o">/</span><span class="n">beta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">rhoE</span><span class="p">)</span>
              <span class="o">+</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">dbnsFlux</span><span class="p">.</span><span class="n">rhoEFlux</span><span class="p">())</span>
            <span class="p">);</span>

            <span class="cp">#include</span> <span class="cpf">&quot;updateFields.H&quot;</span><span class="cp"></span>
        <span class="p">}</span>

        <span class="n">runTime</span><span class="p">.</span><span class="n">write</span><span class="p">();</span>

        <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;    ExecutionTime = &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">runTime</span><span class="p">.</span><span class="n">elapsedCpuTime</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot; s</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;End</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="dbnsturbfoam">
<h4>dbnsTurbFoam<a class="headerlink" href="#dbnsturbfoam" title="永久链接至标题">¶</a></h4>
<div class="literal-block-wrapper docutils container" id="id115">
<div class="code-block-caption"><span class="caption-text">applications/solvers/compressible/dbnsTurbFoam/Make/files</span><a class="headerlink" href="#id115" title="永久链接至代码">¶</a></div>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>dbnsTurbFoam.C

<span class="nv">EXE</span> <span class="o">=</span> <span class="k">$(</span>FOAM_USER_APPBIN<span class="k">)</span>/dbnsTurbFoam
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id116">
<div class="code-block-caption"><span class="caption-text">applications/solvers/compressible/dbnsTurbFoam/Make/options</span><a class="headerlink" href="#id116" title="永久链接至代码">¶</a></div>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nv">EXE_INC</span> <span class="o">=</span> <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/finiteVolume/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/physicalProperties/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/thermophysicalModels/basic/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/thermophysicalModels/specie/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/MomentumTransportModels/momentumTransportModels/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/MomentumTransportModels/compressible/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/ThermophysicalTransportModels/lnInclude <span class="se">\</span>
    -I<span class="k">$(</span>LIB_SRC<span class="k">)</span>/meshTools/lnInclude <span class="se">\</span>
    -I../../../../src/dbns/lnInclude

<span class="nv">EXE_LIBS</span> <span class="o">=</span> <span class="se">\</span>
    -lfiniteVolume <span class="se">\</span>
    -lfvModels <span class="se">\</span>
    -lfvConstraints <span class="se">\</span>
    -lfluidThermophysicalModels <span class="se">\</span>
    -lspecie <span class="se">\</span>
    -lmomentumTransportModels <span class="se">\</span>
    -lcompressibleMomentumTransportModels <span class="se">\</span>
    -lthermophysicalTransportModels <span class="se">\</span>
    -lmeshTools <span class="se">\</span>
    -L<span class="k">$(</span>FOAM_USER_LIBBIN<span class="k">)</span> -ldbns
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id117">
<div class="code-block-caption"><span class="caption-text">applications/solvers/compressible/dbnsTurbFoam/createFields.H</span><a class="headerlink" href="#id117" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Reading thermodynamicProperties</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

<span class="n">autoPtr</span><span class="o">&lt;</span><span class="n">fluidThermo</span><span class="o">&gt;</span> <span class="n">pThermo</span>
<span class="p">(</span>
    <span class="n">fluidThermo</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="p">);</span>
<span class="n">fluidThermo</span><span class="o">&amp;</span> <span class="n">thermo</span> <span class="o">=</span> <span class="n">pThermo</span><span class="p">();</span>
<span class="n">thermo</span><span class="p">.</span><span class="n">validate</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">executable</span><span class="p">(),</span> <span class="s">&quot;h&quot;</span><span class="p">,</span> <span class="s">&quot;e&quot;</span><span class="p">);</span>


<span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">thermo</span><span class="p">.</span><span class="n">p</span><span class="p">();</span>
<span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">h</span> <span class="o">=</span> <span class="n">thermo</span><span class="p">.</span><span class="n">he</span><span class="p">();</span>    <span class="c1">// should be enthalpy</span>
<span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">T</span> <span class="o">=</span> <span class="n">thermo</span><span class="p">.</span><span class="n">T</span><span class="p">();</span>

<span class="n">volScalarField</span> <span class="nf">rho</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;rho&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">READ_IF_PRESENT</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">AUTO_WRITE</span>
    <span class="p">),</span>
    <span class="n">thermo</span><span class="p">.</span><span class="n">rho</span><span class="p">(),</span>
    <span class="n">p</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">().</span><span class="n">types</span><span class="p">()</span>
<span class="p">);</span>

<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Reading field U</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">volVectorField</span> <span class="nf">U</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;U&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">MUST_READ</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">AUTO_WRITE</span>
    <span class="p">),</span>
    <span class="n">mesh</span>
<span class="p">);</span>

<span class="n">volVectorField</span> <span class="nf">rhoU</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;rhoU&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_READ</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_WRITE</span>
    <span class="p">),</span>
    <span class="n">rho</span><span class="o">*</span><span class="n">U</span><span class="p">,</span>
    <span class="n">U</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">().</span><span class="n">types</span><span class="p">()</span>
<span class="p">);</span>

<span class="n">volScalarField</span> <span class="nf">rhoE</span>
<span class="p">(</span>
    <span class="n">IOobject</span>
    <span class="p">(</span>
        <span class="s">&quot;rhoE&quot;</span><span class="p">,</span>
        <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">(),</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_READ</span><span class="p">,</span>
        <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_WRITE</span>
    <span class="p">),</span>
    <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">h</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">U</span><span class="p">))</span> <span class="o">-</span> <span class="n">p</span><span class="p">,</span>
    <span class="n">T</span><span class="p">.</span><span class="n">boundaryField</span><span class="p">().</span><span class="n">types</span><span class="p">()</span>
<span class="p">);</span>

<span class="c1">// Create numeric flux</span>
<span class="n">autoPtr</span><span class="o">&lt;</span><span class="n">basicNumericFlux</span><span class="o">&gt;</span> <span class="n">dbnsFluxPtr</span> <span class="o">=</span> <span class="n">basicNumericFlux</span><span class="o">::</span><span class="n">New</span>
<span class="p">(</span>
    <span class="n">p</span><span class="p">,</span>
    <span class="n">U</span><span class="p">,</span>
    <span class="n">T</span><span class="p">,</span>
    <span class="n">pThermo</span><span class="p">()</span>
<span class="p">);</span>
<span class="n">basicNumericFlux</span><span class="o">&amp;</span> <span class="n">dbnsFlux</span> <span class="o">=</span> <span class="n">dbnsFluxPtr</span><span class="p">();</span>

<span class="c1">// Create mass flux alias for easier coupling with other code components</span>
<span class="k">const</span> <span class="n">surfaceScalarField</span><span class="o">&amp;</span> <span class="n">phi</span> <span class="o">=</span> <span class="n">dbnsFlux</span><span class="p">.</span><span class="n">rhoFlux</span><span class="p">();</span>

<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Creating turbulence model</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">autoPtr</span><span class="o">&lt;</span><span class="n">compressible</span><span class="o">::</span><span class="n">momentumTransportModel</span><span class="o">&gt;</span> <span class="n">turbulence</span>
<span class="p">(</span>
    <span class="n">compressible</span><span class="o">::</span><span class="n">momentumTransportModel</span><span class="o">::</span><span class="n">New</span>
    <span class="p">(</span>
        <span class="n">rho</span><span class="p">,</span>
        <span class="n">U</span><span class="p">,</span>
        <span class="n">phi</span><span class="p">,</span>
        <span class="n">thermo</span>
    <span class="p">)</span>
<span class="p">);</span>

<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Creating thermophysical transport model</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">autoPtr</span><span class="o">&lt;</span><span class="n">fluidThermophysicalTransportModel</span><span class="o">&gt;</span> <span class="n">thermophysicalTransport</span>
<span class="p">(</span>
    <span class="n">fluidThermophysicalTransportModel</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">turbulence</span><span class="p">(),</span> <span class="n">thermo</span><span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id118">
<div class="code-block-caption"><span class="caption-text">applications/solvers/compressible/dbnsTurbFoam/dbnsTurbFoam.C</span><a class="headerlink" href="#id118" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;fvCFD.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;psiThermo.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;bound.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;hllcFlux.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;roeFlux.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;rusanovFlux.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;betaFlux.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;MDLimiter.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;firstOrderLimiter.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;BarthJespersenLimiter.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;VenkatakrishnanLimiter.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;numericFlux.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;compressibleMomentumTransportModels.H&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;fluidThermophysicalTransportModel.H&quot;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="cp">#include</span> <span class="cpf">&quot;setRootCaseLists.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createTime.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createMesh.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createFields.H&quot;</span><span class="cp"></span>
    <span class="cp">#include</span> <span class="cpf">&quot;createTimeControls.H&quot;</span><span class="cp"></span>

    <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Starting time loop</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="c1">// Runge-Kutta coefficient</span>
    <span class="n">scalarList</span> <span class="n">beta</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
    <span class="n">beta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.1100</span><span class="p">;</span>
    <span class="n">beta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.2766</span><span class="p">;</span>
    <span class="n">beta</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5000</span><span class="p">;</span>
    <span class="n">beta</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0000</span><span class="p">;</span>

    <span class="c1">// Switch off solver messages</span>
    <span class="n">lduMatrix</span><span class="o">::</span><span class="n">debug</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">runTime</span><span class="p">.</span><span class="n">loop</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="cp">#include</span> <span class="cpf">&quot;readTimeControls.H&quot;</span><span class="cp"></span>
        <span class="cp">#include</span> <span class="cpf">&quot;readFieldBounds.H&quot;</span><span class="cp"></span>
        <span class="cp">#include</span> <span class="cpf">&quot;acousticCourantNo.H&quot;</span><span class="cp"></span>
        <span class="c1">//#include &quot;setDeltaT.H&quot;  replace it by the following codes</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">adjustTimeStep</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">scalar</span> <span class="n">maxDeltaTFact</span> <span class="o">=</span> <span class="n">maxCo</span><span class="o">/</span><span class="p">(</span><span class="n">CoNum</span> <span class="o">+</span> <span class="n">SMALL</span><span class="p">);</span>
            <span class="n">scalar</span> <span class="n">deltaTFact</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">maxDeltaTFact</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="mf">0.1</span><span class="o">*</span><span class="n">maxDeltaTFact</span><span class="p">),</span> <span class="mf">1.2</span><span class="p">);</span>

            <span class="n">runTime</span><span class="p">.</span><span class="n">setDeltaT</span>
            <span class="p">(</span>
                <span class="n">min</span>
                <span class="p">(</span>
                    <span class="n">deltaTFact</span><span class="o">*</span><span class="n">runTime</span><span class="p">.</span><span class="n">deltaT</span><span class="p">().</span><span class="n">value</span><span class="p">(),</span>
                    <span class="n">maxDeltaT</span>
                <span class="p">)</span>
            <span class="p">);</span>

            <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;deltaT = &quot;</span> <span class="o">&lt;&lt;</span>  <span class="n">runTime</span><span class="p">.</span><span class="n">deltaT</span><span class="p">().</span><span class="n">value</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">runTime</span><span class="o">++</span><span class="p">;</span>

        <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Time = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">runTime</span><span class="p">.</span><span class="n">timeName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">nl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

        <span class="c1">// Low storage Runge-Kutta time integration</span>
        <span class="n">forAll</span> <span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// Solve the approximate Riemann problem for this time step</span>
            <span class="n">dbnsFlux</span><span class="p">.</span><span class="n">computeFlux</span><span class="p">();</span>

            <span class="c1">// Time integration</span>
            <span class="n">solve</span>
            <span class="p">(</span>
                <span class="mf">1.0</span><span class="o">/</span><span class="n">beta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
              <span class="o">+</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">dbnsFlux</span><span class="p">.</span><span class="n">rhoFlux</span><span class="p">())</span>
            <span class="p">);</span>

            <span class="n">solve</span>
            <span class="p">(</span>
                <span class="mf">1.0</span><span class="o">/</span><span class="n">beta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">rhoU</span><span class="p">)</span>
              <span class="o">+</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">dbnsFlux</span><span class="p">.</span><span class="n">rhoUFlux</span><span class="p">())</span>
              <span class="o">+</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="o">-</span><span class="n">rho</span><span class="o">*</span><span class="n">turbulence</span><span class="o">-&gt;</span><span class="n">nuEff</span><span class="p">()</span><span class="o">*</span><span class="n">dev</span><span class="p">(</span><span class="n">twoSymm</span><span class="p">(</span><span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">U</span><span class="p">))))</span>    <span class="c1">// change from +fvc::div(turbulence-&gt;devRhoReff())</span>
            <span class="p">);</span>

            <span class="n">solve</span>
            <span class="p">(</span>
                <span class="mf">1.0</span><span class="o">/</span><span class="n">beta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">fvm</span><span class="o">::</span><span class="n">ddt</span><span class="p">(</span><span class="n">rhoE</span><span class="p">)</span>
              <span class="o">+</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="n">dbnsFlux</span><span class="p">.</span><span class="n">rhoEFlux</span><span class="p">())</span>
              <span class="o">+</span> <span class="n">fvc</span><span class="o">::</span><span class="n">div</span><span class="p">(</span><span class="o">-</span><span class="n">rho</span><span class="o">*</span><span class="n">turbulence</span><span class="o">-&gt;</span><span class="n">nuEff</span><span class="p">()</span><span class="o">*</span><span class="n">dev</span><span class="p">(</span><span class="n">twoSymm</span><span class="p">(</span><span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">U</span><span class="p">)))</span> <span class="o">&amp;</span> <span class="n">U</span><span class="p">)</span>    <span class="c1">// change from + fvc::div(turbulence-&gt;devRhoReff() &amp; U)</span>
              <span class="o">-</span> <span class="n">fvc</span><span class="o">::</span><span class="n">laplacian</span><span class="p">(</span><span class="n">thermophysicalTransport</span><span class="o">-&gt;</span><span class="n">alphaEff</span><span class="p">(),</span> <span class="n">h</span><span class="p">)</span>    <span class="c1">// change from -fvc::laplacian(turbulence-&gt;alphaEff(), h)</span>
            <span class="p">);</span>

            <span class="cp">#include</span> <span class="cpf">&quot;updateFields.H&quot;</span><span class="cp"></span>
        <span class="p">}</span>

        <span class="c1">// Switch on solver messages for turbulence</span>
        <span class="n">lduMatrix</span><span class="o">::</span><span class="n">debug</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="n">turbulence</span><span class="o">-&gt;</span><span class="n">correct</span><span class="p">();</span>
        <span class="n">thermophysicalTransport</span><span class="o">-&gt;</span><span class="n">correct</span><span class="p">();</span>

        <span class="n">runTime</span><span class="p">.</span><span class="n">write</span><span class="p">();</span>

        <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;    ExecutionTime = &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">runTime</span><span class="p">.</span><span class="n">elapsedCpuTime</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot; s</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;End</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="include">
<h4>include<a class="headerlink" href="#include" title="永久链接至标题">¶</a></h4>
<div class="literal-block-wrapper docutils container" id="id119">
<div class="code-block-caption"><span class="caption-text">src/dbns/include/readFieldBounds.H</span><a class="headerlink" href="#id119" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// Read field bounds</span>
<span class="n">dictionary</span> <span class="n">fieldBounds</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">solution</span><span class="p">().</span><span class="n">subDict</span><span class="p">(</span><span class="s">&quot;fieldBounds&quot;</span><span class="p">);</span>

<span class="c1">// Pressure bounds</span>
<span class="n">dimensionedScalar</span> <span class="nf">pMin</span><span class="p">(</span><span class="s">&quot;pMin&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">dimensions</span><span class="p">(),</span> <span class="n">SMALL</span><span class="p">);</span>
<span class="n">dimensionedScalar</span> <span class="nf">pMax</span><span class="p">(</span><span class="s">&quot;pMax&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">dimensions</span><span class="p">(),</span> <span class="mf">1e10</span><span class="p">);</span>
<span class="n">fieldBounds</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">name</span><span class="p">())</span> <span class="o">&gt;&gt;</span> <span class="n">pMin</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="n">pMax</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>

<span class="c1">// Temperature bounds</span>
<span class="n">dimensionedScalar</span> <span class="nf">TMin</span><span class="p">(</span><span class="s">&quot;TMin&quot;</span><span class="p">,</span> <span class="n">T</span><span class="p">.</span><span class="n">dimensions</span><span class="p">(),</span> <span class="n">SMALL</span><span class="p">);</span>
<span class="n">dimensionedScalar</span> <span class="nf">TMax</span><span class="p">(</span><span class="s">&quot;TMax&quot;</span><span class="p">,</span> <span class="n">T</span><span class="p">.</span><span class="n">dimensions</span><span class="p">(),</span> <span class="mf">1e10</span><span class="p">);</span>
<span class="n">fieldBounds</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">T</span><span class="p">.</span><span class="n">name</span><span class="p">())</span> <span class="o">&gt;&gt;</span> <span class="n">TMin</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="n">TMax</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>

<span class="c1">// Density bounds</span>
<span class="n">dimensionedScalar</span> <span class="nf">rhoMin</span><span class="p">(</span><span class="s">&quot;rhoMin&quot;</span><span class="p">,</span> <span class="n">rho</span><span class="p">.</span><span class="n">dimensions</span><span class="p">(),</span> <span class="n">SMALL</span><span class="p">);</span>
<span class="n">dimensionedScalar</span> <span class="nf">rhoMax</span><span class="p">(</span><span class="s">&quot;rhoMax&quot;</span><span class="p">,</span> <span class="n">rho</span><span class="p">.</span><span class="n">dimensions</span><span class="p">(),</span> <span class="mf">1e10</span><span class="p">);</span>
<span class="n">fieldBounds</span><span class="p">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">rho</span><span class="p">.</span><span class="n">name</span><span class="p">())</span> <span class="o">&gt;&gt;</span> <span class="n">rhoMin</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="n">rhoMax</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id120">
<div class="code-block-caption"><span class="caption-text">src/dbns/include/acousticCourantNo.H</span><a class="headerlink" href="#id120" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">scalar</span> <span class="n">CoNum</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
<span class="n">scalar</span> <span class="n">meanCoNum</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">nInternalFaces</span><span class="p">())</span>
<span class="p">{</span>

    <span class="n">volScalarField</span> <span class="n">speed_of_sound</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">thermo</span><span class="p">.</span><span class="n">Cp</span><span class="p">()</span> <span class="o">/</span> <span class="n">thermo</span><span class="p">.</span><span class="n">Cv</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">thermo</span><span class="p">.</span><span class="n">Cp</span><span class="p">()</span> <span class="o">-</span> <span class="n">thermo</span><span class="p">.</span><span class="n">Cv</span><span class="p">())</span> <span class="o">*</span> <span class="n">T</span><span class="p">);</span>
    <span class="n">surfaceScalarField</span> <span class="n">acCo</span> <span class="o">=</span>
            <span class="p">(</span><span class="n">mag</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span> <span class="o">*</span> <span class="n">mesh</span><span class="p">.</span><span class="n">magSf</span><span class="p">())</span> <span class="o">+</span> <span class="n">fvc</span><span class="o">::</span><span class="n">interpolate</span><span class="p">(</span><span class="n">speed_of_sound</span><span class="p">))</span>
            <span class="o">*</span> <span class="n">mesh</span><span class="p">.</span><span class="n">surfaceInterpolation</span><span class="o">::</span><span class="n">deltaCoeffs</span><span class="p">()</span> <span class="o">*</span> <span class="n">runTime</span><span class="p">.</span><span class="n">deltaT</span><span class="p">();</span>

    <span class="n">CoNum</span> <span class="o">=</span> <span class="n">gMax</span><span class="p">(</span><span class="n">acCo</span><span class="p">.</span><span class="n">internalField</span><span class="p">());</span>

    <span class="n">meanCoNum</span> <span class="o">=</span> <span class="n">gSum</span><span class="p">(</span><span class="n">acCo</span><span class="p">.</span><span class="n">internalField</span><span class="p">())</span> <span class="o">/</span> <span class="n">mesh</span><span class="p">.</span><span class="n">nInternalFaces</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">Info</span><span class="o">&lt;&lt;</span> <span class="s">&quot;Acoustic Courant Number mean: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">meanCoNum</span>
    <span class="o">&lt;&lt;</span> <span class="s">&quot; max: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">CoNum</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id121">
<div class="code-block-caption"><span class="caption-text">src/dbns/include/updateFields.H</span><a class="headerlink" href="#id121" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// Compute U</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">rhoU</span><span class="o">/</span><span class="n">rho</span><span class="p">;</span>
<span class="n">U</span><span class="p">.</span><span class="n">correctBoundaryConditions</span><span class="p">();</span>

<span class="c1">// Calculate enthalpy from rhoE</span>
<span class="k">const</span> <span class="n">volScalarField</span> <span class="n">Cp</span> <span class="o">=</span> <span class="n">thermo</span><span class="p">.</span><span class="n">Cp</span><span class="p">();</span>
<span class="k">const</span> <span class="n">volScalarField</span> <span class="n">Cv</span> <span class="o">=</span> <span class="n">thermo</span><span class="p">.</span><span class="n">Cv</span><span class="p">();</span>

<span class="c1">// h = rhoE/rho - 0.5*magSqr(U) + p/rho;</span>
<span class="c1">// Alternative formulation, Felipe Alves Portela TU Delft</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">Cp</span><span class="o">/</span><span class="n">Cv</span><span class="o">*</span><span class="p">(</span><span class="n">rhoE</span><span class="o">/</span><span class="n">rho</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">U</span><span class="p">));</span>
<span class="n">h</span><span class="p">.</span><span class="n">correctBoundaryConditions</span><span class="p">();</span>

<span class="c1">// Bound enthalpy</span>
<span class="n">dimensionedScalar</span> <span class="n">CpMin</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">Cp</span><span class="p">);</span>
<span class="n">dimensionedScalar</span> <span class="n">CpMax</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">Cp</span><span class="p">);</span>

<span class="n">dimensionedScalar</span> <span class="n">hMin</span> <span class="o">=</span> <span class="n">CpMin</span><span class="o">*</span><span class="n">TMin</span><span class="p">;</span>
<span class="n">dimensionedScalar</span> <span class="n">hMax</span> <span class="o">=</span> <span class="n">CpMax</span><span class="o">*</span><span class="n">TMax</span><span class="p">;</span>

<span class="c1">//boundMinMax(h, hMin, hMax);</span>
<span class="n">bound</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">hMin</span><span class="p">);</span>

<span class="c1">// Correct thermodynamics</span>
<span class="n">thermo</span><span class="p">.</span><span class="n">correct</span><span class="p">();</span>

<span class="c1">// Bound density</span>
<span class="c1">//boundMinMax(rho, rhoMin, rhoMax);</span>
<span class="n">bound</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">rhoMin</span><span class="p">);</span>

<span class="c1">// Compute p from rho</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="n">thermo</span><span class="p">.</span><span class="n">Cp</span><span class="p">()</span> <span class="o">-</span> <span class="n">thermo</span><span class="p">.</span><span class="n">Cv</span><span class="p">())</span><span class="o">*</span><span class="n">T</span><span class="p">;</span>
<span class="n">p</span><span class="p">.</span><span class="n">correctBoundaryConditions</span><span class="p">();</span>

<span class="c1">// Bound pressure</span>
<span class="c1">//boundMinMax(p, pMin, pMax);</span>
<span class="n">bound</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pMin</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="numericflux">
<h4>numericFlux<a class="headerlink" href="#numericflux" title="永久链接至标题">¶</a></h4>
<p>密度基求解器的单级数值通量类。数值通量对象如下进行创建与初始化：</p>
<div class="literal-block-wrapper docutils container" id="id122">
<div class="code-block-caption"><span class="caption-text">src/dbns/numericFlux/numericFlux.C</span><a class="headerlink" href="#id122" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Flux</span><span class="p">,</span> <span class="n">class</span> <span class="n">Limiter</span><span class="o">&gt;</span>
<span class="n">Foam</span><span class="o">::</span><span class="n">numericFlux</span><span class="o">&lt;</span><span class="n">Flux</span><span class="p">,</span> <span class="n">Limiter</span><span class="o">&gt;::</span><span class="n">numericFlux</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">volVectorField</span><span class="o">&amp;</span> <span class="n">U</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">T</span><span class="p">,</span>
    <span class="n">basicThermo</span><span class="o">&amp;</span> <span class="n">thermo</span>
<span class="p">)</span>
<span class="o">:</span>
    <span class="n">numericFluxBase</span><span class="o">&lt;</span><span class="n">Flux</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">mesh</span><span class="p">()),</span>
    <span class="n">p_</span><span class="p">(</span><span class="n">p</span><span class="p">),</span>
    <span class="n">U_</span><span class="p">(</span><span class="n">U</span><span class="p">),</span>
    <span class="n">T_</span><span class="p">(</span><span class="n">T</span><span class="p">),</span>
    <span class="n">thermo_</span><span class="p">(</span><span class="n">thermo</span><span class="p">),</span>
    <span class="n">rhoFlux_</span>
    <span class="p">(</span>
        <span class="n">IOobject</span>
        <span class="p">(</span>
            <span class="s">&quot;phi&quot;</span><span class="p">,</span>
            <span class="n">this</span><span class="o">-&gt;</span><span class="n">mesh</span><span class="p">().</span><span class="n">time</span><span class="p">().</span><span class="n">timeName</span><span class="p">(),</span>
            <span class="n">this</span><span class="o">-&gt;</span><span class="n">mesh</span><span class="p">(),</span>
            <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_READ</span><span class="p">,</span>
            <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_WRITE</span>
        <span class="p">),</span>
        <span class="p">(</span><span class="n">linearInterpolate</span><span class="p">(</span><span class="n">thermo_</span><span class="p">.</span><span class="n">rho</span><span class="p">()</span><span class="o">*</span><span class="n">U_</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">mesh</span><span class="p">().</span><span class="n">Sf</span><span class="p">())</span>
    <span class="p">),</span>
    <span class="n">rhoUFlux_</span>
    <span class="p">(</span>
        <span class="n">IOobject</span>
        <span class="p">(</span>
            <span class="s">&quot;rhoUFlux&quot;</span><span class="p">,</span>
            <span class="n">this</span><span class="o">-&gt;</span><span class="n">mesh</span><span class="p">().</span><span class="n">time</span><span class="p">().</span><span class="n">timeName</span><span class="p">(),</span>
            <span class="n">this</span><span class="o">-&gt;</span><span class="n">mesh</span><span class="p">(),</span>
            <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_READ</span><span class="p">,</span>
            <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_WRITE</span>
        <span class="p">),</span>
        <span class="n">rhoFlux_</span><span class="o">*</span><span class="n">linearInterpolate</span><span class="p">(</span><span class="n">U_</span><span class="p">)</span>
    <span class="p">),</span>
    <span class="n">rhoEFlux_</span>
    <span class="p">(</span>
        <span class="n">IOobject</span>
        <span class="p">(</span>
            <span class="s">&quot;rhoEFlux&quot;</span><span class="p">,</span>
            <span class="n">this</span><span class="o">-&gt;</span><span class="n">mesh</span><span class="p">().</span><span class="n">time</span><span class="p">().</span><span class="n">timeName</span><span class="p">(),</span>
            <span class="n">this</span><span class="o">-&gt;</span><span class="n">mesh</span><span class="p">(),</span>
            <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_READ</span><span class="p">,</span>
            <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_WRITE</span>
        <span class="p">),</span>
        <span class="n">rhoFlux_</span><span class="o">*</span><span class="n">linearInterpolate</span><span class="p">(</span><span class="n">thermo</span><span class="p">.</span><span class="n">Cv</span><span class="p">()</span><span class="o">*</span><span class="n">T_</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">U_</span><span class="p">))</span>
    <span class="p">)</span>
<span class="p">{}</span>
</pre></div>
</div>
</div>
<p>在求解器中调用的computeFlux函数执行了通量计算操作，它调用了相应的limiter，并依次计算每个网格面的数值通量。其中调用limiter的部分如下所示：</p>
<div class="literal-block-wrapper docutils container" id="id123">
<div class="code-block-caption"><span class="caption-text">src/dbns/numericFlux/numericFlux.C</span><a class="headerlink" href="#id123" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volVectorField</span><span class="o">&gt;</span> <span class="n">tgradP</span> <span class="o">=</span> <span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">p_</span><span class="p">);</span>
<span class="k">const</span> <span class="n">volVectorField</span><span class="o">&amp;</span> <span class="n">gradP</span> <span class="o">=</span> <span class="n">tgradP</span><span class="p">();</span>

<span class="k">const</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volTensorField</span><span class="o">&gt;</span> <span class="n">tgradU</span> <span class="o">=</span> <span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">U_</span><span class="p">);</span>
<span class="k">const</span> <span class="n">volTensorField</span><span class="o">&amp;</span> <span class="n">gradU</span> <span class="o">=</span> <span class="n">tgradU</span><span class="p">();</span>

<span class="k">const</span> <span class="n">tmp</span><span class="o">&lt;</span><span class="n">volVectorField</span><span class="o">&gt;</span> <span class="n">tgradT</span> <span class="o">=</span> <span class="n">fvc</span><span class="o">::</span><span class="n">grad</span><span class="p">(</span><span class="n">T_</span><span class="p">);</span>
<span class="k">const</span> <span class="n">volVectorField</span><span class="o">&amp;</span> <span class="n">gradT</span> <span class="o">=</span> <span class="n">tgradT</span><span class="p">();</span>

<span class="n">MDLimiter</span><span class="o">&lt;</span><span class="n">scalar</span><span class="p">,</span> <span class="n">Limiter</span><span class="o">&gt;</span> <span class="n">scalarPLimiter</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">p_</span><span class="p">,</span> <span class="n">gradP</span><span class="p">);</span>
<span class="n">MDLimiter</span><span class="o">&lt;</span><span class="n">vector</span><span class="p">,</span> <span class="n">Limiter</span><span class="o">&gt;</span> <span class="n">vectorULimiter</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">U_</span><span class="p">,</span> <span class="n">gradU</span><span class="p">);</span>
<span class="n">MDLimiter</span><span class="o">&lt;</span><span class="n">scalar</span><span class="p">,</span> <span class="n">Limiter</span><span class="o">&gt;</span> <span class="n">scalarTLimiter</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">T_</span><span class="p">,</span> <span class="n">gradT</span><span class="p">);</span>

<span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">pLimiter</span> <span class="o">=</span> <span class="n">scalarPLimiter</span><span class="p">.</span><span class="n">phiLimiter</span><span class="p">();</span>
<span class="k">const</span> <span class="n">volVectorField</span><span class="o">&amp;</span> <span class="n">ULimiter</span> <span class="o">=</span> <span class="n">vectorULimiter</span><span class="p">.</span><span class="n">phiLimiter</span><span class="p">();</span>
<span class="k">const</span> <span class="n">volScalarField</span><span class="o">&amp;</span> <span class="n">TLimiter</span> <span class="o">=</span> <span class="n">scalarTLimiter</span><span class="p">.</span><span class="n">phiLimiter</span><span class="p">();</span>
</pre></div>
</div>
</div>
<p>在计算网格内部的数值通量时如下进行计算：</p>
<div class="literal-block-wrapper docutils container" id="id124">
<div class="code-block-caption"><span class="caption-text">src/dbns/numericFlux/numericFlux.C</span><a class="headerlink" href="#id124" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">forAll</span> <span class="p">(</span><span class="n">owner</span><span class="p">,</span> <span class="n">faceI</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">label</span> <span class="n">own</span> <span class="o">=</span> <span class="n">owner</span><span class="p">[</span><span class="n">faceI</span><span class="p">];</span>
    <span class="k">const</span> <span class="n">label</span> <span class="n">nei</span> <span class="o">=</span> <span class="n">neighbour</span><span class="p">[</span><span class="n">faceI</span><span class="p">];</span>

    <span class="k">const</span> <span class="n">vector</span> <span class="n">deltaRLeft</span> <span class="o">=</span> <span class="n">faceCentre</span><span class="p">[</span><span class="n">faceI</span><span class="p">]</span> <span class="o">-</span> <span class="n">cellCentre</span><span class="p">[</span><span class="n">own</span><span class="p">];</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">deltaRRight</span> <span class="o">=</span> <span class="n">faceCentre</span><span class="p">[</span><span class="n">faceI</span><span class="p">]</span> <span class="o">-</span> <span class="n">cellCentre</span><span class="p">[</span><span class="n">nei</span><span class="p">];</span>

    <span class="c1">// calculate fluxes with reconstructed primitive variables at faces</span>
    <span class="n">Flux</span><span class="o">::</span><span class="n">evaluateFlux</span>
    <span class="p">(</span>
        <span class="n">rhoFlux_</span><span class="p">[</span><span class="n">faceI</span><span class="p">],</span>
        <span class="n">rhoUFlux_</span><span class="p">[</span><span class="n">faceI</span><span class="p">],</span>
        <span class="n">rhoEFlux_</span><span class="p">[</span><span class="n">faceI</span><span class="p">],</span>
        <span class="n">p_</span><span class="p">[</span><span class="n">own</span><span class="p">]</span> <span class="o">+</span> <span class="n">pLimiter</span><span class="p">[</span><span class="n">own</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">deltaRLeft</span> <span class="o">&amp;</span> <span class="n">gradP</span><span class="p">[</span><span class="n">own</span><span class="p">]),</span>
        <span class="n">p_</span><span class="p">[</span><span class="n">nei</span><span class="p">]</span> <span class="o">+</span> <span class="n">pLimiter</span><span class="p">[</span><span class="n">nei</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">deltaRRight</span> <span class="o">&amp;</span> <span class="n">gradP</span><span class="p">[</span><span class="n">nei</span><span class="p">]),</span>
        <span class="n">U_</span><span class="p">[</span><span class="n">own</span><span class="p">]</span> <span class="o">+</span> <span class="n">cmptMultiply</span><span class="p">(</span><span class="n">ULimiter</span><span class="p">[</span><span class="n">own</span><span class="p">],</span> <span class="p">(</span><span class="n">deltaRLeft</span> <span class="o">&amp;</span> <span class="n">gradU</span><span class="p">[</span><span class="n">own</span><span class="p">])),</span>
        <span class="n">U_</span><span class="p">[</span><span class="n">nei</span><span class="p">]</span> <span class="o">+</span> <span class="n">cmptMultiply</span><span class="p">(</span><span class="n">ULimiter</span><span class="p">[</span><span class="n">nei</span><span class="p">],</span> <span class="p">(</span><span class="n">deltaRRight</span> <span class="o">&amp;</span> <span class="n">gradU</span><span class="p">[</span><span class="n">nei</span><span class="p">])),</span>
        <span class="n">T_</span><span class="p">[</span><span class="n">own</span><span class="p">]</span> <span class="o">+</span> <span class="n">TLimiter</span><span class="p">[</span><span class="n">own</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">deltaRLeft</span> <span class="o">&amp;</span> <span class="n">gradT</span><span class="p">[</span><span class="n">own</span><span class="p">]),</span>
        <span class="n">T_</span><span class="p">[</span><span class="n">nei</span><span class="p">]</span> <span class="o">+</span> <span class="n">TLimiter</span><span class="p">[</span><span class="n">nei</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">deltaRRight</span> <span class="o">&amp;</span> <span class="n">gradT</span><span class="p">[</span><span class="n">nei</span><span class="p">]),</span>
        <span class="n">R</span><span class="p">[</span><span class="n">own</span><span class="p">],</span>
        <span class="n">R</span><span class="p">[</span><span class="n">nei</span><span class="p">],</span>
        <span class="n">Cv</span><span class="p">[</span><span class="n">own</span><span class="p">],</span>
        <span class="n">Cv</span><span class="p">[</span><span class="n">nei</span><span class="p">],</span>
        <span class="n">Sf</span><span class="p">[</span><span class="n">faceI</span><span class="p">],</span>
        <span class="n">magSf</span><span class="p">[</span><span class="n">faceI</span><span class="p">]</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>对于边界处的数值通量则如下进行计算（coupled边界条件则有所不同）：</p>
<div class="literal-block-wrapper docutils container" id="id125">
<div class="code-block-caption"><span class="caption-text">src/dbns/numericFlux/numericFlux.C</span><a class="headerlink" href="#id125" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">forAll</span> <span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">facei</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Calculate fluxes</span>
    <span class="n">Flux</span><span class="o">::</span><span class="n">evaluateFlux</span>
    <span class="p">(</span>
        <span class="n">pRhoFlux</span><span class="p">[</span><span class="n">facei</span><span class="p">],</span>
        <span class="n">pRhoUFlux</span><span class="p">[</span><span class="n">facei</span><span class="p">],</span>
        <span class="n">pRhoEFlux</span><span class="p">[</span><span class="n">facei</span><span class="p">],</span>
        <span class="n">pp</span><span class="p">[</span><span class="n">facei</span><span class="p">],</span>
        <span class="n">pp</span><span class="p">[</span><span class="n">facei</span><span class="p">],</span>
        <span class="n">pU</span><span class="p">[</span><span class="n">facei</span><span class="p">],</span>
        <span class="n">pU</span><span class="p">[</span><span class="n">facei</span><span class="p">],</span>
        <span class="n">pT</span><span class="p">[</span><span class="n">facei</span><span class="p">],</span>
        <span class="n">pT</span><span class="p">[</span><span class="n">facei</span><span class="p">],</span>
        <span class="n">pR</span><span class="p">[</span><span class="n">facei</span><span class="p">],</span>
        <span class="n">pR</span><span class="p">[</span><span class="n">facei</span><span class="p">],</span>
        <span class="n">pCv</span><span class="p">[</span><span class="n">facei</span><span class="p">],</span>
        <span class="n">pCv</span><span class="p">[</span><span class="n">facei</span><span class="p">],</span>
        <span class="n">pSf</span><span class="p">[</span><span class="n">facei</span><span class="p">],</span>
        <span class="n">pMagSf</span><span class="p">[</span><span class="n">facei</span><span class="p">]</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>上述的计算数值通量所调用的evaluateFlux函数具体执行的内容由选取的Flux类型决定，其函数也在dbnsFlux中进行定义。</p>
</div>
<div class="section" id="betaflux">
<h4>betaFlux<a class="headerlink" href="#betaflux" title="永久链接至标题">¶</a></h4>
<div class="literal-block-wrapper docutils container" id="id126">
<div class="code-block-caption"><span class="caption-text">src/dbns/dbnsFlux/betaFlux/betaFlux.C</span><a class="headerlink" href="#id126" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">betaFlux</span><span class="o">::</span><span class="n">evaluateFlux</span>
<span class="p">(</span>
    <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">rhoFlux</span><span class="p">,</span>
    <span class="n">vector</span><span class="o">&amp;</span> <span class="n">rhoUFlux</span><span class="p">,</span>
    <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">rhoEFlux</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">pLeft</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">pRight</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&amp;</span> <span class="n">ULeft</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&amp;</span> <span class="n">URight</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">TLeft</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">TRight</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">RLeft</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">RRight</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">CvLeft</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">CvRight</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&amp;</span> <span class="n">Sf</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">magSf</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="c1">// Step 1: decode rho left and right:</span>
    <span class="n">scalar</span> <span class="n">rhoLeft</span> <span class="o">=</span> <span class="n">pLeft</span><span class="o">/</span><span class="p">(</span><span class="n">RLeft</span><span class="o">*</span><span class="n">TLeft</span><span class="p">);</span>
    <span class="n">scalar</span> <span class="n">rhoRight</span> <span class="o">=</span> <span class="n">pRight</span><span class="o">/</span><span class="p">(</span><span class="n">RRight</span><span class="o">*</span><span class="n">TRight</span><span class="p">);</span>

    <span class="c1">// Decode left and right total energy:</span>
    <span class="n">scalar</span> <span class="n">eLeft</span> <span class="o">=</span> <span class="n">CvLeft</span><span class="o">*</span><span class="n">TLeft</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">ULeft</span><span class="p">);</span>
    <span class="n">scalar</span> <span class="n">eRight</span> <span class="o">=</span> <span class="n">CvRight</span><span class="o">*</span><span class="n">TRight</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">URight</span><span class="p">);</span>

    <span class="c1">// Adiabatic exponent is constant for ideal gas but if Cp=Cp(T) it must be computed for each cell and evaluated at each face through reconstruction</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">kappaLeft</span> <span class="o">=</span> <span class="p">(</span><span class="n">CvLeft</span><span class="o">+</span><span class="n">RLeft</span><span class="p">)</span><span class="o">/</span><span class="n">CvLeft</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">kappaRight</span> <span class="o">=</span> <span class="p">(</span><span class="n">CvRight</span><span class="o">+</span><span class="n">RRight</span><span class="p">)</span><span class="o">/</span><span class="n">CvRight</span><span class="p">;</span>

    <span class="c1">// normal vector</span>
    <span class="n">vector</span> <span class="n">normalVector</span> <span class="o">=</span> <span class="n">Sf</span><span class="o">/</span><span class="n">magSf</span><span class="p">;</span>

    <span class="c1">// Compute left and right contravariant velocities:</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">contrVLeft</span>  <span class="o">=</span> <span class="p">(</span><span class="n">ULeft</span> <span class="o">&amp;</span> <span class="n">normalVector</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">contrVRight</span> <span class="o">=</span> <span class="p">(</span><span class="n">URight</span> <span class="o">&amp;</span> <span class="n">normalVector</span><span class="p">);</span>

    <span class="c1">// Compute left and right total enthalpies:</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">hLeft</span> <span class="o">=</span> <span class="n">eLeft</span> <span class="o">+</span> <span class="n">pLeft</span><span class="o">/</span><span class="n">rhoLeft</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">hRight</span> <span class="o">=</span> <span class="n">eRight</span> <span class="o">+</span> <span class="n">pRight</span><span class="o">/</span><span class="n">rhoRight</span><span class="p">;</span>

    <span class="c1">// Compute left and right velocity square</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">qLeftSquare</span>  <span class="o">=</span> <span class="n">magSqr</span><span class="p">(</span><span class="n">ULeft</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">qRightSquare</span> <span class="o">=</span> <span class="n">magSqr</span><span class="p">(</span><span class="n">URight</span><span class="p">);</span>

    <span class="c1">// compute left and right speed of sound</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">cLeft</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">max</span><span class="p">((</span><span class="n">kappaLeft</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">hLeft</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">qLeftSquare</span><span class="p">),</span> <span class="n">SMALL</span><span class="p">));</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">cRight</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">max</span><span class="p">((</span><span class="n">kappaRight</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">hRight</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">qRightSquare</span><span class="p">),</span> <span class="n">SMALL</span><span class="p">));</span>

    <span class="k">const</span> <span class="n">scalar</span> <span class="n">magULeft</span>  <span class="o">=</span> <span class="n">mag</span><span class="p">(</span><span class="n">ULeft</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">magURight</span> <span class="o">=</span> <span class="n">mag</span><span class="p">(</span><span class="n">URight</span><span class="p">);</span>

    <span class="k">const</span> <span class="n">scalar</span> <span class="n">MLeft</span> <span class="o">=</span> <span class="n">mag</span><span class="p">(</span><span class="n">magULeft</span><span class="o">/</span><span class="n">cLeft</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">MRight</span> <span class="o">=</span> <span class="n">mag</span><span class="p">(</span><span class="n">magURight</span><span class="o">/</span><span class="n">cRight</span><span class="p">);</span>

    <span class="c1">// Compute beta parameter - this should be done in multidimensional way similarly to multidimensional limiters</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">Mmax</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">MLeft</span><span class="p">,</span> <span class="n">MRight</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">Mmin</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">MLeft</span><span class="p">,</span> <span class="n">MRight</span><span class="p">);</span>

    <span class="n">scalar</span> <span class="n">beta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">Mmin</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">scalar</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>
        <span class="n">scalar</span> <span class="n">r</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">sqr</span><span class="p">(</span><span class="n">Mmax</span><span class="p">)</span> <span class="o">-</span> <span class="n">sqr</span><span class="p">(</span><span class="n">Mmin</span><span class="p">))</span><span class="o">/</span><span class="n">Mmin</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&gt;=</span> <span class="n">alpha</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Step 2: compute Roe averaged quantities for face:</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">rhoTilde</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">rhoLeft</span><span class="o">*</span><span class="n">rhoRight</span><span class="p">,</span> <span class="n">SMALL</span><span class="p">));</span>

    <span class="c1">// Some temporary variables:</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">rhoLeftSqrt</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">rhoLeft</span><span class="p">,</span> <span class="n">SMALL</span><span class="p">));</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">rhoRightSqrt</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">rhoRight</span><span class="p">,</span> <span class="n">SMALL</span><span class="p">));</span>

    <span class="k">const</span> <span class="n">scalar</span> <span class="n">wLeft</span> <span class="o">=</span> <span class="n">rhoLeftSqrt</span><span class="o">/</span><span class="p">(</span><span class="n">rhoLeftSqrt</span> <span class="o">+</span> <span class="n">rhoRightSqrt</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">wRight</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">wLeft</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">vector</span> <span class="n">UTilde</span> <span class="o">=</span> <span class="n">ULeft</span><span class="o">*</span><span class="n">wLeft</span> <span class="o">+</span> <span class="n">URight</span><span class="o">*</span><span class="n">wRight</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">hTilde</span> <span class="o">=</span> <span class="n">hLeft</span><span class="o">*</span><span class="n">wLeft</span> <span class="o">+</span> <span class="n">hRight</span><span class="o">*</span><span class="n">wRight</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">qTildeSquare</span> <span class="o">=</span> <span class="n">magSqr</span><span class="p">(</span><span class="n">UTilde</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">kappaTilde</span> <span class="o">=</span> <span class="n">kappaLeft</span><span class="o">*</span><span class="n">wLeft</span> <span class="o">+</span> <span class="n">kappaRight</span><span class="o">*</span><span class="n">wRight</span><span class="p">;</span>

    <span class="c1">// Speed of sound</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">cTilde</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">max</span><span class="p">((</span><span class="n">kappaTilde</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">hTilde</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">qTildeSquare</span><span class="p">),</span> <span class="n">SMALL</span><span class="p">));</span>

    <span class="c1">// Roe averaged contravariant velocity</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">contrVTilde</span> <span class="o">=</span> <span class="p">(</span><span class="n">UTilde</span> <span class="o">&amp;</span> <span class="n">normalVector</span><span class="p">);</span>

    <span class="c1">// Step 3: compute primitive differences:</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">deltaP</span> <span class="o">=</span> <span class="n">pRight</span> <span class="o">-</span> <span class="n">pLeft</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">deltaRho</span> <span class="o">=</span> <span class="n">rhoRight</span> <span class="o">-</span> <span class="n">rhoLeft</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">deltaU</span> <span class="o">=</span> <span class="n">URight</span> <span class="o">-</span> <span class="n">ULeft</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">deltaContrV</span> <span class="o">=</span> <span class="p">(</span><span class="n">deltaU</span> <span class="o">&amp;</span> <span class="n">normalVector</span><span class="p">);</span>

    <span class="c1">// Step 4: compute wave strengths:</span>

    <span class="c1">// Roe and Pike - formulation</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">r1</span> <span class="o">=</span> <span class="p">(</span><span class="n">deltaP</span> <span class="o">-</span> <span class="n">rhoTilde</span><span class="o">*</span><span class="n">cTilde</span><span class="o">*</span><span class="n">deltaContrV</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">sqr</span><span class="p">(</span><span class="n">cTilde</span><span class="p">));</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">deltaRho</span> <span class="o">-</span> <span class="n">deltaP</span><span class="o">/</span><span class="n">sqr</span><span class="p">(</span><span class="n">cTilde</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">r3</span> <span class="o">=</span> <span class="p">(</span><span class="n">deltaP</span> <span class="o">+</span> <span class="n">rhoTilde</span><span class="o">*</span><span class="n">cTilde</span><span class="o">*</span><span class="n">deltaContrV</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">sqr</span><span class="p">(</span><span class="n">cTilde</span><span class="p">));</span>

    <span class="c1">// Step 5: compute l vectors</span>

    <span class="c1">// rho row:</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">l1rho</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">l2rho</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">l3rho</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">l4rho</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">// first U column</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">l1U</span> <span class="o">=</span> <span class="n">UTilde</span> <span class="o">-</span> <span class="n">cTilde</span><span class="o">*</span><span class="n">normalVector</span><span class="p">;</span>

    <span class="c1">// second U column</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">l2U</span> <span class="o">=</span> <span class="n">UTilde</span><span class="p">;</span>

    <span class="c1">// third U column</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">l3U</span> <span class="o">=</span> <span class="n">deltaU</span> <span class="o">-</span> <span class="n">deltaContrV</span><span class="o">*</span><span class="n">normalVector</span><span class="p">;</span>

    <span class="c1">// fourth U column</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">l4U</span> <span class="o">=</span> <span class="n">UTilde</span> <span class="o">+</span> <span class="n">cTilde</span><span class="o">*</span><span class="n">normalVector</span><span class="p">;</span>

    <span class="c1">// E row</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">l1e</span> <span class="o">=</span> <span class="n">hTilde</span> <span class="o">-</span> <span class="n">cTilde</span><span class="o">*</span><span class="n">contrVTilde</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">l2e</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">qTildeSquare</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">l3e</span> <span class="o">=</span> <span class="p">(</span><span class="n">UTilde</span> <span class="o">&amp;</span> <span class="n">deltaU</span><span class="p">)</span> <span class="o">-</span> <span class="n">contrVTilde</span><span class="o">*</span><span class="n">deltaContrV</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">l4e</span> <span class="o">=</span> <span class="n">hTilde</span> <span class="o">+</span> <span class="n">cTilde</span><span class="o">*</span><span class="n">contrVTilde</span><span class="p">;</span>

    <span class="c1">// Step 6: compute eigenvalues</span>

    <span class="n">scalar</span> <span class="n">lambda1</span> <span class="o">=</span> <span class="n">mag</span><span class="p">(</span><span class="n">contrVTilde</span> <span class="o">-</span> <span class="n">cTilde</span><span class="p">);</span>
    <span class="n">scalar</span> <span class="n">lambda2</span> <span class="o">=</span> <span class="n">mag</span><span class="p">(</span><span class="n">contrVTilde</span><span class="p">);</span>
    <span class="n">scalar</span> <span class="n">lambda3</span> <span class="o">=</span> <span class="n">mag</span><span class="p">(</span><span class="n">contrVTilde</span> <span class="o">+</span> <span class="n">cTilde</span><span class="p">);</span>

    <span class="n">scalar</span> <span class="n">lambdaMax</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">lambda1</span><span class="p">,</span> <span class="n">lambda2</span><span class="p">),</span> <span class="n">lambda3</span><span class="p">);</span>

    <span class="n">scalar</span> <span class="n">lambda1Max</span> <span class="o">=</span> <span class="n">beta</span><span class="o">*</span><span class="n">lambda1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">beta</span><span class="p">)</span><span class="o">*</span><span class="n">lambdaMax</span><span class="p">;</span>
    <span class="n">scalar</span> <span class="n">lambda2Max</span> <span class="o">=</span> <span class="n">beta</span><span class="o">*</span><span class="n">lambda2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">beta</span><span class="p">)</span><span class="o">*</span><span class="n">lambdaMax</span><span class="p">;</span>
    <span class="n">scalar</span> <span class="n">lambda3Max</span> <span class="o">=</span> <span class="n">beta</span><span class="o">*</span><span class="n">lambda3</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">beta</span><span class="p">)</span><span class="o">*</span><span class="n">lambdaMax</span><span class="p">;</span>

    <span class="c1">// Step 7: check for Harten entropy correction</span>


    <span class="c1">// Components of deltaF1</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">diffF11</span>  <span class="o">=</span> <span class="n">lambda1Max</span><span class="o">*</span><span class="n">r1</span><span class="o">*</span><span class="n">l1rho</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">diffF124</span> <span class="o">=</span> <span class="n">lambda1Max</span><span class="o">*</span><span class="n">r1</span><span class="o">*</span><span class="n">l1U</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">diffF15</span>  <span class="o">=</span> <span class="n">lambda1Max</span><span class="o">*</span><span class="n">r1</span><span class="o">*</span><span class="n">l1e</span><span class="p">;</span>

    <span class="c1">// Components of deltaF2</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">diffF21</span>  <span class="o">=</span> <span class="n">lambda2Max</span><span class="o">*</span><span class="p">(</span><span class="n">r2</span><span class="o">*</span><span class="n">l2rho</span> <span class="o">+</span> <span class="n">rhoTilde</span><span class="o">*</span><span class="n">l3rho</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">diffF224</span> <span class="o">=</span> <span class="n">lambda2Max</span><span class="o">*</span><span class="p">(</span><span class="n">r2</span><span class="o">*</span><span class="n">l2U</span> <span class="o">+</span> <span class="n">rhoTilde</span><span class="o">*</span><span class="n">l3U</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">diffF25</span>  <span class="o">=</span> <span class="n">lambda2Max</span><span class="o">*</span><span class="p">(</span><span class="n">r2</span><span class="o">*</span><span class="n">l2e</span> <span class="o">+</span> <span class="n">rhoTilde</span><span class="o">*</span><span class="n">l3e</span><span class="p">);</span>

    <span class="c1">// Components of deltaF3</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">diffF31</span>  <span class="o">=</span> <span class="n">lambda3Max</span><span class="o">*</span><span class="n">r3</span><span class="o">*</span><span class="n">l4rho</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">diffF324</span> <span class="o">=</span> <span class="n">lambda3Max</span><span class="o">*</span><span class="n">r3</span><span class="o">*</span><span class="n">l4U</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">diffF35</span>  <span class="o">=</span> <span class="n">lambda3Max</span><span class="o">*</span><span class="n">r3</span><span class="o">*</span><span class="n">l4e</span><span class="p">;</span>

    <span class="c1">// Step 8: compute left and right fluxes</span>

    <span class="c1">// Left flux 5-vector</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">fluxLeft11</span> <span class="o">=</span> <span class="n">rhoLeft</span><span class="o">*</span><span class="n">contrVLeft</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">fluxLeft124</span> <span class="o">=</span> <span class="n">ULeft</span><span class="o">*</span><span class="n">fluxLeft11</span> <span class="o">+</span> <span class="n">normalVector</span><span class="o">*</span><span class="n">pLeft</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">fluxLeft15</span> <span class="o">=</span> <span class="n">hLeft</span><span class="o">*</span><span class="n">fluxLeft11</span><span class="p">;</span>

    <span class="c1">// Right flux 5-vector</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">fluxRight11</span> <span class="o">=</span> <span class="n">rhoRight</span><span class="o">*</span><span class="n">contrVRight</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">fluxRight124</span> <span class="o">=</span> <span class="n">URight</span><span class="o">*</span><span class="n">fluxRight11</span> <span class="o">+</span> <span class="n">normalVector</span><span class="o">*</span><span class="n">pRight</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">fluxRight15</span> <span class="o">=</span> <span class="n">hRight</span><span class="o">*</span><span class="n">fluxRight11</span><span class="p">;</span>

    <span class="c1">// Step 9: compute face flux 5-vector</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">flux1</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">fluxLeft11</span> <span class="o">+</span> <span class="n">fluxRight11</span> <span class="o">-</span> <span class="p">(</span><span class="n">diffF11</span> <span class="o">+</span> <span class="n">diffF21</span> <span class="o">+</span> <span class="n">diffF31</span><span class="p">));</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">flux24</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">fluxLeft124</span> <span class="o">+</span> <span class="n">fluxRight124</span> <span class="o">-</span> <span class="p">(</span><span class="n">diffF124</span> <span class="o">+</span> <span class="n">diffF224</span> <span class="o">+</span> <span class="n">diffF324</span><span class="p">));</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">flux5</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">fluxLeft15</span> <span class="o">+</span> <span class="n">fluxRight15</span> <span class="o">-</span> <span class="p">(</span><span class="n">diffF15</span> <span class="o">+</span> <span class="n">diffF25</span> <span class="o">+</span> <span class="n">diffF35</span><span class="p">));</span>

    <span class="c1">// Compute private data</span>
    <span class="n">rhoFlux</span>  <span class="o">=</span> <span class="n">flux1</span><span class="o">*</span><span class="n">magSf</span><span class="p">;</span>
    <span class="n">rhoUFlux</span> <span class="o">=</span> <span class="n">flux24</span><span class="o">*</span><span class="n">magSf</span><span class="p">;</span>
    <span class="n">rhoEFlux</span> <span class="o">=</span> <span class="n">flux5</span><span class="o">*</span><span class="n">magSf</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="hllcflux">
<h4>hllcFlux<a class="headerlink" href="#hllcflux" title="永久链接至标题">¶</a></h4>
<div class="math notranslate nohighlight">
\[\begin{align}
\kappa_{L} = \frac{R_{L} - C_{vL}}{C_{vL}} ,\quad \kappa_{R} = \frac{R_{R} - C_{vR}}{C_{vR}}
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
\rho_{L} = \frac{p_{L}}{R_{L}T_{L}} ,\quad \rho_{R} = \frac{p_{R}}{R_{R}T_{R}}
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
(\rho\mathbf{U})_{L} = \rho_{L}\mathbf{U}_{L} ,\quad (\rho\mathbf{U})_{R} = \rho_{R}\mathbf{U}_{R}
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
(\rho E)_{L} = \rho_{L}(C_{vL}T_{L} + \frac{1}{2}|\mathbf{U}_{L}|^{2})
,\quad
(\rho E)_{R} = \rho_{R}(C_{vR}T_{R} + \frac{1}{2}|\mathbf{U}_{R}|^{2})
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
H_{L} = \frac{(\rho E)_{L} + p_{L}}{\rho_{L}}
,\quad
H_{R} = \frac{(\rho E)_{R} + p_{R}}{\rho_{R}}
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
a_{L} = \sqrt{\frac{\kappa_{L}p_{L}}{\rho_{L}}}
,\quad
a_{R} = \sqrt{\frac{\kappa_{R}p_{R}}{\rho_{R}}}
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
\tilde{\mathbf{U}} = \frac{\sqrt{\rho_{L}}}{\sqrt{\rho_{L}} + \sqrt{\rho_{R}}}\mathbf{U}_{L} + \frac{\sqrt{\rho_{R}}}{\sqrt{\rho_{L}} + \sqrt{\rho_{R}}}\mathbf{U}_{R}
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
\tilde{H} = \frac{\sqrt{\rho_{L}}}{\sqrt{\rho_{L}} + \sqrt{\rho_{R}}}H_{L} + \frac{\sqrt{\rho_{R}}}{\sqrt{\rho_{L}} + \sqrt{\rho_{R}}}H_{R}
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
\tilde{\kappa} = \frac{\sqrt{\rho_{L}}}{\sqrt{\rho_{L}} + \sqrt{\rho_{R}}}\kappa_{L} + \frac{\sqrt{\rho_{R}}}{\sqrt{\rho_{L}} + \sqrt{\rho_{R}}}\kappa_{R}
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
\tilde{a} = \sqrt{(\tilde{\kappa} - 1) \Big(\tilde{H} - \frac{1}{2}(\tilde{\mathbf{U}} \cdot \mathbf{n}_{f})\Big)}
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
S_{L} = \min\Big( \mathbf{U}_{L}\cdot\mathbf{n}_{f} - a_{L}, \tilde{\mathbf{U}}\cdot\mathbf{n}_{f} - \tilde{a} \Big)
,\quad
S_{R} = \max\Big( \mathbf{U}_{R}\cdot\mathbf{n}_{f} + a_{R}, \tilde{\mathbf{U}}\cdot\mathbf{n}_{f} + \tilde{a} \Big)
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
S_{*} = \frac{
\rho_{R}(\mathbf{U}_{R}\cdot\mathbf{n}_{f})(S_{R} - \mathbf{U}_{R}\cdot\mathbf{n}_{f})
- \rho_{L}(\mathbf{U}_{L}\cdot\mathbf{n}_{f})(S_{L} - \mathbf{U}_{L}\cdot\mathbf{n}_{f})
+ p_{L} - p_{R}
}{
\rho_{R}(S_{R} - \mathbf{U}_{R}\cdot\mathbf{n}_{f}) - \rho_{L}(S_{L} - \mathbf{U}_{L}\cdot\mathbf{n}_{f})
}
\end{align}\]</div>
<div class="math notranslate nohighlight">
\[\begin{align}
p_{*L} = \rho_{L}(\mathbf{U}_{L}\cdot\mathbf{n}_{f} - S_{L})(\mathbf{U}_{L}\cdot\mathbf{n}_{f} - S_{*}) + p_{L}
,\quad
p_{*R} = \rho_{R}(\mathbf{U}_{R}\cdot\mathbf{n}_{f} - S_{R})(\mathbf{U}_{R}\cdot\mathbf{n}_{f} - S_{*}) + p_{R}
,\quad
p_{*} = p_{*L} = p_{*R}
\end{align}\]</div>
<p>如果 <span class="math notranslate nohighlight">\(S_{L} &gt; 0\)</span> ，则</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\mathbf{F} =
\begin{bmatrix}
(\mathbf{U}_{L}\cdot\mathbf{n}_{f}) \rho_{L} S_{f} \\
\Big((\mathbf{U}_{L}\cdot\mathbf{n}_{f}) (\rho\mathbf{U})_{L} + p_{L}\mathbf{n}_{f}\Big)S_{f} \\
(\mathbf{U}_{L}\cdot\mathbf{n}_{f})\big((\rho E)_{L} + p_{L}\big)S_{f}
\end{bmatrix}
\end{align}\end{split}\]</div>
<p>如果 <span class="math notranslate nohighlight">\(S_{*} &gt; 0\)</span> ，则</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\mathbf{F} =
\begin{bmatrix}
S_{*}\frac{S_{L} - \mathbf{U}_{L}\cdot\mathbf{n}_{f}}{S_{L} - S_{*}}\rho_{L}S_{f} \\
\Big( S_{*}\frac{(S_{L} - \mathbf{U}_{L}\cdot\mathbf{n}_{f})(\rho\mathbf{U})_{L} + (p_{*} - p_{L})\mathbf{n}_{f}}{S_{L} - S_{*}} + p_{*}\mathbf{n}_{f} \Big)S_{f} \\
S_{*}\Big(\frac{(S_{L} - \mathbf{U}_{L}\cdot\mathbf{n}_{f})(\rho E)_{L} - p_{L}(\mathbf{U}_{L}\cdot\mathbf{n}_{f}) + p_{*}S_{*}}{S_{L} - S_{*}} + p_{*}\Big)S_{f}
\end{bmatrix}
\end{align}\end{split}\]</div>
<p>如果 <span class="math notranslate nohighlight">\(S_{R} &gt; 0\)</span> ，则</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\mathbf{F} =
\begin{bmatrix}
S_{*}\frac{S_{R} - \mathbf{U}_{R}\cdot\mathbf{n}_{f}}{S_{L} - S_{*}}\rho_{R}S_{f} \\
\Big( S_{*}\frac{(S_{R} - \mathbf{U}_{R}\cdot\mathbf{n}_{f})(\rho\mathbf{U})_{R} + (p_{*} - p_{R})\mathbf{n}_{f}}{S_{R} - S_{*}} + p_{*}\mathbf{n}_{f} \Big)S_{f} \\
S_{*}\Big(\frac{(S_{R} - \mathbf{U}_{R}\cdot\mathbf{n}_{f})(\rho E)_{R} - p_{R}(\mathbf{U}_{R}\cdot\mathbf{n}_{f}) + p_{*}S_{*}}{S_{R} - S_{*}} + p_{*}\Big)S_{f}
\end{bmatrix}
\end{align}\end{split}\]</div>
<p>如果 <span class="math notranslate nohighlight">\(S_{R} &lt; 0\)</span> ，则</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\mathbf{F} =
\begin{bmatrix}
(\mathbf{U}_{R}\cdot\mathbf{n}_{f}) \rho_{R} S_{f} \\
\Big((\mathbf{U}_{R}\cdot\mathbf{n}_{f}) (\rho\mathbf{U})_{R} + p_{R}\mathbf{n}_{f}\Big)S_{f} \\
(\mathbf{U}_{R}\cdot\mathbf{n}_{f})\big((\rho E)_{R} + p_{R}\big)S_{f}
\end{bmatrix}
\end{align}\end{split}\]</div>
<div class="literal-block-wrapper docutils container" id="id127">
<div class="code-block-caption"><span class="caption-text">src/dbns/dbnsFlux/hllcFlux/hllcFlux.C</span><a class="headerlink" href="#id127" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">hllcFlux</span><span class="o">::</span><span class="n">evaluateFlux</span>
<span class="p">(</span>
    <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">rhoFlux</span><span class="p">,</span>
    <span class="n">vector</span><span class="o">&amp;</span> <span class="n">rhoUFlux</span><span class="p">,</span>
    <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">rhoEFlux</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">pLeft</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">pRight</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&amp;</span> <span class="n">ULeft</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&amp;</span> <span class="n">URight</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">TLeft</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">TRight</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">RLeft</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">RRight</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">CvLeft</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">CvRight</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&amp;</span> <span class="n">Sf</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">magSf</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="c1">// Step 1: decode left and right:</span>
    <span class="c1">// normal vector</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">normalVector</span> <span class="o">=</span> <span class="n">Sf</span><span class="o">/</span><span class="n">magSf</span><span class="p">;</span>

    <span class="c1">// Ratio of specific heat capacities</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">kappaLeft</span> <span class="o">=</span> <span class="p">(</span><span class="n">RLeft</span> <span class="o">+</span> <span class="n">CvLeft</span><span class="p">)</span><span class="o">/</span><span class="n">CvLeft</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">kappaRight</span> <span class="o">=</span> <span class="p">(</span><span class="n">RRight</span> <span class="o">+</span> <span class="n">CvRight</span><span class="p">)</span><span class="o">/</span><span class="n">CvRight</span><span class="p">;</span>

    <span class="c1">// Compute conservative variables assuming perfect gas law</span>

    <span class="c1">// Density</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">rhoLeft</span> <span class="o">=</span> <span class="n">pLeft</span><span class="o">/</span><span class="p">(</span><span class="n">RLeft</span><span class="o">*</span><span class="n">TLeft</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">rhoRight</span> <span class="o">=</span> <span class="n">pRight</span><span class="o">/</span><span class="p">(</span><span class="n">RRight</span><span class="o">*</span><span class="n">TRight</span><span class="p">);</span>

    <span class="c1">// DensityVelocity</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">rhoULeft</span> <span class="o">=</span> <span class="n">rhoLeft</span><span class="o">*</span><span class="n">ULeft</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">rhoURight</span> <span class="o">=</span> <span class="n">rhoRight</span><span class="o">*</span><span class="n">URight</span><span class="p">;</span>

    <span class="c1">// DensityTotalEnergy</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">rhoELeft</span> <span class="o">=</span> <span class="n">rhoLeft</span><span class="o">*</span><span class="p">(</span><span class="n">CvLeft</span><span class="o">*</span><span class="n">TLeft</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">ULeft</span><span class="p">));</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">rhoERight</span> <span class="o">=</span> <span class="n">rhoRight</span><span class="o">*</span><span class="p">(</span><span class="n">CvRight</span><span class="o">*</span><span class="n">TRight</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">URight</span><span class="p">));</span>

    <span class="c1">// Compute left and right total enthalpies:</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">HLeft</span> <span class="o">=</span> <span class="p">(</span><span class="n">rhoELeft</span> <span class="o">+</span> <span class="n">pLeft</span><span class="p">)</span><span class="o">/</span><span class="n">rhoLeft</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">HRight</span> <span class="o">=</span> <span class="p">(</span><span class="n">rhoERight</span> <span class="o">+</span> <span class="n">pRight</span><span class="p">)</span><span class="o">/</span><span class="n">rhoRight</span><span class="p">;</span>

    <span class="c1">// Compute qLeft and qRight (q_{l,r} = U_{l,r} \bullet n)</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">qLeft</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULeft</span> <span class="o">&amp;</span> <span class="n">normalVector</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">qRight</span> <span class="o">=</span> <span class="p">(</span><span class="n">URight</span> <span class="o">&amp;</span> <span class="n">normalVector</span><span class="p">);</span>

    <span class="c1">// Speed of sound, for left and right side, assuming perfect gas</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">aLeft</span> <span class="o">=</span> <span class="n">Foam</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="n">kappaLeft</span> <span class="o">*</span> <span class="n">pLeft</span><span class="o">/</span><span class="n">rhoLeft</span><span class="p">));</span>

    <span class="k">const</span> <span class="n">scalar</span> <span class="n">aRight</span> <span class="o">=</span> <span class="n">Foam</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="n">kappaRight</span> <span class="o">*</span> <span class="n">pRight</span><span class="o">/</span><span class="n">rhoRight</span><span class="p">));</span>


    <span class="c1">// Step 2:</span>
    <span class="c1">// needs rho_{l,r}, U_{l,r}, H_{l,r}, kappa_{l,r}, Gamma_{l,r}, q_{l,r}</span>

    <span class="c1">// Compute Roe weights</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">rhoLeftSqrt</span> <span class="o">=</span> <span class="n">Foam</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="n">rhoLeft</span><span class="p">));</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">rhoRightSqrt</span> <span class="o">=</span> <span class="n">Foam</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="n">rhoRight</span><span class="p">));</span>

    <span class="k">const</span> <span class="n">scalar</span> <span class="n">wLeft</span> <span class="o">=</span> <span class="n">rhoLeftSqrt</span><span class="o">/</span><span class="n">stabilise</span><span class="p">((</span><span class="n">rhoLeftSqrt</span> <span class="o">+</span> <span class="n">rhoRightSqrt</span><span class="p">),</span><span class="n">VSMALL</span><span class="p">);</span>

    <span class="k">const</span> <span class="n">scalar</span> <span class="n">wRight</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">wLeft</span><span class="p">;</span>

    <span class="c1">// Roe averaged velocity</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">UTilde</span> <span class="o">=</span> <span class="n">wLeft</span><span class="o">*</span><span class="n">ULeft</span> <span class="o">+</span> <span class="n">wRight</span><span class="o">*</span><span class="n">URight</span><span class="p">;</span>

    <span class="c1">// Roe averaged contravariant velocity</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">contrUTilde</span> <span class="o">=</span> <span class="p">(</span><span class="n">UTilde</span> <span class="o">&amp;</span> <span class="n">normalVector</span><span class="p">);</span>

    <span class="c1">// Roe averaged total enthalpy</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">HTilde</span> <span class="o">=</span> <span class="n">wLeft</span><span class="o">*</span><span class="n">HLeft</span> <span class="o">+</span> <span class="n">wRight</span><span class="o">*</span><span class="n">HRight</span><span class="p">;</span>

    <span class="c1">// Roe averaged kappa</span>
    <span class="c1">// TODO: needs to be verified!</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">kappaTilde</span> <span class="o">=</span> <span class="n">wLeft</span><span class="o">*</span><span class="n">kappaLeft</span> <span class="o">+</span> <span class="n">wRight</span><span class="o">*</span><span class="n">kappaRight</span><span class="p">;</span>

    <span class="c1">// Speed of sound with Roe reconstruction values</span>
    <span class="c1">// TODO: not sure if the correct (flow speed) and kappa is used here</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">aTilde</span> <span class="o">=</span> <span class="n">Foam</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span> <span class="p">,(</span><span class="n">kappaTilde</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">HTilde</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">sqr</span><span class="p">(</span><span class="n">contrUTilde</span><span class="p">))));</span>

    <span class="c1">// Step 3: compute signal speeds for face:</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">SLeft</span>  <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">qLeft</span><span class="o">-</span><span class="n">aLeft</span><span class="p">,</span> <span class="n">contrUTilde</span><span class="o">-</span><span class="n">aTilde</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">SRight</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">contrUTilde</span><span class="o">+</span><span class="n">aTilde</span><span class="p">,</span> <span class="n">qRight</span><span class="o">+</span><span class="n">aRight</span><span class="p">);</span>

    <span class="k">const</span> <span class="n">scalar</span> <span class="n">SStar</span> <span class="o">=</span> <span class="p">(</span><span class="n">rhoRight</span><span class="o">*</span><span class="n">qRight</span><span class="o">*</span><span class="p">(</span><span class="n">SRight</span><span class="o">-</span><span class="n">qRight</span><span class="p">)</span> <span class="o">-</span> <span class="n">rhoLeft</span><span class="o">*</span><span class="n">qLeft</span><span class="o">*</span><span class="p">(</span><span class="n">SLeft</span> <span class="o">-</span> <span class="n">qLeft</span><span class="p">)</span> <span class="o">+</span> <span class="n">pLeft</span> <span class="o">-</span> <span class="n">pRight</span> <span class="p">)</span><span class="o">/</span><span class="n">stabilise</span><span class="p">((</span><span class="n">rhoRight</span><span class="o">*</span><span class="p">(</span><span class="n">SRight</span><span class="o">-</span><span class="n">qRight</span><span class="p">)</span><span class="o">-</span><span class="n">rhoLeft</span><span class="o">*</span><span class="p">(</span><span class="n">SLeft</span><span class="o">-</span><span class="n">qLeft</span><span class="p">)),</span><span class="n">VSMALL</span><span class="p">);</span>

    <span class="c1">// Compute pressure in star region from the right side</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">pStarRight</span> <span class="o">=</span> <span class="n">rhoRight</span><span class="o">*</span><span class="p">(</span><span class="n">qRight</span> <span class="o">-</span> <span class="n">SRight</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">qRight</span> <span class="o">-</span> <span class="n">SStar</span><span class="p">)</span> <span class="o">+</span> <span class="n">pRight</span><span class="p">;</span>

    <span class="c1">// Should be equal to the left side</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">pStarLeft</span>  <span class="o">=</span> <span class="n">rhoLeft</span><span class="o">*</span><span class="p">(</span><span class="n">qLeft</span> <span class="o">-</span>  <span class="n">SLeft</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">qLeft</span> <span class="o">-</span> <span class="n">SStar</span><span class="p">)</span> <span class="o">+</span> <span class="n">pLeft</span><span class="p">;</span>

    <span class="c1">// Give a warning if this is not the case</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mag</span><span class="p">(</span><span class="n">pStarRight</span> <span class="o">-</span> <span class="n">pStarLeft</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-6</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Info</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;mag(pStarRight-pStarLeft) &gt; VSMALL &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Use pStarRight for pStar, as in theory, pStarRight == pStarLeft</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">pStar</span> <span class="o">=</span> <span class="n">pStarRight</span><span class="p">;</span>

    <span class="c1">// Step 4: upwinding - compute states:</span>
    <span class="n">scalar</span> <span class="n">convectionSpeed</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="n">scalar</span> <span class="n">rhoState</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="n">vector</span> <span class="n">rhoUState</span> <span class="o">=</span> <span class="n">vector</span><span class="o">::</span><span class="n">zero</span><span class="p">;</span>
    <span class="n">scalar</span> <span class="n">rhoEState</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="n">scalar</span> <span class="n">pState</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="p">(</span><span class="n">SLeft</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="c1">// compute F_l</span>
        <span class="n">convectionSpeed</span> <span class="o">=</span> <span class="n">qLeft</span><span class="p">;</span>
        <span class="n">rhoState</span>  <span class="o">=</span> <span class="n">rhoLeft</span><span class="p">;</span>
        <span class="n">rhoUState</span> <span class="o">=</span> <span class="n">rhoULeft</span><span class="p">;</span>
        <span class="n">rhoEState</span> <span class="o">=</span> <span class="n">rhoELeft</span><span class="p">;</span>
        <span class="n">pState</span> <span class="o">=</span> <span class="n">pLeft</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="p">(</span><span class="n">SStar</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">scalar</span> <span class="n">omegaLeft</span> <span class="o">=</span> <span class="n">scalar</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span class="o">/</span><span class="n">stabilise</span><span class="p">((</span><span class="n">SLeft</span> <span class="o">-</span> <span class="n">SStar</span><span class="p">),</span> <span class="n">VSMALL</span><span class="p">);</span>

        <span class="c1">// Compute left star region</span>
        <span class="n">convectionSpeed</span> <span class="o">=</span> <span class="n">SStar</span><span class="p">;</span>
        <span class="n">rhoState</span>  <span class="o">=</span> <span class="n">omegaLeft</span><span class="o">*</span><span class="p">(</span><span class="n">SLeft</span> <span class="o">-</span> <span class="n">qLeft</span><span class="p">)</span><span class="o">*</span><span class="n">rhoLeft</span><span class="p">;</span>
        <span class="n">rhoUState</span> <span class="o">=</span> <span class="n">omegaLeft</span><span class="o">*</span><span class="p">((</span><span class="n">SLeft</span> <span class="o">-</span> <span class="n">qLeft</span><span class="p">)</span><span class="o">*</span><span class="n">rhoULeft</span> <span class="o">+</span> <span class="p">(</span><span class="n">pStar</span> <span class="o">-</span> <span class="n">pLeft</span><span class="p">)</span><span class="o">*</span><span class="n">normalVector</span><span class="p">);</span>
        <span class="n">rhoEState</span> <span class="o">=</span> <span class="n">omegaLeft</span><span class="o">*</span><span class="p">((</span><span class="n">SLeft</span> <span class="o">-</span> <span class="n">qLeft</span><span class="p">)</span><span class="o">*</span><span class="n">rhoELeft</span> <span class="o">-</span> <span class="n">pLeft</span><span class="o">*</span><span class="n">qLeft</span> <span class="o">+</span> <span class="n">pStar</span><span class="o">*</span><span class="n">SStar</span><span class="p">);</span>
        <span class="n">pState</span> <span class="o">=</span> <span class="n">pStar</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="p">(</span><span class="n">SRight</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">scalar</span> <span class="n">omegaRight</span> <span class="o">=</span> <span class="n">scalar</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span class="o">/</span><span class="n">stabilise</span><span class="p">((</span><span class="n">SRight</span> <span class="o">-</span> <span class="n">SStar</span><span class="p">),</span> <span class="n">VSMALL</span><span class="p">);</span>

        <span class="c1">// compute right star region</span>
        <span class="n">convectionSpeed</span> <span class="o">=</span> <span class="n">SStar</span><span class="p">;</span>
        <span class="n">rhoState</span>  <span class="o">=</span> <span class="n">omegaRight</span><span class="o">*</span><span class="p">(</span><span class="n">SRight</span> <span class="o">-</span> <span class="n">qRight</span><span class="p">)</span><span class="o">*</span><span class="n">rhoRight</span><span class="p">;</span>
        <span class="n">rhoUState</span> <span class="o">=</span> <span class="n">omegaRight</span><span class="o">*</span><span class="p">((</span><span class="n">SRight</span> <span class="o">-</span> <span class="n">qRight</span><span class="p">)</span><span class="o">*</span><span class="n">rhoURight</span> <span class="o">+</span> <span class="p">(</span><span class="n">pStar</span> <span class="o">-</span> <span class="n">pRight</span><span class="p">)</span><span class="o">*</span><span class="n">normalVector</span><span class="p">);</span>
        <span class="n">rhoEState</span> <span class="o">=</span> <span class="n">omegaRight</span><span class="o">*</span><span class="p">((</span><span class="n">SRight</span> <span class="o">-</span> <span class="n">qRight</span><span class="p">)</span><span class="o">*</span><span class="n">rhoERight</span> <span class="o">-</span> <span class="n">pRight</span><span class="o">*</span><span class="n">qRight</span> <span class="o">+</span> <span class="n">pStar</span><span class="o">*</span><span class="n">SStar</span><span class="p">);</span>
        <span class="n">pState</span> <span class="o">=</span> <span class="n">pStar</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">neg</span><span class="p">(</span><span class="n">SRight</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="c1">// compute F_r</span>
        <span class="n">convectionSpeed</span> <span class="o">=</span> <span class="n">qRight</span><span class="p">;</span>
        <span class="n">rhoState</span>  <span class="o">=</span> <span class="n">rhoRight</span><span class="p">;</span>
        <span class="n">rhoUState</span> <span class="o">=</span> <span class="n">rhoURight</span><span class="p">;</span>
        <span class="n">rhoEState</span> <span class="o">=</span> <span class="n">rhoERight</span><span class="p">;</span>
        <span class="n">pState</span> <span class="o">=</span> <span class="n">pRight</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">Info</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Error in HLLC Riemann solver&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">rhoFlux</span>  <span class="o">=</span> <span class="p">(</span><span class="n">convectionSpeed</span><span class="o">*</span><span class="n">rhoState</span><span class="p">)</span><span class="o">*</span><span class="n">magSf</span><span class="p">;</span>
    <span class="n">rhoUFlux</span> <span class="o">=</span> <span class="p">(</span><span class="n">convectionSpeed</span><span class="o">*</span><span class="n">rhoUState</span> <span class="o">+</span> <span class="n">pState</span><span class="o">*</span><span class="n">normalVector</span><span class="p">)</span><span class="o">*</span><span class="n">magSf</span><span class="p">;</span>
    <span class="n">rhoEFlux</span> <span class="o">=</span> <span class="p">(</span><span class="n">convectionSpeed</span><span class="o">*</span><span class="p">(</span><span class="n">rhoEState</span> <span class="o">+</span> <span class="n">pState</span><span class="p">))</span><span class="o">*</span><span class="n">magSf</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="hllcaleflux">
<h4>hllcALEFlux<a class="headerlink" href="#hllcaleflux" title="永久链接至标题">¶</a></h4>
<div class="literal-block-wrapper docutils container" id="id128">
<div class="code-block-caption"><span class="caption-text">src/dbns/dbnsFlux/hllcALEFlux/hllcALEFlux.C</span><a class="headerlink" href="#id128" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">hllcALEFlux</span><span class="o">::</span><span class="n">evaluateFlux</span>
<span class="p">(</span>
    <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">rhoFlux</span><span class="p">,</span>
    <span class="n">vector</span><span class="o">&amp;</span> <span class="n">rhoUFlux</span><span class="p">,</span>
    <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">rhoEFlux</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">pLeft</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">pRight</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&amp;</span> <span class="n">ULeft</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&amp;</span> <span class="n">URight</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">TLeft</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">TRight</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">RLeft</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">RRight</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">CvLeft</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">CvRight</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&amp;</span> <span class="n">Sf</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">magSf</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&amp;</span> <span class="n">dotX</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="c1">// Step 1: decode left and right:</span>
    <span class="c1">// normal vector</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">normalVector</span> <span class="o">=</span> <span class="n">Sf</span><span class="o">/</span><span class="n">magSf</span><span class="p">;</span>

    <span class="c1">// Ratio of specific heat capacities</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">kappaLeft</span> <span class="o">=</span> <span class="p">(</span><span class="n">RLeft</span> <span class="o">+</span> <span class="n">CvLeft</span><span class="p">)</span><span class="o">/</span><span class="n">CvLeft</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">kappaRight</span> <span class="o">=</span> <span class="p">(</span><span class="n">RRight</span> <span class="o">+</span> <span class="n">CvRight</span><span class="p">)</span><span class="o">/</span><span class="n">CvRight</span><span class="p">;</span>

    <span class="c1">// Compute conservative variables assuming perfect gas law</span>

    <span class="c1">// Density</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">rhoLeft</span> <span class="o">=</span> <span class="n">pLeft</span><span class="o">/</span><span class="p">(</span><span class="n">RLeft</span><span class="o">*</span><span class="n">TLeft</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">rhoRight</span> <span class="o">=</span> <span class="n">pRight</span><span class="o">/</span><span class="p">(</span><span class="n">RRight</span><span class="o">*</span><span class="n">TRight</span><span class="p">);</span>

    <span class="c1">// DensityVelocity</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">rhoULeft</span> <span class="o">=</span> <span class="n">rhoLeft</span><span class="o">*</span><span class="n">ULeft</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">rhoURight</span> <span class="o">=</span> <span class="n">rhoRight</span><span class="o">*</span><span class="n">URight</span><span class="p">;</span>

    <span class="c1">// DensityTotalEnergy</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">rhoELeft</span> <span class="o">=</span> <span class="n">rhoLeft</span><span class="o">*</span><span class="p">(</span><span class="n">CvLeft</span><span class="o">*</span><span class="n">TLeft</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">ULeft</span><span class="p">));</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">rhoERight</span> <span class="o">=</span> <span class="n">rhoRight</span><span class="o">*</span><span class="p">(</span><span class="n">CvRight</span><span class="o">*</span><span class="n">TRight</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">URight</span><span class="p">));</span>

    <span class="c1">// Compute left and right total enthalpies:</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">HLeft</span> <span class="o">=</span> <span class="p">(</span><span class="n">rhoELeft</span> <span class="o">+</span> <span class="n">pLeft</span><span class="p">)</span><span class="o">/</span><span class="n">rhoLeft</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">HRight</span> <span class="o">=</span> <span class="p">(</span><span class="n">rhoERight</span> <span class="o">+</span> <span class="n">pRight</span><span class="p">)</span><span class="o">/</span><span class="n">rhoRight</span><span class="p">;</span>

    <span class="c1">// Compute velocity relative to mesh</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">URelLeft</span> <span class="o">=</span> <span class="n">ULeft</span> <span class="o">-</span> <span class="n">dotX</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">URelRight</span> <span class="o">=</span> <span class="n">URight</span> <span class="o">-</span> <span class="n">dotX</span><span class="p">;</span>

    <span class="c1">// Compute qLeft and qRight (q_{l,r} = U_{l,r} \bullet n)</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">qLeft</span> <span class="o">=</span> <span class="p">(</span><span class="n">URelLeft</span> <span class="o">&amp;</span> <span class="n">normalVector</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">qRight</span> <span class="o">=</span> <span class="p">(</span><span class="n">URelRight</span> <span class="o">&amp;</span> <span class="n">normalVector</span><span class="p">);</span>

    <span class="c1">// Speed of sound, for left and right side, assuming perfect gas</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">aLeft</span> <span class="o">=</span> <span class="n">Foam</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span> <span class="p">,</span> <span class="n">kappaLeft</span><span class="o">*</span><span class="n">pLeft</span><span class="o">/</span><span class="n">rhoLeft</span><span class="p">));</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">aRight</span> <span class="o">=</span> <span class="n">Foam</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">kappaRight</span><span class="o">*</span><span class="n">pRight</span><span class="o">/</span><span class="n">rhoRight</span><span class="p">));</span>


    <span class="c1">// Step 2:</span>
    <span class="c1">// needs rho_{l,r}, U_{l,r}, H_{l,r}, kappa_{l,r}, Gamma_{l,r}, q_{l,r}</span>
    <span class="c1">// compute Roe weights</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">rhoLeftSqrt</span> <span class="o">=</span> <span class="n">Foam</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="n">rhoLeft</span><span class="p">));</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">rhoRightSqrt</span> <span class="o">=</span> <span class="n">Foam</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="n">rhoRight</span><span class="p">));</span>

    <span class="k">const</span> <span class="n">scalar</span> <span class="n">wLeft</span> <span class="o">=</span> <span class="n">rhoLeftSqrt</span> <span class="o">/</span> <span class="n">stabilise</span><span class="p">((</span><span class="n">rhoLeftSqrt</span> <span class="o">+</span> <span class="n">rhoRightSqrt</span><span class="p">),</span><span class="n">VSMALL</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">wRight</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">wLeft</span><span class="p">;</span>

    <span class="c1">// Roe averaged velocity</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">UTilde</span> <span class="o">=</span> <span class="n">wLeft</span><span class="o">*</span><span class="n">ULeft</span> <span class="o">+</span> <span class="n">wRight</span><span class="o">*</span><span class="n">URight</span><span class="p">;</span>

    <span class="c1">// Roe averaged relative face velocity</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">contrURelTilde</span> <span class="o">=</span> <span class="p">((</span><span class="n">UTilde</span> <span class="o">-</span> <span class="n">dotX</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">normalVector</span><span class="p">);</span>

    <span class="c1">// Roe averaged contravariant velocity</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">contrUTilde</span> <span class="o">=</span> <span class="p">(</span><span class="n">UTilde</span> <span class="o">&amp;</span> <span class="n">normalVector</span><span class="p">);</span>

    <span class="c1">// Roe averaged total enthalpy</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">HTilde</span> <span class="o">=</span> <span class="n">wLeft</span><span class="o">*</span><span class="n">HLeft</span> <span class="o">+</span> <span class="n">wRight</span><span class="o">*</span><span class="n">HRight</span><span class="p">;</span>

    <span class="c1">// Roe averaged kappa</span>
    <span class="c1">// TODO: needs to be verified!</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">kappaTilde</span> <span class="o">=</span> <span class="n">wLeft</span><span class="o">*</span><span class="n">kappaLeft</span> <span class="o">+</span> <span class="n">wRight</span><span class="o">*</span><span class="n">kappaRight</span><span class="p">;</span>

    <span class="c1">// Speed of sound with Roe reconstruction values</span>
    <span class="c1">// TODO: not sure if the correct (flow speed) and kappa is used here</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">aTilde</span> <span class="o">=</span> <span class="n">Foam</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,(</span><span class="n">kappaTilde</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">HTilde</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">sqr</span><span class="p">(</span><span class="n">contrUTilde</span><span class="p">))));</span>

    <span class="c1">// Step 3: compute signal speeds for face:</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">SLeft</span>  <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">qLeft</span><span class="o">-</span><span class="n">aLeft</span><span class="p">,</span>   <span class="n">contrURelTilde</span><span class="o">-</span><span class="n">aTilde</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">SRight</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">qRight</span><span class="o">+</span><span class="n">aRight</span><span class="p">,</span> <span class="n">contrURelTilde</span><span class="o">+</span><span class="n">aTilde</span><span class="p">);</span>

    <span class="k">const</span> <span class="n">scalar</span> <span class="n">SStar</span> <span class="o">=</span> <span class="p">(</span><span class="n">rhoRight</span><span class="o">*</span><span class="n">qRight</span><span class="o">*</span><span class="p">(</span><span class="n">SRight</span><span class="o">-</span><span class="n">qRight</span><span class="p">)</span>
    <span class="o">-</span> <span class="n">rhoLeft</span><span class="o">*</span><span class="n">qLeft</span><span class="o">*</span><span class="p">(</span><span class="n">SLeft</span> <span class="o">-</span> <span class="n">qLeft</span><span class="p">)</span> <span class="o">+</span> <span class="n">pLeft</span> <span class="o">-</span> <span class="n">pRight</span> <span class="p">)</span><span class="o">/</span>
        <span class="n">stabilise</span><span class="p">((</span><span class="n">rhoRight</span><span class="o">*</span><span class="p">(</span><span class="n">SRight</span><span class="o">-</span><span class="n">qRight</span><span class="p">)</span><span class="o">-</span><span class="n">rhoLeft</span><span class="o">*</span><span class="p">(</span><span class="n">SLeft</span><span class="o">-</span><span class="n">qLeft</span><span class="p">)),</span><span class="n">VSMALL</span><span class="p">);</span>

    <span class="c1">// Compute pressure in star region from the right side</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">pStarRight</span> <span class="o">=</span> <span class="n">rhoRight</span><span class="o">*</span><span class="p">(</span><span class="n">qRight</span> <span class="o">-</span> <span class="n">SRight</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">qRight</span> <span class="o">-</span> <span class="n">SStar</span><span class="p">)</span> <span class="o">+</span> <span class="n">pRight</span><span class="p">;</span>

    <span class="c1">// Should be equal to the left side</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">pStarLeft</span>  <span class="o">=</span> <span class="n">rhoLeft</span><span class="o">*</span><span class="p">(</span><span class="n">qLeft</span> <span class="o">-</span>  <span class="n">SLeft</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">qLeft</span> <span class="o">-</span> <span class="n">SStar</span><span class="p">)</span> <span class="o">+</span> <span class="n">pLeft</span><span class="p">;</span>

    <span class="c1">// Give a warning if this is not the case</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">mag</span><span class="p">(</span><span class="n">pStarRight</span><span class="o">-</span><span class="n">pStarLeft</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-6</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Info</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;mag(pStarRight-pStarLeft) &gt; VSMALL &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Use pStarRight for pStar, as in theory, pStarRight == pStarLeft</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">pStar</span> <span class="o">=</span> <span class="n">pStarRight</span><span class="p">;</span>

    <span class="c1">// Step 4: upwinding - compute states:</span>
    <span class="n">scalar</span> <span class="n">convectionSpeed</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="n">scalar</span> <span class="n">rhoState</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="n">vector</span> <span class="n">rhoUState</span> <span class="o">=</span> <span class="n">vector</span><span class="o">::</span><span class="n">zero</span><span class="p">;</span>
    <span class="n">scalar</span> <span class="n">rhoEState</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="n">scalar</span> <span class="n">pState</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>

    <span class="c1">// TODO: Maybe one can use pos/neg implementation, but then one has to evaluate all 4 states at each iteration!</span>
    <span class="c1">// label A = pos(SLeft);</span>
    <span class="c1">// label B = pos(SStar);</span>
    <span class="c1">// label C = pos(SRight);</span>
    <span class="c1">// please double check the bool operators again, if one want&#39;s to implement this!!!</span>
    <span class="c1">// scalar convectionSpeed = A*B*C*qLeft+(1-A)*B*C*SStar +(1-A)*(1-B)*C*SStar+(1-A)*(1-B)*(1-C)*qRight:</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="p">(</span><span class="n">SLeft</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="c1">// Compute F_l</span>
        <span class="n">convectionSpeed</span> <span class="o">=</span> <span class="n">qLeft</span><span class="p">;</span>
        <span class="n">rhoState</span>  <span class="o">=</span> <span class="n">rhoLeft</span><span class="p">;</span>
        <span class="n">rhoUState</span> <span class="o">=</span> <span class="n">rhoULeft</span><span class="p">;</span>
        <span class="n">rhoEState</span> <span class="o">=</span> <span class="n">rhoELeft</span><span class="p">;</span>
        <span class="n">pState</span> <span class="o">=</span> <span class="n">pLeft</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="p">(</span><span class="n">SStar</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">scalar</span> <span class="n">omegaLeft</span> <span class="o">=</span> <span class="n">scalar</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span class="o">/</span><span class="n">stabilise</span><span class="p">((</span><span class="n">SLeft</span> <span class="o">-</span> <span class="n">SStar</span><span class="p">),</span> <span class="n">VSMALL</span><span class="p">);</span>

        <span class="c1">// Compute left star region</span>
        <span class="n">convectionSpeed</span> <span class="o">=</span> <span class="n">SStar</span><span class="p">;</span>
        <span class="n">rhoState</span>  <span class="o">=</span> <span class="n">omegaLeft</span><span class="o">*</span><span class="p">(</span><span class="n">SLeft</span> <span class="o">-</span> <span class="n">qLeft</span><span class="p">)</span><span class="o">*</span><span class="n">rhoLeft</span><span class="p">;</span>
        <span class="n">rhoUState</span> <span class="o">=</span> <span class="n">omegaLeft</span><span class="o">*</span><span class="p">((</span><span class="n">SLeft</span> <span class="o">-</span> <span class="n">qLeft</span><span class="p">)</span><span class="o">*</span><span class="n">rhoULeft</span> <span class="o">+</span> <span class="p">(</span><span class="n">pStar</span> <span class="o">-</span> <span class="n">pLeft</span><span class="p">)</span><span class="o">*</span><span class="n">normalVector</span><span class="p">);</span>
        <span class="n">rhoEState</span> <span class="o">=</span> <span class="n">omegaLeft</span><span class="o">*</span><span class="p">((</span><span class="n">SLeft</span> <span class="o">-</span> <span class="n">qLeft</span><span class="p">)</span><span class="o">*</span><span class="n">rhoELeft</span> <span class="o">-</span> <span class="n">pLeft</span><span class="o">*</span><span class="n">qLeft</span> <span class="o">+</span> <span class="n">pStar</span><span class="o">*</span><span class="n">SStar</span><span class="p">);</span>
        <span class="n">pState</span> <span class="o">=</span> <span class="n">pStar</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="p">(</span><span class="n">SRight</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">scalar</span> <span class="n">omegaRight</span> <span class="o">=</span> <span class="n">scalar</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span class="o">/</span><span class="n">stabilise</span><span class="p">((</span><span class="n">SRight</span> <span class="o">-</span> <span class="n">SStar</span><span class="p">),</span> <span class="n">VSMALL</span><span class="p">);</span>

        <span class="c1">// Compute right star region</span>
        <span class="n">convectionSpeed</span> <span class="o">=</span> <span class="n">SStar</span><span class="p">;</span>
        <span class="n">rhoState</span>  <span class="o">=</span> <span class="n">omegaRight</span><span class="o">*</span><span class="p">(</span><span class="n">SRight</span> <span class="o">-</span> <span class="n">qRight</span><span class="p">)</span><span class="o">*</span><span class="n">rhoRight</span><span class="p">;</span>
        <span class="n">rhoUState</span> <span class="o">=</span> <span class="n">omegaRight</span><span class="o">*</span><span class="p">((</span><span class="n">SRight</span> <span class="o">-</span> <span class="n">qRight</span><span class="p">)</span><span class="o">*</span><span class="n">rhoURight</span> <span class="o">+</span> <span class="p">(</span><span class="n">pStar</span> <span class="o">-</span> <span class="n">pRight</span><span class="p">)</span><span class="o">*</span><span class="n">normalVector</span><span class="p">);</span>
        <span class="n">rhoEState</span> <span class="o">=</span> <span class="n">omegaRight</span><span class="o">*</span><span class="p">((</span><span class="n">SRight</span> <span class="o">-</span> <span class="n">qRight</span><span class="p">)</span><span class="o">*</span><span class="n">rhoERight</span> <span class="o">-</span> <span class="n">pRight</span><span class="o">*</span><span class="n">qRight</span> <span class="o">+</span> <span class="n">pStar</span><span class="o">*</span><span class="n">SStar</span><span class="p">);</span>
        <span class="n">pState</span> <span class="o">=</span> <span class="n">pStar</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">neg</span><span class="p">(</span><span class="n">SRight</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="c1">// Compute F_r</span>
        <span class="n">convectionSpeed</span> <span class="o">=</span> <span class="n">qRight</span><span class="p">;</span>
        <span class="n">rhoState</span>  <span class="o">=</span> <span class="n">rhoRight</span><span class="p">;</span>
        <span class="n">rhoUState</span> <span class="o">=</span> <span class="n">rhoURight</span><span class="p">;</span>
        <span class="n">rhoEState</span> <span class="o">=</span> <span class="n">rhoERight</span><span class="p">;</span>
        <span class="n">pState</span> <span class="o">=</span> <span class="n">pRight</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">Info</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Error in HLLC Riemann solver&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">rhoFlux</span>  <span class="o">=</span> <span class="p">(</span><span class="n">convectionSpeed</span><span class="o">*</span><span class="n">rhoState</span><span class="p">)</span><span class="o">*</span><span class="n">magSf</span><span class="p">;</span>
    <span class="n">rhoUFlux</span> <span class="o">=</span> <span class="p">(</span><span class="n">convectionSpeed</span><span class="o">*</span><span class="n">rhoUState</span><span class="o">+</span><span class="n">pState</span><span class="o">*</span><span class="n">normalVector</span><span class="p">)</span><span class="o">*</span><span class="n">magSf</span><span class="p">;</span>
    <span class="n">rhoEFlux</span> <span class="o">=</span> <span class="p">(</span><span class="n">convectionSpeed</span><span class="o">*</span><span class="p">(</span><span class="n">rhoEState</span><span class="o">+</span><span class="n">pState</span><span class="p">)</span> <span class="o">+</span> <span class="n">pState</span><span class="o">*</span><span class="p">(</span><span class="n">dotX</span> <span class="o">&amp;</span> <span class="n">normalVector</span><span class="p">))</span><span class="o">*</span><span class="n">magSf</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="roeflux">
<h4>roeFlux<a class="headerlink" href="#roeflux" title="永久链接至标题">¶</a></h4>
<div class="literal-block-wrapper docutils container" id="id129">
<div class="code-block-caption"><span class="caption-text">src/dbns/dbnsFlux/roeFlux/roeFlux.C</span><a class="headerlink" href="#id129" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">roeFlux</span><span class="o">::</span><span class="n">evaluateFlux</span>
<span class="p">(</span>
    <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">rhoFlux</span><span class="p">,</span>
    <span class="n">vector</span><span class="o">&amp;</span> <span class="n">rhoUFlux</span><span class="p">,</span>
    <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">rhoEFlux</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">pLeft</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">pRight</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&amp;</span> <span class="n">ULeft</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&amp;</span> <span class="n">URight</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">TLeft</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">TRight</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">RLeft</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">RRight</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">CvLeft</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">CvRight</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&amp;</span> <span class="n">Sf</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">magSf</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="c1">// Step 1: decode rho left and right:</span>
    <span class="n">scalar</span> <span class="n">rhoLeft</span> <span class="o">=</span> <span class="n">pLeft</span><span class="o">/</span><span class="p">(</span><span class="n">RLeft</span><span class="o">*</span><span class="n">TLeft</span><span class="p">);</span>
    <span class="n">scalar</span> <span class="n">rhoRight</span> <span class="o">=</span> <span class="n">pRight</span><span class="o">/</span><span class="p">(</span><span class="n">RRight</span><span class="o">*</span><span class="n">TRight</span><span class="p">);</span>

    <span class="c1">// Decode left and right total energy:</span>
    <span class="n">scalar</span> <span class="n">eLeft</span> <span class="o">=</span> <span class="n">CvLeft</span><span class="o">*</span><span class="n">TLeft</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">ULeft</span><span class="p">);</span>
    <span class="n">scalar</span> <span class="n">eRight</span> <span class="o">=</span> <span class="n">CvRight</span><span class="o">*</span><span class="n">TRight</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">URight</span><span class="p">);</span>

    <span class="c1">// Adiabatic exponent is constant for ideal gas but if Cp=Cp(T) it must be computed for each cell and evaluated at each face through reconstruction</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">kappaLeft</span> <span class="o">=</span> <span class="p">(</span><span class="n">CvLeft</span> <span class="o">+</span> <span class="n">RLeft</span><span class="p">)</span><span class="o">/</span><span class="n">CvLeft</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">kappaRight</span> <span class="o">=</span> <span class="p">(</span><span class="n">CvRight</span> <span class="o">+</span> <span class="n">RRight</span><span class="p">)</span><span class="o">/</span><span class="n">CvRight</span><span class="p">;</span>

    <span class="c1">// normal vector</span>
    <span class="n">vector</span> <span class="n">normalVector</span> <span class="o">=</span> <span class="n">Sf</span><span class="o">/</span><span class="n">magSf</span><span class="p">;</span>

    <span class="c1">// Compute left and right contravariant velocities:</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">contrVLeft</span>  <span class="o">=</span> <span class="p">(</span><span class="n">ULeft</span> <span class="o">&amp;</span> <span class="n">normalVector</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">contrVRight</span> <span class="o">=</span> <span class="p">(</span><span class="n">URight</span> <span class="o">&amp;</span> <span class="n">normalVector</span><span class="p">);</span>

    <span class="c1">// Compute left and right total enthalpies:</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">hLeft</span> <span class="o">=</span> <span class="n">eLeft</span> <span class="o">+</span> <span class="n">pLeft</span><span class="o">/</span><span class="n">rhoLeft</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">hRight</span> <span class="o">=</span> <span class="n">eRight</span> <span class="o">+</span> <span class="n">pRight</span><span class="o">/</span><span class="n">rhoRight</span><span class="p">;</span>

    <span class="c1">// Step 2: compute Roe averged quantities for face:</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">rhoTilde</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">rhoLeft</span><span class="o">*</span><span class="n">rhoRight</span><span class="p">,</span> <span class="n">SMALL</span><span class="p">));</span>

    <span class="c1">// Some temporary variables:</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">rhoLeftSqrt</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">rhoLeft</span><span class="p">,</span> <span class="n">SMALL</span><span class="p">));</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">rhoRightSqrt</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">rhoRight</span><span class="p">,</span> <span class="n">SMALL</span><span class="p">));</span>

    <span class="k">const</span> <span class="n">scalar</span> <span class="n">wLeft</span> <span class="o">=</span> <span class="n">rhoLeftSqrt</span><span class="o">/</span><span class="p">(</span><span class="n">rhoLeftSqrt</span> <span class="o">+</span> <span class="n">rhoRightSqrt</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">wRight</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">wLeft</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">vector</span> <span class="n">UTilde</span> <span class="o">=</span> <span class="n">ULeft</span><span class="o">*</span><span class="n">wLeft</span> <span class="o">+</span> <span class="n">URight</span><span class="o">*</span><span class="n">wRight</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">hTilde</span> <span class="o">=</span> <span class="n">hLeft</span><span class="o">*</span><span class="n">wLeft</span> <span class="o">+</span> <span class="n">hRight</span><span class="o">*</span><span class="n">wRight</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">qTildeSquare</span> <span class="o">=</span> <span class="n">magSqr</span><span class="p">(</span><span class="n">UTilde</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">kappaTilde</span> <span class="o">=</span> <span class="n">kappaLeft</span><span class="o">*</span><span class="n">wLeft</span> <span class="o">+</span> <span class="n">kappaRight</span><span class="o">*</span><span class="n">wRight</span><span class="p">;</span>

    <span class="c1">// Speed of sound</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">cTilde</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">max</span><span class="p">((</span><span class="n">kappaTilde</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">hTilde</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">qTildeSquare</span><span class="p">),</span> <span class="n">SMALL</span><span class="p">));</span>

    <span class="c1">// Roe averaged contravariant velocity</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">contrVTilde</span> <span class="o">=</span> <span class="p">(</span><span class="n">UTilde</span> <span class="o">&amp;</span> <span class="n">normalVector</span><span class="p">);</span>

    <span class="c1">// Step 3: compute primitive differences:</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">deltaP</span> <span class="o">=</span> <span class="n">pRight</span> <span class="o">-</span> <span class="n">pLeft</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">deltaRho</span> <span class="o">=</span> <span class="n">rhoRight</span> <span class="o">-</span> <span class="n">rhoLeft</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">deltaU</span> <span class="o">=</span> <span class="n">URight</span> <span class="o">-</span> <span class="n">ULeft</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">deltaContrV</span> <span class="o">=</span> <span class="p">(</span><span class="n">deltaU</span> <span class="o">&amp;</span> <span class="n">normalVector</span><span class="p">);</span>

    <span class="c1">// Step 4: compute wave strengths:</span>

    <span class="c1">// Roe and Pike - formulation</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">r1</span> <span class="o">=</span> <span class="p">(</span><span class="n">deltaP</span> <span class="o">-</span> <span class="n">rhoTilde</span><span class="o">*</span><span class="n">cTilde</span><span class="o">*</span><span class="n">deltaContrV</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">sqr</span><span class="p">(</span><span class="n">cTilde</span><span class="p">));</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">deltaRho</span> <span class="o">-</span> <span class="n">deltaP</span><span class="o">/</span><span class="n">sqr</span><span class="p">(</span><span class="n">cTilde</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">r3</span> <span class="o">=</span> <span class="p">(</span><span class="n">deltaP</span> <span class="o">+</span> <span class="n">rhoTilde</span><span class="o">*</span><span class="n">cTilde</span><span class="o">*</span><span class="n">deltaContrV</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">sqr</span><span class="p">(</span><span class="n">cTilde</span><span class="p">));</span>

    <span class="c1">// Step 5: compute l vectors</span>

    <span class="c1">// rho row:</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">l1rho</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">l2rho</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">l3rho</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">l4rho</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">// first U column</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">l1U</span> <span class="o">=</span> <span class="n">UTilde</span> <span class="o">-</span> <span class="n">cTilde</span><span class="o">*</span><span class="n">normalVector</span><span class="p">;</span>

    <span class="c1">// second U column</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">l2U</span> <span class="o">=</span> <span class="n">UTilde</span><span class="p">;</span>

    <span class="c1">// third U column</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">l3U</span> <span class="o">=</span> <span class="n">deltaU</span> <span class="o">-</span> <span class="n">deltaContrV</span><span class="o">*</span><span class="n">normalVector</span><span class="p">;</span>

    <span class="c1">// fourth U column</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">l4U</span> <span class="o">=</span> <span class="n">UTilde</span> <span class="o">+</span> <span class="n">cTilde</span><span class="o">*</span><span class="n">normalVector</span><span class="p">;</span>

    <span class="c1">// E row</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">l1e</span> <span class="o">=</span> <span class="n">hTilde</span> <span class="o">-</span> <span class="n">cTilde</span><span class="o">*</span><span class="n">contrVTilde</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">l2e</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">qTildeSquare</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">l3e</span> <span class="o">=</span> <span class="p">(</span><span class="n">UTilde</span> <span class="o">&amp;</span> <span class="n">deltaU</span><span class="p">)</span> <span class="o">-</span> <span class="n">contrVTilde</span><span class="o">*</span><span class="n">deltaContrV</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">l4e</span> <span class="o">=</span> <span class="n">hTilde</span> <span class="o">+</span> <span class="n">cTilde</span><span class="o">*</span><span class="n">contrVTilde</span><span class="p">;</span>

    <span class="c1">// Step 6: compute eigenvalues</span>

    <span class="c1">// derived from algebra by hand, only for Euler equation usefull</span>
    <span class="n">scalar</span> <span class="n">lambda1</span> <span class="o">=</span> <span class="n">mag</span><span class="p">(</span><span class="n">contrVTilde</span> <span class="o">-</span> <span class="n">cTilde</span><span class="p">);</span>
    <span class="n">scalar</span> <span class="n">lambda2</span> <span class="o">=</span> <span class="n">mag</span><span class="p">(</span><span class="n">contrVTilde</span><span class="p">);</span>
    <span class="n">scalar</span> <span class="n">lambda3</span> <span class="o">=</span> <span class="n">mag</span><span class="p">(</span><span class="n">contrVTilde</span> <span class="o">+</span> <span class="n">cTilde</span><span class="p">);</span>

    <span class="c1">// Step 7: check for Harten entropy correction</span>

    <span class="c1">// const scalar eps = 0.1*cTilde; // adjustable parameter</span>

    <span class="c1">// if (lambda1 &lt; eps || lambda2 &lt; eps || lambda3 &lt; eps)</span>
    <span class="c1">// {</span>
    <span class="c1">//     lambda1 = (sqr(lambda1) + sqr(eps))/(2.0*eps);</span>
    <span class="c1">//     lambda2 = (sqr(lambda2) + sqr(eps))/(2.0*eps);</span>
    <span class="c1">//     lambda3 = (sqr(lambda3) + sqr(eps))/(2.0*eps);</span>
    <span class="c1">// }</span>

    <span class="c1">// Step 7a: Alternative entropy correction: Felipe Portela, 9/Oct/2013</span>

    <span class="k">const</span> <span class="n">scalar</span> <span class="n">UL</span> <span class="o">=</span> <span class="n">ULeft</span> <span class="o">&amp;</span> <span class="n">normalVector</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">UR</span> <span class="o">=</span> <span class="n">URight</span> <span class="o">&amp;</span> <span class="n">normalVector</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">cLeft</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">max</span><span class="p">((</span><span class="n">kappaLeft</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">hLeft</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">ULeft</span><span class="p">)),</span> <span class="n">SMALL</span><span class="p">));</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">cRight</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">max</span><span class="p">((</span><span class="n">kappaRight</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">hRight</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">URight</span><span class="p">)),</span> <span class="n">SMALL</span><span class="p">));</span>

    <span class="c1">// First eigenvalue: U - c</span>
    <span class="n">scalar</span> <span class="n">eps</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,(</span><span class="n">UR</span> <span class="o">-</span> <span class="n">cRight</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">UL</span> <span class="o">-</span> <span class="n">cLeft</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lambda1</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">lambda1</span> <span class="o">=</span> <span class="p">(</span><span class="n">sqr</span><span class="p">(</span><span class="n">lambda1</span><span class="p">)</span> <span class="o">+</span> <span class="n">sqr</span><span class="p">(</span><span class="n">eps</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">eps</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Second eigenvalue: U</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">UR</span> <span class="o">-</span> <span class="n">UL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lambda2</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">lambda2</span> <span class="o">=</span> <span class="p">(</span><span class="n">sqr</span><span class="p">(</span><span class="n">lambda2</span><span class="p">)</span> <span class="o">+</span> <span class="n">sqr</span><span class="p">(</span><span class="n">eps</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">eps</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Third eigenvalue: U + c</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,(</span><span class="n">UR</span> <span class="o">+</span> <span class="n">cRight</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">UL</span> <span class="o">+</span> <span class="n">cLeft</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lambda3</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">lambda3</span> <span class="o">=</span> <span class="p">(</span><span class="n">sqr</span><span class="p">(</span><span class="n">lambda3</span><span class="p">)</span> <span class="o">+</span> <span class="n">sqr</span><span class="p">(</span><span class="n">eps</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">eps</span><span class="p">);</span>
    <span class="p">}</span>


    <span class="c1">// Step 8: Compute flux differences</span>

    <span class="c1">// Components of deltaF1</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">diffF11</span> <span class="o">=</span> <span class="n">lambda1</span><span class="o">*</span><span class="n">r1</span><span class="o">*</span><span class="n">l1rho</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">diffF124</span> <span class="o">=</span> <span class="n">lambda1</span><span class="o">*</span><span class="n">r1</span><span class="o">*</span><span class="n">l1U</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">diffF15</span> <span class="o">=</span> <span class="n">lambda1</span><span class="o">*</span><span class="n">r1</span><span class="o">*</span><span class="n">l1e</span><span class="p">;</span>

    <span class="c1">// Components of deltaF2</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">diffF21</span> <span class="o">=</span> <span class="n">lambda2</span><span class="o">*</span><span class="p">(</span><span class="n">r2</span><span class="o">*</span><span class="n">l2rho</span> <span class="o">+</span> <span class="n">rhoTilde</span><span class="o">*</span><span class="n">l3rho</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">diffF224</span> <span class="o">=</span> <span class="n">lambda2</span><span class="o">*</span><span class="p">(</span><span class="n">r2</span><span class="o">*</span><span class="n">l2U</span> <span class="o">+</span> <span class="n">rhoTilde</span><span class="o">*</span><span class="n">l3U</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">diffF25</span> <span class="o">=</span> <span class="n">lambda2</span><span class="o">*</span><span class="p">(</span><span class="n">r2</span><span class="o">*</span><span class="n">l2e</span> <span class="o">+</span> <span class="n">rhoTilde</span><span class="o">*</span><span class="n">l3e</span><span class="p">);</span>

    <span class="c1">// Components of deltaF3</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">diffF31</span> <span class="o">=</span> <span class="n">lambda3</span><span class="o">*</span><span class="n">r3</span><span class="o">*</span><span class="n">l4rho</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">diffF324</span> <span class="o">=</span> <span class="n">lambda3</span><span class="o">*</span><span class="n">r3</span><span class="o">*</span><span class="n">l4U</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">diffF35</span> <span class="o">=</span> <span class="n">lambda3</span><span class="o">*</span><span class="n">r3</span><span class="o">*</span><span class="n">l4e</span><span class="p">;</span>

    <span class="c1">// Step 9: compute left and right fluxes</span>

    <span class="c1">// Left flux 5-vector</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">fluxLeft11</span> <span class="o">=</span> <span class="n">rhoLeft</span><span class="o">*</span><span class="n">contrVLeft</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">fluxLeft124</span> <span class="o">=</span> <span class="n">ULeft</span><span class="o">*</span><span class="n">fluxLeft11</span> <span class="o">+</span> <span class="n">normalVector</span><span class="o">*</span><span class="n">pLeft</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">fluxLeft15</span> <span class="o">=</span> <span class="n">hLeft</span><span class="o">*</span><span class="n">fluxLeft11</span><span class="p">;</span>

    <span class="c1">// Right flux 5-vector</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">fluxRight11</span> <span class="o">=</span> <span class="n">rhoRight</span><span class="o">*</span><span class="n">contrVRight</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">fluxRight124</span> <span class="o">=</span> <span class="n">URight</span><span class="o">*</span><span class="n">fluxRight11</span> <span class="o">+</span> <span class="n">normalVector</span><span class="o">*</span><span class="n">pRight</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">fluxRight15</span> <span class="o">=</span> <span class="n">hRight</span><span class="o">*</span><span class="n">fluxRight11</span><span class="p">;</span>

    <span class="c1">// Step 10: compute face flux 5-vector</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">flux1</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">fluxLeft11</span> <span class="o">+</span> <span class="n">fluxRight11</span> <span class="o">-</span> <span class="p">(</span><span class="n">diffF11</span> <span class="o">+</span> <span class="n">diffF21</span> <span class="o">+</span> <span class="n">diffF31</span><span class="p">));</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">flux24</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">fluxLeft124</span> <span class="o">+</span> <span class="n">fluxRight124</span> <span class="o">-</span> <span class="p">(</span><span class="n">diffF124</span> <span class="o">+</span> <span class="n">diffF224</span> <span class="o">+</span> <span class="n">diffF324</span><span class="p">));</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">flux5</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">fluxLeft15</span> <span class="o">+</span> <span class="n">fluxRight15</span> <span class="o">-</span> <span class="p">(</span><span class="n">diffF15</span> <span class="o">+</span> <span class="n">diffF25</span> <span class="o">+</span> <span class="n">diffF35</span><span class="p">));</span>

    <span class="c1">// Compute private data</span>
    <span class="n">rhoFlux</span>  <span class="o">=</span> <span class="n">flux1</span><span class="o">*</span><span class="n">magSf</span><span class="p">;</span>
    <span class="n">rhoUFlux</span> <span class="o">=</span> <span class="n">flux24</span><span class="o">*</span><span class="n">magSf</span><span class="p">;</span>
    <span class="n">rhoEFlux</span> <span class="o">=</span> <span class="n">flux5</span><span class="o">*</span><span class="n">magSf</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="rusanovflux">
<h4>rusanovFlux<a class="headerlink" href="#rusanovflux" title="永久链接至标题">¶</a></h4>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">Foam</span><span class="o">::</span><span class="n">rusanovFlux</span><span class="o">::</span><span class="n">evaluateFlux</span>
<span class="p">(</span>
    <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">rhoFlux</span><span class="p">,</span>
    <span class="n">vector</span><span class="o">&amp;</span> <span class="n">rhoUFlux</span><span class="p">,</span>
    <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">rhoEFlux</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">pLeft</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">pRight</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&amp;</span> <span class="n">ULeft</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&amp;</span> <span class="n">URight</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">TLeft</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">TRight</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">RLeft</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">RRight</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">CvLeft</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">CvRight</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&amp;</span> <span class="n">Sf</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">magSf</span>
<span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="c1">// Step 1: decode rho left and right:</span>
    <span class="n">scalar</span> <span class="n">rhoLeft</span> <span class="o">=</span> <span class="n">pLeft</span><span class="o">/</span><span class="p">(</span><span class="n">RLeft</span><span class="o">*</span><span class="n">TLeft</span><span class="p">);</span>
    <span class="n">scalar</span> <span class="n">rhoRight</span> <span class="o">=</span> <span class="n">pRight</span><span class="o">/</span><span class="p">(</span><span class="n">RRight</span><span class="o">*</span><span class="n">TRight</span><span class="p">);</span>

    <span class="c1">// Decode left and right total energy:</span>
    <span class="n">scalar</span> <span class="n">eLeft</span> <span class="o">=</span> <span class="n">CvLeft</span><span class="o">*</span><span class="n">TLeft</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">ULeft</span><span class="p">);</span>
    <span class="n">scalar</span> <span class="n">eRight</span> <span class="o">=</span> <span class="n">CvRight</span><span class="o">*</span><span class="n">TRight</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">magSqr</span><span class="p">(</span><span class="n">URight</span><span class="p">);</span>

    <span class="c1">// Adiabatic exponent is constant for ideal gas but if Cp=Cp(T) it must be computed for each cell and evaluated at each face through reconstruction</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">kappaLeft</span> <span class="o">=</span> <span class="p">(</span><span class="n">CvLeft</span><span class="o">+</span><span class="n">RLeft</span><span class="p">)</span><span class="o">/</span><span class="n">CvLeft</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">kappaRight</span> <span class="o">=</span> <span class="p">(</span><span class="n">CvRight</span><span class="o">+</span><span class="n">RRight</span><span class="p">)</span><span class="o">/</span><span class="n">CvRight</span><span class="p">;</span>

    <span class="c1">// normal vector</span>
    <span class="n">vector</span> <span class="n">normalVector</span> <span class="o">=</span> <span class="n">Sf</span><span class="o">/</span><span class="n">magSf</span><span class="p">;</span>

    <span class="c1">// Compute left and right contravariant velocities:</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">contrVLeft</span>  <span class="o">=</span> <span class="p">(</span><span class="n">ULeft</span> <span class="o">&amp;</span> <span class="n">normalVector</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">contrVRight</span> <span class="o">=</span> <span class="p">(</span><span class="n">URight</span> <span class="o">&amp;</span> <span class="n">normalVector</span><span class="p">);</span>

    <span class="c1">// Compute left and right total enthalpies:</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">hLeft</span> <span class="o">=</span> <span class="n">eLeft</span> <span class="o">+</span> <span class="n">pLeft</span><span class="o">/</span><span class="n">rhoLeft</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">hRight</span> <span class="o">=</span> <span class="n">eRight</span> <span class="o">+</span> <span class="n">pRight</span><span class="o">/</span><span class="n">rhoRight</span><span class="p">;</span>

    <span class="c1">// Step 2: compute Roe averged quantities for face:</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">rhoTilde</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">rhoLeft</span><span class="o">*</span><span class="n">rhoRight</span><span class="p">,</span> <span class="n">SMALL</span><span class="p">));</span>

    <span class="c1">// Some temporary variables:</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">rhoLeftSqrt</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">rhoLeft</span><span class="p">,</span> <span class="n">SMALL</span><span class="p">));</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">rhoRightSqrt</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">rhoRight</span><span class="p">,</span> <span class="n">SMALL</span><span class="p">));</span>

    <span class="k">const</span> <span class="n">scalar</span> <span class="n">wLeft</span> <span class="o">=</span> <span class="n">rhoLeftSqrt</span><span class="o">/</span><span class="p">(</span><span class="n">rhoLeftSqrt</span> <span class="o">+</span> <span class="n">rhoRightSqrt</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">wRight</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">wLeft</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">vector</span> <span class="n">UTilde</span> <span class="o">=</span> <span class="n">ULeft</span><span class="o">*</span><span class="n">wLeft</span> <span class="o">+</span> <span class="n">URight</span><span class="o">*</span><span class="n">wRight</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">hTilde</span> <span class="o">=</span> <span class="n">hLeft</span><span class="o">*</span><span class="n">wLeft</span> <span class="o">+</span> <span class="n">hRight</span><span class="o">*</span><span class="n">wRight</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">qTildeSquare</span> <span class="o">=</span> <span class="n">magSqr</span><span class="p">(</span><span class="n">UTilde</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">kappaTilde</span> <span class="o">=</span> <span class="n">kappaLeft</span><span class="o">*</span><span class="n">wLeft</span> <span class="o">+</span> <span class="n">kappaRight</span><span class="o">*</span><span class="n">wRight</span><span class="p">;</span>

    <span class="c1">// Speed of sound</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">cTilde</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">max</span><span class="p">((</span><span class="n">kappaTilde</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">hTilde</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">qTildeSquare</span><span class="p">),</span> <span class="n">SMALL</span><span class="p">));</span>

    <span class="c1">// Roe averaged contravariant velocity</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">contrVTilde</span> <span class="o">=</span> <span class="p">(</span><span class="n">UTilde</span> <span class="o">&amp;</span> <span class="n">normalVector</span><span class="p">);</span>

    <span class="c1">// Step 3: compute primitive differences:</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">deltaP</span> <span class="o">=</span> <span class="n">pRight</span> <span class="o">-</span> <span class="n">pLeft</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">deltaRho</span> <span class="o">=</span> <span class="n">rhoRight</span> <span class="o">-</span> <span class="n">rhoLeft</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">deltaU</span> <span class="o">=</span> <span class="n">URight</span> <span class="o">-</span> <span class="n">ULeft</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">deltaContrV</span> <span class="o">=</span> <span class="p">(</span><span class="n">deltaU</span> <span class="o">&amp;</span> <span class="n">normalVector</span><span class="p">);</span>

    <span class="c1">// Step 4: compute wave strengths:</span>

    <span class="c1">// Roe and Pike - formulation</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">r1</span> <span class="o">=</span> <span class="p">(</span><span class="n">deltaP</span> <span class="o">-</span> <span class="n">rhoTilde</span><span class="o">*</span><span class="n">cTilde</span><span class="o">*</span><span class="n">deltaContrV</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">sqr</span><span class="p">(</span><span class="n">cTilde</span><span class="p">));</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">deltaRho</span> <span class="o">-</span> <span class="n">deltaP</span><span class="o">/</span><span class="n">sqr</span><span class="p">(</span><span class="n">cTilde</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">r3</span> <span class="o">=</span> <span class="p">(</span><span class="n">deltaP</span> <span class="o">+</span> <span class="n">rhoTilde</span><span class="o">*</span><span class="n">cTilde</span><span class="o">*</span><span class="n">deltaContrV</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">sqr</span><span class="p">(</span><span class="n">cTilde</span><span class="p">));</span>

    <span class="c1">// Step 5: compute l vectors</span>

    <span class="c1">// rho row:</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">l1rho</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">l2rho</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">l3rho</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">l4rho</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">// first U column</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">l1U</span> <span class="o">=</span> <span class="n">UTilde</span> <span class="o">-</span> <span class="n">cTilde</span><span class="o">*</span><span class="n">normalVector</span><span class="p">;</span>

    <span class="c1">// second U column</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">l2U</span> <span class="o">=</span> <span class="n">UTilde</span><span class="p">;</span>

    <span class="c1">// third U column</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">l3U</span> <span class="o">=</span> <span class="n">deltaU</span> <span class="o">-</span> <span class="n">deltaContrV</span><span class="o">*</span><span class="n">normalVector</span><span class="p">;</span>

    <span class="c1">// fourth U column</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">l4U</span> <span class="o">=</span> <span class="n">UTilde</span> <span class="o">+</span> <span class="n">cTilde</span><span class="o">*</span><span class="n">normalVector</span><span class="p">;</span>

    <span class="c1">// E row</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">l1e</span> <span class="o">=</span> <span class="n">hTilde</span> <span class="o">-</span> <span class="n">cTilde</span><span class="o">*</span><span class="n">contrVTilde</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">l2e</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">qTildeSquare</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">l3e</span> <span class="o">=</span> <span class="p">(</span><span class="n">UTilde</span> <span class="o">&amp;</span> <span class="n">deltaU</span><span class="p">)</span> <span class="o">-</span> <span class="n">contrVTilde</span><span class="o">*</span><span class="n">deltaContrV</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">l4e</span> <span class="o">=</span> <span class="n">hTilde</span> <span class="o">+</span> <span class="n">cTilde</span><span class="o">*</span><span class="n">contrVTilde</span><span class="p">;</span>

    <span class="c1">// Step 6: compute eigenvalues</span>

    <span class="c1">// derived from algebra by hand, only for Euler equation usefull</span>
    <span class="n">scalar</span> <span class="n">lambda1</span> <span class="o">=</span> <span class="n">mag</span><span class="p">(</span><span class="n">contrVTilde</span> <span class="o">-</span> <span class="n">cTilde</span><span class="p">);</span>
    <span class="n">scalar</span> <span class="n">lambda2</span> <span class="o">=</span> <span class="n">mag</span><span class="p">(</span><span class="n">contrVTilde</span><span class="p">);</span>
    <span class="n">scalar</span> <span class="n">lambda3</span> <span class="o">=</span> <span class="n">mag</span><span class="p">(</span><span class="n">contrVTilde</span> <span class="o">+</span> <span class="n">cTilde</span><span class="p">);</span>

    <span class="n">scalar</span> <span class="n">lambdaMax</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">lambda1</span><span class="p">,</span><span class="n">lambda2</span><span class="p">),</span><span class="n">lambda3</span><span class="p">);</span>

    <span class="c1">// Step 7: Compute flux differences</span>

    <span class="c1">// Components of deltaF1</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">diffF11</span> <span class="o">=</span> <span class="n">lambdaMax</span><span class="o">*</span><span class="n">r1</span><span class="o">*</span><span class="n">l1rho</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">diffF124</span> <span class="o">=</span> <span class="n">lambdaMax</span><span class="o">*</span><span class="n">r1</span><span class="o">*</span><span class="n">l1U</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">diffF15</span> <span class="o">=</span> <span class="n">lambdaMax</span><span class="o">*</span><span class="n">r1</span><span class="o">*</span><span class="n">l1e</span><span class="p">;</span>

    <span class="c1">// Components of deltaF2</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">diffF21</span> <span class="o">=</span> <span class="n">lambdaMax</span><span class="o">*</span><span class="p">(</span><span class="n">r2</span><span class="o">*</span><span class="n">l2rho</span> <span class="o">+</span> <span class="n">rhoTilde</span><span class="o">*</span><span class="n">l3rho</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">diffF224</span> <span class="o">=</span> <span class="n">lambdaMax</span><span class="o">*</span><span class="p">(</span><span class="n">r2</span><span class="o">*</span><span class="n">l2U</span> <span class="o">+</span> <span class="n">rhoTilde</span><span class="o">*</span><span class="n">l3U</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">diffF25</span> <span class="o">=</span> <span class="n">lambdaMax</span><span class="o">*</span><span class="p">(</span><span class="n">r2</span><span class="o">*</span><span class="n">l2e</span> <span class="o">+</span> <span class="n">rhoTilde</span><span class="o">*</span><span class="n">l3e</span><span class="p">);</span>

    <span class="c1">// Components of deltaF3</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">diffF31</span> <span class="o">=</span> <span class="n">lambdaMax</span><span class="o">*</span><span class="n">r3</span><span class="o">*</span><span class="n">l4rho</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">diffF324</span> <span class="o">=</span> <span class="n">lambdaMax</span><span class="o">*</span><span class="n">r3</span><span class="o">*</span><span class="n">l4U</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">diffF35</span> <span class="o">=</span> <span class="n">lambdaMax</span><span class="o">*</span><span class="n">r3</span><span class="o">*</span><span class="n">l4e</span><span class="p">;</span>

    <span class="c1">// Step 8: compute left and right fluxes</span>

    <span class="c1">// Left flux 5-vector</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">fluxLeft11</span> <span class="o">=</span> <span class="n">rhoLeft</span><span class="o">*</span><span class="n">contrVLeft</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">fluxLeft124</span> <span class="o">=</span> <span class="n">ULeft</span><span class="o">*</span><span class="n">fluxLeft11</span> <span class="o">+</span> <span class="n">normalVector</span><span class="o">*</span><span class="n">pLeft</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">fluxLeft15</span> <span class="o">=</span> <span class="n">hLeft</span><span class="o">*</span><span class="n">fluxLeft11</span><span class="p">;</span>

    <span class="c1">// Right flux 5-vector</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">fluxRight11</span> <span class="o">=</span> <span class="n">rhoRight</span><span class="o">*</span><span class="n">contrVRight</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">fluxRight124</span> <span class="o">=</span> <span class="n">URight</span><span class="o">*</span><span class="n">fluxRight11</span> <span class="o">+</span> <span class="n">normalVector</span><span class="o">*</span><span class="n">pRight</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">fluxRight15</span> <span class="o">=</span> <span class="n">hRight</span><span class="o">*</span><span class="n">fluxRight11</span><span class="p">;</span>

    <span class="c1">// Step 10: compute face flux 5-vector</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">flux1</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">fluxLeft11</span> <span class="o">+</span> <span class="n">fluxRight11</span> <span class="o">-</span> <span class="p">(</span><span class="n">diffF11</span> <span class="o">+</span> <span class="n">diffF21</span> <span class="o">+</span> <span class="n">diffF31</span><span class="p">));</span>
    <span class="k">const</span> <span class="n">vector</span> <span class="n">flux24</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">fluxLeft124</span> <span class="o">+</span> <span class="n">fluxRight124</span> <span class="o">-</span> <span class="p">(</span><span class="n">diffF124</span> <span class="o">+</span> <span class="n">diffF224</span> <span class="o">+</span> <span class="n">diffF324</span><span class="p">));</span>
    <span class="k">const</span> <span class="n">scalar</span> <span class="n">flux5</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">fluxLeft15</span> <span class="o">+</span> <span class="n">fluxRight15</span> <span class="o">-</span> <span class="p">(</span><span class="n">diffF15</span> <span class="o">+</span> <span class="n">diffF25</span> <span class="o">+</span> <span class="n">diffF35</span><span class="p">));</span>

    <span class="c1">// Compute private data</span>
    <span class="n">rhoFlux</span>  <span class="o">=</span> <span class="n">flux1</span><span class="o">*</span><span class="n">magSf</span><span class="p">;</span>
    <span class="n">rhoUFlux</span> <span class="o">=</span> <span class="n">flux24</span><span class="o">*</span><span class="n">magSf</span><span class="p">;</span>
    <span class="n">rhoEFlux</span> <span class="o">=</span> <span class="n">flux5</span><span class="o">*</span><span class="n">magSf</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="mdlimiter">
<h4>MDLimiter<a class="headerlink" href="#mdlimiter" title="永久链接至标题">¶</a></h4>
<p>在使用limiter时首先如下构建基本对象并初始化：</p>
<div class="literal-block-wrapper docutils container" id="id130">
<div class="code-block-caption"><span class="caption-text">src/dbns/limiter/MDLimiter.H</span><a class="headerlink" href="#id130" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">MDLimiter</span>
<span class="p">(</span>
    <span class="k">const</span> <span class="n">GeoFieldType</span><span class="o">&amp;</span> <span class="n">phi</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">GeoGradFieldType</span><span class="o">&amp;</span> <span class="n">gradPhi</span>
<span class="p">)</span>
<span class="o">:</span>
    <span class="n">mesh_</span><span class="p">(</span><span class="n">phi</span><span class="p">.</span><span class="n">mesh</span><span class="p">()),</span>
    <span class="n">phi_</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span>
    <span class="n">gradPhi_</span><span class="p">(</span><span class="n">gradPhi</span><span class="p">),</span>
    <span class="n">phiLimiter_</span>
    <span class="p">(</span>
        <span class="n">IOobject</span>
        <span class="p">(</span>
            <span class="s">&quot;phiLimiter&quot;</span><span class="p">,</span>
            <span class="n">mesh_</span><span class="p">.</span><span class="n">time</span><span class="p">().</span><span class="n">timeName</span><span class="p">(),</span>
            <span class="n">mesh_</span><span class="p">,</span>
            <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_READ</span><span class="p">,</span>
            <span class="n">IOobject</span><span class="o">::</span><span class="n">NO_WRITE</span>
        <span class="p">),</span>
        <span class="n">mesh_</span><span class="p">,</span>
        <span class="n">dimensioned</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;pLimiter&quot;</span><span class="p">,</span> <span class="n">dimless</span><span class="p">,</span> <span class="n">pTraits</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">one</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>在网格内部面上的limiter的值如下进行计算：</p>
<div class="literal-block-wrapper docutils container" id="id131">
<div class="code-block-caption"><span class="caption-text">src/dbns/limiter/MDLimiter.H</span><a class="headerlink" href="#id131" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">forAll</span> <span class="p">(</span><span class="n">owner</span><span class="p">,</span> <span class="n">faceI</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">label</span><span class="o">&amp;</span> <span class="n">own</span> <span class="o">=</span> <span class="n">owner</span><span class="p">[</span><span class="n">faceI</span><span class="p">];</span>
    <span class="k">const</span> <span class="n">label</span><span class="o">&amp;</span> <span class="n">nei</span> <span class="o">=</span> <span class="n">neighbour</span><span class="p">[</span><span class="n">faceI</span><span class="p">];</span>

    <span class="n">vector</span> <span class="n">deltaRLeft</span> <span class="o">=</span> <span class="n">faceCentre</span><span class="p">[</span><span class="n">faceI</span><span class="p">]</span> <span class="o">-</span> <span class="n">cellCentre</span><span class="p">[</span><span class="n">own</span><span class="p">];</span>
    <span class="n">vector</span> <span class="n">deltaRRight</span> <span class="o">=</span> <span class="n">faceCentre</span><span class="p">[</span><span class="n">faceI</span><span class="p">]</span> <span class="o">-</span> <span class="n">cellCentre</span><span class="p">[</span><span class="n">nei</span><span class="p">];</span>

    <span class="c1">// Find minimal limiter value in each cell</span>

    <span class="c1">// Owner side</span>
    <span class="n">limitFunction</span><span class="p">.</span><span class="n">limiter</span>
    <span class="p">(</span>
        <span class="n">phiLimiterIn</span><span class="p">[</span><span class="n">own</span><span class="p">],</span>
        <span class="n">cellVolume</span><span class="p">[</span><span class="n">own</span><span class="p">],</span>
        <span class="n">phiMaxIn</span><span class="p">[</span><span class="n">own</span><span class="p">]</span> <span class="o">-</span> <span class="n">phi_</span><span class="p">[</span><span class="n">own</span><span class="p">],</span>
        <span class="n">phiMinIn</span><span class="p">[</span><span class="n">own</span><span class="p">]</span> <span class="o">-</span> <span class="n">phi_</span><span class="p">[</span><span class="n">own</span><span class="p">],</span>
        <span class="p">(</span><span class="n">deltaRLeft</span> <span class="o">&amp;</span> <span class="n">gradPhiIn</span><span class="p">[</span><span class="n">own</span><span class="p">])</span>
    <span class="p">);</span>

    <span class="c1">// Neighbour side</span>
    <span class="n">limitFunction</span><span class="p">.</span><span class="n">limiter</span>
    <span class="p">(</span>
        <span class="n">phiLimiterIn</span><span class="p">[</span><span class="n">nei</span><span class="p">],</span>
        <span class="n">cellVolume</span><span class="p">[</span><span class="n">nei</span><span class="p">],</span>
        <span class="n">phiMaxIn</span><span class="p">[</span><span class="n">nei</span><span class="p">]</span> <span class="o">-</span> <span class="n">phi_</span><span class="p">[</span><span class="n">nei</span><span class="p">],</span>
        <span class="n">phiMinIn</span><span class="p">[</span><span class="n">nei</span><span class="p">]</span> <span class="o">-</span> <span class="n">phi_</span><span class="p">[</span><span class="n">nei</span><span class="p">],</span>
        <span class="p">(</span><span class="n">deltaRRight</span> <span class="o">&amp;</span> <span class="n">gradPhiIn</span><span class="p">[</span><span class="n">nei</span><span class="p">])</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>一般边界面上不需要设置limiter，而coupled边界条件需要特殊处理。上述调用的limiter()函数的执行内容由具体选取的limiter类型决定。</p>
</div>
<div class="section" id="firstorderlimiter">
<h4>firstOrderLimiter<a class="headerlink" href="#firstorderlimiter" title="永久链接至标题">¶</a></h4>
<p>一阶limiter实际上就是没有设置limiter，将limiter的值全部设置为零。</p>
<div class="literal-block-wrapper docutils container" id="id132">
<div class="code-block-caption"><span class="caption-text">src/dbns/limiter/firstOrderLimiter.H</span><a class="headerlink" href="#id132" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">//- Set scalar limiter value</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">limiter</span>
<span class="p">(</span>
    <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">lim</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">cellVolume</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">deltaOneMax</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">deltaOneMin</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">deltaTwo</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">lim</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//- Set Type limiter</span>
<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">limiter</span>
<span class="p">(</span>
    <span class="n">Type</span><span class="o">&amp;</span> <span class="n">lim</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">cellVolume</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Type</span><span class="o">&amp;</span> <span class="n">deltaOneMax</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Type</span><span class="o">&amp;</span> <span class="n">deltaOneMin</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Type</span><span class="o">&amp;</span> <span class="n">extrapolate</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">lim</span> <span class="o">=</span> <span class="n">pTraits</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">zero</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="barthjespersenlimiter">
<h4>BarthJespersenLimiter<a class="headerlink" href="#barthjespersenlimiter" title="永久链接至标题">¶</a></h4>
<div class="literal-block-wrapper docutils container" id="id133">
<div class="code-block-caption"><span class="caption-text">src/dbns/limiter/BarthJespersenLimiter.H</span><a class="headerlink" href="#id133" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">limiter</span>
<span class="p">(</span>
    <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">lim</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">cellVolume</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">deltaOneMax</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">deltaOneMin</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">extrapolate</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mag</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">SMALL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">extrapolate</span> <span class="o">-</span> <span class="n">deltaOneMax</span> <span class="o">&gt;</span> <span class="n">SMALL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">lim</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">lim</span><span class="p">,</span> <span class="n">deltaOneMax</span><span class="o">/</span><span class="n">extrapolate</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">extrapolate</span> <span class="o">-</span> <span class="n">deltaOneMin</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">SMALL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">lim</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">lim</span><span class="p">,</span> <span class="n">deltaOneMin</span><span class="o">/</span><span class="n">extrapolate</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//- Set Type limiter</span>
<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">limiter</span>
<span class="p">(</span>
    <span class="n">Type</span><span class="o">&amp;</span> <span class="n">lim</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">cellVolume</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Type</span><span class="o">&amp;</span> <span class="n">deltaOneMax</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Type</span><span class="o">&amp;</span> <span class="n">deltaOneMin</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Type</span><span class="o">&amp;</span> <span class="n">extrapolate</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">direction</span> <span class="n">cmpt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cmpt</span> <span class="o">&lt;</span> <span class="n">Type</span><span class="o">::</span><span class="n">nComponents</span><span class="p">;</span> <span class="n">cmpt</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">limiter</span>
        <span class="p">(</span>
            <span class="n">lim</span><span class="p">.</span><span class="n">component</span><span class="p">(</span><span class="n">cmpt</span><span class="p">),</span>
            <span class="n">cellVolume</span><span class="p">,</span>
            <span class="n">deltaOneMax</span><span class="p">.</span><span class="n">component</span><span class="p">(</span><span class="n">cmpt</span><span class="p">),</span>
            <span class="n">deltaOneMin</span><span class="p">.</span><span class="n">component</span><span class="p">(</span><span class="n">cmpt</span><span class="p">),</span>
            <span class="n">extrapolate</span><span class="p">.</span><span class="n">component</span><span class="p">(</span><span class="n">cmpt</span><span class="p">)</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="venkatakrishnanlimiter">
<h4>VenkatakrishnanLimiter<a class="headerlink" href="#venkatakrishnanlimiter" title="永久链接至标题">¶</a></h4>
<div class="literal-block-wrapper docutils container" id="id134">
<div class="code-block-caption"><span class="caption-text">src/dbns/limiter/VenkatakrishnanLimiter.H</span><a class="headerlink" href="#id134" title="永久链接至代码">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">VenkatakrishnanLimiter</span><span class="p">()</span>
<span class="o">:</span>
    <span class="n">k_</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="p">{}</span>

<span class="c1">//- Set scalar limiter value</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">limiter</span>
<span class="p">(</span>
    <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">lim</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">cellVolume</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">deltaOneMax</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">deltaOneMin</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">extrapolate</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">scalar</span> <span class="n">epsilonSquare</span> <span class="o">=</span> <span class="n">pow3</span><span class="p">(</span><span class="n">k_</span><span class="p">)</span><span class="o">*</span><span class="n">cellVolume</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">mag</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">SMALL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Limiter remains unchanged</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">extrapolate</span> <span class="o">&gt;</span> <span class="n">VSMALL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">lim</span> <span class="o">=</span> <span class="n">max</span>
        <span class="p">(</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="n">min</span>
            <span class="p">(</span>
                <span class="p">(</span>
                    <span class="p">(</span><span class="n">sqr</span><span class="p">(</span><span class="n">deltaOneMax</span><span class="p">)</span> <span class="o">+</span> <span class="n">epsilonSquare</span><span class="p">)</span><span class="o">*</span><span class="n">extrapolate</span>
                  <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sqr</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">)</span><span class="o">*</span><span class="n">deltaOneMax</span>
                <span class="p">)</span><span class="o">/</span>
                <span class="n">stabilise</span>
                <span class="p">(</span>
                    <span class="n">extrapolate</span><span class="o">*</span>
                    <span class="p">(</span>
                        <span class="n">sqr</span><span class="p">(</span><span class="n">deltaOneMax</span><span class="p">)</span>
                      <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sqr</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">)</span>
                      <span class="o">+</span> <span class="n">deltaOneMax</span><span class="o">*</span><span class="n">extrapolate</span>
                      <span class="o">+</span> <span class="n">epsilonSquare</span>
                    <span class="p">),</span>
                    <span class="n">SMALL</span>
                <span class="p">),</span>
                <span class="n">lim</span>
            <span class="p">)</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">extrapolate</span> <span class="o">&lt;</span> <span class="n">VSMALL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">lim</span> <span class="o">=</span> <span class="n">max</span>
        <span class="p">(</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="n">min</span>
            <span class="p">(</span>
                <span class="p">(</span>
                    <span class="p">(</span><span class="n">sqr</span><span class="p">(</span><span class="n">deltaOneMin</span><span class="p">)</span> <span class="o">+</span> <span class="n">epsilonSquare</span><span class="p">)</span><span class="o">*</span><span class="n">extrapolate</span>
                  <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sqr</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">)</span><span class="o">*</span><span class="n">deltaOneMin</span>
                <span class="p">)</span><span class="o">/</span>
                <span class="n">stabilise</span>
                <span class="p">(</span>
                    <span class="n">extrapolate</span><span class="o">*</span>
                    <span class="p">(</span>
                        <span class="n">sqr</span><span class="p">(</span><span class="n">deltaOneMin</span><span class="p">)</span>
                      <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sqr</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">)</span>
                      <span class="o">+</span> <span class="n">deltaOneMin</span><span class="o">*</span><span class="n">extrapolate</span>
                      <span class="o">+</span> <span class="n">epsilonSquare</span>
                    <span class="p">),</span>
                    <span class="n">SMALL</span>
                <span class="p">),</span>
                <span class="n">lim</span>
            <span class="p">)</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//- Set Type limiter</span>
<span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">limiter</span>
<span class="p">(</span>
    <span class="n">Type</span><span class="o">&amp;</span> <span class="n">lim</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar</span><span class="o">&amp;</span> <span class="n">cellVolume</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Type</span><span class="o">&amp;</span> <span class="n">deltaOneMax</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Type</span><span class="o">&amp;</span> <span class="n">deltaOneMin</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Type</span><span class="o">&amp;</span> <span class="n">extrapolate</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">direction</span> <span class="n">cmpt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cmpt</span> <span class="o">&lt;</span> <span class="n">Type</span><span class="o">::</span><span class="n">nComponents</span><span class="p">;</span> <span class="n">cmpt</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">limiter</span>
        <span class="p">(</span>
            <span class="n">lim</span><span class="p">.</span><span class="n">component</span><span class="p">(</span><span class="n">cmpt</span><span class="p">),</span>
            <span class="n">cellVolume</span><span class="p">,</span>
            <span class="n">deltaOneMax</span><span class="p">.</span><span class="n">component</span><span class="p">(</span><span class="n">cmpt</span><span class="p">),</span>
            <span class="n">deltaOneMin</span><span class="p">.</span><span class="n">component</span><span class="p">(</span><span class="n">cmpt</span><span class="p">),</span>
            <span class="n">extrapolate</span><span class="p">.</span><span class="n">component</span><span class="p">(</span><span class="n">cmpt</span><span class="p">)</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Linux.html" class="btn btn-neutral float-left" title="Linux" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="OpenFOAM算例运行案例.html" class="btn btn-neutral float-right" title="OpenFOAM算例运行案例" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2022-2023, Koishi.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>