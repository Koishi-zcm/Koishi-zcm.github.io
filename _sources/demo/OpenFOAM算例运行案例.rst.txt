********************
OpenFOAM算例运行案例
********************

在运行算例前要先创立一个 :code:`run` 文件夹来存放算例文件。该文件位于 :code:`HOME/OpenFOAM/<USER>/run` 下，其中 :code:`<USER>` 为用户具体的名称。 :code:`run` 文件夹通过 :code:`$FOAM_RUN` 环境变量来定义，可以在终端输入

.. code-block:: 

    ls $FOAM_RUN

来查看 :code:`run` 文件夹的具体位置。如果终端返回空文件夹，则可以输入

.. code-block:: 

    mkdir -p $FOAM_RUN

来创建 :code:`run` 文件夹。



教程案例
==========

cavity算例
-----------

下面来尝试运行教程算例中的cavity算例。先将该算例拷贝到run目录下，同时进入该算例目录。

.. code-block:: 

    cd $FOAM_RUN
    cp -r $FOAM_TUTORIALS/incompressible/icoFoam/cavity/cavity .
    cd cavity

.. attention:: 上面第二行命令中最后的实心句号 :code:`.` 不可遗漏。

网格生成
^^^^^^^^^^^

接下来用OpenFOAM提供的 :code:`blockMesh` 命令来生成网格。该命令通过读取位于算例文件夹下的 :code:`system/ployMesh` 文件夹内的 :code:`blockMeshDict` 字典文件的信息来生成网格。该文件首先指定各个block顶点(vertices)的坐标，然后通过顶点编号来定义block，最后定义边界面。

进入到算例目录下之后，直接在终端输入该命令即可生成网格：

.. code-block:: 

    blockMesh


初始场设置
^^^^^^^^^^^^^

网格生成完毕后，就可以进入算例目录下查看该算例的初始场信息。因为cavity算例是从0秒开始计算的，所以初始的场信息存储在cavity目录下的 :code:`0` 文件夹下。该文件夹下包含 :code:`p` 和 :code:`U` 两个文件夹，分别是压力场和速度场，它们的初值和边界条件必须指定。

首先进入 :code:`p` 文件查看其信息。可以看到场文件中有3个主要信息：

- :code:`dimensions` 指定场的单位，此处为运动压力，即除以密度之后的压力，单位为 :math:`\mathrm{m^{2}}\mathrm{s^{-2}}` 。
- :code:`internalField` 内部场可以指定为 :code:`uniform` (均一场)，或者每个网格的数据都需要指定的 :code:`nonuniform` (非均一场)。
- :code:`boundaryField` 指定边界场信息，包括边界条件以及所有边界面所需的信息。
  
对于这个cavity算例，边界场由 :code:`walls` 组成，并分为两个 :code:`patches` ：(1) :code:`fixedWalls` 用来指定固定边界，即cavity几何的底部和侧面。(2) :code:`movingWall` 用来指定cavity几何的上部。它们作为壁面，压力边界条件均为 :code:`zeroGradient` ，意味着压力的法向梯度为零。 :code:`frontAndBack` 面即为2D算例的前后面，因此必须指定为 :code:`empty` 。

在该算例中，由于压力是运动压力，作为不可压缩流，其绝对值是没有意义的，关心的是相对压力，同时由于压力边界条件全部为 :code:`zeroGradient` ，需要设置压力参考点和参考值，所以初始场都设置为 :code:`uniform` ，考虑相对值时无所谓具体数值，就保持默认设置，即 :code:`uniform 0` 即可。

进入到 :code:`U` 文件查看其信息。 :code:`dimensions` 是速度的单位。内部场初始化为零，而由于速度是具有三个分量的矢量，因此初始化要写成 :code:`uniform (0 0 0)` 。速度场的 :code:`frontAndBack` 同样为 :code:`empty` ，其他的 :code:`patches` 均为 :code:`fixedWalls` ，且指定为无滑移边界条件即 :code:`fixedValue` ，其值为 :code:`value uniform (0 0 0)` 。因为在该算例中，我们假设顶部壁面以每秒1米的速度在x方向移动，这是一个固定速度即 :code:`fixedValue` ，其具体的值为 :code:`uniform (1 0 0)` ，所以 :code:`movingWall` 当中有相应的些设定。


physicalProperties设置
^^^^^^^^^^^^^^^^^^^^^^^^^

算例的物理特性存储在constant/physicalProperties文件当中。对于cavity算例，唯一需要给定的参数为运动粘度。我们的算例雷诺数为 :code:`10` ，根据雷诺数的定义 :code:`\operatorname{Re}=\frac{d|\boldsymbol{U}|}{\nu}` ，此处特征长度 :code:`d=0.1~\mathrm{m}` ，速度 :code:`|\boldsymbol{U}|=1~\mathrm{m/s}` ，运动粘度为 :code:`0.01~\mathrm{m^{2}/s}` 。指定运动粘度场的方式为：

.. code-block:: C

    nu              [0 2 -1 0 0 0 0] 0.01;


controlDict设置
^^^^^^^^^^^^^^^^^

进入system/controlDict字典来对时间步、输入输出时间、场数据的读取和写入进行控制。因为我们在 :math:`t=0` 的时候开始进行计算，所以设定 :code:`startFrom` 关键字信息为 :code:`startTime` ，并把 :code:`startTime` 指定为 :code:`0` 。运算结束的时候，我们希望能够达到稳定的状态，即流体在空腔内循环，一个通用准则是：层流下流体应该穿过(循环)计算域 :math:`10` 次。不过，该算例中没有进出口，因此流体没有穿过计算域，所以结束时间应该设置为空腔内循环 :math:`10` 次的时间。这里我们设置设置结束时间为 :math:`0.5~\mathrm{s}` ，于是把 :code:`stopAt` 关键字指定为 :code:`endTime` 并指定为 :code:`endTime` 为 :code:`0.5` 。

当运行 :code:`icoFoam` 的时候，为了达到数值稳定以及时间计算精度，库朗数 :math:`\mathrm{Co}=\frac{\delta t|\boldsymbol{U}|}{\delta x}` 应该小于1，其中 :math:`\delta t` 为时间步， :math:`|\boldsymbol{U}|` 为某个网格单元内的速度矢量的模， :code:`\delta x` 为速度方向的网格长度。由于流体域内速度并不均一，为了保证库朗数在各处都小于 :math:`1` ，可以依据最大速度和最小网格尺寸来确定时间步。在该算例中，网格大小是固定的，因此在顶盖附近，速度接近 :math:`1~\mathrm{m/s}` 的地方库朗数最大，网格大小为

.. math::
	\begin{align}
	\delta x=\frac{d}{n}=\frac{0.1}{20}=0.005~\mathrm{m}   
	\end{align}

为了使库朗数在整个流体域都小于或等于1，时间必须小于或等于

.. math::
	\begin{align}
	\delta t=\frac{\mathrm{Co}\delta x }{|\boldsymbol{U}|}=\frac{1\times 0.005}{1}=0.005~\mathrm{s} 
	\end{align}

所以设定时间步 :code:`deltaT` 为 :code:`0.005` 。随着计算的进行，为了在某个固定的时间间隔写入数据，可以通过 :code:`writeControl` 关键字来控制，如果要在 :math:`0.1~\mathrm{s},~0.2~\mathrm{s},\cdots,~0.5~\mathrm{s}` 写入结果，由于计算时间步为 :math:`0.005~\mathrm{s}` ，因此需要每 :math:`20` 个时间步输出一次结果，所以设定 :code:`writeInterval` 为 :code:`20` 。启动运算后OpenFOAM将会在每一个时间步内创建一个文件夹，例如0.1文件夹。


fvScheme设置
^^^^^^^^^^^^^^

在 :code:`system` 文件夹下的 :code:`fvScheme` 文件来指定有限体积法的离散格式。在 :code:`system` 下的 :code:`fvSolution` 文件中指定方程组矩阵求解器、残差以及其他算法控制。


网格查看
^^^^^^^^^^

在运行算例之前，最好通过ParaView查看一下网格。使用ParaView之前，要保证每个版本OpenFOAM对应的Thirdparty文件编译完成，即进入对应的Thirdparty文件目录，在终端输入：

.. code-block:: 

    ./Allwmake


编译完成后，进入算例文件夹下，输入

.. code-block:: 

    paraFoam &

即可打开ParaView窗口。在该窗口中，可以看到算例模块打开的名称为 :code:`cavity.openfoam` 。在Properties选项卡内中找到Mesh Regions，勾选所有网格，之后点击Apply即可加载所有几何数据。找到Display选项卡，可以更改Representation为Wireframe使几何数据以线网格的形式呈现；在Coloring中修改为Solid Color来更改着色方式。


cavityFine算例
-----------------

网格生成
^^^^^^^^^^^

现在在cavity算例的基础上，复制重命名一个算例为cavityFine，进入blockMeshDict编辑网格信息，将原本的 :code:`(20 20 1)` 修改为 :code:`(40 40 1)` 来增加每个方向的网格数量以提高密度。重新进入终端运行 :code:`blockMesh` 重新生成网格。


mapFields场映射
^^^^^^^^^^^^^^^^^

从cavity到cavityFine时，由于几何、边界类型和条件是相同的，因此场本身可以认为是相同的，于是可以用 :code:`mapFields` 命令来把一个给定几何的场信息映射到另一个几何的对应场。读取的场信息通过 :code:`controlDict` 中的 :code:`startFrom` 的 :code:`startTime` 指定，而cavity算例的最终结果存储在0.5文件夹中，因此cavityFine算例中 :code:`controlDict` 文件中的 :code:`startTime` 应该设定为 :code:`0.5` 。设定完后，还需要将0.5文件夹中的 :code:`p` 文件和 :code:`U` 文件当中已存在的点数据全部删除，否则后续会出现点数量不对应的报错。删除后就可以在该算例目录中的终端运行：

.. code-block::

    mapFields ../cavity -consistent

正常运行完成后0.5文件夹内的 :code:`p` 文件和 :code:`U` 文件中的点数据就更新成功了。在网格大小减半后，为了保持 :math:`\mathrm{Co}` 小于 :math:`1` ， :code:`controlDict` 字典中的 :code:`deltaT` 需要设定为 :code:`0.0025` ，同时设置 :code:`endTime` 为 :code:`0.7` 。之前设定写入数据的方式是固定 :code:`timeStep` ，现在我们将 :code:`writeControl` 改为 :code:`runTime` 方式来指定每多少个物理时间间隔来写结果文件，此时 :code:`writeInterval` 为 :code:`0.1` 。


输出log文件
^^^^^^^^^^^^^

为了将输出信息记录为log文件以便查看，通过下面的方式来运行 :code:`icoFoam` ：

.. code-block:: 

    icoFoam > log &

可以直接点开log文件或者用命令 :code:`cat log` 查看其中的信息。删除原本的 :code:`cavity.foam` 文件，重新在终端输入下面的命令来启动Paraview查看结果。

.. code-block:: 

    paraFoam -builtin


获取速度场分量
^^^^^^^^^^^^^^^^

可以在算例目录下运行下面的命令来得到速度场各分量的文件：（注意其中的双引号）

.. code-block:: 

    postProcess -func "components(U)"

之后就可以在ParaView中Refresh Times来加载新的场，同时注意如果网格选择了边界区域，那么在ParaView中的插值会出现问题，因此要不能勾选边界面如 :code:`movingWall` ， :code:`fixedWalls` 和 :code:`frontAndBack` ，只勾选 :code:`internalMesh` 。


绘制指定线上的数据图表
^^^^^^^^^^^^^^^^^^^^^^^^

现在，在ParaView当中，对cavity.foam添加Filter，选择 :code:`Data Analysis` 中的 :code:`Plot Over Line` 。设置线的起始端和结束端，这里设置 :code:`Point1` 起始点为 :code:`(0.05,0,0.005)` ，在 :code:`Point2` 中设置终点为 :code:`(0.05,0.1,0.005)` ，同时设置 :code:`Resolution` 为 :code:`100` 。点击Apply后就会生成对应的图表，默认在Display面板中设置 :code:`Attribute Type` 为 :code:`Point Data` ，设置 :code:`X Array name` 为 :code:`arc_length` 。可以在 :code:`Series Parameters` 中选择显示的场，同时左键选择对应的量之后，可以进一步设置线条颜色、标签名、线条宽度、线条类型、标记点类型、坐标轴类型。



cavityGrade算例
----------------

在对任何一个算例求解之前应该预测哪里误差比较大然后在那一部分细化网格。在cavity算例中，速度最大的变动发生在壁面处，因此这一部分网格可以进行非均匀化处理。从blockMeshDict文件中可以看到，在该算例中使用了4个blocks，上下面和左右面都需要网格非均匀化分布处理，每个block在x,y方向都有10个网格，最大网格和最小网格的大小比为2。可以执行 :code:`blockMesh` 命令后用ParaView查看一下非均匀化处理之后的网格情况。

因为顶盖附近的速度最高，网格最小，顶盖附近的库朗数也会变大，所以要计算一下顶盖附近网格的大小来确定适合本算例的时间步。当使用一个非均匀网格时，如果长度为 :math:`l` ，内置 :math:`n` 个网格单元，最末端和起始端网格比为 :math:`R` ，那么最小的网格大小就是 :math:`\delta x` ，其大小为

.. math::
    \begin{align}
    \delta x=l \frac{r - 1}{\alpha r - 1} 
    \end{align}

其中 :math:`r=R^{\frac{1}{n-1}}` 是相邻网格单元的大小比，且有

.. math::
    \begin{align}
    \alpha =\left \{  \begin{array}{cl}
    R & R>1; \\
    1-r^{-n}r^{-1} & R<1;
    \end{array} \right.
    \end{align}

对于cavityGrade算例，每个方向网格数为10，最大网格单元和最小网格单元大小比为2，block的高宽为 :math:`0.05~\mathrm{m}` ，因此最小的网格单元为 :math:`3.45~\mathrm{mm}` ，从而可知时间步应该小于 :math:`3.45~\mathrm{ms}` 才能保证库朗数小于1。为了方便写入每个时间步的计算结果， :code:`deltaT` 设置为 :math:`2.5~\mathrm{ms}` ， :code:`writeInterval` 设置为 :code:`40` ，因此每隔0.1秒写一个结果文件。本算例的 :code:`startTime` 需要设置为cavityFine的结束时间，即 :math:`0.7~\mathrm{s}` ，而由于cavity和cavityFine算例都已经收敛地很好了，因此整个算例只需要计算 :math:`0.1~\mathrm{s}` ，即结束时间 :code:`endTime` 设为 :code:`0.8` 。之后在cavityGrade目录下使用下面的命令即可映射结果：

.. code-block::

    mapFields ../cavityFine -consistent

运行 :code:`icoFoam` 监控运行输出信息，并对结果后处理与之前的结果比对。



cavityHighRe算例
--------------------

目前的算例雷诺数非常低，仅为10，可以快速地达到稳定状态，并且只有一个非常小的涡旋存在于空腔的底角。接下来我们把雷诺数增加到100，这会明显增加收敛时间。首先拷贝cavity算例并命名为cavityHighRe。可以在run目录下用下面的命令来完成拷贝：

.. code-block:: 

    foamCloneCase -latestTime cavity cavityHighRe

进入cavityHighRe算例中的constant文件夹，编辑physicalProperties文件，为了让雷诺数扩大为10倍，可以通过把粘度降低为原来的1/10来实现，即变为 :math:`10\mathrm{e}-3~\mathrm{m^{2}s^{-1}}` 。修改 :code:`startTime` 为 :code:`latestTime` ，结束时间 :code:`endTime` 设为 :math:`2~\mathrm{s}` 。

接下来在算例目录下运行算例查看输出。可以用下面的命令来以后台进程的方式来运行算例，其中的UNIX命令 :code:`nohup` 表示当用户退出登录时程序依然继续运行， :code:`nice` 用于调整进程优先级， :code:`-20` 对应最高优先进程， :code:`19` 对应最低优先进程。

.. code-block:: 

    nohup nice -n 19 icoFoam > log &


.. note:: 

    查看log文件可以发现，icoFoam在非常短的时间内就停止了对速度进行迭代， :code:`No Iterations 0` 表示速度的求解已经停止，并且在压力的初始残差小于 :code:`fvSolution` 设定的残差值 :code:`10e-6` 之后，求解就已经收敛。

接下来可以用ParaView查看结果的速度矢量，可以发现角落里的第二个涡略微变大了。可以继续尝试减少粘度来增加雷诺数并重新运行算例，涡的数量会增加，因此也就需要在涡的附近增加网格来求解更复杂的流型。另外，高雷诺数也增加了收敛所需要的时间，需要监控残差并延长求解时间以确保收敛。


cavityRAS算例
--------------

在如果继续用上一个算例的思想来求解湍流域的话，提高网格数量和增加求解时间将会带来求解稳定性较差、计算资源消耗庞大的问题。接下来我们使用Reynolds-Average Simulation (RAS)湍流模型来求解流体的平均行为以及统计波动，算例雷诺数为 :code:`10e4` 的顶盖驱动流，使用附带壁面函数的标准 :math:`k-\varepsilon` 模型来进行求解。这会出现两个新的变量：湍流动能场 :math:`k` 和湍流动能耗散率场 :math:`\varepsilon` ，需要使用的求解器为 :code:`pisoFoam` 。

首先从 :code:`tutorials/incompressible/pisoFoam/RAS` 文件夹中将 :code:`cavity` 算例复制出来并重命名为 :code:`cavityRAS` 。进入算例目录，直接使用 :code:`blockMesh` 生成网格。

.. note:: 当使用附带壁面函数的标准 :math:`k-\varepsilon` 模型时，没必要引入非均匀网格，因为壁面附近的流型已经被模化而不是直接求解。

OpenFOAM自带的壁面函数边界条件可以分别用于不同边界面，不同壁面可以使用不同的壁面边界条件。我们可以对湍流粘度场 :math:`\nu_{t}` 进行修改以使用不同的壁面函数，其位于 :code:`0/nut` 文件夹内。在该算例中，通过把 :code:`movingWall` 和 :code:`fixedWall` 指定为 :code:`nutWallFunction` 类型来使用标准壁面函数模型。如果想指定其他的壁面边界模型，例如指定为粗糙壁面边界类型，可以通过 :code:`nutRoughWallFunction` 关键词来指定。

我们可以打开 :math:`k` 文件和 :math:`\varepsilon` 文件来查看它们的边界类型。对于壁面边界条件， :math:`\varepsilon` 为 :code:`epsilonWallFunction` 边界条件， :math:`k` 为 :code:`kqRWallFunction` 边界条件。 :code:`kqRWallFunction` 是一个普适性边界条件，它可以用于任何的湍动能类场，例如 :math:`k` 、 :math:`q` 以及雷诺应力 :math:`R` 场。最初的 :math:`k` 和 :math:`\varepsilon` 值通过对速度波动量 :math:`\boldsymbol{U}'` 和湍流尺度量 :math:`l` 进行预估来计算，它们的计算公式为：

.. math::
    \begin{align}
    & k=\frac{1}{2}\overline{\boldsymbol{U}'\cdot \boldsymbol{U}'}, && \varepsilon =\frac{C_{\mu}^{0.75}k^{1.5}}{l} 
    \end{align}

其中 :math:`C_{\mu}` 是 :math:`k-\varepsilon` 模型的标准参数，其值为 :math:`0.09` 。对于笛卡尔坐标系， :math:`k` 的计算公式可以改写为

.. math::
    \begin{align}
    k=\frac{1}{2}\left ( U_{x}'^{2}+U_{y}'^{2}+U_{z}'^{2} \right )
    \end{align}

其中 :math:`U_{x}'` , :math:`U_{y}'` , :math:`U_{z}'` 是速度在 :math:`x,y,z` 方向的脉动速度。

在本算例中，我们假定其为各向同性湍流，满足 :math:`U_{x}'^{2}=U_{y}'^{2}=U_{z}'^{2}` ，其值为顶盖速度的 :math:`5\%` ，湍流尺度为正方体宽度的 :math:`20\%` 即 :math:`0.1~\mathrm{m}` ，从而可以计算出 :math:`k` 和 :math:`\varepsilon` 的初始条件：

.. math::
    \begin{align}
    & U_{x}'=U_{y}'=U_{z}'=\frac{5}{100}~\mathrm{m/s} \\
    & k=\frac{3}{2}(\frac{5}{100})^{2} = 3.75\times 10^{-3}~\mathrm{m^{2}s^{-2}} \\
    & \varepsilon =\frac{C_{\mu}^{0.75}k^{.15}}{l}\approx 7.54\times 10^{-4}~\mathrm{m^{2}s^{-2}}    
    \end{align}

速度和压力的边界条件跟之前的相同，为 :code:`(0 0 0)` 和 :code:`0` 。

目前存在很多的湍流模型，在大多数瞬态求解器中，湍流模型是在运行时进行选择的。求解器最开始运行的时候，它会读取 :code:`constant/momentum Transport` 文件中的 :code:`simulationType` 关键字来获取湍流模型的相关信息。可选的 :code:`simulationType` 包括 :code:`laminar` ， :code:`RAS` 和 :code:`LES` 。在该算例中我们选择 :code:`RAS` ，并选择标准 :math:`k-\varepsilon` 模型 :code:`kEpsilon` ，同时要确保 :code:`turbulence` 设置为 :code:`on` 状态。每个湍流模型的参数都存储在每个湍流模型的代码中并且具有一个默认值，如果 :code:`printCoeffs` 设置为 :code:`on` 的话，那么这些参数的值会被输出到终端。这些模型的参数也可以通过在 :code:`RAS` 子字典文件中自定义来修改。

接下来到 :code:`physicalProperties` 文件中设置层流粘度。经过计算可知当设置动力粘度为 :code:`10e-5` 时雷诺数可以达到 :math:`10^{4}` 。最后进入 :code:`controlDict` 里面进行调整。为了保证库朗数小于1，将 :code:`deltaT` 设置为 :code:`0.005` ，并将结束时间设置为 :math:`10~\mathrm{s}` 。

此时在算例目录下进入终端键入 :code:`pisoFoam` 命令来运行算例。在这个算例中，由于粘度非常低，顶盖附近的边界层会非常薄，而我们顶盖附近的网格又比较稀疏，因此在这些网格中的速度要比顶盖的速度小得多。实际上，大约100个时间步之后，可以看到顶盖附近的网格单元速度的上限大约为 :math:`0.2~\mathrm{m/s}` ，因此最大库朗数不会超过 :math:`0.2` ，从而可以通过调节时间步来增大库朗数的同时保持小于1的条件。这里，我们从第10秒开始，将 :code:`endTime` 设置为 :code:`20` ，同时调节 :code:`deltaT` 为 :code:`0.02` ，重新运行。

.. note:: 监控残差情况可以判断是否达到稳态，或者算例的某个结果场达到了一种循环的状态。后者的情况下，算例可能永远不会收敛，但这并不意味着计算地不精确。


cavityClipped算例
-------------------

有时候可能会需要改变一下几何模型然后重新计算，在这种情况下最好保留所有计算过的文件，并在新算例中调用它们。然而，在新的几何模型中，场数据可能不一样了。不过， :code:`mapFields` 程序可以处理完全一样的几何或者不一样的几何，以及重合边界或者非重合边界。这里我们来运行 :code:`icoFoam/cavity/cavityClipped` 算例。在这个算例中，几何模型在底部的右边有一个边长为0.04米正方形被移除，可以进入 :code:`blockMeshDict` 来查看网格细节。直接使用 :code:`blockMesh` 生成网格， :code:`patches` 参考之前算例的设定。为了在 :code:`mapFields` 的过程中便于区分，在本算例中，将原本的 :code:`movingWall` 改名为 :code:`lid` 。

在非连续几何的映射中，不能保证所有场数据都能映射过来。在某些区域，原始场并不包含相关数据，这些区域还是被映射场的原始数据，因此在映射前，在响应的时间步内就应该存在响应的场数据。在这个算例中，我们从0.5秒开始进行映射，因此在 :code:`controlDict` 中设定 :code:`startTime` 为 :code:`0.5` ，并把0秒的场数据拷贝到0.5文件中。

接下来将cavity中的速度和压力场数据映射到cavityClipped算例中。因为映射是不连续的，因此需要编辑 :code:`system/mapFieldsDict` 文件。该文件内包含两个关键词： :code:`patchMap` 和 :code:`cuttingPatches` 。

如果想把原始场的 :code:`patches` 条件映射到被映射场的 :code:`patches` 的时候，要使用 :code:`patchMap` 。在本算例中，我们的 :code:`lid` 边界条件和cavity算例中的 :code:`movingWall` 边界条件是一致的，因此可以如下设置：

.. code-block:: C

    patchMap        (lid movingWall);

当需要把原始场的内部数据映射到被映射场的边界时，要使用 :code:`cuttingPatches` 。在本算例中，因为 :code:`fixedWalls` 的边界条件为 :code:`noSlip` ，因此我们不需要对 :code:`fixedWalls` 的边界的值进行映射，所以可以指定为空：

.. code-block:: C

    cuttingPatches  ();

.. note:: 如果需要将内部场的值映射到 :code:`fixedWalls` 边界上，则需要在 :code:`fixedWalls` 中指定 :code:`fixedValue` 边界条件，其关键字 :code:`value` 值在映射过程中将会被改写。在这种情况下，需要在 :code:`cuttingPatches` 里面指定 :code:`fixedWalls` 关键词。

接下来就可以执行下面的命令进行映射：

.. code-block:: 

    mapFields ../cavity

之后就可以运行 :code:`icoFoam` 并进入ParaView查看结果。在ParaView中可以直接添加Stream Tracer滤镜来查看流线情况，并且可以添加Aphabetical当中的Extract Block滤镜，选择lid和fixedWalls边界面进行高亮来让图像结果更加漂亮。


plateHole算例
---------------

本算例我们来对一个中心带有圆形空洞的方盘进行线弹性稳态应力分析。整个方盘边长4米，中心空洞的半径为0.5米，该方盘左右面分别承受了一个均匀的 :math:`10~\mathrm{kpa}` 的载荷。由于该几何体是对称的，因此求解域只需要覆盖整个几何体的四分之一即可。这里我们选择右上角作为求解域并绘制对应的网格。

从 :code:`tutorials/stressAnalysis/solidDisplacementFoam` 中将 :code:`plateHole` 算例复制出来，进入 :code:`system/blockMeshDict` 查看网格信息。

作为二维算例，网格需要有两层，其高度也要指定，这里指定为 :code:`0.5` 。从图中可以看出一层有11个顶点，依次编号写出 :code:`vertices` 内容：

.. code-block:: C

    vertices
    (
        (0.5 0 0)                   // 0
        (1 0 0)                     // 1
        (2 0 0)                     // 2
        (2 0.707107 0)              // 3
        (0.707107 0.707107 0)       // 4
        (0.353553 0.353553 0)       // 5
        (2 2 0)                     // 6
        (0.707107 2 0)              // 7
        (0 2 0)                     // 8
        (0 1 0)                     // 9
        (0 0.5 0)                   // 10
        // 二维算例网格的第二层直接在第一层顶点信息的基础上修改高度即可
        (0.5 0 0.5)                 // 11
        (1 0 0.5)                   // 12
        (2 0 0.5)                   // 13
        (2 0.707107 0.5)            // 14
        (0.707107 0.707107 0.5)     // 15
        (0.353553 0.353553 0.5)     // 16
        (2 2 0.5)                   // 17
        (0.707107 2 0.5)            // 18
        (0 2 0.5)                   // 19
        (0 1 0.5)                   // 20
        (0 0.5 0.5)                 // 21
    );

根据图中的block结构，可以看到整个网格划分成了5个大网格块，注意顶点标签顺序决定的block自身坐标系方向，可以在图中看到各个block的 :math:`x_{1},x_{2}` 方向；在设置加密数量的时候要根据各个block之间坐标系方向的配合关系，不能出现同一边缘出现不同的加密设置；并且由于是二维算例，三个方向的加密设置在第三个参数都设置为了 :code:`1` ；同时希望生成均匀网格，所以非均匀化参数全部设置为了 :code:`1` ，如下所示：

.. code-block:: C

    blocks
    (
        hex (5 4 9 10 16 15 20 21) (10 10 1) simpleGrading (1 1 1)
        hex (0 1 4 5 11 12 15 16) (10 10 1) simpleGrading (1 1 1)
        hex (1 2 3 4 12 13 14 15) (20 10 1) simpleGrading (1 1 1)
        hex (4 3 6 7 15 14 17 18) (20 20 1) simpleGrading (1 1 1)
        hex (9 4 7 8 20 15 18 19) (10 20 1) simpleGrading (1 1 1)
    );

然后设置特殊边缘，这里都是圆弧类型边缘，通过 :code:`arc` 关键词指定，需要给定起始点、终止点标签以及该圆弧通过的一个点的坐标。注意不要忘记第二层的网格也需要指定圆弧边缘：

.. code-block:: C

    edges
    (
        arc 0 5 (0.469846 0.17101 0)
        arc 5 10 (0.17101 0.469846 0)
        arc 1 4 (0.939693 0.34202 0)
        arc 4 9 (0.34202 0.939693 0)
        arc 11 16 (0.469846 0.17101 0.5)
        arc 16 21 (0.17101 0.469846 0.5)
        arc 12 15 (0.939693 0.34202 0.5)
        arc 15 20 (0.34202 0.939693 0.5)
    );


接下来设置边界面信息。对于这个算例，可以区分出left,right,up,down,up（这些可以自由命名）以及二维算例统一的上下表面frontAndBack共六个边界面。由于我们是根据对称性只画了右上角的网格，因此left和down边界面实际上是完整网格的对称界面，于是设置为 :code:`symmetryPlane` ；frontAndBack作为二维算例统一的边界面，固定类型为 :code:`empty` ；其余边界面属于普通边界面，指定为 :code:`patch` 即可。通过在 :code:`faces` 里面列出完整的顶点标签列表来指定边界面：

.. code-block:: C

    boundary
    (
        left
        {
            type symmetryPlane;
            faces
            (
                (8 9 20 19)
                (9 10 21 20)
            );
        }
        right
        {
            type patch;
            faces
            (
                (2 3 14 13)
                (3 6 17 14)
            );
        }
        down
        {
            type symmetryPlane;
            faces
            (
                (0 1 12 11)
                (1 2 13 12)
            );
        }
        up
        {
            type patch;
            faces
            (
                (7 8 19 18)
                (6 7 18 17)
            );
        }
        hole
        {
            type patch;
            faces
            (
                (10 5 16 21)
                (5 0 11 16)
            );
        }
        frontAndBack
        {
            type empty;
            faces
            (
                (10 9 4 5)
                (5 4 1 0)
                (1 4 3 2)
                (4 7 6 3)
                (4 9 8 7)
                (21 16 15 20)
                (16 11 12 15)
                (12 13 14 15)
                (15 14 17 18)
                (15 18 19 20)
            );
        }
    );


.. figure:: ../_images/openFOAM/二维中心空洞平板第一层的block结构.png
  :align: center

*Figure 二维中心空洞平板第一层的block结构*



以上就设置好了blockMeshDict，可以通过 :code:`blockMesh` 来生成网格文件夹 :code:`constant/polyMesh` 并通过ParaView查看网格情况。网格生成后就需要指定边界条件的初始场。对于无热应力的单纯应力分析，只有位移量 :math:`D` 需要设定，进入 :code:`0/D` 文件，内部场位移量初始条件设置为：

.. code-block:: C

    internalField   uniform (0 0 0);

然后依次设定各个边界面的初始场信息。对于特殊边界面，例如已经left,down已经指定为了 :code:`symmetryPlane` ，frontAndBack指定为了 :code:`empty` ，那么在设定边界场的时候也要使用对应的类型。而其他没有特殊指定的，就要给定所需类型，在本算例中，应力边界类型是 :code:`tractionDisplacement` ，在该关键词内需要用 :code:`traction` 关键词给定应力边界矢量大小，用 :code:`pressure` 关键词给定边界面压力大小。因为up和hole边界面的牵引力为零，因此边界牵引力和压力设为零，而right边界面的牵引力应该设为 :code:`(1e4 0 0)` ，压力设为零：

.. code-block:: C

    boundaryField
    {
        left
        {
            type            symmetryPlane;
        }
        right
        {
            type            tractionDisplacement;
            traction        uniform (10000 0 0);
            pressure        uniform 0;
            value           uniform (0 0 0);
        }
        down
        {
            type            symmetryPlane;
        }
        up
        {
            type            tractionDisplacement;
            traction        uniform (0 0 0);
            pressure        uniform 0;
            value           uniform (0 0 0);
        }
        hole
        {
            type            tractionDisplacement;
            traction        uniform (0 0 0);
            pressure        uniform 0;
            value           uniform (0 0 0);
        }
        frontAndBack
        {
            type            empty;
        }
    }


接下来进入 :code:`constant/physicalProperties` 设置物理特性。在本算例中，我们需要指定钢材料的物理特性，包括密度为 :math:`7854~\mathrm{kg/m^{3}}` ，杨氏模量为 :math:`2\times10^{11}\mathrm{Pa}` ，泊松比为 :math:`0.3` 。 :code:`solidDisplacementFoam` 求解器也可以计算温度场，因此可以求解和动量方程耦合（通过生成的热应力来耦合）在一起的热物理方程，如果需要的话就需要额外指定热物理特性如热容、热导和热膨胀系数。当然，在本算例中我们不求解热物理方程，因此设定 :code:`planeStress     yes;` 而 :code:`thermalStress   no;` 。下面是各物理特性参数的设置：

.. code-block:: C

    rho
    {
        type        uniform;
        value       7854;
    }

    nu
    {
        type        uniform;
        value       0.3;
    }

    E
    {
        type        uniform;
        value       2e+11;
    }

    Cp
    {
        type        uniform;
        value       434;
    }

    kappa
    {
        type        uniform;
        value       60.5;
    }

    alphav
    {
        type        uniform;
        value       1.1e-05;
    }


接下来进入controlDict进行求解的控制设定。由于这是一个稳态问题，因此时间步无关紧要，方便起见设定时间步长 :code:`deltaT` 为 :code:`1` 。在稳态问题中，时间步也就表示了迭代步。终止时间 :code:`endTime` 设定为 :code:`100` ，即最高迭代次数。写入控制 :code:`writeInterval` 设定为 :code:`20` ：

.. code-block:: C

    application     solidDisplacementFoam;

    startFrom       startTime;

    startTime       0;

    stopAt          endTime;

    endTime         100;

    deltaT          1;

    writeControl    timeStep;

    writeInterval   20;

    purgeWrite      0;

    writeFormat     ascii;

    writePrecision  6;

    writeCompression off;

    timeFormat      general;

    timePrecision   6;

    graphFormat     raw;

    runTimeModifiable true;



接下来进入fvSchemes字典文件进行离散格式设置和求解器控制。本算例分析的是一个稳态问题，因此 :code:`timeScheme` 的时间离散里面选择 :code:`SteadyState` ，这样就屏蔽了时间离散项。应力分析的动量方程包含几个含有位移梯度量的显性项。梯度项计算的精确性和光滑性对结果有着很大影响，一般情况下有限体积离散建立于高斯定律之上，高斯定律对于大部分的模拟也是足够精确的。不过在本算例中，我们使用最小二乘法，该方法对网格质量较差的情况能更好地计算梯度，因此需要修改 :code:`gradSchemes` 关键词下的 :code:`grad(U)` 和 :code:`grad(T)` 改用 :code:`leastSquares` 关键词：

.. code-block:: C

    d2dt2Schemes
    {
        default         steadyState;
    }

    ddtSchemes
    {
        default         Euler;
    }

    gradSchemes
    {
        default         leastSquares;
        grad(D)         leastSquares;
        grad(T)         leastSquares;
    }

    divSchemes
    {
        default         none;
        div(sigmaD)     Gauss linear;
    }

    laplacianSchemes
    {
        default         none;
        laplacian(DD,D) Gauss linear corrected;
        laplacian(kappa,T) Gauss linear corrected;
    }

    interpolationSchemes
    {
        default         linear;
    }

    snGradSchemes
    {
        default         none;
    }



接下来进入fvSolution设置求解线性方程组使用的矩阵求解器。可以看到， :math:`D` 的矩阵求解器为GAMG，是多重网格矩阵求解法；求解器的 :code:`tolerance` 为 :math:`10^{-6}` ；矩阵求解器的相对误差由 :code:`relTol` 控制，用于控制每次迭代的残差减少量。在本算例中，由于方程式中很多项是显性的，并且采用分离迭代求解技术，因此迭代残差设置地太小是不经济的，合理的迭代残差为0.01，在本算例中甚至可以更高设置为0.9。在 :code:`stressAnalysis` 关键词中包含了该求解器所需的控制参数，其中 :code:`nCorrectors` 表示整个方程组求解的外循环数，包括每个时间步的拉伸边界条件。由于这是个稳态问题，我们用时间步代表迭代数，因此可以设置 :code:`nCorrectors` 为1；同时还需要设置求解变量的外循环收敛残差，当达到该值的时候迭代停止，在本算例中我们设置为 :math:`10^{-6}` ：

.. code-block:: C

    solvers
    {
        "(D|T)"
        {
            solver          GAMG;
            tolerance       1e-06;
            relTol          0.9;
            smoother        GaussSeidel;
            nCellsInCoarsestLevel 20;
        }
    }

    stressAnalysis
    {
        compactNormalStress yes;
        nCorrectors     1;
        D               1e-06;
    }


接下来就可以开始运行算例。应该在log文件中查看收敛信息，它包括了迭代数、每步迭代的初始残差和最终残差。根据之前的设定，最终残差应该总是小于最初残差的0.9倍，一旦初始残差小于收敛残差 :math:`10^{-6}` 的时候程序收敛，就可以终止程序：

.. code-block:: 

    solidDisplacementFoam > log &


求解器求解出来的对称张量应力场为sigma，通过 :code:`postProcess` 可以求出该张量的分量，如此每个时间步内就会得到sigmaxx,sigmaxy,sigmaxz,sigmayy,sigmayz,sigmazz分量文件。

.. code-block:: 

    postProcess -func 'components(sigma)'


如果要把计算域中对称面的左边的数据输出出来，可以通过 :code:`postProcess` 使用 :code:`graphUniform` 函数来获得。在此之前，需要 :code:`system/graphUniform` 文件来进行设置。该函数能够提取指定线段中的数据，分别需要设定起始点、终止点和采样点个数，需要提取的场在 :code:`fields` 关键词处指定，而输出坐标点也可以通过 :code:`axis` 关键词来指定，可以指定为x,y,z,xyz四种类型：

.. code-block:: C

    start           (0 0.5 0.25);
    end             (0 2 0.25);
    nPoints         100;

    fields          (sigmaxx);

    axis            y;

    #includeEtc "caseDicts/postProcessing/graphs/graphUniform.cfg"


接下来就可以执行下面的命令来提取数据：

.. code-block:: 

    postProcess -func 'graphUniform'

之后就得到了 :code:`postProcessing/graphUniform` 文件夹，每个时间文件内都包含了指定线段范围处场的数据集，可以导出到其他软件与其他数据配合或进行后处理绘制成图。



damBreak算例
---------------

简化的二维溃坝问题 :code:`tutorial/multiphase/interFoam/laminar/damBreak` 将使用 :code:`interFoam` 来进行求解。该问题为两种液体被一种尖锐的界面（或者自由表面）分隔的瞬态流动。 :code:`interFoam` 中的两相算法基于流体的体积分数法(VOF)，在该方法中，每个网格中的相体积分数（或相分数 :code:`alpha` ）通过求解一个组分输运方程确定。物理属性则基于这个相分数通过加权平均计算。在VOF方法中，组分间的界面不是计算出来的，而是作为相分数场的一个属性表现出来，这个界面需要通过后处理得到。由于相分数可以为0到1之间的任何值，所以相界面并没有被严格定义，因此相界面表示它应存在的那些网格单元。

本算例的物理过程如下：设置为一个静止的水柱，使其位于水箱左侧，在水箱的底部有一个小的障碍，在 :math:`t=0~\mathrm{s}` 时让水柱自由流动发生水柱崩塌。在崩塌过程中，水撞击水箱底部的一个障碍形成复杂的流场结构，其中包括若干被水包裹的气泡。几何场与网格设置如图所示。


.. figure:: ../_images/openFOAM/溃坝的几何场与网格划分.png
  :align: center

*Figure 溃坝的几何场与网格划分*


进入 :code:`system/blockMeshDict` 查看网格信息，可以看到通过 :code:`convertToMeters` 关键词设置了倍数0.146，从而让记录点坐标的时候能有更多整数。在本2D算例中，里面没有在边界中指定 :code:`frontAndBack` 来描述上下面，而是使用了 :code:`defaultPatch` 关键词来给定，这样在生成 :code:`polyMesh/boundary` 后会自动添加 :code:`defaultFaces` ，并且类型为 :code:`empty` 。对于作为水坝壁面的leftWall,rightWall,lowerWall，他们的类型应该设定为 :code:`wall` ；而上边界为了允许流动的出入，可以只简单地指定为 :code:`patch` 类型。设置完成后可以直接运行 :code:`blockMesh` 生成网格文件。


.. note:: 边界面设定为壁面类型 :code:`wall` 时可以在后续应用壁面函数模型或者其他有关壁面的模型。例如在 :code:`interFoam` 求解器中，可以壁面依附模型来附加壁面表面张力的影响。该模型通过将 :code:`alpha` 场的边界条件设置为 :code:`constantAlphaContactAngle` 来实现。如果要使用这个边界条件，必须给出关键词静态接触角 :code:`theta0` 的值。



.. code-block:: C

    convertToMeters 0.146;

    vertices
    (
        (0 0 0)                // 0
        (2 0 0)                // 1
        (2.16438 0 0)          // 2
        (4 0 0)                // 3
        (0 0.32876 0)          // 4
        (2 0.32876 0)          // 5
        (2.16438 0.32876 0)    // 6
        (4 0.32876 0)          // 7
        (0 4 0)                // 8
        (2 4 0)                // 9
        (2.16438 4 0)          // 10
        (4 4 0)                // 11
        // 下面是第二层顶点，设置了高度为0.1
        (0 0 0.1)              // 12
        (2 0 0.1)              // 13
        (2.16438 0 0.1)        // 14
        (4 0 0.1)              // 15
        (0 0.32876 0.1)        // 16
        (2 0.32876 0.1)        // 17
        (2.16438 0.32876 0.1)  // 18
        (4 0.32876 0.1)        // 19
        (0 4 0.1)              // 20
        (2 4 0.1)              // 21
        (2.16438 4 0.1)        // 22
        (4 4 0.1)              // 23
    );

    blocks
    (
        hex (0 1 5 4 12 13 17 16) (23 8 1) simpleGrading (1 1 1)
        hex (2 3 7 6 14 15 19 18) (19 8 1) simpleGrading (1 1 1)
        hex (4 5 9 8 16 17 21 20) (23 42 1) simpleGrading (1 1 1)
        hex (5 6 10 9 17 18 22 21) (4 42 1) simpleGrading (1 1 1)
        hex (6 7 11 10 18 19 23 22) (19 42 1) simpleGrading (1 1 1)
    );

    defaultPatch
    {
        type empty;
    }

    boundary
    (
        leftWall
        {
            type wall;
            faces
            (
                (0 12 16 4)
                (4 16 20 8)
            );
        }
        rightWall
        {
            type wall;
            faces
            (
                (7 19 15 3)
                (11 23 19 7)
            );
        }
        lowerWall
        {
            type wall;
            faces
            (
                (0 1 13 12)
                (1 5 17 13)
                (5 6 18 17)
                (2 14 18 6)
                (2 3 15 14)
            );
        }
        atmosphere
        {
            type patch;
            faces
            (
                (8 20 21 9)
                (9 21 22 10)
                (10 22 23 11)
            );
        }
    );


在本算例中，我们将忽略界面和壁面间的表面张力效应，这可以使用 :code:`constantAlphaContactAngle` 边界条件并设定静态接触角 :math:`\theta=90` 来实现，不过这里我们直接设定 :code:`alpha` 的边界条件为 :code:`zeroGradient` 来实现该效果。

本算例上边界与大气环境自由相通，允许流动的出入，因此 :code:`atmosphere` 界面需要设定边界基础类型为 :code:`patch` 类型，并针对不同的物理量设置不同的边界数值类型：

+--------+-----------------------------+----------------------------------------------------------------------------------+
| 物理量 | 数值类型                    | 含义                                                                             |
+========+=============================+==================================================================================+
| 压力   | totalPressure               | 一种fixedValue条件，利用指定的总压p0和局部速度U来计算得到                        |
+--------+-----------------------------+----------------------------------------------------------------------------------+
| 速度   | pressureInletOutletVelocity | 对所有分量应用zeroGradient条件；当流动为入流是，对边界切向分量应用fixedValue条件 |
+--------+-----------------------------+----------------------------------------------------------------------------------+
| 相分数 | inletOutlet                 | 出流时为zeroGradient条件，入流时则为fixedValue条件                               |
+--------+-----------------------------+----------------------------------------------------------------------------------+

不过在本例中，使用p_rgh场作为初始场而不是p场，所以在所有边界处采用fixedFluxPressure边界条件，且上述的totalPressure类型也要更改为prghTotalPressure。在某些包含重力以及表面张力的求解器中，fixedFluxPressure边界条件能够调节压力梯度以使得边界的通量和速度边界条件相匹配。


下面需要为相分数 :math:`\alpha_{\text{water}}` 指定一个非均匀条件以区分水和空气。两相问题一般区分为1和0两个值，而区域的赋值需要通过setFields实现，因此需要书写system/setFieldsDict字典。在本例中setFieldsDict文件的核心内容为：

.. code-block:: C

    defaultFieldValues
    (
        volScalarFieldValue alpha.water 0
    );

    regions
    (
        boxToCell
        {
            box (0 0 -1) (0.1461 0.292 1);
            fieldValues
            (
                volScalarFieldValue alpha.water 1
            );
        }
    );


其中defaultFieldValues关键词用来设置场的默认值，这个值将会在下面的regions关键词指定的区域以外使用。在regions关键词中，boxToCell通过定义一个最小和最大的矢量来创建一个方块区域，在此区域为水相，即设定值为1。

.. attention:: 

    setFields从文件中读取场并重新定义这些场，然后把它们写入文件，原始的文件将会被覆盖，因此建议在执行setFields前先进行备份。OpenFOAM中通过在原文件名字后面加上 :code:`.orig` 来表示备份文件。



设置完成后就可以在算例目录终端中输入：

.. code-block:: 

    setFields



接下来设置物质特性(物理常量)。对于两相问题，需要在constant文件夹内设置各相物质的physicalProperties以及两相物性phaseProperties，在本例中就需要有physicalProperties.water，physicalProperties.air和phaseProperties三个文件来进行描述。本例中涉及到的物性参数有：

+----------------+------------------------------------+--------+----------------------------+
| 物理量         | 单位                               | 关键词 | 值                         |
+================+====================================+========+============================+
| 水的运动粘度   | :math:`\mathrm{m^{2}\cdot s^{-1}}` | nu     | :math:`1.0\times 10^{-6}`  |
+----------------+------------------------------------+--------+----------------------------+
| 水的密度       | :math:`\mathrm{kg/m^{3}}`          | rho    | :math:`1.0\times 10^{3}`   |
+----------------+------------------------------------+--------+----------------------------+
| 空气的运动粘度 | :math:`\mathrm{m^{2}\cdot s^{-1}}` | nu     | :math:`1.48\times 10^{-5}` |
+----------------+------------------------------------+--------+----------------------------+
| 空气的密度     | :math:`\mathrm{kg/m^{3}}`          | rho    | :math:`1.0`                |
+----------------+------------------------------------+--------+----------------------------+
| 两相表面张力   | :math:`\mathrm{N/m}`               | sigma  | :math:`0.7`                |
+----------------+------------------------------------+--------+----------------------------+

因此三个文件应当如下进行书写：

.. code-block:: C

    FoamFile
    {
        format      ascii;
        class       dictionary;
        location    "constant";
        object      physicalProperties.water;
    }
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    viscosityModel  constant;

    nu              1e-06;

    rho             1000;


.. code-block:: C

    FoamFile
    {
        format      ascii;
        class       dictionary;
        location    "constant";
        object      physicalProperties.air;
    }
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    viscosityModel  constant;

    nu              1.48e-05;

    rho             1;


.. code-block:: C

    FoamFile
    {
        format      ascii;
        class       dictionary;
        location    "constant";
        object      phaseProperties;
    }
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    phases          (water air);

    sigma           0.07;



重力加速度g在真个求解域内统一分布，因此也属于constant文件件内需要设置的内容。与普通的场文件不同，g是uniformDimensionedVectorField类型，因此只需要指定dimensions关键词和value关键词，本例中的书写方式如下：

.. code-block:: C

    FoamFile
    {
        format      ascii;
        class       uniformDimensionedVectorField;
        location    "constant";
        object      g;
    }
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    dimensions      [0 1 -2 0 0 0 0];
    value           (0 -9.81 0);

在constant文件夹内还需要有动量传递文件momentumTransport，在本例中不求解湍流模型，因此simulationType设置为laminar。




与标准流体算法相比，表面追踪算法对库朗数更加敏感。如果采用显性MULES算法，在界面区域库朗数不应该超过上限如0.25；如果在MULESCorr中指定采用半隐型MULES算法，理论上库朗数对相方程求解没有影响，因此库朗数只取决于时间精度。

对于速度容易预测的算例，最好直接指定一个满足库朗数要求的固定时间步长，但这对于复杂的算例来说相当困难。因此，interFoam求解器在controlDict中提供了自动调整时间步长的方法。需要指定adjustTimeStep为yes，设置writeControl为adjustableRunTime，并设置最大库朗数maxCo和最大相场库朗数maxAlphaCo为1.0；时间步长的上限maxDeltaT可以设置为一个不会超过的值，比如1.0。如此就可以在给定的deltaT基础上，根据情况自动缩小时间步长以满足库朗数要求，而给定writeInterval一个具体数值将会强制要求调节时间步长以达到对应时间进行输出。


.. attention:: 在tutorial提供的controlDict中，设置了writeFormat为binary，这对于巨量数据的情况是有益于提升读取速度的；但是如果希望便于查看文件，则修改writeFormat为ascii。



interFoam求解器在求解相场的时候采用了MULES方法，可以保证在任何数值格式、网格类型的情况下的相场有界，因此在使用interFoam求解器时，对流项格式的选择不再局限于如迎风格式的稳定且有界的格式。

对流项格式设置在fvSchemes文件中的divSchemes关键词中。在本例中，动量方程的对流项为 :math:`\nabla \cdot (\rho \boldsymbol{U}\boldsymbol{U})` ，书写为 :code:`div(rhophi, U)` ，这里使用 :code:`Gauss linearUpwind grad(U)` 以实现良好的精度。 :math:`\nabla \cdot (\boldsymbol{U}\alpha_{l})` 书写为 :code:`div(phi, alpha)` ，采用 :code:`vanLeer` 格式，通常情况下有界线性格式需要一个系数，这里设置该系数为1.0来实现最好的稳定性。其他离散项采用常用的格式，因此fvSchemes文件中的核心内容如下：

.. code-block:: C

    ddtSchemes
    {
        default         Euler;
    }

    gradSchemes
    {
        default         Gauss linear;
    }

    divSchemes
    {
        div(rhoPhi,U)  Gauss linearUpwind grad(U);
        div(phi,alpha)  Gauss interfaceCompression vanLeer 1;
        div(((rho*nuEff)*dev2(T(grad(U))))) Gauss linear;
    }

    laplacianSchemes
    {
        default         Gauss linear corrected;
    }

    interpolationSchemes
    {
        default         linear;
    }

    snGradSchemes
    {
        default         corrected;
    }



fvSolution文件控制矩阵求解器，其中的alpha.water子字典中包含了interFoam特定的一些参数。nAlphaCorr代表的是 :math:`\alpha_{l}` 通量修正的次数；nAlphaSubCycles代表的是将每个时间步长均分成对应个数的子步长，循环后加和；MULESCorr即Weller所提出的MULES修正，一般设置为yes；cAlpha是一个控制界面压缩的因子，0相当于无压缩，1相当于守恒压缩，大于1的数表示强化界面压缩，一般取1。本算例的fvSolution文件的核心内容如下：

.. code-block:: C

    solvers
    {
        "alpha.water.*"
        {
            nAlphaCorr      2;
            nAlphaSubCycles 1;
            cAlpha          1;
            
            MULESCorr       yes;
            nLimiterIter    5;
            
            solver          smoothSolver;
            smoother        symGaussSeidel;
            tolerance       1e-8;
            relTol          0;
        }

        "pcorr.*"
        {
            solver          PCG;
            preconditioner  DIC;
            tolerance       1e-5;
            relTol          0;
        }

        p_rgh
        {
            solver          PCG;
            preconditioner  DIC;
            tolerance       1e-07;
            relTol          0.05;
        }

        p_rghFinal
        {
            $p_rgh;
            relTol          0;
        }

        U
        {
            solver          smoothSolver;
            smoother        symGaussSeidel;
            tolerance       1e-06;
            relTol          0;
        }
    }

    PIMPLE
    {
        momentumPredictor   no;
        nOuterCorrectors    1;
        nCorrectors         3;
        nNonOrthogonalCorrectors 0;
    }

    relaxationFactors
    {
        equations
        {
            ".*" 1;
        }
    }


完成后就可以开始运行算例。可以采用tee命令来让程序交互式地运行，同时在终端输出结果并备份输出到文件log：

.. code-block:: 

    interFoam | tee log



damBreakFine算例
-----------------

下面增加damBreak算例的网格数量，并采用多核运算来减少运行时间。首先复制damBreak算例改名为damBreakFine，然后进入system/blockMeshDict修改blocks关键词内容：

.. code-block:: C

    blocks
    (
        hex (0 1 5 4 12 13 17 16) (46 10 1) simpleGrading (1 1 1)
        hex (2 3 7 6 14 15 19 18) (40 10 1) simpleGrading (1 1 1)
        hex (4 5 9 8 16 17 21 20) (46 76 1) simpleGrading (1 2 1)
        hex (5 6 10 9 17 18 22 21) (4 76 1) simpleGrading (1 2 1)
        hex (6 7 11 10 18 19 23 22) (40 76 1) simpleGrading (1 2 1)
    );

运行blockMesh重新生成网格，此时由于网格发生了变化，通过mapFields映射场可能会在界面处产生插值，并且已有的0/alpha.water.gz文件中的网格编号与新生成的网格不相符，因此需要删除该文件并重新运行setFields

OpenFOAM使用区域分解法进行并行计算。在该方法中，几何和相关的场被分割为若干部分并被分配到不同的处理器进行求解。因此，并行运算一个算例的第一步是利用decomposePar分解求解域，所以需要设置decomposeParDict文件。

numberOfSubdomains指定了要将算例分割成为子区域的数量，通常与可用于运算此算例的处理器数一致。本例中，区域分割的方法method选择simple，其对应的simpleCoeffs通过矢量n给定，其分量决定xyz方向分割求解域的个数，必须满足 :math:`n_{x}\times n_{y} \times n_{z}=\text{numberOfSubdomains}` 。最好使每个子区域的网格连接面数量最少。本算例是二维的，因此z方向不能被分割， :math:`n_{z}` 必须设置为1。本例中decomposeParDict文件书写为：

.. code-block:: C

    FoamFile
    {
        format      ascii;
        class       dictionary;
        location    "system";
        object      decomposeParDict;
    }
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    numberOfSubdomains 4;

    method          simple;

    simpleCoeffs
    {
        n               (2 2 1);
    }

    hierarchicalCoeffs
    {
        n               (1 1 1);
        order           xyz;
    }

    manualCoeffs
    {
        dataFile        "";
    }

    distributed     no;

    roots           ( );


完成后就可以在算例目录终端下输入下面的命令对网格进行分解：

.. code-block:: 

    decomposePar

本例中使用openMPI来进行并行运算：

.. code-block:: 

    mpirun -np 4 interFoam -parallel > log &

算例运行结束之后，需要使用reconstructPar命令来将分割后的场和网格重新合并起来。也可以单独对分割后的求解域的一部分进行后处理，例如

.. code-block:: 

    paraFoam -case processor1





cylinder算例
--------------

下面使用potentialFoam来研究圆柱势流(potential flow)，该求解器假设流场不可压缩、无旋无黏、稳态且忽略重力。控制方程有两个：不可压缩流体的质量守恒方程

.. math::
    \begin{align}
    \nabla \cdot \boldsymbol{U}=0
    \end{align}

不可压缩无旋场的稳态压力方程

.. math::
    \begin{align}
    \nabla ^{2}p=0
    \end{align}


.. note:: 

    potentialFoam求解器能够为其他问题提供符合质量守恒方程的初始场，在运行算例之前首先运行势流求解器可以大大加快收敛且增加求解稳定性。





复制算例tutorials/basic/potentialFoam/cylinder。在这个算例中，圆柱是对称的，所以计算域只取上半部分。左边界是入口Inlet，右边界是出口Outlet，下边界和圆柱边界为symmetryPlane，而上边界我们假设计算域在y方向上无穷大，垂直于上边界的速度梯度特别小，因此上边界选择垂直于上边界速度梯度为0的边界条件，即symmetryPlane。运行blockMesh得到网格。

在本算例中，我们不需要设置流体的性质，因为整个流体是不可压缩、无旋、无黏的。在system/controlDict中记录算例运行的参数，而由于我们处理的是稳态问题，所以算例只应该运行一个时间步。

potentialFoam通过迭代来求解压力方程，并且可以对压力方程中的拉普拉斯项进行非正交修正(压力方程中的显式项会在正交修正迭代之后进行更新)。对压力方程的非正交修正迭代次数由fvSolution当中potentialFlow字典的nNonOrthogonalCorrectors关键字来决定。可以明显观察到nNonOrthogonalCorrectors设置为0或3时结果的不同，非正交修正能够使结果与理论解更加相近。

直接运行potentialFoam的时候只会计算U和phi，额外添加控制语句可以输出其他内容：

.. code-block:: 

    potentialFoam -withFunctionObjects -writePhi -writep





pitzDaily算例
------------------

在tutorials/incompressible/simpleFoam/pitzDaily算例中，计算域是一个二维的、由一个窄的入口、一个后向台阶、一个在出口处收缩的喷管组成。simpleFoam求解器的控制方程有两个：不可压缩流体的质量守恒方程

.. math::
    \begin{align}
    \nabla \cdot \boldsymbol{U} = 0
    \end{align}

稳态动量方程

.. math::
    \begin{align}
    \nabla \cdot (\boldsymbol{U}\boldsymbol{U}) + \nabla \cdot \boldsymbol{R} = -\nabla p
    \end{align}

其中 :math:`p` 是动压， :math:`\boldsymbol{R} = \nu_{\text{eff}} \nabla \boldsymbol{U}` 是带有有效动力粘度系数 :math:`\nu_{\text{eff}}` 的粘性力项。 :math:`\nu_{\text{eff}}` 是通过传递模型和湍流模型计算得到的。初始条件 :math:`\boldsymbol{U}=0~\mathrm{m/s}` 、 :math:`p=0~\mathrm{Pa}` ，进口为固定速度入口， :math:`\boldsymbol{U}=(10,0,0)~\mathrm{m/s}` ，出口为固定压力出口 :math:`p=0~\mathrm{Pa}` ，其他边界都是非滑移边界。空气的运动粘度系数为

.. math::
    \begin{align}
    \nu = \frac{\mu}{\rho} = 18.1 \times 10^{-6} / 1.293 = 14.0 ~\mu\mathrm{m^{2}/s}
    \end{align}

湍流模型选用标准 :math:`k-\epsilon` 模型，常数分别为 :math:`C_{\mu} = 0.09` ； :math:`C_{1}=1.44` ； :math:`C_{2}=1.92` ； :math:`\alpha_{k}=1` ； :math:`\alpha_{\varepsilon}=0.76923` 。

.. note:: 

    simpleFoam利用SIMPLE格式来求解稳态不可压缩流体的问题。这个求解器可以使用incompressibleTurbulenceModel库中所有的湍流模式以及incompressibleTransportModel库中的所有牛顿以及非牛顿流体模型。

一般来说，剪切应力(速度梯度)大的区域网格细化尤其重要，这些区域的网格需要比其他剪切应力较其他剪切应力较低的区域更细。在进行求解之前，我们可以提前估计一下在哪些地方容易出现大的剪切应力。在入口处有一个沿着x方向的稳态流动，在流体经过台阶时，这个稳态流动和下方静止的流体之间会产生一个剪切应力，并且在计算域的下半部分产生漩涡，因此剪切应力比较大的区域应该在计算域的中心线附近和靠近壁面的地方。

在本算例中，需要为速度 :math:`\boldsymbol{U}` 、压力 :math:`p` 、湍流动能 :math:`k` 和耗散率 :math:`\varepsilon` 设置边界条件和初始条件。上下边界设置为wall，左边界设置为Inlet，右边界设置为Outlet，这样的边界组合需要在入口处设定 :math:`U` 、 :math:`k` 、 :math:`\varepsilon` 的类型为fixedValue。

:math:`k` 和 :math:`\varepsilon` 的值如下进行计算：假设入口湍流是各向同性，而且入口处的速度波动为 :math:`5\%` 则有

.. math::
    \begin{align}
    U_{x}' = U_{y}' = U_{z}' = \frac{5}{100} \times 10 = 0.5 ~\mathrm{m/s}
    \end{align}

且有

.. math::
    \begin{align}
    k = 1.5 \times (0.5)^{2} = 0.375 ~\mathrm{m^{2}/s^{2}}
    \end{align}

如果假定湍流尺度为入口边界长度的十分之一则有

.. math::
    \begin{align}
    \varepsilon = \frac{C_{\mu}^{0.75}k^{1.5}}{l} = \frac{0.09^{0.75} \times 0.375^{1.5}}{0.1 \times 25.4 \times 10^{-3}} = 14855 ~\mathrm{m^{2}/s^{2}}
    \end{align}

在出口处只需要将 :math:`p` 设置为 :math:`0~\mathrm{Pa}` 。




forwardStep算例
-----------------

本算例将探究前向台阶的超音速绕流，入口速度马赫数为3，在入口附近有一个台阶，在台阶附近会产生激波。复制tutorials/compressible/rhoCentralFoam/forwardStep算例，将使用rhoCentralFoam求解器进行计算。控制方程有四个，分别是质量守恒方程：

.. math::
    \begin{align}
    \frac{\partial \rho}{\partial t} + \nabla \cdot (\rho \boldsymbol{U}) = 0 
    \end{align}

理想气体状态方程：

.. math::
    \begin{align}
    p = \rho RT
    \end{align}


牛顿流体的动量守恒方程：

.. math::
    \begin{align}
    \frac{\partial \rho \boldsymbol{U}}{\partial t} + \nabla \cdot (\rho \boldsymbol{U}\boldsymbol{U}) - \nabla \cdot \mu \nabla \boldsymbol{U} = -\nabla p 
    \end{align}

能量方程(忽略粘性项)和傅里叶定律：

.. math::
    \begin{align}
    & \frac{\partial \rho e}{\partial t} + \nabla \cdot (\rho \boldsymbol{U}e) - \nabla \cdot \frac{k}{c_{\nu}} \nabla e = -p \nabla \cdot \boldsymbol{U}  \\
    & e = C_{\nu} T \\
    & q = -k\nabla T
    \end{align}


算例的初始条件为： :math:`U = 1~\mathrm{m/s}` ， :math:`p = 1~\mathrm{Pa}` ， :math:`T = 1~\mathrm{K}` 。


在physicalProperties文件中，可以看到模型的设置情况：

.. code-block:: C

    thermoType
    {
        type            hePsiThermo;    // 基于密度计算
        mixture         pureMixture;    
        transport       const;          // 拥有固定的动力黏度和热导热系数(普朗特数)
        thermo          hConst;         // 拥有固定的定压比热容
        equationOfState perfectGas;     // 理想气体
        specie          specie;
        energy          sensibleInternalEnergy;   // 以焓作为能量方程的变量
    }

    mixture
    {
        specie
        {
            molWeight       11640.3;    // 物质的摩尔质量g/mol
        }
        thermodynamics
        {
            Cp              2.5;
            Hf              0;
        }
        transport
        {
            mu              0;          // 动力粘度
            Pr              1;          // 普朗特数
        }
    }



自建案例
==========

离心机内取料支臂附近流场二维模拟
-----------------------------------

该模拟属于超音速可压缩流模拟，因此使用的求解器为rhoCentralFoam。

网格划分
^^^^^^^^^^^

圆柱障碍外形的网格划分使用下面的代码获得基础几何面：

.. code-block:: python

    import math

    import salome
    salome.salome_init()
    import GEOM
    from salome.geom import geomBuilder
    geompy = geomBuilder.New()

    gg = salome.ImportComponentGUI("GEOM")


    radius = 3.5 * 1e-3
    leftRate = 30
    updownRate = 30
    rightRate = 50

    # create circle face
    p0 = geompy.MakeVertex(0.0, 0.0, 0.0)
    p1 = geompy.MakeVertex(0.0, 0.0, 0.01)
    v_normal = geompy.MakeVector(p0, p1)
    circle = geompy.MakeCircle(p0, v_normal, radius)
    circleFace = geompy.MakeFace(circle, True)
    geompy.addToStudy(circleFace, "circleFace")

    # create rectangle face
    p2 = geompy.MakeVertex(-leftRate * radius, updownRate * radius, 0.0)    # left-up corner
    p3 = geompy.MakeVertex(-leftRate * radius, -updownRate * radius, 0.0)   # left_down corner
    p4 = geompy.MakeVertex(rightRate * radius, updownRate * radius, 0.0)     # right_up corner
    p5 = geompy.MakeVertex(rightRate * radius, -updownRate * radius, 0.0)    # right-down corner
    edge1 = geompy.MakeEdge(p2, p3)
    edge2 = geompy.MakeEdge(p2, p4)
    edge3 = geompy.MakeEdge(p5, p3)
    edge4 = geompy.MakeEdge(p5, p4)
    wire1 = geompy.MakeWire([edge1, edge2, edge3, edge4])
    rectangleFace = geompy.MakeFace(wire1, True)
    geompy.addToStudy(rectangleFace, "rectangleFace")

    # cut the circle from rectangle
    base = geompy.MakeCut(rectangleFace, circleFace)
    geompy.addToStudy(base, "baseFace")



    # make partition for the base face
    p6 = geompy.MakeVertex(- leftRate * radius, 0.0, 0.0)
    p7 = geompy.MakeVertex(rightRate * radius, 0.0, 0.0)
    partitionTool1 = geompy.MakeEdge(p6, p7)

    p8 = geompy.MakeVertex(0.0, updownRate * radius, 0.0)
    p9 = geompy.MakeVertex(0.0, - updownRate * radius, 0.0)
    partitionTool2 = geompy.MakeEdge(p8, p9)

    partitionTool3 = geompy.MakeCircle(p0, v_normal, 3 * radius)

    p10 = geompy.MakeVertex(- 0.7 * 3 * radius, updownRate * radius, 0.0)
    p11 = geompy.MakeVertex(- 0.7 * 3 * radius, - updownRate * radius, 0.0)
    partitionTool4 = geompy.MakeEdge(p10, p11)

    p12 = geompy.MakeVertex(0.7 * 3 * radius, updownRate * radius, 0.0)
    p13 = geompy.MakeVertex(0.7 * 3 * radius, - updownRate * radius, 0.0)
    partitionTool5 = geompy.MakeEdge(p12, p13)

    partitionBase = geompy.MakePartition([base], [partitionTool1, partitionTool2, partitionTool3, partitionTool4, partitionTool5])
    geompy.addToStudy(partitionBase, "partitionBase")


在创建主要网格的时候，3D设置使用Hexahedron(i,j,k)算法生成六面体网格，并为圆柱面添加边界层：

- Total thickness：0.0006
- Number of layers：5
- Stretch factor：1.3

2D设置使用Quadrangle:Mapping，1D设置使用Wire Discretisation并设置Number of Segments为15，且采用Equidistant distribution。

之后进一步创建subMesh：

- 对thicknessEdge创建subMesh，1D设置使用Wire Discretisation设置Number of Segments为1，且采用Equidistant distribution。添加Hypothesis为Propagation of 1D Hyp. on Opposite Edges。
- 对leftEdge1创建subMesh，1D设置使用Wire Discretisation设置Number of Segments为30，且采用Scale distrubution，Scale Factor使用0.05。添加Hypothesis为Propagation of 1D Hyp. on Opposite Edges。
- 对leftEdge2创建subMesh，1D设置使用Wire Discretisation设置Number of Segments为30，且采用Scale distrubution，Scale Factor使用20。添加Hypothesis为Propagation of 1D Hyp. on Opposite Edges。
- 对sideEdge1创建subMesh，1D设置使用Wire Discretisation设置Number of Segments为50，且采用Scale distrubution，Scale Factor使用5。添加Hypothesis为Propagation of 1D Hyp. on Opposite Edges。
- 对sideEdge2创建subMesh，1D设置使用Wire Discretisation设置Number of Segments为50，且采用Scale distrubution，Scale Factor使用0.05。添加Hypothesis为Propagation of 1D Hyp. on Opposite Edges。
- 对radius创建subMesh，1D设置使用Wire Discretisation设置Number of Segments为15，且采用Scale distrubution，Scale Factor使用3。添加Hypothesis为Propagation of 1D Hyp. on Opposite Edges。
- 对boundaryEdge1创建subMesh，1D设置使用Wire Discretisation设置Number of Segments为5，且采用Scale distrubution，Scale Factor使用5。添加Hypothesis为Propagation of 1D Hyp. on Opposite Edges。
- 对boundaryEdge2创建subMesh，1D设置使用Wire Discretisation设置Number of Segments为5，且采用Scale distrubution，Scale Factor使用0.2。添加Hypothesis为Propagation of 1D Hyp. on Opposite Edges。




对于较扁的障碍外形，通过下面的代码创建基础图形：

.. code-block:: python

    import math

    import salome
    salome.salome_init()
    import GEOM
    from salome.geom import geomBuilder
    geompy = geomBuilder.New()

    gg = salome.ImportComponentGUI("GEOM")


    length = 11.5 * 1e-3
    width = 4 * 1e-3
    leftRate = 30
    updownRate = 30
    rightRate = 50

    # create obstacle vertex
    obstacleVertex1 = geompy.MakeVertex(- length/2, 0.0, 0.0)
    obstacleVertex2 = geompy.MakeVertex(length/2, 0.0, 0.0)
    obstacleVertex3 = geompy.MakeVertex(0.0, width/2, 0.0)
    obstacleVertex4 = geompy.MakeVertex(0.0, - width/2, 0.0)
    upCurve = geompy.MakeInterpol([obstacleVertex1, obstacleVertex3, obstacleVertex2])
    downCurve = geompy.MakeInterpol([obstacleVertex1, obstacleVertex4, obstacleVertex2])
    wireObstacle = geompy.MakeWire([upCurve, downCurve])
    obstacleFace = geompy.MakeFace(wireObstacle, True)


    # create rectangle vertex
    rectangleVertex1 = geompy.MakeVertex(- length/2 * leftRate, width/2 * updownRate, 0.0)
    rectangleVertex2 = geompy.MakeVertex(- length/2 * leftRate, - width/2 * updownRate, 0.0)
    rectangleVertex3 = geompy.MakeVertex(length/2 * rightRate, width/2 * updownRate, 0.0)
    rectangleVertex4 = geompy.MakeVertex(length/2 * rightRate, - width/2 * updownRate, 0.0)
    edge1 = geompy.MakeEdge(rectangleVertex1, rectangleVertex2)
    edge2 = geompy.MakeEdge(rectangleVertex1, rectangleVertex3)
    edge3 = geompy.MakeEdge(rectangleVertex4, rectangleVertex3)
    edge4 = geompy.MakeEdge(rectangleVertex4, rectangleVertex2)
    rectangleWire = geompy.MakeWire([edge1,edge2,edge3,edge4])
    rectangleFace = geompy.MakeFace(rectangleWire, True)


    # create base face
    baseFace = geompy.MakeCut(rectangleFace, obstacleFace)
    geompy.addToStudy(baseFace, "baseFace")


    # create circle partition tool
    centerPoint = geompy.MakeVertex(0.0, 0.0, 0.0)
    zPoint = geompy.MakeVertex(0.0, 0.0, 1.0)
    vector_normal = geompy.MakeVector(centerPoint, zPoint)
    circlePartitionTool = geompy.MakeCircle(centerPoint, vector_normal, 3 * length/2)
    geompy.addToStudy(circlePartitionTool, "circlePartitionTool")
    geompy.addToStudy(centerPoint, "centerPoint")


    # create straight line partition tool
    leftCenterVertex = geompy.MakeVertex(- length/2 * leftRate, 0.0, 0.0)
    rightCenterVertex = geompy.MakeVertex(length/2 * rightRate, 0.0, 0.0)
    upCenterVertex = geompy.MakeVertex(0.0, width/2 * updownRate, 0.0)
    downCenterVertex = geompy.MakeVertex(0.0, - width/2 * updownRate, 0.0)
    xLinePartitionTool = geompy.MakeEdge(leftCenterVertex, rightCenterVertex)
    yLinePartitionTool = geompy.MakeEdge(upCenterVertex, downCenterVertex)
    geompy.addToStudy(xLinePartitionTool, "xLinePartitionTool")
    geompy.addToStudy(yLinePartitionTool, "yLinePartitionTool")

    tmpVertex1 = geompy.MakeVertex(- 0.7 * 3 * length/2, width/2 * updownRate, 0.0)
    tmpVertex2 = geompy.MakeVertex(- 0.7 * 3 * length/2, - width/2 * updownRate, 0.0)
    tmpLine1 = geompy.MakeEdge(tmpVertex1, tmpVertex2)
    tmpVertex3 = geompy.MakeVertex(0.7 * 3 * length/2, width/2 * updownRate, 0.0)
    tmpVertex4 = geompy.MakeVertex(0.7 * 3 * length/2, - width/2 * updownRate, 0.0)
    tmpLine2 = geompy.MakeEdge(tmpVertex3, tmpVertex4)


    # create temporary partition
    tmpPartition = geompy.MakePartition([baseFace], [circlePartitionTool, xLinePartitionTool, yLinePartitionTool, tmpLine1, tmpLine2])
    geompy.addToStudy(tmpPartition, "tmpPartition")



在创建主要网格的时候，3D设置使用Hexahedron(i,j,k)算法生成六面体网格，并为圆柱面添加边界层：

- Total thickness：0.0006
- Number of layers：5
- Stretch factor：1.3

2D设置使用Quadrangle:Mapping，1D设置使用Wire Discretisation并设置Number of Segments为15，且采用Equidistant distribution。

之后进一步创建subMesh：

- 对thicknessEdge创建subMesh，1D设置使用Wire Discretisation设置Number of Segments为1，且采用Equidistant distribution。添加Hypothesis为Propagation of 1D Hyp. on Opposite Edges。
- 对inletDownEdge创建subMesh，1D设置使用Wire Discretisation设置Number of Segments为30，且采用Scale distrubution，Scale Factor使用5。添加Hypothesis为Propagation of 1D Hyp. on Opposite Edges。
- 对inletUpEdge创建subMesh，1D设置使用Wire Discretisation设置Number of Segments为30，且采用Scale distrubution，Scale Factor使用0.2。添加Hypothesis为Propagation of 1D Hyp. on Opposite Edges。
- 对sideLeftEdge创建subMesh，1D设置使用Wire Discretisation设置Number of Segments为50，且采用Scale distrubution，Scale Factor使用10。添加Hypothesis为Propagation of 1D Hyp. on Opposite Edges。
- 对sideRightEdge创建subMesh，1D设置使用Wire Discretisation设置Number of Segments为50，且采用Scale distrubution，Scale Factor使用0.05。添加Hypothesis为Propagation of 1D Hyp. on Opposite Edges。
- 对radiusEdge创建subMesh，1D设置使用Wire Discretisation设置Number of Segments为25，且采用Scale distrubution，Scale Factor使用5。添加Hypothesis为Propagation of 1D Hyp. on Opposite Edges。




physicalProperties设置
^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

	thermoType
	{
	    type            hePsiThermo;
	    mixture         pureMixture;
	    transport       const;
	    thermo          hConst;
	    equationOfState perfectGas;    // 使用理想气体状态方程
	    specie          specie;
	    energy          sensibleInternalEnergy;    // 使用内能
	}

	UF6
	{
	    specie
	    {
	        molWeight       352;  // 摩尔质量g/mol
	    }
	    thermodynamics
	    {
	        Cp              385;  // J/(kg.K)
	        Hf              0;
	    }
	    transport
	    {
	        mu              1.83e-5;  // Pa.s
	        Pr              1.155;    // 普朗特数
	    }
	}


momentumTransport设置
^^^^^^^^^^^^^^^^^^^^^^^

为了在确定合适的边界条件的时候节省计算资源，先使用层流模型，即

.. code-block:: C

    simulationType  laminar;


边界条件和初始条件设置
^^^^^^^^^^^^^^^^^^^^^^^^^

对于温度初始值，认为算域内控制温度为 :math:`300~\mathrm{K}` 。

对于速度初始值，目标是要模拟马赫数为 :math:`5.7` 的情况，但是直接模拟太容易发散，所以首先考虑入口速度为 :math:`100~\mathrm{m/s}` 的情况，可以计算得到当前条件下的音速为 :math:`146.455~\mathrm{m/s}` ，因此此时马赫数为 :math:`0.68` ，属于亚音速情况。

对于压强初始值，考虑离心机半径 :math:`144~\mathrm{mm}` 处位置的压强，认为离心机半径为 :math:`150~\mathrm{mm}` ，离心机角速度 :math:`3500~\mathrm{rad/s}` ，控制离心机壁面压强为 :math:`100~\mathrm{torr}` （也即 :math:`13332~\mathrm{Pa}` ）。根据离心机压强半径公式可以计算得到算域压强初始条件应该设置为 :math:`2902~\mathrm{Pa}` 。

首先尝试使用下面的边界条件组合：

+--------------+--------------+--------------+--------------+
| patchName    | U            | p            | T            |
+==============+==============+==============+==============+
| inletFace    | fixedValue   | zeroGradient | fixedValue   |
+--------------+--------------+--------------+--------------+
| outletFace   | zeroGradient | zeroGradient | fixedValue   |
+--------------+--------------+--------------+--------------+
| rightFace    | zeroGradient | zeroGradient | fixedValue   |
+--------------+--------------+--------------+--------------+
| leftFace     | zeroGradient | zeroGradient | fixedValue   |
+--------------+--------------+--------------+--------------+
| cylinderFace | noSlip       | zeroGradient | zeroGradient |
+--------------+--------------+--------------+--------------+
| topFace      | empty        | empty        | empty        |
+--------------+--------------+--------------+--------------+
| downFace     | empty        | empty        | empty        |
+--------------+--------------+--------------+--------------+

上面的边界条件组合时，会出现温度场在outletFace处数值堆积，这一问题也影响到了密度场的结果，并且各个场在入口侧都会出现波前锋逆向接触inletFace然后发生快速数值反弹现象，如图所示：

.. figure:: ../_images/OpenFOAM算例运行案例/温度场固定值边界与压力场零梯度边界的耦合问题.png


为了解决温度场在outletFace处数值堆积的问题，尝试更换其固定值边界为自由流边界，即尝试使用下面的边界条件组合：

+--------------+--------------+--------------+--------------+
| patchName    | U            | p            | T            |
+==============+==============+==============+==============+
| inletFace    | fixedValue   | zeroGradient | fixedValue   |
+--------------+--------------+--------------+--------------+
| outletFace   | zeroGradient | zeroGradient | freestram    |
+--------------+--------------+--------------+--------------+
| rightFace    | zeroGradient | zeroGradient | freestram    |
+--------------+--------------+--------------+--------------+
| leftFace     | zeroGradient | zeroGradient | freestram    |
+--------------+--------------+--------------+--------------+
| cylinderFace | noSlip       | zeroGradient | zeroGradient |
+--------------+--------------+--------------+--------------+
| topFace      | empty        | empty        | empty        |
+--------------+--------------+--------------+--------------+
| downFace     | empty        | empty        | empty        |
+--------------+--------------+--------------+--------------+

使用了上述边界条件组合之后，outletFace处的数值堆积问题得到解决，但是inletFace处的反弹现象依然存在，使得压强场和密度场结果较差，这很可能是压强入口边界条件设置为了零梯度边界造成的影响。结果如图所示：

.. figure:: ../_images/OpenFOAM算例运行案例/调整温度边界条件为自由流后出口处数值堆积问题得到改善.png


为了解决入口处数值反弹问题，尝试修改压力入口边界条件，使用下面的边界条件组合：

+--------------+--------------------+--------------------+--------------+
| patchName    | U                  | p                  | T            |
+==============+====================+====================+==============+
| inletFace    | freestreamVelocity | freestreamPressure | fixedValue   |
+--------------+--------------------+--------------------+--------------+
| outletFace   | freestreamVelocity | freestreamPressure | freestram    |
+--------------+--------------------+--------------------+--------------+
| rightFace    | freestreamVelocity | freestreamPressure | freestram    |
+--------------+--------------------+--------------------+--------------+
| leftFace     | freestreamVelocity | freestreamPressure | freestram    |
+--------------+--------------------+--------------------+--------------+
| cylinderFace | noSlip             | zeroGradient       | zeroGradient |
+--------------+--------------------+--------------------+--------------+
| topFace      | empty              | empty              | empty        |
+--------------+--------------------+--------------------+--------------+
| downFace     | empty              | empty              | empty        |
+--------------+--------------------+--------------------+--------------+

结果表明上述设置能够改善入口数值反弹问题，不过结果呈现出边界处固定值限制附近流场的现象。与此同时，出口处再次出现了部分区域的数值堆积，不过堆积程度没有像开始时那么严重。结果如图所示：

.. figure:: ../_images/OpenFOAM算例运行案例/压力入口边界改为自由流压力边界条件后入口数值反弹问题得到改善.png

为了解决出口处部分区域的数值堆积问题，尝试使用无反射边界条件，使用如下的边界条件组合：

+--------------+--------------------+--------------------+--------------+
| patchName    | U                  | p                  | T            |
+==============+====================+====================+==============+
| inletFace    | fixedValue         | zeroGradient       | fixedValue   |
+--------------+--------------------+--------------------+--------------+
| outletFace   | advective          | advective          | advective    |
+--------------+--------------------+--------------------+--------------+
| rightFace    | freestreamVelocity | freestreamPressure | freestram    |
+--------------+--------------------+--------------------+--------------+
| leftFace     | freestreamVelocity | freestreamPressure | freestram    |
+--------------+--------------------+--------------------+--------------+
| cylinderFace | noSlip             | zeroGradient       | zeroGradient |
+--------------+--------------------+--------------------+--------------+
| topFace      | empty              | empty              | empty        |
+--------------+--------------------+--------------------+--------------+
| downFace     | empty              | empty              | empty        |
+--------------+--------------------+--------------------+--------------+

可以看到，压力场和密度场在出口处的数值堆积问题得到改善，但是速度场和温度场出口处在接近leftFace和rightFace的区域仍存在明显的数值堆积。结果如图所示：

.. figure:: ../_images/OpenFOAM算例运行案例/出口处使用无反射边界改善了压力场密度场在出口处的数值堆积问题.png



后续分析与测试证明，主要原因在于算域不够大，前激波碰到了inletFace上，由于激波后缘被固定了速度值，产生非物理现象而导致数值反弹。通过扩大算域重新生成网格后，采用下面的边界条件组合可以计算得到良好结果：

+--------------+--------------------+--------------------+------------------+
| patchName    | U                  | p                  | T                |
+==============+====================+====================+==================+
| inletFace    | fixedValue         | zeroGradient       | fixedValue       |
+--------------+--------------------+--------------------+------------------+
| outletFace   | waveTransmissive   | waveTransmissive   | waveTransmissive |
+--------------+--------------------+--------------------+------------------+
| rightFace    | freestreamVelocity | freestreamPressure | freestram        |
+--------------+--------------------+--------------------+------------------+
| leftFace     | freestreamVelocity | freestreamPressure | freestram        |
+--------------+--------------------+--------------------+------------------+
| cylinderFace | noSlip             | zeroGradient       | zeroGradient     |
+--------------+--------------------+--------------------+------------------+
| topFace      | empty              | empty              | empty            |
+--------------+--------------------+--------------------+------------------+
| downFace     | empty              | empty              | empty            |
+--------------+--------------------+--------------------+------------------+


.. note:: 不过，为了提高求解稳定性，入口速度是按照100、200、300、400、495.159的顺序依次计算，将前一次的最后一个时间步的计算结果场文件复制到下一次0文件夹中，以此逐步达到马赫数为5.7的情形。


当障碍物外形改变后，网格外形和数量都有所差别，无法直接复制场文件作为初始场进行计算，因此要使用mapFields功能。首先在system文件夹中创建mapFieldsDict文件，其内容为

.. code-block:: C

    FoamFile
    {
        format      ascii;
        class       dictionary;
        location    "system";
        object      mapFieldsDict;
    }
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    patchMap        ( );

    cuttingPatches  ( );


这次映射的源文件夹是cylinderRefinedMesh05，所以要进入该文件夹的system/controlDict文件中，将startTime赋值改为最后一个时间步时间0.05，然后回到映射的目标文件夹，在算例文件夹中进入终端运行下列命令：

.. code-block:: 

    mapFields ../cylinderRefinedMesh05


.. attention:: 如果映射的目标文件本身是先从以往算例复制得到的，那么要先删除掉场文件夹中已有的初始信息，保持为空或者使用默认的uniform初始场形式。如果不这样做，程序将会报错，认为网格数量不一致无法映射。

.. note:: 映射之后可以进入paraView查看初始场情况，需要注意取消勾选Skip Zero Time（位于Refresh按钮下面）。


修改算域大小、重新划分网格并设置边界条件初始场之后，计算正常进行，结果如下所示：

.. figure:: ../_images/OpenFOAM算例运行案例/四种不同外形取料壁的层流模型流场分布.png




fvSchemes设置
^^^^^^^^^^^^^^^

.. code-block:: C

	fluxScheme      Kurganov;

	ddtSchemes
	{
	    default         Euler;
	}

	gradSchemes
	{
	    default         Gauss linear;
	}

	divSchemes
	{
	    default         none;
	    div(tauMC)      Gauss linear;
	}

	laplacianSchemes
	{
	    default         Gauss linear limited corrected 0.5;
	}

	interpolationSchemes
	{
	    default           linear;
	    reconstruct(rho)  vanLeer;
	    reconstruct(U)    vanLeerV;
	    reconstruct(T)    vanLeer;
	}

	snGradSchemes
	{
	    default         limited corrected 0.5;
	}



fvSolution设置
^^^^^^^^^^^^^^^^


在使用层流模型的时候，矩阵求解器设置如下：

.. code-block:: C

	solvers
	{
	    "(rho|rhoU|rhoE)"
	    {
	        solver          diagonal;
	    }

	    U
	    {
	        solver          smoothSolver;
	        smoother        GaussSeidel;
	        nSweeps         2;
	        tolerance       1e-09;
	        relTol          0.01;
	    }

	    "(h|e)"
	    {
	        $U;
	        tolerance       1e-10;
	        relTol          0;
	    }
	}















