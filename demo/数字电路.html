<!DOCTYPE html>
<html class="writer-html4" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>数字电路 &mdash; MyKnowledge MyKnowledge 文档</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
        <script async="async" type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="模拟电路" href="模拟电路.html" />
    <link rel="prev" title="电路原理" href="电路原理.html" />
    <link href="../_static/style.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            MyKnowledge
          </a>
              <div class="version">
                1.01
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="微积分.html">微积分</a></li>
<li class="toctree-l1"><a class="reference internal" href="线性代数.html">线性代数</a></li>
<li class="toctree-l1"><a class="reference internal" href="复变函数.html">复变函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="电路原理.html">电路原理</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">数字电路</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">逻辑代数基础</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id3">数制与码制</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">卡诺图化简法</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id5">门电路</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cmos">CMOS门电路</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id10">反门</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nand">与非门（NAND）</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nor">或非门（NOR）</a></li>
<li class="toctree-l4"><a class="reference internal" href="#xor">异或门（XOR）</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id11">直接用CMOS实现复杂组合逻辑</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id12">逻辑门的连接</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id13">三态门</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id14">数字信号的传递</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ssi">基本SSI逻辑门器件</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id15">组合逻辑电路</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id16">加法器</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id17">超前进位加法器</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id20">竞争冒险</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id21">常用组合逻辑</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id22">编码器</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id23">译码器</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id24">多路选择器</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id25">多路分配器</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id26">比较器</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#alu">ALU(算术逻辑单元)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id27">可编程逻辑</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id28">时序逻辑原理</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#rsd">RS锁存器与D锁存器</a></li>
<li class="toctree-l3"><a class="reference internal" href="#d">D触发器</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id29">时序逻辑电路分类</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id30">同步时序逻辑分析</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id31">异步时序逻辑分析</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id32">计数型时序逻辑</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id33">寄存器</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id34">移位寄存器</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id35">扭环形计数器（约翰逊计数器）</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id36">同步二进制计数器</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id37">常用时序逻辑组件</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id38">寄存器和移位寄存器</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id39">计数器</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#vhdl">VHDL</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#entity">实体entity</a></li>
<li class="toctree-l3"><a class="reference internal" href="#architecture">结构体architecture</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id40">操作符号</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id41">赋值符号</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id42">按位运算符</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="模拟电路.html">模拟电路</a></li>
<li class="toctree-l1"><a class="reference internal" href="数值分析与算法.html">数值分析与算法</a></li>
<li class="toctree-l1"><a class="reference internal" href="数理方程.html">数理方程</a></li>
<li class="toctree-l1"><a class="reference internal" href="流体力学.html">流体力学</a></li>
<li class="toctree-l1"><a class="reference internal" href="计算流体力学有限体积法.html">计算流体力学有限体积法</a></li>
<li class="toctree-l1"><a class="reference internal" href="AutoCAD.html">AutoCAD</a></li>
<li class="toctree-l1"><a class="reference internal" href="C++.html">C++</a></li>
<li class="toctree-l1"><a class="reference internal" href="Latex.html">Latex</a></li>
<li class="toctree-l1"><a class="reference internal" href="Linux.html">Linux</a></li>
<li class="toctree-l1"><a class="reference internal" href="OpenFOAM.html">OpenFOAM</a></li>
<li class="toctree-l1"><a class="reference internal" href="OpenFOAM算例运行案例.html">OpenFOAM算例运行案例</a></li>
<li class="toctree-l1"><a class="reference internal" href="Python.html">Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="Salome.html">Salome</a></li>
<li class="toctree-l1"><a class="reference internal" href="Solidworks.html">Solidworks</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">MyKnowledge</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">数字电路</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/demo/数字电路.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="id1">
<h1>数字电路<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<div class="section" id="id2">
<h2>逻辑代数基础<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<div class="section" id="id3">
<h3>数制与码制<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>十进制小数转化为二进制满足下面的规则：对于一个十进制小数 <span class="math notranslate nohighlight">\((S)_{10}\)</span> ，满足</p>
<div class="math notranslate nohighlight">
\[\begin{align*}
    (S)_{10} = k_{-1}2^{-1} + k_{-2}2^{-2} + \cdots + k_{-m}2^{-m}
\end{align*}\]</div>
<p>将上式两边同乘以 <span class="math notranslate nohighlight">\(2\)</span> 得到</p>
<div class="math notranslate nohighlight">
\[\begin{align*}
    2(S)_{10} = k_{-1} + (k_{-2}2^{-1} + k_{-3}2^{-2} + \cdots + k_{-m}2^{-m + 1})
\end{align*}\]</div>
<p>上式说明，将小数 <span class="math notranslate nohighlight">\((S)_{10}\)</span> 乘以 <span class="math notranslate nohighlight">\(2\)</span> 所得乘积的整数部分即 <span class="math notranslate nohighlight">\(k_{-1}\)</span> 。以此类推，将每次乘 <span class="math notranslate nohighlight">\(2\)</span> 后所得乘积的小数部分再乘以 <span class="math notranslate nohighlight">\(2\)</span> ，便可求出二进制小数的每一位了。</p>
<p>对于有效数字（不包括符号位）为 <span class="math notranslate nohighlight">\(n\)</span> 位的二进制数 <span class="math notranslate nohighlight">\(N\)</span> ，它的补码 <span class="math notranslate nohighlight">\((N)_{\text{COMP}}\)</span> 表示方法为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
    (N)_{\text{COMP}} =
    \left\{\begin{array}{cc}
        N &amp; \text{（当）}N\text{为正数} \\
        2^{n} - N &amp; \text{（当）}N\text{为负数}
    \end{array}\right.
\end{align*}\end{split}\]</div>
<p>即正数（当符号位为 <span class="math notranslate nohighlight">\(0\)</span> 时）的补码与原码相同，负数（当符号位为 <span class="math notranslate nohighlight">\(1\)</span> 时）的补码等于 <span class="math notranslate nohighlight">\(2^{n} - N\)</span> 。符号位保持不变。</p>
<p>二进制 <span class="math notranslate nohighlight">\(N\)</span> 的反码 <span class="math notranslate nohighlight">\((N)_{\text{INV}}\)</span> 定义为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
    (N)_{\text{INV}} =
    \left\{\begin{array}{cc}
        N &amp; \text{（当）}N\text{为正数} \\
        (2^{n} - 1) - N &amp; \text{（当）}N\text{为负数}
    \end{array}\right.
\end{align*}\end{split}\]</div>
<p>为了避免在求补码的过程中做减法运算，通常是先求出 <span class="math notranslate nohighlight">\(N\)</span> 的反码 <span class="math notranslate nohighlight">\((N)_{\text{INV}}\)</span> ，然后在负数的反码上加 $1$ 而得到补码。</p>
<p>8421码又称BCD码，在这种编码方式中，每一位二值代码的 <span class="math notranslate nohighlight">\(1\)</span> 都代表一个固定数值，将每一位的 <span class="math notranslate nohighlight">\(1\)</span> 代表的十进制数加起来，得到的结果就是它所代表的十进制数码。由于代码中从左到右每一位的 <span class="math notranslate nohighlight">\(1\)</span> 分别表示 <span class="math notranslate nohighlight">\(8\)</span> 、<span class="math notranslate nohighlight">\(4\)</span> 、<span class="math notranslate nohighlight">\(2\)</span> 、<span class="math notranslate nohighlight">\(1\)</span> ，所以将这种代码称为8421码。每一位 <span class="math notranslate nohighlight">\(1\)</span> 代表的十进制数称为这一位的权。8421码中每一位的权是固定不变的，它属于恒权代码。</p>
<p>余3码如果看作一个4位二进制数，则它的数值要比它所表示的十进制数码多3，故将这种代码称为余3码。在用余3码做十进制加法运算时，若两数之和为10，正好等于二进制数的16，于是便从高位自动产生进位信号；同时对称互为反码的特征也让求取对10的补码更加方便。余3码不是恒权代码，代码中每一位的1所代表的十进制数在各个代码中不能是固定的。</p>
<p>5211码每一位的权正好与8421码十进制计数器4个触发器输出脉冲的分频比相对应。这种对应关系在构成某些数字系统时很有用。</p>
<p>格雷码的每一位状态变化都按一定的顺序循环。自右向左，每一位状态循环中连续的 <span class="math notranslate nohighlight">\(0\)</span> 、<span class="math notranslate nohighlight">\(1\)</span> 数目增加一倍。与普通的二进制代码相比，格雷码最大的优点在于当它按照编码顺序依次变化时，相邻两个代码之间只有一位发生变化。这样在代码转换的过程中就不会产生过渡“噪声”。</p>
</div>
<div class="section" id="id4">
<h3>卡诺图化简法<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<dl class="docutils">
<dt>定义 <span class="classifier-delimiter">:</span> <span class="classifier">最小项</span></dt>
<dd>一个函数的某个乘积项包含了函数的全部变量，其中每个变量都以原变量或反变量的形式出现，且仅出现一次，则这个乘积称为该函数的一个标准积项，通常称为最小项。</dd>
</dl>
<p>最小项通常用 <span class="math notranslate nohighlight">\(m_{i}\)</span> 来表示，其中下标 <span class="math notranslate nohighlight">\(i\)</span> 的确定方式为：把最小项中原变量记为 <span class="math notranslate nohighlight">\(1\)</span> ，反变量记为 <span class="math notranslate nohighlight">\(0\)</span> ，当变量顺序确定后，可以按顺序排列成一个二进制数，则与这个二进制数相对应的十进制数就是这个最小项的下标 <span class="math notranslate nohighlight">\(i\)</span> 。</p>
<dl class="docutils">
<dt>定义 <span class="classifier-delimiter">:</span> <span class="classifier">最小项的相邻性</span></dt>
<dd>任何两个最小项如果只有一个因子不同，其他因子都相同，则称这两个最小项为相邻最小项。相邻的两个最小项之和可以合并一项，消去一个变量。</dd>
</dl>
<p>将 <span class="math notranslate nohighlight">\(n\)</span> 变量的全部最小项各用一个小方块表示，并使具有逻辑相邻性的最小项在几何位置上也相邻地排列起来，所得到的图形称为 $n$ 变量最小项的卡诺图。对于有 <span class="math notranslate nohighlight">\(n\)</span> 个变量的逻辑函数，其最小项有 <span class="math notranslate nohighlight">\(2^{n}\)</span> 个，因此该逻辑函数的卡诺图有 <span class="math notranslate nohighlight">\(2^{n}\)</span> 个小方格。</p>
<p>为了保证图中几何位置的最小项在逻辑上也具有相邻性，图两侧的二进制数码不能按照自然二进制数从小到大地顺序排列，而必须按照格雷码顺序排列，以确保相邻的两个最小项仅有一个变量是不同的。</p>
<p>卡诺图化简法有以下特征：</p>
<ol class="arabic simple">
<li>由最小项表达式确定变量的个数，如果最小项中缺少变量，要利用 <span class="math notranslate nohighlight">\((A+\overline{A})\)</span> 的方式补齐。</li>
<li>将卡诺图中的1格画圈，不能漏圈；1格允许被一个以上的圈所包围。</li>
<li>圈的个数应尽可能少，一个圈和一个与项相对应。</li>
<li>圈内格数按照 <span class="math notranslate nohighlight">\(2^{k}\)</span> 来组合，圈的面积越大越好。</li>
<li>每个圈应至少包含一个新的1格，否则这个圈是多余的。</li>
<li>用卡诺图化简所得到的最简与或式不是唯一的。</li>
</ol>
<p>约束项和任意项统称为逻辑函数式中的无关项。这里所说的“无关”是指是否把这些最小项写入逻辑函数式无关紧要，可以写入也可以删除。因此无关项在卡诺图对应的位置上既可以填入 <span class="math notranslate nohighlight">\(1\)</span> ，可以填入 <span class="math notranslate nohighlight">\(0\)</span> ，用 <span class="math notranslate nohighlight">\(X\)</span> 来表示。在化简逻辑函数式可以根据需要认为它是 <span class="math notranslate nohighlight">\(1\)</span> 或 <span class="math notranslate nohighlight">\(0\)</span> 。</p>
</div>
</div>
<div class="section" id="id5">
<h2>门电路<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<p>模拟电路的处理形式会由于实践过程中的制造工艺分散性、干扰等导致数据异常，所以模拟电路通常只用在整个系统的最前端。模拟电路通过传感器将信息转换为电量之后，就需要进入数字系统。在数字系统当中只传递0和1，但是所付出的代价要么是空间变宽，要么是时间变长。</p>
<p>在电压信号进行数字化的过程中，我们将中间的区域称为无效区。无效区的宽度需要根据实际需求来确定，如果无效区太宽会导致无法有效接收信号，如果无效区太窄会导致噪声明显。在输入发生变化时，电压信号会经过这个无效区，此时电路的输出时不确定的。</p>
<p>两个反向器连用不必去掉，它能够对信号进行整理。所以数字电路就是通过这些信号处理方式，将噪声剔除，确保信息准确高效传递。</p>
<div class="section" id="cmos">
<h3>CMOS门电路<a class="headerlink" href="#cmos" title="永久链接至标题">¶</a></h3>
<p>在CMOS集成电路中，以金属-氧化物-半导体场效应晶体管 <a class="footnote-reference" href="#id8" id="id6">[1]</a> 作为开关器件。</p>
<p>如图所示的是MOS管的结构示意图和符号。在P型半导体衬底上，制作两个高掺杂浓度的N型区，形成MOS管的源极S(Source)和漏极D(Drain)，第三个电极称为栅极G(Gate)。 <a class="footnote-reference" href="#id9" id="id7">[2]</a></p>
<div class="figure align-center">
<img alt="../_images/MOS管的结构和符号.png" src="../_images/MOS管的结构和符号.png" />
</div>
<p><em>MOS管的结构和符号</em></p>
<p>如果在漏极和源极之间加上电压 <span class="math notranslate nohighlight">\(v_{DS}\)</span> ，而令栅极和源极之间的电压 <span class="math notranslate nohighlight">\(V_{GS} = 0\)</span> ，则由于漏极和源极之间相当于两个PN结背向地串联，所以D-S间不导通， <span class="math notranslate nohighlight">\(i_{D} = 0\)</span> 。</p>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[1]</a></td><td>Metal-Oxide-Semiconductor Field-Effect Transistor，简称MOS管。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[2]</a></td><td>栅极通常用金属铝或多晶硅制作。栅极和衬底之间被二氧化硅绝缘层隔开，绝缘层的厚度极薄，在 <span class="math notranslate nohighlight">\(0.1 ~\mathrm{\mu m}\)</span> 以内。</td></tr>
</tbody>
</table>
<p>静态CMOS门是上拉网络（PUN）和下拉网络（PDN）的组合。</p>
<dl class="docutils">
<dt>定义 <span class="classifier-delimiter">:</span> <span class="classifier">上拉网络</span></dt>
<dd>上拉网络由PMOS管构成。每当 <span class="math notranslate nohighlight">\(F(In_{1},In_{2},\dots,In_{N})=1\)</span> 时，它将提供一条在输出和 <span class="math notranslate nohighlight">\(V_{\text{DD}}\)</span> 之间的通路。</dd>
<dt>定义 <span class="classifier-delimiter">:</span> <span class="classifier">下拉网络</span></dt>
<dd>下拉网络由NMOS管构成。每当 <span class="math notranslate nohighlight">\(F(In_{1},In_{2},\dots,In_{N})=0\)</span> 时，它将提供一条在输出和GND之间的通路。</dd>
</dl>
<p>PUN和PDN网络是以相互排斥的方式构成的：PUN和PDN是对偶网络；实现具有N个输入的逻辑门需要2N个晶体管。在稳定状态时，输出节点总是一个低阻节点。</p>
<p>对于NMOS器件，栅极至源极电压 <span class="math notranslate nohighlight">\(V_{\text{GS}}\)</span> 必须显著高于通道阈值电压才能完全导通，否则通道的电压将降低。NMOS器件只能发送弱逻辑“1”（高电平），但发送强逻辑“0”（低电平）时不会丢失。</p>
<p>对于PMOS器件，栅极至源极电压 <span class="math notranslate nohighlight">\(V_{\text{GS}}\)</span> 必须明显小于通道阈值电压才能将其完全关闭，否则电流仍将流过通道。PMOS器件可以无损失地发送强逻辑“1”（高电平），但会发送弱逻辑“0”（低电平）。</p>
<p>CMOS综合了NMOS和PMOS的特点，能够实现双向对称传输，从而接近理想开关。</p>
<div class="section" id="id10">
<h4>反门<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h4>
<div class="figure align-center">
<img alt="../_images/CMOS反相器.png" src="../_images/CMOS反相器.png" />
</div>
<p><em>Figure CMOS反相器</em></p>
</div>
<div class="section" id="nand">
<h4>与非门（NAND）<a class="headerlink" href="#nand" title="永久链接至标题">¶</a></h4>
<div class="figure align-center">
<img alt="../_images/CMOS与非门.png" src="../_images/CMOS与非门.png" />
</div>
<p><em>Figure CMOS与非门</em></p>
</div>
<div class="section" id="nor">
<h4>或非门（NOR）<a class="headerlink" href="#nor" title="永久链接至标题">¶</a></h4>
<div class="figure align-center">
<img alt="../_images/CMOS或非门.png" src="../_images/CMOS或非门.png" />
</div>
<p><em>Figure CMOS或非门</em></p>
</div>
<div class="section" id="xor">
<h4>异或门（XOR）<a class="headerlink" href="#xor" title="永久链接至标题">¶</a></h4>
<p>通过组合逻辑门可以得到异或门的逻辑效果：</p>
<div class="figure align-center">
<img alt="../_images/组合逻辑门得到异或门.png" src="../_images/组合逻辑门得到异或门.png" />
</div>
<p><em>Figure 组合逻辑门得到异或门</em></p>
</div>
<div class="section" id="id11">
<h4>直接用CMOS实现复杂组合逻辑<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h4>
<p>以实现多输入的与非门为例，并不是通过双与门级联来得到的，而是使用场效应管设计，在半导体结构上增加一对场效应管。这样就能使开销线性增加，而不是倍数增加。</p>
<div class="figure align-center">
<img alt="../_images/三输入与非门.png" src="../_images/三输入与非门.png" />
</div>
<p><em>Figure 三输入与非门</em></p>
</div>
<div class="section" id="id12">
<h4>逻辑门的连接<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li>逻辑门可以互相逐级连接，构成更复杂的逻辑关系；</li>
<li>逻辑门的输出可以提供给多个输入，但是需要考虑扇入扇出能力；</li>
<li>逻辑门的输入端只能由一个信号驱动，不同逻辑门的输出端不能直接连接，否则可能出现低阻抗通道导致短路。</li>
</ul>
</div>
<div class="section" id="id13">
<h4>三态门<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h4>
<p>三态门是在原来反相器的基础上增加了Enable输入端，可以控制该逻辑门是否发挥作用。</p>
<div class="figure align-center">
<img alt="../_images/三态门.png" src="../_images/三态门.png" />
</div>
<p><em>Figure 三态门</em></p>
</div>
</div>
<div class="section" id="id14">
<h3>数字信号的传递<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h3>
<p>即使只是一个反相器来处理信号，电压信号也不是真的像遇到开关一样瞬间变化。真实世界里输出值也不是恒定的，存在一定的变化；真实世界里也不存在无限快的阶跃跳变，总是存在过渡过程的；真实的世界里由于存在干扰和噪声，不能使用单一电平值作为0/1的判据。</p>
<p>数字信号的输入允许范围要比输出定义值要更大，以提供一定的噪声容忍能力。</p>
<div class="figure align-center">
<img alt="../_images/数字信号传递的电平约定.png" src="../_images/数字信号传递的电平约定.png" />
</div>
<p><em>Figure 数字信号传递的电平约定</em></p>
<p>不同的电平标准，输入输出有效信号范围的具体数值时不同的。不同电平标准的信号互相连接的时候，必须注意其信号范围。必要的时候必须使用电平转换芯片。</p>
<p>开关是有速度的，需要响应时间。提高数字电路主频的方法：改进工艺，缩小晶体管尺寸，降低电容，减少信号传递的距离；降低电压，减少信号变化所需的时间。</p>
<dl class="docutils">
<dt>定义 <span class="classifier-delimiter">:</span> <span class="classifier">传播延迟 <span class="math notranslate nohighlight">\(t_{\text{pd}}\)</span></span></dt>
<dd>从有效输入到生成有效输出的延迟时间的上限。 <span class="math notranslate nohighlight">\(T_{\text{pd}}\)</span> 是指从输入到输出的所有路径累积传播延迟的最大值。</dd>
<dt>定义 <span class="classifier-delimiter">:</span> <span class="classifier">污染延迟 <span class="math notranslate nohighlight">\(t_{\text{cd}}\)</span></span></dt>
<dd>从任何无效输入到生成无效输出的延迟时间的下限。 <span class="math notranslate nohighlight">\(T_{\text{cd}}\)</span> 是指从输入到输出所有路径累积污染延迟的最小值。</dd>
</dl>
<div class="figure align-center">
<img alt="../_images/传播延迟和污染延迟.png" src="../_images/传播延迟和污染延迟.png" />
</div>
<p><em>Figure 传播延迟和污染延迟</em></p>
</div>
</div>
<div class="section" id="ssi">
<h2>基本SSI逻辑门器件<a class="headerlink" href="#ssi" title="永久链接至标题">¶</a></h2>
<p>最常见的是74系列SSI，具有一系列小规模集成电路，提供预制的标准逻辑功能，并且统一封装（左上电源，右下为地），具有不同电气/工艺特性，不同厂商的器件互相兼容。</p>
<dl class="docutils">
<dt>定义 <span class="classifier-delimiter">:</span> <span class="classifier">扇入扇出</span></dt>
<dd>逻辑门的输入驱动要求称为扇入值，其输出驱动能力极限称为扇出值。</dd>
</dl>
<p>SSI器件可能多次使用输入引脚的信号，从外部很难判断该引脚信号的逻辑门负载数目，很难计算扇入扇出是否匹配。为了解决这个问题，通过在输入引脚首先进行反向，保证该引脚对外只有该反相器这一个负载，也就是整个引脚对外的扇入值为1。系统设计判断扇入扇出时，只需要数后面连接了多少个引脚，不需要深入了解器件内部对该引脚信号的使用情况。</p>
<p>SSI器件大量使用低电平有效的负逻辑信号，通常用上划线表示。这样设计有以下好处：</p>
<ul class="simple">
<li>低电平更容易兼容不同电压标准；</li>
<li>半导体器件的灌电流能力强于拉电流能力；</li>
<li>低电平信号抗干扰能力更强（低电平就是接地，地是阻抗非常小的参考点；负向干扰很容易被抑制；电源电压不稳定时，高电平电压会波动，但低电平信号不会）。</li>
</ul>
<p>一些常见74基本集成逻辑器件：</p>
<ul class="simple">
<li>7400——四个二输入与非门</li>
<li>7402——四个二输入或非门</li>
<li>7404——六个非门</li>
<li>7408——四个二输入与门</li>
<li>7486——四个异或门</li>
</ul>
<div class="figure align-center">
<img alt="../_images/一些常见74基本集成逻辑器件.png" src="../_images/一些常见74基本集成逻辑器件.png" />
</div>
<p><em>Figure 一些常见74基本集成逻辑器件</em></p>
</div>
<div class="section" id="id15">
<h2>组合逻辑电路<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h2>
<p>组合逻辑电路（简称组合电路）任意时刻的输出信号仅取决于该时刻的输入信号，与信号作用前电路原来的状态无关（不包含记忆存储原件；不存在输出到输入的反馈回路）。</p>
<p>组合逻辑电路的分析方法（给出逻辑电路到分析功能）一般是下面几个步骤：</p>
<ol class="arabic simple">
<li>根据逻辑图写出逻辑表达式</li>
<li>根据逻辑图/逻辑表达式列出真值表</li>
<li>根据真值表输入输出对应关系，归纳电路逻辑功能（或使用布尔代数定理化简逻辑表达式，归纳逻辑功能）</li>
</ol>
<p>组合逻辑电路的设计方法（给出功能到设计逻辑）一般是下面几个步骤：</p>
<ol class="arabic simple">
<li>根据功能所需，列出输入输出信号对应的真值表达式</li>
<li>根据真值表列出逻辑一般表达式（积之和）</li>
<li>用布尔代数相关定理或卡诺图化简逻辑表达式（根据不同的要求，如最少的门电路或最少的集成电路器件和种类）</li>
<li>根据表达式搭建逻辑电路</li>
</ol>
<div class="section" id="id16">
<h3>加法器<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h3>
<div class="figure align-center">
<img alt="../_images/全加器.png" src="../_images/全加器.png" />
</div>
<p><em>Figure 全加器</em></p>
<p>在实现下面的加减法器时，需要考虑溢出（overflow）的问题。溢出仅发生于如下两种情况：</p>
<ul class="simple">
<li>正数+正数=负数</li>
<li>负数+负数=正数</li>
</ul>
<p>这两种情况只需要通过符号位即可判定。而符号位的运算是通过最高位的全加器完成的：全加器的输入 <span class="math notranslate nohighlight">\(X\)</span> 、 <span class="math notranslate nohighlight">\(Y\)</span> 对应两个运算数的符号位；全加器的输出 <span class="math notranslate nohighlight">\(S\)</span> 对应计算结果的符号位。因此，溢出就满足 <span class="math notranslate nohighlight">\(\text{Overflow}=Z~\text{xor}~C\)</span> 。</p>
<div class="figure align-center">
<img alt="../_images/4bit加减法器.png" src="../_images/4bit加减法器.png" />
</div>
<p><em>Figure 4bit加减法器</em></p>
<p><strong>例题</strong> 分析4bit加法器的 <span class="math notranslate nohighlight">\(T_{\text{pd}}\)</span> 和 <span class="math notranslate nohighlight">\(T_{\text{cd}}\)</span> 。已知异或门满足 <span class="math notranslate nohighlight">\(T_{\text{pd}}=12~\mathrm{ns}\)</span> ， <span class="math notranslate nohighlight">\(T_{\text{cd}}=2~\mathrm{ns}\)</span> ，与门/或门满足 <span class="math notranslate nohighlight">\(T_{\text{pd}}=4~\mathrm{ns}\)</span> ， <span class="math notranslate nohighlight">\(T_{\text{cd}}=1~\mathrm{ns}\)</span> 。</p>
<p><strong>解</strong> 在寻找最长路径或最短路径时，需要将抽象的1bit加法器拆分为基本的逻辑门，从头到尾分析4bit加法器从输入端到最终输出端的路径情况，而不能仅从1bit加法器计算 <span class="math notranslate nohighlight">\(T_{\text{pd}}\)</span> 或 <span class="math notranslate nohighlight">\(T_{\text{cd}}\)</span> 然后乘以倍数来得到。</p>
<p>从四个1bit加法器的逻辑门连接来看，最长的路径是A0-C1-C2-C3-S3，有 <span class="math notranslate nohighlight">\(T_{\text{pd}}=12+12+(4\times2)\times3=48~\mathrm{ns}\)</span> ；最短路径是B3/A3-C4或C0-S0，均有 <span class="math notranslate nohighlight">\(T_{\text{cd}}=2~\mathrm{ns}\)</span> 。</p>
</div>
<div class="section" id="id17">
<h3>超前进位加法器<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h3>
<p>之前描述的加法器属于行波进位加法器（Ripple Carry Adder, RCA），其最高位的进位必须等待所有进位计算完毕才能计算出结果。下面讲述超前进位加法器（Lookahead Carry Adder, LCA），它每级进位判断不依赖低级的进位输出，而根据输入信息直接判断。</p>
<p>行波进位加法器的低位全加器的 <span class="math notranslate nohighlight">\(C_{\text{out}}\)</span> 连接到高一位全加器 <span class="math notranslate nohighlight">\(C_{\text{in}}\)</span> ，它的电路布局简单，设计方便，但高位的运算必须等待低位的运算完成，延迟时间长。超前进位加法器的每个全加器的进位输入并不来自于前一级的全加器，而是来自超前进位的逻辑，它计算 <span class="math notranslate nohighlight">\(C_{i+1}\)</span> 的延迟时间固定为三级门延迟，与加法器的位数无关，但是如果进一步拓宽加法器的位数，则电路会变得非常复杂。</p>
<p>要实现超前进位需定义两个变量：进位生成 <span class="math notranslate nohighlight">\(G_{i}=X_{i}\cdot Y_{i}\)</span> ，进位传播 <span class="math notranslate nohighlight">\(P_{i}=X_{i}\oplus Y_{i}\)</span> 。那么全加器的逻辑函数可以表示为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
   &amp;S_{i}=X_{i}\oplus Y_{i}\oplus C_{i}=P_{i}\oplus C_{i} \\
   &amp;C_{i+1}=X_{i}\cdot Y_{i}+(X_{i}\oplus Y_{i})\cdot C_{i}=G_{i}+P_{i}C_{i}
\end{align}\end{split}\]</div>
<p>于是4位加法器的每级进位输出逻辑式可以得到改写，变为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
   C_{1} &amp; = G_{0}+P_{0}\cdot C_{0} \\
   C_{2} &amp; = G_{1}+P_{1}\cdot C_{1}=G_{1}+P_{1}\cdot G_{0}+P_{1}\cdot P_{0}\cdot C_{0} \\
   C_{3} &amp; = G_{2}+P_{2}\cdot C_{2}=G_{2}+P_{2}\cdot G_{1}+P_{2}\cdot P_{1}\cdot G_{0}+P_{2}\cdot P_{1}\cdot P_{0}\cdot C_{0} \\
   C_{4} &amp; = G_{3}+P_{3}\cdot C_{3}=G_{3}+P_{3}\cdot G_{2}+P_{3}\cdot P_{2}\cdot G_{1}+P_{3}\cdot P_{2}\cdot P_{1}\cdot G_{0}+P_{3}\cdot P_{2}\cdot P_{1}\cdot P_{0}\cdot C_{0}
\end{align}\end{split}\]</div>
<div class="figure align-center">
<img alt="../_images/4bit超前进位加法器.png" src="../_images/4bit超前进位加法器.png" />
</div>
<p><em>Figure 4bit超前进位加法器</em></p>
<p>下面拓展到16位加法器。除了用行波形式拓展，还可以用CLA4作为基本单元，用超前进位方式拓展。 <a class="footnote-reference" href="#id19" id="id18">[3]</a></p>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id18">[3]</a></td><td>直接实现更多位的完全超前进位，电流会变得非常复杂。一般用多个小规模的超前进位加法器拼接较大的加法器。</td></tr>
</tbody>
</table>
<p>超前进位逻辑的核心，是利用中间变量 <span class="math notranslate nohighlight">\(P\)</span> 、 <span class="math notranslate nohighlight">\(G\)</span> 来实现进位： <span class="math notranslate nohighlight">\(C_{i+1}=G_{i}+P_{i}C_{i}\)</span> 。至于中间变量 <span class="math notranslate nohighlight">\(P\)</span> 、 <span class="math notranslate nohighlight">\(G\)</span> 的产生，以 <span class="math notranslate nohighlight">\(C_{4}\)</span> 为例，其满足</p>
<div class="math notranslate nohighlight">
\[\begin{align}
   C_{4}=G_{3}+P_{3}\cdot C_{3}=G_{3}+P_{3}\cdot G_{2}+P_{3}\cdot P_{2}\cdot G_{1}+P_{3}\cdot P_{2}\cdot P_{1}\cdot G_{0}+P_{3}\cdot P_{2}\cdot P_{1}\cdot P_{0}\cdot C_{0}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(G_{3}+P_{3}\cdot G_{2}+P_{3}\cdot P_{2}\cdot G_{1}+P_{3}\cdot P_{2}\cdot P_{1}\cdot G_{0}\)</span> 的表达形式即为 <span class="math notranslate nohighlight">\(G_{m}\)</span> ，其中 <span class="math notranslate nohighlight">\(P_{3}\cdot P_{2}\cdot P_{1}\cdot P_{0}\)</span> 的表达形式即为 <span class="math notranslate nohighlight">\(P_{m}\)</span> 。</p>
<div class="figure align-center">
<img alt="../_images/16bit超前进位加法器.png" src="../_images/16bit超前进位加法器.png" />
</div>
<p><em>Figure 16bit超前进位加法器</em></p>
</div>
<div class="section" id="id20">
<h3>竞争冒险<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h3>
<p>所有门电路都会有传输延迟时间（ <span class="math notranslate nohighlight">\(t_{\text{pd}}\)</span> ），而不同的信号通道之间，信号可能因为传输延迟时间的不同，到达的时间也不同。造成传输延迟时间不同的原因有：</p>
<ul class="simple">
<li>不同通道逻辑门的级数不同</li>
<li>不同通道逻辑门电路的传输延迟时间不同</li>
<li>不同通道电路连线的传输延迟时间不同</li>
</ul>
<dl class="docutils">
<dt>定义 <span class="classifier-delimiter">:</span> <span class="classifier">竞争冒险</span></dt>
<dd>经过不同路径产生的信号，由于其到达时刻有先有后，导致输出信号出现多次变化。这种信号时差引起的现象称为 <strong>竞争</strong> 。竞争导致输出出现错误状态，称为出现 <strong>冒险</strong> 。造成错误后果的竞争，为 <em>临界竞争</em> ；竞争的结果不导致冒险发现，为 <em>非临界竞争</em> 。</dd>
</dl>
<p>对于上述电路， <span class="math notranslate nohighlight">\(Y=B\overline{C}+AC\)</span> ，如果输入信号恒保持 <span class="math notranslate nohighlight">\(A=1; B=1\)</span> ，C信号从0变成1然后又从1变成0。那么 <span class="math notranslate nohighlight">\(Y\)</span> 的电平情况会出现下图所示的变化。在C从1变成0的过程，在传输延迟传递时，存在1降低到低电平后、3跳跃为高电平前的这段时间，这就导致在这段时间同时出现1和3的低电平，最终输出Y为低电平，于是在原本逻辑上应当一直保持高电平的Y输出中出现了低电平毛刺。</p>
<div class="figure align-center">
<img alt="../_images/组合逻辑电路的竞争冒险.png" src="../_images/组合逻辑电路的竞争冒险.png" />
</div>
<p><em>Figure 组合逻辑电路的竞争冒险</em></p>
<p>判断是否竞争冒险现象的方法是：输出端函数在一定条件下会变为下面形式时就会存在竞争冒险</p>
<div class="math notranslate nohighlight">
\[\begin{align}
   &amp;L=A+\overline{A} &amp;&amp;L=A\cdot \overline{A}
\end{align}\]</div>
<p>消除竞争冒险现象的方法有：</p>
<ol class="arabic simple">
<li>发现并消除互补变量</li>
<li>修改逻辑设计，增加冗余乘积项</li>
<li>输出端并联电容器（利用了电容器电压不能突变的特性来平滑尖脉冲，会影响输出信号速度，只能用于慢速电路）</li>
<li>引入封锁/选通脉冲（在输出端加入额外控制信号，使输入信号发生变化的时间段内输出状态时确定的。封锁：输入信号变化时，输出端暂时被“关闭”；选通：只有在选通信号有效时，输出才打开）</li>
<li>使用同步逻辑电路（组合逻辑的输入/输出由时序组件提供/存储。时序组件仅在特定时刻才执行动作，只要这个特定时刻和毛刺不同时出现，就可以避免错误状态影响后续逻辑）</li>
</ol>
</div>
<div class="section" id="id21">
<h3>常用组合逻辑<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h3>
<div class="section" id="id22">
<h4>编码器<a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h4>
<p>数字电路中的编码是用二进制代码表示某种特定含义的信息。 <span class="math notranslate nohighlight">\(n\)</span> 位编码输出信号可以组成 <span class="math notranslate nohighlight">\(2^{n}\)</span> 个不同的状态，可以表示 <span class="math notranslate nohighlight">\(2^{n}\)</span> 个信号，因此需要编码的状态有 <span class="math notranslate nohighlight">\(2^{n}\)</span> 种，属于全编码器（二进制编码器）。</p>
<p>编码器的输入其实就是独热码，所以编码器也是“独热码-二进制”转换电路。下面给出的是4-2编码器，输出满足</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
   &amp;Y_{0}=\overline{I}_{0}I_{1}\overline{I}_{2}\overline{I}_{3}+\overline{I}_{0}\overline{I}_{1}\overline{I}_{2}I_{3}=I_{1}+I_{3} \\
   &amp;Y_{1}=\overline{I}_{0}\overline{I}_{1}I_{2}\overline{I}_{3}+\overline{I}_{0}\overline{I}_{1}\overline{I}_{2}I_{3}=I_{2}+I_{3}
\end{align}\end{split}\]</div>
<div class="figure align-center">
<img alt="../_images/4-2编码器.png" src="../_images/4-2编码器.png" />
</div>
<p><em>Figure 4-2编码器</em></p>
<p>但是，上述的普通编码器在编码过程中，只能有一个“有效”输入信号，可以进行编码的输入状态组合是有限的，并不完备；如果有多个“有效输入”，此时的编码输出时错误的。因此，我们将使用优先编码器。它在编码过程中可以有多个“有效”输入信号，可编码状态涵盖了输入信号的全部可能组合状态；如果有多个“有效”输入，仅对其中优先级最高的输入进行编码。</p>
<p>下面是一个4-2线优先编码器， <span class="math notranslate nohighlight">\(V\)</span> 是一个有效的位指示符，在输入有效时为1。当所有输入均为零时，此有效位为零，表示没有有效输入。输出信号与有效位指示符满足</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
   &amp;Y_{1}=D_{3}+\overline{D}_{3}D_{2}=D_{3}+D_{2} \\
   &amp;Y_{0}=D_{3}+\overline{D}_{3}\overline{D}_{2}D_{1}=D_{3}+\overline{D}_{2}D_{1} \\
   &amp;V=D_{3}+D_{2}+D_{1}+D_{0}
\end{align}\end{split}\]</div>
<div class="figure align-center">
<img alt="../_images/4-2线优先编码器.png" src="../_images/4-2线优先编码器.png" />
</div>
<p><em>Figure 4-2线优先编码器</em></p>
<p>下面是一个8-3线优先编码器，除了基本逻辑功能外，它还增加了使能输入端 <span class="math notranslate nohighlight">\(EI\)</span> 、使能输出端 <span class="math notranslate nohighlight">\(EO\)</span> 、编码有效符号位 <span class="math notranslate nohighlight">\(GS\)</span> ，这些添加的端口有利于后续拓展集成功能。各输出端满足下面的关系</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
   &amp;\overline{A}_{0}=\overline{(I_{1}\overline{I}_{2}\overline{I}_{4}\overline{I}_{6}+I_{3}\overline{I}_{4}\overline{I}_{6}+I_{5}\overline{I}_{6}+I_{7})EI}  \\
   &amp;\overline{A}_{1}=\overline{(I_{2}\overline{I}_{4}\overline{I}_{5}+I_{3}\overline{I}_{4}\overline{I}_{5}+I_{6}+I_{7})EI}  \\
   &amp;\overline{A}_{2}=\overline{(I_{4}+I_{5}+I_{6}+I_{7})EI}  \\
   &amp;\overline{EO} =\overline{(\overline{I}_{0}\overline{I}_{1}\overline{I}_{2}\overline{I}_{3}\overline{I}_{4}\overline{I}_{5}\overline{I}_{6}\overline{I}_{7}\overline{I}_{8})EI}  \\
   &amp;\overline{GS}=\overline{\overline{EO}\cdot EI}=\overline{(I_{0}+I_{1}+I_{2}+I_{3}+I_{4}+I_{5}+I_{6}+I_{7})EI}
\end{align}\end{split}\]</div>
<div class="figure align-center">
<img alt="../_images/8-3线优先编码器.png" src="../_images/8-3线优先编码器.png" />
</div>
<p><em>Figure 8-3线优先编码器</em></p>
<p>下面是一个16-4线优先编码器，使用两片148来实现功能。外部enable无效时，第二片148输出的EO也无效，保证第一片148也不工作。第二片148进行有效编码时，EO输出高电平，把第1片148置于禁止状态；只有第二片148使能，且无有效输入时，其EO才输出低电平，允许第一片148对外编码。通过EI/EO级联，保证只有一片148处于编码状态，其输出直接做“与”得到最终的输出。</p>
<p>需要增加A3最高位，当第二片148处于有效编码时，该最高位应给出输出，因此可以直接用第二片148的GS输出。</p>
<div class="figure align-center">
<img alt="../_images/16-4线优先编码器.png" src="../_images/16-4线优先编码器.png" />
</div>
<p><em>Figure 16-4线优先编码器</em></p>
<p>下面是一个8输入优先编码器的VHDL代码实现：</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="k">entity</span> <span class="nc">priority_encoder</span> <span class="k">is</span>
   <span class="k">port</span> <span class="p">(</span>
      <span class="n">I</span> <span class="o">:</span> <span class="k">in</span> <span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">7</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">);</span>
      <span class="n">A</span> <span class="o">:</span> <span class="k">out</span> <span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">2</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">)</span>
   <span class="p">);</span>
<span class="k">end</span> <span class="nc">priority_encoder</span><span class="p">;</span>

<span class="k">architecture</span> <span class="nc">priority_encoder_arc</span> <span class="k">of</span> <span class="nc">priority_encoder</span> <span class="k">is</span>
<span class="k">begin</span>
   <span class="n">A</span> <span class="o">&lt;=</span> <span class="s">&quot;111&quot;</span> <span class="k">when</span> <span class="n">I</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">=</span><span class="sc">&#39;1&#39;</span> <span class="k">else</span>
       <span class="s">&quot;110&quot;</span> <span class="k">when</span> <span class="n">I</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">=</span><span class="sc">&#39;1&#39;</span> <span class="k">else</span>
       <span class="s">&quot;101&quot;</span> <span class="k">when</span> <span class="n">I</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">=</span><span class="sc">&#39;1&#39;</span> <span class="k">else</span>
       <span class="s">&quot;100&quot;</span> <span class="k">when</span> <span class="n">I</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">=</span><span class="sc">&#39;1&#39;</span> <span class="k">else</span>
       <span class="s">&quot;011&quot;</span> <span class="k">when</span> <span class="n">I</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">=</span><span class="sc">&#39;1&#39;</span> <span class="k">else</span>
       <span class="s">&quot;010&quot;</span> <span class="k">when</span> <span class="n">I</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">=</span><span class="sc">&#39;1&#39;</span> <span class="k">else</span>
       <span class="s">&quot;001&quot;</span> <span class="k">when</span> <span class="n">I</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="sc">&#39;1&#39;</span> <span class="k">else</span>
       <span class="s">&quot;000&quot;</span> <span class="k">when</span> <span class="n">I</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">=</span><span class="sc">&#39;1&#39;</span> <span class="k">else</span>
       <span class="s">&quot;111&quot;</span><span class="p">;</span>
<span class="k">end</span> <span class="nc">priority_encoder_arc</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="id23">
<h4>译码器<a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h4>
<p>译码指的是将具有特定含义的二进制代码翻译成原始信息。译码器是编码器的逆过程。 <span class="math notranslate nohighlight">\(n\)</span> 位编码可以翻译成 <span class="math notranslate nohighlight">\(2^{n}\)</span> 个不同的状态，即可以表示 <span class="math notranslate nohighlight">\(2^{n}\)</span> 种原始信号的组合。常用的译码器有：二进制译码器、十进制译码器、显示译码器（7段数码管显示译码）。</p>
<p>下图展示的是2-4译码器的基本逻辑过程以及基础逻辑门。</p>
<div class="figure align-center">
<img alt="../_images/2-4译码器.png" src="../_images/2-4译码器.png" />
</div>
<p><em>Figure 2-4译码器</em></p>
<p>基于上面的基本逻辑，实际的2-4译码器芯片——74139的具体逻辑实现如下图所示。它是双2线-4线译码器，并添加了一个Enable输入端来控制。</p>
<div class="figure align-center">
<img alt="../_images/2-4译码器芯片74139.png" src="../_images/2-4译码器芯片74139.png" />
</div>
<p><em>Figure 2-4译码器芯片74139</em></p>
<p>下图展示的是3-8译码器芯片——74138。它具有三个输入端（A0，A1，A2），八个输出端（Y0，Y1，…，Y7），三个使能端（CS1，CS2，CS3）。使能逻辑为 <span class="math notranslate nohighlight">\(EI = CS_{1}\cdot \overline{CS}_{2}\cdot\overline{CS}_{3}\)</span> 。</p>
<div class="figure align-center">
<img alt="../_images/3-8译码器芯片74138.png" src="../_images/3-8译码器芯片74138.png" />
</div>
<p><em>Figure 3-8译码器芯片74138</em></p>
<p>通过将上述的译码器芯片进行组合，可以实现译码器的扩展。下面给出的是4-16线译码的实现方式。</p>
<div class="figure align-center">
<img alt="../_images/4-16线译码.png" src="../_images/4-16线译码.png" />
</div>
<p><em>Figure 4-16线译码</em></p>
<p>二进制译码器的输出涵盖了输入信号的所有组合，可以提供输入信号的所有乘积项组合，于是可用于实现组合逻辑。利用译码器提供的最小项，外加多输入“或”门（与非门）即可实现“积之和”。</p>
<p>7442译码器属于BCD-十进制译码器，它有四BCD输入端（A0，A1，A2，A3）以及十输出端（0，1，2，…，9）。</p>
<div class="figure align-center">
<img alt="../_images/7442译码器.png" src="../_images/7442译码器.png" />
</div>
<p><em>Figure 7442译码器</em></p>
<dl class="docutils">
<dt>定义 <span class="classifier-delimiter">:</span> <span class="classifier">显示码</span></dt>
<dd><p class="first">显示码是将二进制数字转换成特殊显示器件的驱动码，包括下面三种类型：</p>
<ul class="last simple">
<li>字形重叠式：将不同字符形状的电极重叠起来，要显示某字符，只需使相应的电极发亮即可；</li>
<li>分段式：数码由多个发光的条形条组成，应用最为广泛。具有LED型和液晶型；</li>
<li>点阵式：数码可发光点阵组成，利用光点的不同组合便可显示不同的数码和字符图案。</li>
</ul>
</dd>
</dl>
<p>多位数显示要遵守一些默认习惯：个位的0和十分位的0永远显示，而整数部分最高位和小数部分最低位的0不显示，显示译码器需要很好地处理这些情况。</p>
<p>七段显示译码芯片——744511是一种与共阴极数字显示器配合使用的集成译码器。它具有四个输入端（A，B，C，D），七个输出端（a，b，c，d，e，f，g），没有使能端，但有三个辅助控制端（测试/LT，灭灯/BI，冻结/LE）。</p>
<div class="figure align-center">
<img alt="../_images/七段显示译码芯片744511.png" src="../_images/七段显示译码芯片744511.png" />
</div>
<p><em>Figure 七段显示译码芯片744511</em></p>
<div class="figure align-center">
<img alt="../_images/744511驱动数码管方式与辅助控制端功能.png" src="../_images/744511驱动数码管方式与辅助控制端功能.png" />
</div>
<p><em>Figure 744511驱动数码管方式与辅助控制端功能</em></p>
<p>七段显示译码芯片——7448属于二-十进制译码器，是一种与共阴极数字显示器配合使用的集成译码器。它具有四个输入端（A，B，C，D），七个输出端（a，b，c，d，e，f，g），没有使能端，但有三个辅助控制端（动态灭零输出/RBO，测试/LT，动态灭零输入/RBI）。</p>
<p>7448通过RBO和RBI的配合使用，实现多位数显示的“无效0消隐”。</p>
<div class="figure align-center">
<img alt="../_images/7448辅助控制端功能.png" src="../_images/7448辅助控制端功能.png" />
</div>
<p><em>Figure 7448辅助控制端功能</em></p>
</div>
<div class="section" id="id24">
<h4>多路选择器<a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h4>
<p>多路选择器能够根据选择信号，从多个输入信号中选择一个进行输出。</p>
<p>2-1选择器是最基础的多路选择器，它实现的功能是：如果C为1，则Y输出等于B输入；如果C为0，则Y输出等于A输入。这个逻辑功能可以根据 <span class="math notranslate nohighlight">\(Y=B\overline{C}+AC\)</span> 来实现。通过多路选择器的级联可以实现更多输入的选择控制。但是实际上，多路控制器的内部包含了二进制译码器，用与门控制信号是否输出的同时，还用二进制译码器来确定所需输入信号（最小项的特性保证任意时刻只有一个与门被控制打开）。</p>
<div class="figure align-center">
<img alt="../_images/多路选择器.png" src="../_images/多路选择器.png" />
</div>
<p><em>Figure 多路选择器</em></p>
<p>集成多路选择器——74151属于八输入选择器，它有八个输入端，三个控制端（S0，S1，S2），两个输出端（Z， <span class="math notranslate nohighlight">\(\overline{Z}\)</span> ），一个使能端（E）。输出的逻辑表达式为 <span class="math notranslate nohighlight">\(Z=\overline{E}\sum_{i=0}^{7}m_{i}I_{i}\)</span> 。</p>
<div class="figure align-center">
<img alt="../_images/集成多路选择器74151.png" src="../_images/集成多路选择器74151.png" />
</div>
<p><em>Figure 集成多路选择器74151</em></p>
<p>使用74151可以实现3变量逻辑函数。例如，要想实现 <span class="math notranslate nohighlight">\(L=\overline{X}YZ+X\overline{Y}Z+XY\)</span> 的逻辑输出功能，首先将其化为最小项之和，并根据实际情况给定 <span class="math notranslate nohighlight">\(D_{i}\)</span> 的值：</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
   L&amp;=\overline{X}YZ+X\overline{Y}Z+XY \\
    &amp;=\overline{X}YZ+X\overline{Y}Z+XY\overline{Z}+XYZ \\
    &amp;=m_{3}+m_{5}+m_{6}+m_{7} \\
    &amp;=\sum_{i=0}^{7}m_{i}D_{i}
\end{align}\end{split}\]</div>
<div class="figure align-center">
<img alt="../_images/74151实现3变量逻辑函数.png" src="../_images/74151实现3变量逻辑函数.png" />
</div>
<p><em>Figure 74151实现3变量逻辑函数</em></p>
<p>除了从逻辑函数式转换得到最小项之和，还可以直接从真值表得到最小项之和，从而使用74151来实现3变量逻辑函数。</p>
<p>除了3变量逻辑函数，74151还可以实现4变量逻辑函数。例如要想实现 <span class="math notranslate nohighlight">\(F2=A_{1}\cdot B_{0} ~\text{XOR}~ A_{0}\cdot B_{1}=\sum m(6,7,9,11,13,14)\)</span> 的逻辑关系，可以通过先观察3变量与输出的关系，再加入第4个变量对输出的影响的方式，来实现该4变量逻辑函数。</p>
<div class="figure align-center">
<img alt="../_images/74151实现4变量逻辑函数.png" src="../_images/74151实现4变量逻辑函数.png" />
</div>
<p><em>Figure 74151实现4变量逻辑函数</em></p>
<p>4-1多路选择器的VHDL代码实现如下：</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="k">entity</span> <span class="nc">multiplexer41</span> <span class="k">is</span>
   <span class="k">port</span> <span class="p">(</span>
      <span class="n">data0</span><span class="p">,</span> <span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">,</span> <span class="n">data3</span> <span class="o">:</span> <span class="k">in</span> <span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">7</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">);</span>
      <span class="n">sel</span> <span class="o">:</span> <span class="k">in</span> <span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">);</span>
      <span class="n">data_out</span> <span class="o">:</span> <span class="k">out</span> <span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">7</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">)</span>
   <span class="p">);</span>
<span class="k">end</span> <span class="nc">multiplexer41</span><span class="p">;</span>

<span class="k">architecture</span> <span class="nc">multiplexer41_arc</span> <span class="k">of</span> <span class="nc">multiplexer41</span> <span class="k">is</span>
<span class="k">begin</span>
   <span class="k">with</span> <span class="n">sel</span> <span class="k">select</span>
      <span class="n">data_out</span> <span class="o">&lt;=</span> <span class="n">data0</span> <span class="k">when</span> <span class="s">&quot;00&quot;</span><span class="p">,</span>
               <span class="n">data1</span> <span class="k">when</span> <span class="s">&quot;01&quot;</span><span class="p">,</span>
               <span class="n">data2</span> <span class="k">when</span> <span class="s">&quot;10&quot;</span><span class="p">,</span>
               <span class="n">data3</span> <span class="k">when</span> <span class="s">&quot;11&quot;</span><span class="p">,</span>
               <span class="s">&quot;00000000&quot;</span> <span class="k">when</span> <span class="k">others</span><span class="p">;</span>
<span class="k">end</span> <span class="nc">multiplexer41_arc</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="id25">
<h4>多路分配器<a class="headerlink" href="#id25" title="永久链接至标题">¶</a></h4>
<p>多路分配器能够根据选择信号，将一个输入信号传送到多个输出信号。以1-2分配器为例，如果SEL为0，则将D信号送到A；如果SEL为1，则将D信号送到B。与多路选择器类似，多路分配器内部也包含了二进制译码器，用与门来控制信号是否输出，同时用二进制译码器来确定当前选定的通道（保证任意时刻只有一个与门被控制打开）。</p>
<div class="figure align-center">
<img alt="../_images/多路分配器.png" src="../_images/多路分配器.png" />
</div>
<p><em>Figure 多路分配器</em></p>
</div>
<div class="section" id="id26">
<h4>比较器<a class="headerlink" href="#id26" title="永久链接至标题">¶</a></h4>
<p>比较两个二进制数A和B大小关系的电路称为数值比较器。比较结果有三种情况： <span class="math notranslate nohighlight">\(A&gt;B\)</span> 、 <span class="math notranslate nohighlight">\(A=B\)</span> 、 <span class="math notranslate nohighlight">\(A&lt;B\)</span> ，分别通过三个输出端给以指示，因此输出逻辑为</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
   &amp;Y_{(A&gt;B)}=A\overline{B} \\
   &amp;Y_{(A&lt;B)}=\overline{A}B \\
   &amp;Y_{(A=B)}=\overline{A}\cdot\overline{B}+AB
\end{align}\end{split}\]</div>
<p>通过级联的方式可以得到级联多位比较器。多位数值比较器按照“高位数大则该数大，高位数小则该数小，高位相等看低位”的原则，从高位到低位依次进行比较而得到。</p>
<p>集成数值比较器——7485是一个4位数值比较器。</p>
<div class="figure align-center">
<img alt="../_images/集成数值比较器7485.png" src="../_images/集成数值比较器7485.png" />
</div>
<p><em>Figure 集成数值比较器7485</em></p>
<p>如果想拓展数值比较器的位数，可以考虑串联或并联的方式：</p>
<ol class="arabic simple">
<li>串联方式</li>
</ol>
<blockquote>
<div><ul class="simple">
<li>低4位的比较结果作为高4位的条件</li>
<li>n次串联拓展则比较时间需要n倍比较器的延迟时间</li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li>并联方式</li>
</ol>
<blockquote>
<div><ul class="simple">
<li>n组比较并行进行</li>
<li>每组的比较结果再进行一次比较</li>
<li>比较时间只需要两倍的比较器延迟时间</li>
</ul>
</div></blockquote>
<div class="figure align-center">
<img alt="../_images/数值比较器的位数拓展.png" src="../_images/数值比较器的位数拓展.png" />
</div>
<p><em>Figure 数值比较器的位数拓展</em></p>
</div>
</div>
</div>
<div class="section" id="alu">
<h2>ALU(算术逻辑单元)<a class="headerlink" href="#alu" title="永久链接至标题">¶</a></h2>
<p>算术逻辑单元是实现算术运算和逻辑运算的组合逻辑电路。ALU是中央处理器（CPU）的执行单元，是处理器最重要的核心部分，其输入包括运算数和操作码。ALU通常只处理整数，浮点数由FPU负责。大部分ALU都可以完成以下运算：</p>
<ul class="simple">
<li>整数算术运算（加、减，有时还包括乘、除）</li>
<li>位逻辑运算（与、或、非、异或）</li>
<li>其他辅助运算：取反、移位</li>
</ul>
<div class="figure align-center">
<img alt="../_images/74181真值表及逻辑电路图.png" src="../_images/74181真值表及逻辑电路图.png" />
</div>
<p><em>Figure 74181真值表及逻辑电路图</em></p>
<p>通过级联74181可以拓展运算位宽。级联的方式有串行级联和辅助外部超前进位级联。</p>
<div class="figure align-center">
<img alt="../_images/级联74181拓展运算位宽.png" src="../_images/级联74181拓展运算位宽.png" />
</div>
<p><em>Figure 级联74181拓展运算位宽</em></p>
</div>
<div class="section" id="id27">
<h2>可编程逻辑<a class="headerlink" href="#id27" title="永久链接至标题">¶</a></h2>
<p>任何一个逻辑函数表达式都可以转换为一组最小项之和（积之和），称为最小项表达式。这是逻辑函数最接近真值表的表示形式；并且，任意一个逻辑函数，其真值表是唯一的，于是最小项表达式也是唯一的；这样也容易判断在变量的一个输入组合下，逻辑函数的值是否为1。</p>
<p>在具备最小项的前提下，只要选择合适的最小项求和，即可得到满足逻辑要求的输出。</p>
<p>通过更改输出信号与输入信号各种组合积的连接关系（积之和），可以实现任何真值表，也就能实现任何组合逻辑。如下图所示，该可编程器件就是利用积之和的形式来实现任意逻辑函数的，其积阵列固定，速度快；具有规则结构，便于使用自动工具。这种“固定的积”和“设定的和”的形式，就是 <strong>PROM型可编程器件</strong> 。</p>
<div class="figure align-center">
<img alt="../_images/PROM型可编程器件.png" src="../_images/PROM型可编程器件.png" />
</div>
<p><em>Figure PROM型可编程器件</em></p>
<p>PROM型可编程器件会提供完备的积项，这会带来一些缺点：很多情况下存在无用的积项；限制了允许输入信号数目（ <span class="math notranslate nohighlight">\(2^{N}\)</span> ）。因此，PROM型可编程器件仅适用于小规模逻辑。</p>
<p>如果译码器电路所在的“与门”平面连线关系不是固定的，而是和“或门”平面一样可以配置的，那么就可以从“与门”阵列产生更适合具体逻辑所需的组合信号，而非简单的完备积。这种“设定的积”和“设定的和”的形式，就是 <strong>PLA型可编程器件</strong> 。其结构灵活，适用于大规模逻辑；而因为具有两级可设定环节，所以器件速度慢。</p>
<p>另外还存在 <strong>PAL型可编程器件</strong> ，采用“设定的积”和“固定的和”的形式。其与PROM的结构相反，速度快，但是能实现的逻辑存在限制，并且规则推演复杂。</p>
<p>以上的三类可编程器件再加上GAL（Generic Array Logic）归类为SPLD，其容量已经不能满足要求。</p>
<p>复杂的可编程逻辑器件（CPLD）由若干个类似于PLA的标准元件构成，提供更多的逻辑资源。CPLD有三个模块：可编程逻辑（LAB）、可编程互连线（PIA）、可编程引脚（PIO）。三个模块具有不同的功能：</p>
<ul class="simple">
<li>LAB：含有4-20个宏单元。宏单元类似SPLD，内部可编程实现逻辑。宏单元之间可以进行拓展互连，组合提供更多的可控乘积项，满足更复杂逻辑的需求。</li>
<li>PIA：提供LAB内部、LAB之间的全局连接。可以编程改变连接关系。</li>
<li>PIO：引脚功能和方向可以设定。三态缓冲控制可以实现输入输出或双向。引脚输入输出寄存器能改善时序。电气特性可调整，上升沿或驱动电流。</li>
</ul>
<p>将可配置的与门/或门/查找器集成在一起，就构成了可编程逻辑器件（PLD，Programmable Logic Devices）。这是一种数字集成电路的半成品，在其芯片上按一定排列方式集成了大量的门和触发器等基本逻辑元件，使用者可以利用开发工具对其进行加工，即按设计要求将这些片内的元件连接起来，使之完成某个逻辑电路或系统的功能，成为一个可以在实际电路系统中使用的专用电路。</p>
<p>但是和积阵列的方式有许多缺陷：</p>
<ul class="simple">
<li>和积阵列的复杂程度和输入信号的数目有关。</li>
<li>逻辑函数关系和“和积”阵列的具体电路构成有关联：不同器件的分析设计方法不同；存在一些逻辑组合的实现限制；逻辑关系的复杂程序会影响器件的选择和最终实现的效果。</li>
<li>信号连线长，连接的多个开关导致负载大，速度慢。</li>
<li>如果要增加输入输出信号数目，需要多个器件进行级联拓展。</li>
</ul>
<p>于是就有另一种组合逻辑的实现方式—— <strong>多路选择器</strong> 。</p>
<p>例如，对于下图所示的2输入选择器，当输入A恒等于1、B恒等于0，那么该选择器的逻辑就等效于“取反”逻辑；对于下图所示的4输入选择器，通过固定 <span class="math notranslate nohighlight">\(I_{0}I_{1}I_{2}I_{3}\)</span> 的组合形式，可以实现任意二输入逻辑门的功能。之前说明过的74151的使用，就是使用了这种多路选择器/查找表实现任意组合逻辑的方式。</p>
<div class="figure align-center">
<img alt="../_images/多路选择器来实现逻辑功能.png" src="../_images/多路选择器来实现逻辑功能.png" />
</div>
<p><em>Figure 多路选择器实现逻辑功能</em></p>
<p>不过，要实现可编程逻辑，74151这样直接从引脚输入的形式昂贵且修改困难，无法多次设置 <span class="math notranslate nohighlight">\(I_{0}-I_{7}\)</span> 。为了实现可修改的存储器，就产生了基于RAM结构的查找表 <strong>LUT</strong> 。</p>
<p>LUT能够实现N输入的任意逻辑。其电路大小由输入选择信号数目决定；电路结构固定，无需调整更改内部晶体管/FET的连接关系；电路逻辑由外部输入信号状态确定；电路延迟固定，各通道延迟相同。这些特性和所实现的逻辑关系无关。</p>
<div class="figure align-center">
<img alt="../_images/基于LUT的逻辑单元.png" src="../_images/基于LUT的逻辑单元.png" />
</div>
<p><em>Figure 基于LUT的逻辑单元</em></p>
<p>LUT输入端数目和延迟、版图面积、结构设计复杂度等因素互相影响，互相制约，应该综合考虑。</p>
<ol class="arabic simple">
<li>LUT是可编程逻辑阵列的主要部分，也是FPGA最主要的资源，所以要考虑LUT的实现面积。</li>
<li>要通过LUT的面积性能的关系来确定LUT输入的个数。输入数目K的值决定了逻辑单元函数的实现能力和面积利用率。</li>
<li>增加LUT输入端数目能使LUT可实现逻辑功能更强大，但延迟会增大，版图面积也会成指数增加；并且在处理简单逻辑问题时会有资源浪费的风险。</li>
</ol>
<p><strong>FPGA</strong> （Field Programmable Gate Array）属于高密度可编程逻辑器件，其集成度可达上百万门/片以上，可以实现非常复杂的功能电路。不同于PLA/PAL/CPLD，FPGA不包含“积和阵列”；直接利用RAM存储的信息来构成功能逻辑，不需要控制连线开关（速度快，加工简单）；结构上由三部分组成：逻辑模块、I/O模块（用于和器件管脚相连）、编程连接线路和连接开关。</p>
<p>“可编程”的实现工艺主要有三种：熔丝工艺（Anti-fuse）、Flash、SRAM。</p>
<div class="figure align-center">
<img alt="../_images/可编程实现工艺.png" src="../_images/可编程实现工艺.png" />
</div>
<p><em>Figure 可编程实现工艺</em></p>
</div>
<div class="section" id="id28">
<h2>时序逻辑原理<a class="headerlink" href="#id28" title="永久链接至标题">¶</a></h2>
<p>时序逻辑电路的任意时刻的输入信号不仅取决于该时刻的输入信号，而且还取决于电路原来的状态，即与以前的输入信号有关。其包含记忆（存储）元件，存在输出到输入的反馈回路。</p>
<p>首先用反相器首尾相连来构建一个反馈回路：此时电路没有稳定的状态，以反相器的传播延迟为周期进行震荡。再增加一个反相器，两个反相器首尾相连，利用正反馈来维持存储状态——要达到稳定，必须同时满足两个反相器的电压传递曲线。通过两个反相器电压传递曲线的叠加，容易发现两个稳定点和一个位于电压变化过程中间的亚稳态。</p>
<div class="figure align-center">
<img alt="../_images/反相器反馈线路与亚稳态.png" src="../_images/反相器反馈线路与亚稳态.png" />
</div>
<p><em>Figure 反相器反馈线路与亚稳态</em></p>
<dl class="docutils">
<dt>定义 <span class="classifier-delimiter">:</span> <span class="classifier">亚稳态（Metastability）</span></dt>
<dd>亚稳态是满足两个反相器传播函数的状态，这个状态对应无效的逻辑电平。其持续时间不确定，但是如果有一个微小的扰动，就很容易从亚稳态脱离进入其他稳定点。但是，由于扰动的随机性，亚稳态脱离后进入的稳定点是不确定的。</dd>
</dl>
<p>可以减少亚稳态的概率，但是无法彻底消除：</p>
<ol class="arabic simple">
<li>由于晶体管延迟，输出还没有稳定时就被接收了。</li>
<li>通过提高晶体管速度，可以减少亚稳态概率。</li>
<li>输入信号同时发生变化，容易出现亚稳态。</li>
</ol>
<div class="section" id="rsd">
<h3>RS锁存器与D锁存器<a class="headerlink" href="#rsd" title="永久链接至标题">¶</a></h3>
<p>对上述的反相器反馈线路增加两个输入端，就能得到一个基础的可控制存储元件——RS锁存器。</p>
<div class="figure align-center">
<img alt="../_images/RS锁存器.png" src="../_images/RS锁存器.png" />
</div>
<p><em>Figure RS锁存器</em></p>
<p>它的结构最简单，是复杂触发器的基本组成部分。 <span class="math notranslate nohighlight">\(Q,~\overline{Q}\)</span> 是输出端， <span class="math notranslate nohighlight">\(\overline{R}\)</span> 是复位端或称置0输入端， <span class="math notranslate nohighlight">\(\overline{S}\)</span> 是置位端或称置1输入端。其真值表和状态转移图如下</p>
<div class="figure align-center">
<img alt="../_images/RS锁存器的真值表和状态转移图.png" src="../_images/RS锁存器的真值表和状态转移图.png" />
</div>
<p><em>Figure RS锁存器的真值表和状态转移图</em></p>
<div class="admonition attention">
<p class="first admonition-title">注意</p>
<p class="last">由于传播延时的存在，如果要触发器可靠地反转，那么 <span class="math notranslate nohighlight">\(\overline{R}=1\)</span> 或 <span class="math notranslate nohighlight">\(\overline{S}=1\)</span> 的时间应该大于2倍的门的传输延时（最小脉冲宽度）。如果RS的信号脉冲宽度小于最小宽度，锁存器可能进入亚稳态，因此，要想确保锁存器具有正确状态，必须在 <span class="math notranslate nohighlight">\(\overline{R}/\overline{S}\)</span> 端加一个满足最小宽度的信号。</p>
</div>
<p>但是RS锁存器存在缺陷：</p>
<ol class="arabic simple">
<li>电路存储的状态随时受到SR信号的控制，只要SR变化，存储信息就可能受到改写，使用的局限性很大。</li>
<li>另外，输入信号 <span class="math notranslate nohighlight">\(\overline{R},\overline{S}\)</span> 之间存在约束，不能同时有效，限制了触发器逻辑功能的发挥。</li>
</ol>
<p>为了解决上述问题，就设计出了D锁存器。当CP为1时，Q输出跟随D输入；CP为0时，Q输出保持当前状态。</p>
<div class="figure align-center">
<img alt="../_images/D锁存器.png" src="../_images/D锁存器.png" />
</div>
<p><em>Figure D锁存器</em></p>
<div class="admonition attention">
<p class="first admonition-title">注意</p>
<p>类似的，根据RS锁存器结构的要求， <span class="math notranslate nohighlight">\(\overline{R_{D}}/\overline{S_{D}}\)</span> 端信号需要满足最小宽度，那么也就要求输入信号CP/D也需要满足一定的宽度。而CP/D的变化都需要经过一段传播延迟才能使Q端达到稳定，为了避免竞争冒险，就要求CP和D在对应的传播延迟未结束前不能同时变化。</p>
<p class="last">以CP关闭点作为参照，则要求：CP关闭前一段时间内，D必须保持稳定，以允许D信号传播达到稳定；CP关闭后一段时间内，D也必须保持稳定，以允许CP信号传播达到稳定。</p>
</div>
</div>
<div class="section" id="d">
<h3>D触发器<a class="headerlink" href="#d" title="永久链接至标题">¶</a></h3>
<p>D触发器由一对D锁存器构成，其控制信号是反相的：CLK为高，主关从开；CLK为低，主开从关。任意时刻，只有一个锁存器是“导通”的，不存在直接通过两个锁存器的通路。这样，D触发器就实现了“边沿触发”——只有在CLK的上升沿，Q的输出才反映D端的输入信号。D触发器是时序电路的最基本组成单元。</p>
<div class="figure align-center">
<img alt="../_images/D触发器.png" src="../_images/D触发器.png" />
</div>
<p><em>Figure D触发器</em></p>
<div class="figure align-center">
<img alt="../_images/晶体管级的锁存器和触发器设计.png" src="../_images/晶体管级的锁存器和触发器设计.png" />
</div>
<p><em>Figure 晶体管级的锁存器和触发器设计</em></p>
<p>接下来考虑D触发器的时间特性。把D触发器视作一个整体，在CLK上升沿，D被存储到Q。从输出来看从锁存器，Q相对CLK有两个时间延迟：传播延迟 <span class="math notranslate nohighlight">\(t_{\text{pd}}\)</span> 和污染延迟 <span class="math notranslate nohighlight">\(t_{\text{cd}}\)</span> ；而又因为主锁存器的输出 <span class="math notranslate nohighlight">\(Q^{*}\)</span> 要作为从锁存器的输入，其也有传播延迟和污染延迟，所以从输入来看主锁存器，D相对CLK有两个时间要求：建立时间 <span class="math notranslate nohighlight">\(t_{\text{setup}}\)</span> 和保持时间 <span class="math notranslate nohighlight">\(t_{\text{hold}}\)</span> 。</p>
<div class="admonition attention">
<p class="first admonition-title">注意</p>
<ul class="last simple">
<li>主锁存器的 <span class="math notranslate nohighlight">\(t_{\text{cd}}\)</span> 必须大于从锁存器要求的 <span class="math notranslate nohighlight">\(t_{\text{hold}}\)</span> 。</li>
<li>D触发器的数据输入和时钟之间必须满足 <span class="math notranslate nohighlight">\(t_{\text{setup}}\)</span> 和 <span class="math notranslate nohighlight">\(t_{\text{hold}}\)</span> ，否则触发器的输出信号会出现亚稳态。</li>
<li>同步时序逻辑电路中，会大量使用D触发器，综合工具和时序分析工具会检查所有D触发器路径的时间要求，确保 <span class="math notranslate nohighlight">\(t_{\text{setup}}/t_{\text{hold}}\)</span> 要求得到满足。</li>
</ul>
</div>
<div class="figure align-center">
<img alt="../_images/D触发器的时间特性.png" src="../_images/D触发器的时间特性.png" />
</div>
<p><em>Figure D触发器的时间特性</em></p>
<p>系统停留在亚稳态的概率随时间指数减少，可以用MTBF平均无故障时间来衡量亚稳态指标：</p>
<div class="math notranslate nohighlight">
\[\begin{align}
\text{MTBF}  = \frac{e^{T_{\text{MET} }}C_{2}}{C_{1}f_{\text{clock} }f_{\text{data}}}
\end{align}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(T_{\text{MET}}\)</span> 为系统给定的决断时间， <span class="math notranslate nohighlight">\(C_{1},C_{2}\)</span> 是由器件工艺决定的参数， <span class="math notranslate nohighlight">\(f_{\text{clock}}\)</span> 为时钟频率， <span class="math notranslate nohighlight">\(f_{\text{data}}\)</span> 为数据频率。从上式可以发现，提高MTBF的途径有：</p>
<ol class="arabic simple">
<li>降低系统时钟，降低数据频率（由系统参数决定）；</li>
<li>用反应更快的FF（由器件参数决定）；</li>
<li>延长决断时间（由设计决定）。</li>
</ol>
<p>例如，一级D触发器构成的同步器存在亚稳态的概率，通过级联D触发器，使FF1的输出要经过一个CLOCK周期才会被FF2采样，该周期就用于FF1可能产生的亚稳态的退出。这样的多级级联D触发器可以提供更长的亚稳态决断时间，减少亚稳态传播的概率。同步逻辑和异步信号接口时，必须要采用这类措施。</p>
<div class="admonition attention">
<p class="first admonition-title">注意</p>
<ul class="last simple">
<li>级联寄存器必须使用同一个采样时钟。</li>
<li>级联寄存器之间不能有任何组合逻辑。</li>
<li>级联寄存器（除了最后一个寄存器）只能直接驱动下一级寄存器，不能做其他使用。</li>
<li>每一个信号只能用一个同步器。</li>
</ul>
</div>
</div>
<div class="section" id="id29">
<h3>时序逻辑电路分类<a class="headerlink" href="#id29" title="永久链接至标题">¶</a></h3>
<p>时序电路分为两种：同步时序逻辑电路和异步时序逻辑电路。</p>
<p>同步时序电路中各存储单元状态的更新是同时发生的，在同一时钟源的同一脉冲信号边沿作用下同步进行。在时钟脉冲两次作用的间隔期间，即使输入信号发生变化，触发器一般也不会发生状态转换，所以很少发生输出不稳定的现象。同步时序电路的状态很容易用固定周期的时钟脉冲边沿清楚地分离为序列步进。每一个步进都可以通过输入信号和所有触发器的现态单独进行分析，从而有一套比较系统、易于掌握的分析和设计方法。</p>
<p>异步时序逻辑电路没有时钟脉冲，或存在不同的时钟信号，电路状态更新没有统一的时钟脉冲，电路中各存储单元状态的更新不是同时发生的，取决于以任意时间间隔变化的输入信号序列。各存储单元的状态转换因为存在着时间差异而可能造成输出状态短时间的不稳定，而且这种不稳定的状态有时是难以预测的。</p>
</div>
<div class="section" id="id30">
<h3>同步时序逻辑分析<a class="headerlink" href="#id30" title="永久链接至标题">¶</a></h3>
<p>时序电路的输出，不仅取决于电路的输入，而且还依赖电路过去的状态。电路具有记忆能力，包含存储元件。存储元件的输入和输出作为两个分开的信号，组合逻辑电路的输入信号包含了存储元件提供的信息，组合逻辑电路的输出信号提供了待存入存储元件的信息。当前输出时输入信号在上一个特定时刻的状态，记为现态 <span class="math notranslate nohighlight">\(Q^{n}\)</span> ；输入信号仅在下一个特定时刻到来时才被保存，记为次态 <span class="math notranslate nohighlight">\(Q^{n+1}\)</span> 。</p>
<p>时序电路的描述方式有四种：逻辑方程式、状态表、状态图、时序图。</p>
<p><strong>逻辑方程式</strong> 包括三个方程组，依次为输出方程组、驱动方程组、状态方程组。其中状态方程也称为激励方程。对于D触发器，状态方程就是驱动方程。</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
&amp;Z = F_{1}(X,Q^{n}) \\
&amp;Y = F_{2}(X,Q^{n}) \\
&amp;Q^{n+1}=F_{3}(Y,Q^{n})
\end{align}\end{split}\]</div>
<p>根据上述三个方程组，可以唯一地确定时序电路的逻辑功能。不过其缺陷是：直观性不好，不容易由逻辑方程直观地看出该电路的逻辑功能；很难根据给出的设计逻辑要求直接写出上述三个方程组。</p>
<p><strong>状态表</strong> 是输出 <span class="math notranslate nohighlight">\(Z\)</span> 、输入 <span class="math notranslate nohighlight">\(X\)</span> 、次态 <span class="math notranslate nohighlight">\(Q^{n+1}\)</span> 、现态 <span class="math notranslate nohighlight">\(Q^{n}\)</span> 的对应真值表。该真值表描述的是：处在现态 <span class="math notranslate nohighlight">\(Q^{n}\)</span> 的时序逻辑电路，当输入为 <span class="math notranslate nohighlight">\(X\)</span> 时，该电路将进入输出为 <span class="math notranslate nohighlight">\(Z\)</span> 的次态 <span class="math notranslate nohighlight">\(Q^{n+1}\)</span> 。</p>
<p><strong>状态图</strong> 是反映时序逻辑电路的状态转换规律及相应输入、输出取值关系的图形。状态图的圆圈与对应箭头的意义是：在该输入取值条件下，电路将产生相应的输出，同时发生如箭头所指的状态转换。</p>
<p><strong>时序图</strong> 即时序电路的工作波形图，它能直观地描述时序电路的输入信号、时钟信号、输出信号及电路的状态转换等在时间上的对应关系。但是有时并不完全表达出电路状态转换的全部过程。</p>
<div class="figure align-center">
<img alt="../_images/状态表、状态图和时序图.png" src="../_images/状态表、状态图和时序图.png" />
</div>
<p><em>Figure 状态表、状态图和时序图</em></p>
<p>同步时序逻辑的分析方法一般是根据给定的时序逻辑电路图，通过分析求出它的输出Z的变化规律以及电路状态Q的转换规律，进而说明该时序电路的逻辑功能和工作特性。其一般步骤是：</p>
<ol class="arabic">
<li><p class="first">根据给定的时序逻辑电路图写出下列各逻辑方程组：</p>
<blockquote>
<div><ul class="simple">
<li>各触发器的时钟信号CP的逻辑表达式（仅指异步时序逻辑电路）</li>
<li>时序电路的输出方程组： <span class="math notranslate nohighlight">\(Z=F_{1}(X,Q^{n})\)</span></li>
<li>各触发器的激励方程组： <span class="math notranslate nohighlight">\(Y=F_{2}(X,Q^{n})\)</span></li>
</ul>
</div></blockquote>
</li>
<li><p class="first">将激励方程代入相应触发器的特性方程，求得各触发器的状态方程组： <span class="math notranslate nohighlight">\(Q^{n+1}=F_{3}(Y,Q^{n})\)</span></p>
</li>
<li><p class="first">根据状态方程和输出方程，列出该时序逻辑电路的状态表，画出状态图或时序图</p>
</li>
<li><p class="first">用文字描述该时序逻辑电路的逻辑功能</p>
</li>
</ol>
<p>同步时序逻辑的设计方法一般是按照以下步骤进行：</p>
<ol class="arabic">
<li><p class="first">分析功能，明确输入和输出，确定电路所需状态。</p>
</li>
<li><p class="first">考察每一种状态在所有可能的输入组合条件下，其对应的下一状态，得到原始状态图。</p>
<blockquote>
<div><ul class="simple">
<li>n个输入变量，每个状态有 <span class="math notranslate nohighlight">\(2^{n}\)</span> 个可能的转移方向。</li>
<li>需要考虑所有可能，可以转移到其他状态，也可能维持现态。</li>
<li>原始状态图不一定是最简的，可能包含等价状态（输入条件时，输出相同，且向同一个次态转换），通过化简或合并等价状态，得到最小状态图。最小状态图和原始状态图的逻辑功能相同。</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">根据所需状态数量，确定状态信息的位数。每个状态需要对应一个信息位的二进制组合。这个状态编码方案数目是极大的，该方案也会影响最终的电路结构。</p>
</li>
<li><p class="first">根据最小状态图和状态编码，确定状态表。</p>
</li>
<li><p class="first">利用卡诺图等工具，得到状态信息位和输出位的逻辑函数表达式。</p>
</li>
<li><p class="first">检查电路的自启动能力。</p>
</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>选择状态编码方案没有一个标准方法，但是有一些可以遵循的逻辑：</p>
<ul class="last simple">
<li>选择具有逻辑对应含义的状态编码（例如使状态比特直接对应输出）。</li>
<li>给相同输入信号下次态也相同的状态，分配相邻的编码（只有一个1个比特不同）。</li>
<li>相连的状态分配相邻的编码。</li>
<li>尽可能让编码使用更多的1，有利于卡诺图化简。</li>
<li>多尝试其他可能的编码方案。</li>
</ul>
</div>
</div>
<div class="section" id="id31">
<h3>异步时序逻辑分析<a class="headerlink" href="#id31" title="永久链接至标题">¶</a></h3>
<p>异步时序逻辑电路与同步时序逻辑电路的区别在于它没有一个统一的时钟脉冲，因而各存储电路不是同时更新状态，状态之间没有准确界限。</p>
<ul class="simple">
<li>需要单独考虑各触发器的时钟信号作用情况。</li>
<li>状态转换从输入信号影响的第一个触发器开始逐级确定。</li>
<li>状态转换都有一定的时间延迟。</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<ul class="last simple">
<li>从现态到次态的转换过程中有一段“不稳定”的时间，电路的状态是不确定的。</li>
<li>异步时序电路的输入信号（包括时钟信号）必须等待电路进入稳定状态之后才允许发生变化。</li>
<li>异步时序电路的速度慢于同系列的同步时序电路。</li>
</ul>
</div>
<p>下图所示的是一个异步行波计数器，其中 <span class="math notranslate nohighlight">\(Q_{0},Q_{1},Q_{2}\)</span> 的周期分别是CP脉冲的2,4和8倍，相当于将CP脉冲进行了二分频、四分频和八分频。每个周期的 <span class="math notranslate nohighlight">\(Q_{2},Q_{1},Q_{0}\)</span> 组合成二进制数值，电路表现为计数器。如果考虑时钟输入到Q输出的传输延迟时间 <span class="math notranslate nohighlight">\(t_{\text{pd]}}\)</span> ，n位的2进制异步计数器，总延迟时间为 <span class="math notranslate nohighlight">\(nt_{\text{pd}}\)</span> 。</p>
<div class="figure align-center">
<img alt="../_images/异步行波计数器.png" src="../_images/异步行波计数器.png" />
</div>
<p><em>Figure 异步行波计数器</em></p>
</div>
<div class="section" id="id32">
<h3>计数型时序逻辑<a class="headerlink" href="#id32" title="永久链接至标题">¶</a></h3>
<div class="section" id="id33">
<h4>寄存器<a class="headerlink" href="#id33" title="永久链接至标题">¶</a></h4>
<p>四个D触发器构成一个4bit寄存器。</p>
<div class="figure align-center">
<img alt="../_images/4bit寄存器.png" src="../_images/4bit寄存器.png" />
</div>
<p><em>Figure 4bit寄存器</em></p>
</div>
<div class="section" id="id34">
<h4>移位寄存器<a class="headerlink" href="#id34" title="永久链接至标题">¶</a></h4>
<p>移位寄存器能够用于串-并/并-串转换、延时……</p>
<div class="figure align-center">
<img alt="../_images/移位寄存器.png" src="../_images/移位寄存器.png" />
</div>
<p><em>Figure 移位寄存器</em></p>
<p>在线路中加入选择器可以实现双向移位寄存器。</p>
</div>
<div class="section" id="id35">
<h4>扭环形计数器（约翰逊计数器）<a class="headerlink" href="#id35" title="永久链接至标题">¶</a></h4>
<p>在确定初态有效电平后，每过一个CLK周期，输出状态发生变化，而这个过程具有一个周期性，从而产生了时钟同步状态机。</p>
<div class="figure align-center">
<img alt="../_images/扭环计数器（约翰逊计数器）.png" src="../_images/扭环计数器（约翰逊计数器）.png" />
</div>
<p><em>Figure 扭环计数器</em></p>
<p>从上面的扭环计数器计数顺序可以发现，其会存在工作状态环和非工作状态环（异常状态）。为了让该扭环计数器能够自启动，可以额外添加逻辑线路。</p>
<div class="figure align-center">
<img alt="../_images/能自启动的扭环形计数器.png" src="../_images/能自启动的扭环形计数器.png" />
</div>
<p><em>Figure 能自启动的扭环形计数器</em></p>
</div>
<div class="section" id="id36">
<h4>同步二进制计数器<a class="headerlink" href="#id36" title="永久链接至标题">¶</a></h4>
<p>二进制计数器是非常简单的同步时序逻辑。技术区不需要外部输入信号，其输出就是自身内部的计数信息，不需要输出信号。</p>
<div class="figure align-center">
<img alt="../_images/同步二进制计数器.png" src="../_images/同步二进制计数器.png" />
</div>
<p><em>Figure 同步二进制计数器</em></p>
</div>
</div>
<div class="section" id="id37">
<h3>常用时序逻辑组件<a class="headerlink" href="#id37" title="永久链接至标题">¶</a></h3>
<div class="section" id="id38">
<h4>寄存器和移位寄存器<a class="headerlink" href="#id38" title="永久链接至标题">¶</a></h4>
<p>寄存器是计算机和其他数字系统中用来临时时存储代码和数据的逻辑部件。主要组成部分是触发器，通常寄存器由最常用的D触发器组成——一个触发器能存储1位二进制代码，n位触发器存储n位二进制代码。</p>
<p>移位寄存器是具有移位功能的寄存器。为了处理数据，将寄存器中的数据在移位控制信号的作用下，随着时钟信号的同步，依次向高位或低位方向移动1位。</p>
<p><strong>4位集成寄存器74175</strong> 拥有4个独立的D触发器；共用CP脉冲，上升沿触发；共用异步清零信号，低电平有效。</p>
<div class="figure align-center">
<img alt="../_images/4位集成寄存器74175.png" src="../_images/4位集成寄存器74175.png" />
</div>
<p><em>Figure 4位集成寄存器74175</em></p>
<p><strong>8位集成寄存器74374</strong> 和 <strong>8位集成锁存器74373</strong> 。<strong>16位集成寄存器16374</strong> 和 <strong>16位集成锁存器16373</strong> 。</p>
<div class="figure align-center">
<img alt="../_images/8位移位寄存器74164.png" src="../_images/8位移位寄存器74164.png" />
</div>
<p><em>Figure 8位移位寄存器74164</em></p>
<div class="figure align-center">
<img alt="../_images/4位双向移位寄存器74194.png" src="../_images/4位双向移位寄存器74194.png" />
</div>
<p><em>Figure 4位双向移位寄存器74194</em></p>
</div>
<div class="section" id="id39">
<h4>计数器<a class="headerlink" href="#id39" title="永久链接至标题">¶</a></h4>
<p>计数器是数字系统中用的较多的一类基本逻辑器件，基本功能是记录输入时钟脉冲的个数，即实现计数功能，也可以用于分频、定时、产生节拍脉冲和序列脉冲等许多方面。几乎所有的数字设备中都有计数器。</p>
<p>按时钟脉冲的输入方式，可以分为同步计数器、异步计数器；按照数字增减形式，可以分为加法计数器、减法计数器、可逆计数器；按照进位数制，可以分为二进制计数器、非二进制计数器（BCD码计数器、循环码计数器等）；按照容量（模），可以分为五进制、六十进制等。</p>
<div class="figure align-center">
<img alt="../_images/集成双异步二进制加法计数器74393.png" src="../_images/集成双异步二进制加法计数器74393.png" />
</div>
<p><em>Figure 集成双异步二进制加法计数器74393</em></p>
<div class="figure align-center">
<img alt="../_images/异步二进制减法计数器.png" src="../_images/异步二进制减法计数器.png" />
</div>
<p><em>Figure 异步二进制减法计数器</em></p>
<p>低位触发器的输出作为高位触发器的时钟信号，低位变化两次，高位变化一次，从而可以实现逐级二分频。上面的异步计数器 <span class="math notranslate nohighlight">\(Q_{0},Q_{1},Q_{2}\)</span> 的周期分别是CP脉冲的2、4和8倍，相当于将CP脉冲进行了二分频、四分频和八分频，可以用作分频器使用。如果记 <span class="math notranslate nohighlight">\(t_{\text{pd}}\)</span> 为时钟输入到Q输出的传播延迟时间，则每一级触发器增加一级时间延迟 <span class="math notranslate nohighlight">\(t_{\text{pd}}\)</span> ，对于n位的2进制异步计数器，总延迟时间为 <span class="math notranslate nohighlight">\(nt_{\text{pd}}\)</span> ，计数脉冲的最小周期为 <span class="math notranslate nohighlight">\(T_{\text{min}}=nt_{\text{pd}}\)</span> 。</p>
<div class="figure align-center">
<img alt="../_images/3bit同步二进制减法计数器.png" src="../_images/3bit同步二进制减法计数器.png" />
</div>
<p><em>Figure 3bit同步二进制减法计数器</em></p>
<div class="figure align-center">
<img alt="../_images/4bit同步二进制加法计数器.png" src="../_images/4bit同步二进制加法计数器.png" />
</div>
<p><em>Figure 4bit同步二进制加法计数器</em></p>
<p>二进制同步加法计数器的所有触发器同时翻转，比计数脉冲之后一个触发器的传播延迟时间 <span class="math notranslate nohighlight">\(t_{\text{pd}}\)</span> 。进位/溢出信号与时钟信号分离，进位信号由专门的进位链电路生成。同步加法计数器的工作周期取决于触发器的传播延迟时间和进位电路的最大延迟时间。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<ul class="last simple">
<li>进位信号必须在一个时钟信号周期内产生并稳定。</li>
<li>进位链需要判断所有比特位的信息，电路复杂延迟长。</li>
<li>进位链信息不需要存储，单纯的组合电路传播延迟。</li>
</ul>
</div>
<p>集成同步二进制计数器74161/74163是4bit同步二进制加法计数器，拥有计数使能端CEP、CET，4个预置数据输入端D3、D2、D1、D0，低电平有效的清零端 <span class="math notranslate nohighlight">\(\overline{MR}\)</span> （74161是异步清零，清零动作随时生效；74163是同步清零，清零动作只在信号有效的下一个时钟周期的边沿才产生），低电平有效的同步并行预置控制 <span class="math notranslate nohighlight">\(\overline{PE}\)</span> ，进位信号 <span class="math notranslate nohighlight">\(TC = CET \cdot Q_{a} \cdot Q_{b} \cdot Q_{c} \cdot Q_{d}\)</span> 。</p>
<p>通过TC与CET的级联连接，可以实现拓展计数的效果。</p>
<p>集成同步可逆计数器74193是4bit二进制同步可逆计数器，拥有双时钟输入 <span class="math notranslate nohighlight">\(CP_{U}\)</span> 、 <span class="math notranslate nohighlight">\(CP_{D}\)</span> ，4个预置数据输入端 <span class="math notranslate nohighlight">\(P_{0},P_{1},P_{2},P_{3}\)</span> ，高电平有效的异步清零端 <span class="math notranslate nohighlight">\(MR\)</span> ，低电平有效的异步并行预置数 <span class="math notranslate nohighlight">\(\overline{PE}\)</span> 。</p>
<p>用现有的M进制计数器构成N进制计数器时，如果 <span class="math notranslate nohighlight">\(M&gt;N\)</span> ，则只需要一片M进制计数器；如果 <span class="math notranslate nohighlight">\(M&lt;N\)</span> ，则需要多片M进制计数器。当 <span class="math notranslate nohighlight">\(M&gt;N\)</span> 时，通常用两种方法实现：反馈清零法和反馈置数法。</p>
<p>反馈清零法适合于有清零输入端的集成计数器。当计数器从0状态开始计数，输入第N（或N-1）个CP脉冲时，通过与非门译码后，反馈给异步（或同步）清零端一个清零信号，使计数器返回到0状态，接着，计数器重新从0状态开始新的计数周期。</p>
<p>反馈置数法适合于有预置数功能的集成计数器。计数过程将任意一个状态通过译码后，产生一个预置数控制信号反馈给预置数控制端，在下一个CP脉冲信号作用后，计数器就会把预置数输入端的状态置入输出端。预置数控制信号消失后，计数器从被置入的状态重新开始计数。</p>
</div>
</div>
</div>
<div class="section" id="vhdl">
<h2>VHDL<a class="headerlink" href="#vhdl" title="永久链接至标题">¶</a></h2>
<div class="section" id="entity">
<h3>实体entity<a class="headerlink" href="#entity" title="永久链接至标题">¶</a></h3>
<p>实体描述了设计单元的输入输出接口信号或引脚 ，是设计实体经封装后对外的一个通信界面。通过下面的方式来定义：</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="k">entity</span> <span class="nc">and3</span> <span class="k">is</span>
   <span class="k">generic</span> <span class="p">(</span>
         <span class="n">wide</span> <span class="o">:</span> <span class="kt">integer</span> <span class="o">:=</span> <span class="mi">32</span><span class="p">;</span>
         <span class="n">tmp</span> <span class="o">:</span> <span class="kt">integer</span> <span class="o">:=</span> <span class="mi">1</span> <span class="n">ns</span>
      <span class="p">);</span>
   <span class="k">port</span> <span class="p">(</span>
      <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span> <span class="o">:</span> <span class="k">in</span> <span class="kt">std_logic</span><span class="p">;</span>
      <span class="n">s</span> <span class="o">:</span> <span class="k">out</span> <span class="kt">std_logic</span>
   <span class="p">);</span>
<span class="k">end</span> <span class="nc">and3</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition attention">
<p class="first admonition-title">注意</p>
<p class="last">实体名由设计者自由命名 ，用来表示被设计电路芯片的名称 ， 但是必须与VHDL程序的程序的文件名称一致。</p>
</div>
<p>类属 <code class="code docutils literal notranslate"><span class="pre">generic</span></code> 为设计实体与外界通信的静态信息提供通道，用来规定端口的大小、实体中子元件的数目和实体的定时特性等。可以理解为用来设置常数变量符号，让后面可以使用变量符号来进行定义。</p>
<p>端口方向有四种类型，它们的特性如下所示。</p>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="91%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">说明符</th>
<th class="head">含义</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>in</td>
<td>输入。信号进入实体内部，内部的信号不能从该端口输出。</td>
</tr>
<tr class="row-odd"><td>out</td>
<td>输出。信号从实体内部输出，不能通过该端口在实体内部反馈使用。</td>
</tr>
<tr class="row-even"><td>inout</td>
<td>双向。信号不但可以输入到实体内部，还可以从实体内部输出，也允许用于内部反馈。</td>
</tr>
<tr class="row-odd"><td>buffer</td>
<td>缓冲。信号输出到实体外部，同时也可以通过该端口在实体内部反馈使用。</td>
</tr>
</tbody>
</table>
<div class="admonition attention">
<p class="first admonition-title">注意</p>
<p class="last">若实体内部需要反馈输出信号，则输出端口必须被设置为为“BUFFER”，而不能为能为“OUT”。</p>
</div>
<p>常用的数据类型只有两个，一个是 <code class="code docutils literal notranslate"><span class="pre">std_logic</span></code> ，相当于逻辑0/1；另一个是 <code class="code docutils literal notranslate"><span class="pre">std_logic_vector(x</span> <span class="pre">downto</span> <span class="pre">0)</span></code> ，相当于一组二进制数（这里的x等于对应位数-1）。</p>
</div>
<div class="section" id="architecture">
<h3>结构体architecture<a class="headerlink" href="#architecture" title="永久链接至标题">¶</a></h3>
<p>结构体定义了设计单元具体的功能，描述了该基本设计单元的行为、元件和内部的连接关系，具体给出了输入、输出信号之间的逻辑关系。通过下面的方式进行定义：</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="k">architecture</span> <span class="nc">an3_arc</span> <span class="k">of</span> <span class="nc">an3</span> <span class="k">is</span>
   <span class="k">signal</span> <span class="n">tmp</span> <span class="o">:</span> <span class="kt">std_logic</span><span class="p">;</span>
<span class="k">begin</span>
   <span class="n">tmp</span> <span class="o">&lt;=</span> <span class="n">a0</span> <span class="k">and</span> <span class="n">a1</span><span class="p">;</span>
   <span class="n">s</span> <span class="o">&lt;=</span> <span class="n">tmp</span> <span class="k">and</span> <span class="n">a2</span><span class="p">;</span>
<span class="k">end</span> <span class="nc">an3_arc</span><span class="p">;</span>
</pre></div>
</div>
<p>上面的示例是一个静态功能，如果是需要时序逻辑功能的话，要使用 <code class="code docutils literal notranslate"><span class="pre">process</span></code> 进程语句，例如</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="k">architecture</span> <span class="nc">test_arc</span> <span class="k">of</span> <span class="nc">test</span> <span class="k">is</span>

   <span class="k">signal</span> <span class="n">clock</span> <span class="o">:</span> <span class="kt">std_logic</span><span class="p">;</span>

<span class="k">begin</span>
   <span class="n">test</span> <span class="o">:</span> <span class="k">process</span> <span class="p">(</span><span class="n">clock</span><span class="p">)</span>
   <span class="k">begin</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">rising_edge</span><span class="p">(</span><span class="n">clock</span><span class="p">))</span> <span class="k">then</span>
      <span class="n">clock</span> <span class="o">&lt;=</span> <span class="n">clock</span><span class="p">;</span>
     <span class="k">end</span> <span class="k">if</span><span class="p">;</span>
   <span class="k">end</span> <span class="k">process</span> <span class="nc">test</span><span class="p">;</span>
   <span class="n">clkout</span> <span class="o">&lt;=</span> <span class="n">clock</span><span class="p">;</span>
<span class="k">end</span> <span class="nc">test_arc</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">时钟上升沿的描述方式为 <code class="code docutils literal notranslate"><span class="pre">rising_edge(clock)</span></code> ，下降沿的描述方式为 <code class="code docutils literal notranslate"><span class="pre">falling_edge</span> <span class="pre">(Clock)</span></code> 。</p>
</div>
</div>
<div class="section" id="id40">
<h3>操作符号<a class="headerlink" href="#id40" title="永久链接至标题">¶</a></h3>
<div class="section" id="id41">
<h4>赋值符号<a class="headerlink" href="#id41" title="永久链接至标题">¶</a></h4>
<p>一共有三种赋值符号，如下所示：</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="7%" />
<col width="86%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">赋值符号</th>
<th class="head">使用对象</th>
<th class="head">功能</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&lt;=</td>
<td>signal</td>
<td>是一种有延迟的赋值，即赋值操作不是立即生效的。
编译器会根据你代码所描述的功能以及在程序中所处的位置，来决定产生这种延迟的硬件逻辑结构是组合逻辑还是时序逻辑。</td>
</tr>
<tr class="row-odd"><td>:=</td>
<td>variable</td>
<td>是一种无延迟的赋值，即赋值操作立即生效。还有一种用途是初始化赋值，依附于声明语句来进行使用。</td>
</tr>
<tr class="row-even"><td>=&gt;</td>
<td>通用</td>
<td>是映射赋值符号，为赋值符号的左右两边建立起一种连接关系。</td>
</tr>
</tbody>
</table>
<p>使用 <code class="code docutils literal notranslate"><span class="pre">others</span></code> 可以方便地完成对信号和逻辑向量的赋值，下面是一个示例。即使后面修改、拓展或减少了变量的位数，赋值语句也不需要做任何修改，方便代码的维护和调整。</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="k">signal</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">3</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">a</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">=&gt;</span> <span class="sc">&#39;1&#39;</span><span class="p">,</span> <span class="mi">2</span> <span class="o">=&gt;</span> <span class="sc">&#39;1&#39;</span><span class="p">,</span> <span class="k">others</span> <span class="o">=&gt;</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span>  <span class="c1">-- a=&quot;0101&quot;</span>
<span class="n">b</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="k">others</span> <span class="o">=&gt;</span> <span class="sc">&#39;1&#39;</span><span class="p">)</span>  <span class="c1">-- b=&quot;1111&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="id42">
<h4>按位运算符<a class="headerlink" href="#id42" title="永久链接至标题">¶</a></h4>
<p>按位运算符是一类最基本的运算符，可以认为它们直接对应数字逻辑中的与、或、非门等逻辑门。它们的符号表示与功能如下所示。</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">按位运算符</th>
<th class="head">功能</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>not</td>
<td>取反符号。作用于一个操作数，对它进行按位取反。相当于数字逻辑电路中的“非门”。</td>
</tr>
<tr class="row-odd"><td>and</td>
<td>与运算符。是一个双目运算符，即必须有两个操作数，对它们进行按位与运算，相当于数字逻辑电路中的“与门”。</td>
</tr>
<tr class="row-even"><td>or</td>
<td>或运算符。它是一个双目运算符，即必须有两个操作数，对它们进行按位或运算，相当于数字逻辑电路中的“或门”。</td>
</tr>
<tr class="row-odd"><td>xor</td>
<td>异或运算符。它是一个双目运算符，即必须有两个操作数，对它们进行按位异或运算，相当于数字逻辑电路中的“异或门”。</td>
</tr>
<tr class="row-even"><td>xnor</td>
<td>同或运算符，它是一个双目运算符，即必须有两个操作数，对它们进行按位同或运算，相当于数字逻辑电路中的“同或门”。</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="电路原理.html" class="btn btn-neutral float-left" title="电路原理" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="模拟电路.html" class="btn btn-neutral float-right" title="模拟电路" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2022-2023, Koishi.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>