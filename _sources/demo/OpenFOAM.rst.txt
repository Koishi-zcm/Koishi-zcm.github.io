********
OpenFOAM
********

运行算例
========

在运行算例前要先创立一个 :code:`run` 文件夹来存放算例文件。该文件位于 :code:`HOME/OpenFOAM/<USER>/run` 下，其中 :code:`<USER>` 为用户具体的名称。 :code:`run` 文件夹通过 :code:`$FOAM_RUN` 环境变量来定义，可以在终端输入

.. code-block:: 

    ls $FOAM_RUN

来查看 :code:`run` 文件夹的具体位置。如果终端返回空文件夹，则可以输入

.. code-block:: 

    mkdir -p $FOAM_RUN

来创建 :code:`run` 文件夹。


cavity算例
-----------

下面来尝试运行教程算例中的cavity算例。先将该算例拷贝到run目录下，同时进入该算例目录。

.. code-block:: 

    cd $FOAM_RUN
    cp -r $FOAM_TUTORIALS/incompressible/icoFoam/cavity/cavity .
    cd cavity

.. attention:: 上面第二行命令中最后的实心句号 :code:`.` 不可遗漏。

网格生成
^^^^^^^^^^^

接下来用OpenFOAM提供的 :code:`blockMesh` 命令来生成网格。该命令通过读取位于算例文件夹下的 :code:`system/ployMesh` 文件夹内的 :code:`blockMeshDict` 字典文件的信息来生成网格。该文件首先指定各个block顶点(vertices)的坐标，然后通过顶点编号来定义block，最后定义边界面。

进入到算例目录下之后，直接在终端输入该命令即可生成网格：

.. code-block:: 

    blockMesh


初始场设置
^^^^^^^^^^^^^

网格生成完毕后，就可以进入算例目录下查看该算例的初始场信息。因为cavity算例是从0秒开始计算的，所以初始的场信息存储在cavity目录下的 :code:`0` 文件夹下。该文件夹下包含 :code:`p` 和 :code:`U` 两个文件夹，分别是压力场和速度场，它们的初值和边界条件必须指定。

首先进入 :code:`p` 文件查看其信息。可以看到场文件中有3个主要信息：

- :code:`dimensions` 指定场的单位，此处为运动压力，即除以密度之后的压力，单位为 :math:`\mathrm{m^{2}}\mathrm{s^{-2}}` 。
- :code:`internalField` 内部场可以指定为 :code:`uniform` (均一场)，或者每个网格的数据都需要指定的 :code:`nonuniform` (非均一场)。
- :code:`boundaryField` 指定边界场信息，包括边界条件以及所有边界面所需的信息。
  
对于这个cavity算例，边界场由 :code:`walls` 组成，并分为两个 :code:`patches` ：(1) :code:`fixedWalls` 用来指定固定边界，即cavity几何的底部和侧面。(2) :code:`movingWall` 用来指定cavity几何的上部。它们作为壁面，压力边界条件均为 :code:`zeroGradient` ，意味着压力的法向梯度为零。 :code:`frontAndBack` 面即为2D算例的前后面，因此必须指定为 :code:`empty` 。

在该算例中，由于压力是运动压力，作为不可压缩流，其绝对值是没有意义的，关心的是相对压力，同时由于压力边界条件全部为 :code:`zeroGradient` ，需要设置压力参考点和参考值，所以初始场都设置为 :code:`uniform` ，考虑相对值时无所谓具体数值，就保持默认设置，即 :code:`uniform 0` 即可。

进入到 :code:`U` 文件查看其信息。 :code:`dimensions` 是速度的单位。内部场初始化为零，而由于速度是具有三个分量的矢量，因此初始化要写成 :code:`uniform (0 0 0)` 。速度场的 :code:`frontAndBack` 同样为 :code:`empty` ，其他的 :code:`patches` 均为 :code:`fixedWalls` ，且指定为无滑移边界条件即 :code:`fixedValue` ，其值为 :code:`value uniform (0 0 0)` 。因为在该算例中，我们假设顶部壁面以每秒1米的速度在x方向移动，这是一个固定速度即 :code:`fixedValue` ，其具体的值为 :code:`uniform (1 0 0)` ，所以 :code:`movingWall` 当中有相应的些设定。


physicalProperties设置
^^^^^^^^^^^^^^^^^^^^^^^^^

算例的物理特性存储在constant/physicalProperties文件当中。对于cavity算例，唯一需要给定的参数为运动粘度。我们的算例雷诺数为 :code:`10` ，根据雷诺数的定义 :code:`\operatorname{Re}=\frac{d|\boldsymbol{U}|}{\nu}` ，此处特征长度 :code:`d=0.1~\mathrm{m}` ，速度 :code:`|\boldsymbol{U}|=1~\mathrm{m/s}` ，运动粘度为 :code:`0.01~\mathrm{m^{2}/s}` 。指定运动粘度场的方式为：

.. code-block:: C

    nu              [0 2 -1 0 0 0 0] 0.01;


controlDict设置
^^^^^^^^^^^^^^^^^

进入system/controlDict字典来对时间步、输入输出时间、场数据的读取和写入进行控制。因为我们在 :math:`t=0` 的时候开始进行计算，所以设定 :code:`startFrom` 关键字信息为 :code:`startTime` ，并把 :code:`startTime` 指定为 :code:`0` 。运算结束的时候，我们希望能够达到稳定的状态，即流体在空腔内循环，一个通用准则是：层流下流体应该穿过(循环)计算域 :math:`10` 次。不过，该算例中没有进出口，因此流体没有穿过计算域，所以结束时间应该设置为空腔内循环 :math:`10` 次的时间。这里我们设置设置结束时间为 :math:`0.5~\mathrm{s}` ，于是把 :code:`stopAt` 关键字指定为 :code:`endTime` 并指定为 :code:`endTime` 为 :code:`0.5` 。

当运行 :code:`icoFoam` 的时候，为了达到数值稳定以及时间计算精度，库朗数 :math:`\mathrm{Co}=\frac{\delta t|\boldsymbol{U}|}{\delta x}` 应该小于1，其中 :math:`\delta t` 为时间步， :math:`|\boldsymbol{U}|` 为某个网格单元内的速度矢量的模， :code:`\delta x` 为速度方向的网格长度。由于流体域内速度并不均一，为了保证库朗数在各处都小于 :math:`1` ，可以依据最大速度和最小网格尺寸来确定时间步。在该算例中，网格大小是固定的，因此在顶盖附近，速度接近 :math:`1~\mathrm{m/s}` 的地方库朗数最大，网格大小为

.. math::
	\begin{align}
	\delta x=\frac{d}{n}=\frac{0.1}{20}=0.005~\mathrm{m}   
	\end{align}

为了使库朗数在整个流体域都小于或等于1，时间必须小于或等于

.. math::
	\begin{align}
	\delta t=\frac{\mathrm{Co}\delta x }{|\boldsymbol{U}|}=\frac{1\times 0.005}{1}=0.005~\mathrm{s} 
	\end{align}

所以设定时间步 :code:`deltaT` 为 :code:`0.005` 。随着计算的进行，为了在某个固定的时间间隔写入数据，可以通过 :code:`writeControl` 关键字来控制，如果要在 :math:`0.1~\mathrm{s},~0.2~\mathrm{s},\cdots,~0.5~\mathrm{s}` 写入结果，由于计算时间步为 :math:`0.005~\mathrm{s}` ，因此需要每 :math:`20` 个时间步输出一次结果，所以设定 :code:`writeInterval` 为 :code:`20` 。启动运算后OpenFOAM将会在每一个时间步内创建一个文件夹，例如0.1文件夹。


fvScheme设置
^^^^^^^^^^^^^^

在 :code:`system` 文件夹下的 :code:`fvScheme` 文件来指定有限体积法的离散格式。在 :code:`system` 下的 :code:`fvSolution` 文件中指定方程组矩阵求解器、残差以及其他算法控制。


网格查看
^^^^^^^^^^

在运行算例之前，最好通过ParaView查看一下网格。使用ParaView之前，要保证每个版本OpenFOAM对应的Thirdparty文件编译完成，即进入对应的Thirdparty文件目录，在终端输入：

.. code-block:: 

    ./Allwmake


编译完成后，进入算例文件夹下，输入

.. code-block:: 

    paraFoam &

即可打开ParaView窗口。在该窗口中，可以看到算例模块打开的名称为 :code:`cavity.openfoam` 。在Properties选项卡内中找到Mesh Regions，勾选所有网格，之后点击Apply即可加载所有几何数据。找到Display选项卡，可以更改Representation为Wireframe使几何数据以线网格的形式呈现；在Coloring中修改为Solid Color来更改着色方式。


cavityFine算例
-----------------

网格生成
^^^^^^^^^^^

现在在cavity算例的基础上，复制重命名一个算例为cavityFine，进入blockMeshDict编辑网格信息，将原本的 :code:`(20 20 1)` 修改为 :code:`(40 40 1)` 来增加每个方向的网格数量以提高密度。重新进入终端运行 :code:`blockMesh` 重新生成网格。


mapFields场映射
^^^^^^^^^^^^^^^^^

从cavity到cavityFine时，由于几何、边界类型和条件是相同的，因此场本身可以认为是相同的，于是可以用 :code:`mapFields` 命令来把一个给定几何的场信息映射到另一个几何的对应场。读取的场信息通过 :code:`controlDict` 中的 :code:`startFrom` 的 :code:`startTime` 指定，而cavity算例的最终结果存储在0.5文件夹中，因此cavityFine算例中 :code:`controlDict` 文件中的 :code:`startTime` 应该设定为 :code:`0.5` 。设定完后，还需要将0.5文件夹中的 :code:`p` 文件和 :code:`U` 文件当中已存在的点数据全部删除，否则后续会出现点数量不对应的报错。删除后就可以在该算例目录中的终端运行：

.. code-block::

    mapFields ../cavity -consistent

正常运行完成后0.5文件夹内的 :code:`p` 文件和 :code:`U` 文件中的点数据就更新成功了。在网格大小减半后，为了保持 :math:`\mathrm{Co}` 小于 :math:`1` ， :code:`controlDict` 字典中的 :code:`deltaT` 需要设定为 :code:`0.0025` ，同时设置 :code:`endTime` 为 :code:`0.7` 。之前设定写入数据的方式是固定 :code:`timeStep` ，现在我们将 :code:`writeControl` 改为 :code:`runTime` 方式来指定每多少个物理时间间隔来写结果文件，此时 :code:`writeInterval` 为 :code:`0.1` 。


输出log文件
^^^^^^^^^^^^^

为了将输出信息记录为log文件以便查看，通过下面的方式来运行 :code:`icoFoam` ：

.. code-block:: 

    icoFoam > log &

可以直接点开log文件或者用命令 :code:`cat log` 查看其中的信息。删除原本的 :code:`cavity.foam` 文件，重新在终端输入下面的命令来启动Paraview查看结果。

.. code-block:: 

    paraFoam -builtin


获取速度场分量
^^^^^^^^^^^^^^^^

可以在算例目录下运行下面的命令来得到速度场各分量的文件：（注意其中的双引号）

.. code-block:: 

    postProcess -func "components(U)"

之后就可以在ParaView中Refresh Times来加载新的场，同时注意如果网格选择了边界区域，那么在ParaView中的插值会出现问题，因此要不能勾选边界面如 :code:`movingWall` ， :code:`fixedWalls` 和 :code:`frontAndBack` ，只勾选 :code:`internalMesh` 。


绘制指定线上的数据图表
^^^^^^^^^^^^^^^^^^^^^^^^

现在，在ParaView当中，对cavity.foam添加Filter，选择 :code:`Data Analysis` 中的 :code:`Plot Over Line` 。设置线的起始端和结束端，这里设置 :code:`Point1` 起始点为 :code:`(0.05,0,0.005)` ，在 :code:`Point2` 中设置终点为 :code:`(0.05,0.1,0.005)` ，同时设置 :code:`Resolution` 为 :code:`100` 。点击Apply后就会生成对应的图表，默认在Display面板中设置 :code:`Attribute Type` 为 :code:`Point Data` ，设置 :code:`X Array name` 为 :code:`arc_length` 。可以在 :code:`Series Parameters` 中选择显示的场，同时左键选择对应的量之后，可以进一步设置线条颜色、标签名、线条宽度、线条类型、标记点类型、坐标轴类型。



cavityGrade算例
----------------

在对任何一个算例求解之前应该预测哪里误差比较大然后在那一部分细化网格。在cavity算例中，速度最大的变动发生在壁面处，因此这一部分网格可以进行非均匀化处理。从blockMeshDict文件中可以看到，在该算例中使用了4个blocks，上下面和左右面都需要网格非均匀化分布处理，每个block在x,y方向都有10个网格，最大网格和最小网格的大小比为2。可以执行 :code:`blockMesh` 命令后用ParaView查看一下非均匀化处理之后的网格情况。

因为顶盖附近的速度最高，网格最小，顶盖附近的库朗数也会变大，所以要计算一下顶盖附近网格的大小来确定适合本算例的时间步。当使用一个非均匀网格时，如果长度为 :math:`l` ，内置 :math:`n` 个网格单元，最末端和起始端网格比为 :math:`R` ，那么最小的网格大小就是 :math:`\delta x` ，其大小为

.. math::
    \begin{align}
    \delta x=l \frac{r - 1}{\alpha r - 1} 
    \end{align}

其中 :math:`r=R^{\frac{1}{n-1}}` 是相邻网格单元的大小比，且有

.. math::
    \begin{align}
    \alpha =\left \{  \begin{array}{cl}
    R & R>1; \\
    1-r^{-n}r^{-1} & R<1;
    \end{array} \right.
    \end{align}

对于cavityGrade算例，每个方向网格数为10，最大网格单元和最小网格单元大小比为2，block的高宽为 :math:`0.05~\mathrm{m}` ，因此最小的网格单元为 :math:`3.45~\mathrm{mm}` ，从而可知时间步应该小于 :math:`3.45~\mathrm{ms}` 才能保证库朗数小于1。为了方便写入每个时间步的计算结果， :code:`deltaT` 设置为 :math:`2.5~\mathrm{ms}` ， :code:`writeInterval` 设置为 :code:`40` ，因此每隔0.1秒写一个结果文件。本算例的 :code:`startTime` 需要设置为cavityFine的结束时间，即 :math:`0.7~\mathrm{s}` ，而由于cavity和cavityFine算例都已经收敛地很好了，因此整个算例只需要计算 :math:`0.1~\mathrm{s}` ，即结束时间 :code:`endTime` 设为 :code:`0.8` 。之后在cavityGrade目录下使用下面的命令即可映射结果：

.. code-block::

    mapFields ../cavityFine -consistent

运行 :code:`icoFoam` 监控运行输出信息，并对结果后处理与之前的结果比对。



cavityHighRe算例
--------------------

目前的算例雷诺数非常低，仅为10，可以快速地达到稳定状态，并且只有一个非常小的涡旋存在于空腔的底角。接下来我们把雷诺数增加到100，这会明显增加收敛时间。首先拷贝cavity算例并命名为cavityHighRe。可以在run目录下用下面的命令来完成拷贝：

.. code-block:: 

    foamCloneCase -latestTime cavity cavityHighRe

进入cavityHighRe算例中的constant文件夹，编辑physicalProperties文件，为了让雷诺数扩大为10倍，可以通过把粘度降低为原来的1/10来实现，即变为 :math:`10\mathrm{e}-3~\mathrm{m^{2}s^{-1}}` 。修改 :code:`startTime` 为 :code:`latestTime` ，结束时间 :code:`endTime` 设为 :math:`2~\mathrm{s}` 。

接下来在算例目录下运行算例查看输出。可以用下面的命令来以后台进程的方式来运行算例，其中的UNIX命令 :code:`nohup` 表示当用户退出登录时程序依然继续运行， :code:`nice` 用于调整进程优先级， :code:`-20` 对应最高优先进程， :code:`19` 对应最低优先进程。

.. code-block:: 

    nohup nice -n 19 icoFoam > log &


.. note:: 

    查看log文件可以发现，icoFoam在非常短的时间内就停止了对速度进行迭代， :code:`No Iterations 0` 表示速度的求解已经停止，并且在压力的初始残差小于 :code:`fvSolution` 设定的残差值 :code:`10e-6` 之后，求解就已经收敛。

接下来可以用ParaView查看结果的速度矢量，可以发现角落里的第二个涡略微变大了。可以继续尝试减少粘度来增加雷诺数并重新运行算例，涡的数量会增加，因此也就需要在涡的附近增加网格来求解更复杂的流型。另外，高雷诺数也增加了收敛所需要的时间，需要监控残差并延长求解时间以确保收敛。


cavityRAS算例
--------------

在如果继续用上一个算例的思想来求解湍流域的话，提高网格数量和增加求解时间将会带来求解稳定性较差、计算资源消耗庞大的问题。接下来我们使用Reynolds-Average Simulation (RAS)湍流模型来求解流体的平均行为以及统计波动，算例雷诺数为 :code:`10e4` 的顶盖驱动流，使用附带壁面函数的标准 :math:`k-\varepsilon` 模型来进行求解。这会出现两个新的变量：湍流动能场 :math:`k` 和湍流动能耗散率场 :math:`\varepsilon` ，需要使用的求解器为 :code:`pisoFoam` 。

首先从 :code:`tutorials/incompressible/pisoFoam/RAS` 文件夹中将 :code:`cavity` 算例复制出来并重命名为 :code:`cavityRAS` 。进入算例目录，直接使用 :code:`blockMesh` 生成网格。

.. note:: 当使用附带壁面函数的标准 :math:`k-\varepsilon` 模型时，没必要引入非均匀网格，因为壁面附近的流型已经被模化而不是直接求解。

OpenFOAM自带的壁面函数边界条件可以分别用于不同边界面，不同壁面可以使用不同的壁面边界条件。我们可以对湍流粘度场 :math:`\nu_{t}` 进行修改以使用不同的壁面函数，其位于 :code:`0/nut` 文件夹内。在该算例中，通过把 :code:`movingWall` 和 :code:`fixedWall` 指定为 :code:`nutWallFunction` 类型来使用标准壁面函数模型。如果想指定其他的壁面边界模型，例如指定为粗糙壁面边界类型，可以通过 :code:`nutRoughWallFunction` 关键词来指定。

我们可以打开 :math:`k` 文件和 :math:`\varepsilon` 文件来查看它们的边界类型。对于壁面边界条件， :math:`\varepsilon` 为 :code:`epsilonWallFunction` 边界条件， :math:`k` 为 :code:`kqRWallFunction` 边界条件。 :code:`kqRWallFunction` 是一个普适性边界条件，它可以用于任何的湍动能类场，例如 :math:`k` 、 :math:`q` 以及雷诺应力 :math:`R` 场。最初的 :math:`k` 和 :math:`\varepsilon` 值通过对速度波动量 :math:`\boldsymbol{U}'` 和湍流尺度量 :math:`l` 进行预估来计算，它们的计算公式为：

.. math::
    \begin{align}
    & k=\frac{1}{2}\overline{\boldsymbol{U}'\cdot \boldsymbol{U}'}, && \varepsilon =\frac{C_{\mu}^{0.75}k^{1.5}}{l} 
    \end{align}

其中 :math:`C_{\mu}` 是 :math:`k-\varepsilon` 模型的标准参数，其值为 :math:`0.09` 。对于笛卡尔坐标系， :math:`k` 的计算公式可以改写为

.. math::
    \begin{align}
    k=\frac{1}{2}\left ( U_{x}'^{2}+U_{y}'^{2}+U_{z}'^{2} \right )
    \end{align}

其中 :math:`U_{x}'` , :math:`U_{y}'` , :math:`U_{z}'` 是速度在 :math:`x,y,z` 方向的脉动速度。

在本算例中，我们假定其为各向同性湍流，满足 :math:`U_{x}'^{2}=U_{y}'^{2}=U_{z}'^{2}` ，其值为顶盖速度的 :math:`5\%` ，湍流尺度为正方体宽度的 :math:`20\%` 即 :math:`0.1~\mathrm{m}` ，从而可以计算出 :math:`k` 和 :math:`\varepsilon` 的初始条件：

.. math::
    \begin{align}
    & U_{x}'=U_{y}'=U_{z}'=\frac{5}{100}~\mathrm{m/s} \\
    & k=\frac{3}{2}(\frac{5}{100})^{2} = 3.75\times 10^{-3}~\mathrm{m^{2}s^{-2}} \\
    & \varepsilon =\frac{C_{\mu}^{0.75}k^{.15}}{l}\approx 7.54\times 10^{-4}~\mathrm{m^{2}s^{-2}}    
    \end{align}

速度和压力的边界条件跟之前的相同，为 :code:`(0 0 0)` 和 :code:`0` 。

目前存在很多的湍流模型，在大多数瞬态求解器中，湍流模型是在运行时进行选择的。求解器最开始运行的时候，它会读取 :code:`constant/momentum Transport` 文件中的 :code:`simulationType` 关键字来获取湍流模型的相关信息。可选的 :code:`simulationType` 包括 :code:`laminar` ， :code:`RAS` 和 :code:`LES` 。在该算例中我们选择 :code:`RAS` ，并选择标准 :math:`k-\varepsilon` 模型 :code:`kEpsilon` ，同时要确保 :code:`turbulence` 设置为 :code:`on` 状态。每个湍流模型的参数都存储在每个湍流模型的代码中并且具有一个默认值，如果 :code:`printCoeffs` 设置为 :code:`on` 的话，那么这些参数的值会被输出到终端。这些模型的参数也可以通过在 :code:`RAS` 子字典文件中自定义来修改。

接下来到 :code:`physicalProperties` 文件中设置层流粘度。经过计算可知当设置动力粘度为 :code:`10e-5` 时雷诺数可以达到 :math:`10^{4}` 。最后进入 :code:`controlDict` 里面进行调整。为了保证库朗数小于1，将 :code:`deltaT` 设置为 :code:`0.005` ，并将结束时间设置为 :math:`10~\mathrm{s}` 。

此时在算例目录下进入终端键入 :code:`pisoFoam` 命令来运行算例。在这个算例中，由于粘度非常低，顶盖附近的边界层会非常薄，而我们顶盖附近的网格又比较稀疏，因此在这些网格中的速度要比顶盖的速度小得多。实际上，大约100个时间步之后，可以看到顶盖附近的网格单元速度的上限大约为 :math:`0.2~\mathrm{m/s}` ，因此最大库朗数不会超过 :math:`0.2` ，从而可以通过调节时间步来增大库朗数的同时保持小于1的条件。这里，我们从第10秒开始，将 :code:`endTime` 设置为 :code:`20` ，同时调节 :code:`deltaT` 为 :code:`0.02` ，重新运行。

.. note:: 监控残差情况可以判断是否达到稳态，或者算例的某个结果场达到了一种循环的状态。后者的情况下，算例可能永远不会收敛，但这并不意味着计算地不精确。


cavityClipped算例
-------------------

有时候可能会需要改变一下几何模型然后重新计算，在这种情况下最好保留所有计算过的文件，并在新算例中调用它们。然而，在新的几何模型中，场数据可能不一样了。不过， :code:`mapFields` 程序可以处理完全一样的几何或者不一样的几何，以及重合边界或者非重合边界。这里我们来运行 :code:`icoFoam/cavity/cavityClipped` 算例。在这个算例中，几何模型在底部的右边有一个边长为0.04米正方形被移除，可以进入 :code:`blockMeshDict` 来查看网格细节。直接使用 :code:`blockMesh` 生成网格， :code:`patches` 参考之前算例的设定。为了在 :code:`mapFields` 的过程中便于区分，在本算例中，将原本的 :code:`movingWall` 改名为 :code:`lid` 。

在非连续几何的映射中，不能保证所有场数据都能映射过来。在某些区域，原始场并不包含相关数据，这些区域还是被映射场的原始数据，因此在映射前，在响应的时间步内就应该存在响应的场数据。在这个算例中，我们从0.5秒开始进行映射，因此在 :code:`controlDict` 中设定 :code:`startTime` 为 :code:`0.5` ，并把0秒的场数据拷贝到0.5文件中。

接下来将cavity中的速度和压力场数据映射到cavityClipped算例中。因为映射是不连续的，因此需要编辑 :code:`system/mapFieldsDict` 文件。该文件内包含两个关键词： :code:`patchMap` 和 :code:`cuttingPatches` 。

如果想把原始场的 :code:`patches` 条件映射到被映射场的 :code:`patches` 的时候，要使用 :code:`patchMap` 。在本算例中，我们的 :code:`lid` 边界条件和cavity算例中的 :code:`movingWall` 边界条件是一致的，因此可以如下设置：

.. code-block:: C

    patchMap        (lid movingWall);

当需要把原始场的内部数据映射到被映射场的边界时，要使用 :code:`cuttingPatches` 。在本算例中，因为 :code:`fixedWalls` 的边界条件为 :code:`noSlip` ，因此我们不需要对 :code:`fixedWalls` 的边界的值进行映射，所以可以指定为空：

.. code-block:: C

    cuttingPatches  ();

.. note:: 如果需要将内部场的值映射到 :code:`fixedWalls` 边界上，则需要在 :code:`fixedWalls` 中指定 :code:`fixedValue` 边界条件，其关键字 :code:`value` 值在映射过程中将会被改写。在这种情况下，需要在 :code:`cuttingPatches` 里面指定 :code:`fixedWalls` 关键词。

接下来就可以执行下面的命令进行映射：

.. code-block:: 

    mapFields ../cavity

之后就可以运行 :code:`icoFoam` 并进入ParaView查看结果。在ParaView中可以直接添加Stream Tracer滤镜来查看流线情况，并且可以添加Aphabetical当中的Extract Block滤镜，选择lid和fixedWalls边界面进行高亮来让图像结果更加漂亮。


plateHole算例
---------------

本算例我们来对一个中心带有圆形空洞的方盘进行线弹性稳态应力分析。整个方盘边长4米，中心空洞的半径为0.5米，该方盘左右面分别承受了一个均匀的 :math:`10~\mathrm{kpa}` 的载荷。由于该几何体是对称的，因此求解域只需要覆盖整个几何体的四分之一即可。这里我们选择右上角作为求解域并绘制对应的网格。

从 :code:`tutorials/stressAnalysis/solidDisplacementFoam` 中将 :code:`plateHole` 算例复制出来，进入 :code:`system/blockMeshDict` 查看网格信息。

作为二维算例，网格需要有两层，其高度也要指定，这里指定为 :code:`0.5` 。从图中可以看出一层有11个顶点，依次编号写出 :code:`vertices` 内容：

.. code-block:: C

    vertices
    (
        (0.5 0 0)                   // 0
        (1 0 0)                     // 1
        (2 0 0)                     // 2
        (2 0.707107 0)              // 3
        (0.707107 0.707107 0)       // 4
        (0.353553 0.353553 0)       // 5
        (2 2 0)                     // 6
        (0.707107 2 0)              // 7
        (0 2 0)                     // 8
        (0 1 0)                     // 9
        (0 0.5 0)                   // 10
        // 二维算例网格的第二层直接在第一层顶点信息的基础上修改高度即可
        (0.5 0 0.5)                 // 11
        (1 0 0.5)                   // 12
        (2 0 0.5)                   // 13
        (2 0.707107 0.5)            // 14
        (0.707107 0.707107 0.5)     // 15
        (0.353553 0.353553 0.5)     // 16
        (2 2 0.5)                   // 17
        (0.707107 2 0.5)            // 18
        (0 2 0.5)                   // 19
        (0 1 0.5)                   // 20
        (0 0.5 0.5)                 // 21
    );

根据图中的block结构，可以看到整个网格划分成了5个大网格块，注意顶点标签顺序决定的block自身坐标系方向，可以在图中看到各个block的 :math:`x_{1},x_{2}` 方向；在设置加密数量的时候要根据各个block之间坐标系方向的配合关系，不能出现同一边缘出现不同的加密设置；并且由于是二维算例，三个方向的加密设置在第三个参数都设置为了 :code:`1` ；同时希望生成均匀网格，所以非均匀化参数全部设置为了 :code:`1` ，如下所示：

.. code-block:: C

    blocks
    (
        hex (5 4 9 10 16 15 20 21) (10 10 1) simpleGrading (1 1 1)
        hex (0 1 4 5 11 12 15 16) (10 10 1) simpleGrading (1 1 1)
        hex (1 2 3 4 12 13 14 15) (20 10 1) simpleGrading (1 1 1)
        hex (4 3 6 7 15 14 17 18) (20 20 1) simpleGrading (1 1 1)
        hex (9 4 7 8 20 15 18 19) (10 20 1) simpleGrading (1 1 1)
    );

然后设置特殊边缘，这里都是圆弧类型边缘，通过 :code:`arc` 关键词指定，需要给定起始点、终止点标签以及该圆弧通过的一个点的坐标。注意不要忘记第二层的网格也需要指定圆弧边缘：

.. code-block:: C

    edges
    (
        arc 0 5 (0.469846 0.17101 0)
        arc 5 10 (0.17101 0.469846 0)
        arc 1 4 (0.939693 0.34202 0)
        arc 4 9 (0.34202 0.939693 0)
        arc 11 16 (0.469846 0.17101 0.5)
        arc 16 21 (0.17101 0.469846 0.5)
        arc 12 15 (0.939693 0.34202 0.5)
        arc 15 20 (0.34202 0.939693 0.5)
    );


接下来设置边界面信息。对于这个算例，可以区分出left,right,up,down,up（这些可以自由命名）以及二维算例统一的上下表面frontAndBack共六个边界面。由于我们是根据对称性只画了右上角的网格，因此left和down边界面实际上是完整网格的对称界面，于是设置为 :code:`symmetryPlane` ；frontAndBack作为二维算例统一的边界面，固定类型为 :code:`empty` ；其余边界面属于普通边界面，指定为 :code:`patch` 即可。通过在 :code:`faces` 里面列出完整的顶点标签列表来指定边界面：

.. code-block:: C

    boundary
    (
        left
        {
            type symmetryPlane;
            faces
            (
                (8 9 20 19)
                (9 10 21 20)
            );
        }
        right
        {
            type patch;
            faces
            (
                (2 3 14 13)
                (3 6 17 14)
            );
        }
        down
        {
            type symmetryPlane;
            faces
            (
                (0 1 12 11)
                (1 2 13 12)
            );
        }
        up
        {
            type patch;
            faces
            (
                (7 8 19 18)
                (6 7 18 17)
            );
        }
        hole
        {
            type patch;
            faces
            (
                (10 5 16 21)
                (5 0 11 16)
            );
        }
        frontAndBack
        {
            type empty;
            faces
            (
                (10 9 4 5)
                (5 4 1 0)
                (1 4 3 2)
                (4 7 6 3)
                (4 9 8 7)
                (21 16 15 20)
                (16 11 12 15)
                (12 13 14 15)
                (15 14 17 18)
                (15 18 19 20)
            );
        }
    );


.. figure:: ../_images/openFOAM/二维中心空洞平板第一层的block结构.png
  :align: center

*Figure 二维中心空洞平板第一层的block结构*



以上就设置好了blockMeshDict，可以通过 :code:`blockMesh` 来生成网格文件夹 :code:`constant/polyMesh` 并通过ParaView查看网格情况。网格生成后就需要指定边界条件的初始场。对于无热应力的单纯应力分析，只有位移量 :math:`D` 需要设定，进入 :code:`0/D` 文件，内部场位移量初始条件设置为：

.. code-block:: C

    internalField   uniform (0 0 0);

然后依次设定各个边界面的初始场信息。对于特殊边界面，例如已经left,down已经指定为了 :code:`symmetryPlane` ，frontAndBack指定为了 :code:`empty` ，那么在设定边界场的时候也要使用对应的类型。而其他没有特殊指定的，就要给定所需类型，在本算例中，应力边界类型是 :code:`tractionDisplacement` ，在该关键词内需要用 :code:`traction` 关键词给定应力边界矢量大小，用 :code:`pressure` 关键词给定边界面压力大小。因为up和hole边界面的牵引力为零，因此边界牵引力和压力设为零，而right边界面的牵引力应该设为 :code:`(1e4 0 0)` ，压力设为零：

.. code-block:: C

    boundaryField
    {
        left
        {
            type            symmetryPlane;
        }
        right
        {
            type            tractionDisplacement;
            traction        uniform (10000 0 0);
            pressure        uniform 0;
            value           uniform (0 0 0);
        }
        down
        {
            type            symmetryPlane;
        }
        up
        {
            type            tractionDisplacement;
            traction        uniform (0 0 0);
            pressure        uniform 0;
            value           uniform (0 0 0);
        }
        hole
        {
            type            tractionDisplacement;
            traction        uniform (0 0 0);
            pressure        uniform 0;
            value           uniform (0 0 0);
        }
        frontAndBack
        {
            type            empty;
        }
    }


接下来进入 :code:`constant/physicalProperties` 设置物理特性。在本算例中，我们需要指定钢材料的物理特性，包括密度为 :math:`7854~\mathrm{kg/m^{3}}` ，杨氏模量为 :math:`2\times10^{11}\mathrm{Pa}` ，泊松比为 :math:`0.3` 。 :code:`solidDisplacementFoam` 求解器也可以计算温度场，因此可以求解和动量方程耦合（通过生成的热应力来耦合）在一起的热物理方程，如果需要的话就需要额外指定热物理特性如热容、热导和热膨胀系数。当然，在本算例中我们不求解热物理方程，因此设定 :code:`planeStress     yes;` 而 :code:`thermalStress   no;` 。下面是各物理特性参数的设置：

.. code-block:: C

    rho
    {
        type        uniform;
        value       7854;
    }

    nu
    {
        type        uniform;
        value       0.3;
    }

    E
    {
        type        uniform;
        value       2e+11;
    }

    Cp
    {
        type        uniform;
        value       434;
    }

    kappa
    {
        type        uniform;
        value       60.5;
    }

    alphav
    {
        type        uniform;
        value       1.1e-05;
    }


接下来进入controlDict进行求解的控制设定。由于这是一个稳态问题，因此时间步无关紧要，方便起见设定时间步长 :code:`deltaT` 为 :code:`1` 。在稳态问题中，时间步也就表示了迭代步。终止时间 :code:`endTime` 设定为 :code:`100` ，即最高迭代次数。写入控制 :code:`writeInterval` 设定为 :code:`20` ：

.. code-block:: C

    application     solidDisplacementFoam;

    startFrom       startTime;

    startTime       0;

    stopAt          endTime;

    endTime         100;

    deltaT          1;

    writeControl    timeStep;

    writeInterval   20;

    purgeWrite      0;

    writeFormat     ascii;

    writePrecision  6;

    writeCompression off;

    timeFormat      general;

    timePrecision   6;

    graphFormat     raw;

    runTimeModifiable true;



接下来进入fvSchemes字典文件进行离散格式设置和求解器控制。本算例分析的是一个稳态问题，因此 :code:`timeScheme` 的时间离散里面选择 :code:`SteadyState` ，这样就屏蔽了时间离散项。应力分析的动量方程包含几个含有位移梯度量的显性项。梯度项计算的精确性和光滑性对结果有着很大影响，一般情况下有限体积离散建立于高斯定律之上，高斯定律对于大部分的模拟也是足够精确的。不过在本算例中，我们使用最小二乘法，该方法对网格质量较差的情况能更好地计算梯度，因此需要修改 :code:`gradSchemes` 关键词下的 :code:`grad(U)` 和 :code:`grad(T)` 改用 :code:`leastSquares` 关键词：

.. code-block:: C

    d2dt2Schemes
    {
        default         steadyState;
    }

    ddtSchemes
    {
        default         Euler;
    }

    gradSchemes
    {
        default         leastSquares;
        grad(D)         leastSquares;
        grad(T)         leastSquares;
    }

    divSchemes
    {
        default         none;
        div(sigmaD)     Gauss linear;
    }

    laplacianSchemes
    {
        default         none;
        laplacian(DD,D) Gauss linear corrected;
        laplacian(kappa,T) Gauss linear corrected;
    }

    interpolationSchemes
    {
        default         linear;
    }

    snGradSchemes
    {
        default         none;
    }



接下来进入fvSolution设置求解线性方程组使用的矩阵求解器。可以看到， :math:`D` 的矩阵求解器为GAMG，是多重网格矩阵求解法；求解器的 :code:`tolerance` 为 :math:`10^{-6}` ；矩阵求解器的相对误差由 :code:`relTol` 控制，用于控制每次迭代的残差减少量。在本算例中，由于方程式中很多项是显性的，并且采用分离迭代求解技术，因此迭代残差设置地太小是不经济的，合理的迭代残差为0.01，在本算例中甚至可以更高设置为0.9。在 :code:`stressAnalysis` 关键词中包含了该求解器所需的控制参数，其中 :code:`nCorrectors` 表示整个方程组求解的外循环数，包括每个时间步的拉伸边界条件。由于这是个稳态问题，我们用时间步代表迭代数，因此可以设置 :code:`nCorrectors` 为1；同时还需要设置求解变量的外循环收敛残差，当达到该值的时候迭代停止，在本算例中我们设置为 :math:`10^{-6}` ：

.. code-block:: C

    solvers
    {
        "(D|T)"
        {
            solver          GAMG;
            tolerance       1e-06;
            relTol          0.9;
            smoother        GaussSeidel;
            nCellsInCoarsestLevel 20;
        }
    }

    stressAnalysis
    {
        compactNormalStress yes;
        nCorrectors     1;
        D               1e-06;
    }


接下来就可以开始运行算例。应该在log文件中查看收敛信息，它包括了迭代数、每步迭代的初始残差和最终残差。根据之前的设定，最终残差应该总是小于最初残差的0.9倍，一旦初始残差小于收敛残差 :math:`10^{-6}` 的时候程序收敛，就可以终止程序：

.. code-block:: 

    solidDisplacementFoam > log &


求解器求解出来的对称张量应力场为sigma，通过 :code:`postProcess` 可以求出该张量的分量，如此每个时间步内就会得到sigmaxx,sigmaxy,sigmaxz,sigmayy,sigmayz,sigmazz分量文件。

.. code-block:: 

    postProcess -func 'components(sigma)'


如果要把计算域中对称面的左边的数据输出出来，可以通过 :code:`postProcess` 使用 :code:`graphUniform` 函数来获得。在此之前，需要 :code:`system/graphUniform` 文件来进行设置。该函数能够提取指定线段中的数据，分别需要设定起始点、终止点和采样点个数，需要提取的场在 :code:`fields` 关键词处指定，而输出坐标点也可以通过 :code:`axis` 关键词来指定，可以指定为x,y,z,xyz四种类型：

.. code-block:: C

    start           (0 0.5 0.25);
    end             (0 2 0.25);
    nPoints         100;

    fields          (sigmaxx);

    axis            y;

    #includeEtc "caseDicts/postProcessing/graphs/graphUniform.cfg"


接下来就可以执行下面的命令来提取数据：

.. code-block:: 

    postProcess -func 'graphUniform'

之后就得到了 :code:`postProcessing/graphUniform` 文件夹，每个时间文件内都包含了指定线段范围处场的数据集，可以导出到其他软件与其他数据配合或进行后处理绘制成图。



damBreak算例
---------------

简化的二维溃坝问题 :code:`tutorial/multiphase/interFoam/laminar/damBreak` 将使用 :code:`interFoam` 来进行求解。该问题为两种液体被一种尖锐的界面（或者自由表面）分隔的瞬态流动。 :code:`interFoam` 中的两相算法基于流体的体积分数法(VOF)，在该方法中，每个网格中的相体积分数（或相分数 :code:`alpha` ）通过求解一个组分输运方程确定。物理属性则基于这个相分数通过加权平均计算。在VOF方法中，组分间的界面不是计算出来的，而是作为相分数场的一个属性表现出来，这个界面需要通过后处理得到。由于相分数可以为0到1之间的任何值，所以相界面并没有被严格定义，因此相界面表示它应存在的那些网格单元。

本算例的物理过程如下：设置为一个静止的水柱，使其位于水箱左侧，在水箱的底部有一个小的障碍，在 :math:`t=0~\mathrm{s}` 时让水柱自由流动发生水柱崩塌。在崩塌过程中，水撞击水箱底部的一个障碍形成复杂的流场结构，其中包括若干被水包裹的气泡。几何场与网格设置如图所示。


.. figure:: ../_images/openFOAM/溃坝的几何场与网格划分.png
  :align: center

*Figure 溃坝的几何场与网格划分*


进入 :code:`system/blockMeshDict` 查看网格信息，可以看到通过 :code:`convertToMeters` 关键词设置了倍数0.146，从而让记录点坐标的时候能有更多整数。在本2D算例中，里面没有在边界中指定 :code:`frontAndBack` 来描述上下面，而是使用了 :code:`defaultPatch` 关键词来给定，这样在生成 :code:`polyMesh/boundary` 后会自动添加 :code:`defaultFaces` ，并且类型为 :code:`empty` 。对于作为水坝壁面的leftWall,rightWall,lowerWall，他们的类型应该设定为 :code:`wall` ；而上边界为了允许流动的出入，可以只简单地指定为 :code:`patch` 类型。设置完成后可以直接运行 :code:`blockMesh` 生成网格文件。


.. note:: 边界面设定为壁面类型 :code:`wall` 时可以在后续应用壁面函数模型或者其他有关壁面的模型。例如在 :code:`interFoam` 求解器中，可以壁面依附模型来附加壁面表面张力的影响。该模型通过将 :code:`alpha` 场的边界条件设置为 :code:`constantAlphaContactAngle` 来实现。如果要使用这个边界条件，必须给出关键词静态接触角 :code:`theta0` 的值。



.. code-block:: C

    convertToMeters 0.146;

    vertices
    (
        (0 0 0)                // 0
        (2 0 0)                // 1
        (2.16438 0 0)          // 2
        (4 0 0)                // 3
        (0 0.32876 0)          // 4
        (2 0.32876 0)          // 5
        (2.16438 0.32876 0)    // 6
        (4 0.32876 0)          // 7
        (0 4 0)                // 8
        (2 4 0)                // 9
        (2.16438 4 0)          // 10
        (4 4 0)                // 11
        // 下面是第二层顶点，设置了高度为0.1
        (0 0 0.1)              // 12
        (2 0 0.1)              // 13
        (2.16438 0 0.1)        // 14
        (4 0 0.1)              // 15
        (0 0.32876 0.1)        // 16
        (2 0.32876 0.1)        // 17
        (2.16438 0.32876 0.1)  // 18
        (4 0.32876 0.1)        // 19
        (0 4 0.1)              // 20
        (2 4 0.1)              // 21
        (2.16438 4 0.1)        // 22
        (4 4 0.1)              // 23
    );

    blocks
    (
        hex (0 1 5 4 12 13 17 16) (23 8 1) simpleGrading (1 1 1)
        hex (2 3 7 6 14 15 19 18) (19 8 1) simpleGrading (1 1 1)
        hex (4 5 9 8 16 17 21 20) (23 42 1) simpleGrading (1 1 1)
        hex (5 6 10 9 17 18 22 21) (4 42 1) simpleGrading (1 1 1)
        hex (6 7 11 10 18 19 23 22) (19 42 1) simpleGrading (1 1 1)
    );

    defaultPatch
    {
        type empty;
    }

    boundary
    (
        leftWall
        {
            type wall;
            faces
            (
                (0 12 16 4)
                (4 16 20 8)
            );
        }
        rightWall
        {
            type wall;
            faces
            (
                (7 19 15 3)
                (11 23 19 7)
            );
        }
        lowerWall
        {
            type wall;
            faces
            (
                (0 1 13 12)
                (1 5 17 13)
                (5 6 18 17)
                (2 14 18 6)
                (2 3 15 14)
            );
        }
        atmosphere
        {
            type patch;
            faces
            (
                (8 20 21 9)
                (9 21 22 10)
                (10 22 23 11)
            );
        }
    );


在本算例中，我们将忽略界面和壁面间的表面张力效应，这可以使用 :code:`constantAlphaContactAngle` 边界条件并设定静态接触角 :math:`\theta=90` 来实现，不过这里我们直接设定 :code:`alpha` 的边界条件为 :code:`zeroGradient` 来实现该效果。

本算例上边界与大气环境自由相通，允许流动的出入，因此 :code:`atmosphere` 界面需要设定边界基础类型为 :code:`patch` 类型，并针对不同的物理量设置不同的边界数值类型：

+--------+-----------------------------+----------------------------------------------------------------------------------+
| 物理量 | 数值类型                    | 含义                                                                             |
+========+=============================+==================================================================================+
| 压力   | totalPressure               | 一种fixedValue条件，利用指定的总压p0和局部速度U来计算得到                        |
+--------+-----------------------------+----------------------------------------------------------------------------------+
| 速度   | pressureInletOutletVelocity | 对所有分量应用zeroGradient条件；当流动为入流是，对边界切向分量应用fixedValue条件 |
+--------+-----------------------------+----------------------------------------------------------------------------------+
| 相分数 | inletOutlet                 | 出流时为zeroGradient条件，入流时则为fixedValue条件                               |
+--------+-----------------------------+----------------------------------------------------------------------------------+

不过在本例中，使用p_rgh场作为初始场而不是p场，所以在所有边界处采用fixedFluxPressure边界条件，且上述的totalPressure类型也要更改为prghTotalPressure。在某些包含重力以及表面张力的求解器中，fixedFluxPressure边界条件能够调节压力梯度以使得边界的通量和速度边界条件相匹配。


下面需要为相分数 :math:`\alpha_{\text{water}}` 指定一个非均匀条件以区分水和空气。两相问题一般区分为1和0两个值，而区域的赋值需要通过setFields实现，因此需要书写system/setFieldsDict字典。在本例中setFieldsDict文件的核心内容为：

.. code-block:: C

    defaultFieldValues
    (
        volScalarFieldValue alpha.water 0
    );

    regions
    (
        boxToCell
        {
            box (0 0 -1) (0.1461 0.292 1);
            fieldValues
            (
                volScalarFieldValue alpha.water 1
            );
        }
    );


其中defaultFieldValues关键词用来设置场的默认值，这个值将会在下面的regions关键词指定的区域以外使用。在regions关键词中，boxToCell通过定义一个最小和最大的矢量来创建一个方块区域，在此区域为水相，即设定值为1。

.. attention:: 

    setFields从文件中读取场并重新定义这些场，然后把它们写入文件，原始的文件将会被覆盖，因此建议在执行setFields前先进行备份。OpenFOAM中通过在原文件名字后面加上 :code:`.orig` 来表示备份文件。



设置完成后就可以在算例目录终端中输入：

.. code-block:: 

    setFields



接下来设置物质特性(物理常量)。对于两相问题，需要在constant文件夹内设置各相物质的physicalProperties以及两相物性phaseProperties，在本例中就需要有physicalProperties.water，physicalProperties.air和phaseProperties三个文件来进行描述。本例中涉及到的物性参数有：

+----------------+------------------------------------+--------+----------------------------+
| 物理量         | 单位                               | 关键词 | 值                         |
+================+====================================+========+============================+
| 水的运动粘度   | :math:`\mathrm{m^{2}\cdot s^{-1}}` | nu     | :math:`1.0\times 10^{-6}`  |
+----------------+------------------------------------+--------+----------------------------+
| 水的密度       | :math:`\mathrm{kg/m^{3}}`          | rho    | :math:`1.0\times 10^{3}`   |
+----------------+------------------------------------+--------+----------------------------+
| 空气的运动粘度 | :math:`\mathrm{m^{2}\cdot s^{-1}}` | nu     | :math:`1.48\times 10^{-5}` |
+----------------+------------------------------------+--------+----------------------------+
| 空气的密度     | :math:`\mathrm{kg/m^{3}}`          | rho    | :math:`1.0`                |
+----------------+------------------------------------+--------+----------------------------+
| 两相表面张力   | :math:`\mathrm{N/m}`               | sigma  | :math:`0.7`                |
+----------------+------------------------------------+--------+----------------------------+

因此三个文件应当如下进行书写：

.. code-block:: C

    FoamFile
    {
        format      ascii;
        class       dictionary;
        location    "constant";
        object      physicalProperties.water;
    }
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    viscosityModel  constant;

    nu              1e-06;

    rho             1000;


.. code-block:: C

    FoamFile
    {
        format      ascii;
        class       dictionary;
        location    "constant";
        object      physicalProperties.air;
    }
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    viscosityModel  constant;

    nu              1.48e-05;

    rho             1;


.. code-block:: C

    FoamFile
    {
        format      ascii;
        class       dictionary;
        location    "constant";
        object      phaseProperties;
    }
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    phases          (water air);

    sigma           0.07;



重力加速度g在真个求解域内统一分布，因此也属于constant文件件内需要设置的内容。与普通的场文件不同，g是uniformDimensionedVectorField类型，因此只需要指定dimensions关键词和value关键词，本例中的书写方式如下：

.. code-block:: C

    FoamFile
    {
        format      ascii;
        class       uniformDimensionedVectorField;
        location    "constant";
        object      g;
    }
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    dimensions      [0 1 -2 0 0 0 0];
    value           (0 -9.81 0);

在constant文件夹内还需要有动量传递文件momentumTransport，在本例中不求解湍流模型，因此simulationType设置为laminar。




与标准流体算法相比，表面追踪算法对库朗数更加敏感。如果采用显性MULES算法，在界面区域库朗数不应该超过上限如0.25；如果在MULESCorr中指定采用半隐型MULES算法，理论上库朗数对相方程求解没有影响，因此库朗数只取决于时间精度。

对于速度容易预测的算例，最好直接指定一个满足库朗数要求的固定时间步长，但这对于复杂的算例来说相当困难。因此，interFoam求解器在controlDict中提供了自动调整时间步长的方法。需要指定adjustTimeStep为yes，设置writeControl为adjustableRunTime，并设置最大库朗数maxCo和最大相场库朗数maxAlphaCo为1.0；时间步长的上限maxDeltaT可以设置为一个不会超过的值，比如1.0。如此就可以在给定的deltaT基础上，根据情况自动缩小时间步长以满足库朗数要求，而给定writeInterval一个具体数值将会强制要求调节时间步长以达到对应时间进行输出。


.. attention:: 在tutorial提供的controlDict中，设置了writeFormat为binary，这对于巨量数据的情况是有益于提升读取速度的；但是如果希望便于查看文件，则修改writeFormat为ascii。



interFoam求解器在求解相场的时候采用了MULES方法，可以保证在任何数值格式、网格类型的情况下的相场有界，因此在使用interFoam求解器时，对流项格式的选择不再局限于如迎风格式的稳定且有界的格式。

对流项格式设置在fvSchemes文件中的divSchemes关键词中。在本例中，动量方程的对流项为 :math:`\nabla \cdot (\rho \boldsymbol{U}\boldsymbol{U})` ，书写为 :code:`div(rhophi, U)` ，这里使用 :code:`Gauss linearUpwind grad(U)` 以实现良好的精度。 :math:`\nabla \cdot (\boldsymbol{U}\alpha_{l})` 书写为 :code:`div(phi, alpha)` ，采用 :code:`vanLeer` 格式，通常情况下有界线性格式需要一个系数，这里设置该系数为1.0来实现最好的稳定性。其他离散项采用常用的格式，因此fvSchemes文件中的核心内容如下：

.. code-block:: C

    ddtSchemes
    {
        default         Euler;
    }

    gradSchemes
    {
        default         Gauss linear;
    }

    divSchemes
    {
        div(rhoPhi,U)  Gauss linearUpwind grad(U);
        div(phi,alpha)  Gauss interfaceCompression vanLeer 1;
        div(((rho*nuEff)*dev2(T(grad(U))))) Gauss linear;
    }

    laplacianSchemes
    {
        default         Gauss linear corrected;
    }

    interpolationSchemes
    {
        default         linear;
    }

    snGradSchemes
    {
        default         corrected;
    }



fvSolution文件控制矩阵求解器，其中的alpha.water子字典中包含了interFoam特定的一些参数。nAlphaCorr代表的是 :math:`\alpha_{l}` 通量修正的次数；nAlphaSubCycles代表的是将每个时间步长均分成对应个数的子步长，循环后加和；MULESCorr即Weller所提出的MULES修正，一般设置为yes；cAlpha是一个控制界面压缩的因子，0相当于无压缩，1相当于守恒压缩，大于1的数表示强化界面压缩，一般取1。本算例的fvSolution文件的核心内容如下：

.. code-block:: C

    solvers
    {
        "alpha.water.*"
        {
            nAlphaCorr      2;
            nAlphaSubCycles 1;
            cAlpha          1;
            
            MULESCorr       yes;
            nLimiterIter    5;
            
            solver          smoothSolver;
            smoother        symGaussSeidel;
            tolerance       1e-8;
            relTol          0;
        }

        "pcorr.*"
        {
            solver          PCG;
            preconditioner  DIC;
            tolerance       1e-5;
            relTol          0;
        }

        p_rgh
        {
            solver          PCG;
            preconditioner  DIC;
            tolerance       1e-07;
            relTol          0.05;
        }

        p_rghFinal
        {
            $p_rgh;
            relTol          0;
        }

        U
        {
            solver          smoothSolver;
            smoother        symGaussSeidel;
            tolerance       1e-06;
            relTol          0;
        }
    }

    PIMPLE
    {
        momentumPredictor   no;
        nOuterCorrectors    1;
        nCorrectors         3;
        nNonOrthogonalCorrectors 0;
    }

    relaxationFactors
    {
        equations
        {
            ".*" 1;
        }
    }


完成后就可以开始运行算例。可以采用tee命令来让程序交互式地运行，同时在终端输出结果并备份输出到文件log：

.. code-block:: 

    interFoam | tee log



damBreakFine算例
-----------------

下面增加damBreak算例的网格数量，并采用多核运算来减少运行时间。首先复制damBreak算例改名为damBreakFine，然后进入system/blockMeshDict修改blocks关键词内容：

.. code-block:: C

    blocks
    (
        hex (0 1 5 4 12 13 17 16) (46 10 1) simpleGrading (1 1 1)
        hex (2 3 7 6 14 15 19 18) (40 10 1) simpleGrading (1 1 1)
        hex (4 5 9 8 16 17 21 20) (46 76 1) simpleGrading (1 2 1)
        hex (5 6 10 9 17 18 22 21) (4 76 1) simpleGrading (1 2 1)
        hex (6 7 11 10 18 19 23 22) (40 76 1) simpleGrading (1 2 1)
    );

运行blockMesh重新生成网格，此时由于网格发生了变化，通过mapFields映射场可能会在界面处产生插值，并且已有的0/alpha.water.gz文件中的网格编号与新生成的网格不相符，因此需要删除该文件并重新运行setFields

OpenFOAM使用区域分解法进行并行计算。在该方法中，几何和相关的场被分割为若干部分并被分配到不同的处理器进行求解。因此，并行运算一个算例的第一步是利用decomposePar分解求解域，所以需要设置decomposeParDict文件。

numberOfSubdomains指定了要将算例分割成为子区域的数量，通常与可用于运算此算例的处理器数一致。本例中，区域分割的方法method选择simple，其对应的simpleCoeffs通过矢量n给定，其分量决定xyz方向分割求解域的个数，必须满足 :math:`n_{x}\times n_{y} \times n_{z}=\text{numberOfSubdomains}` 。最好使每个子区域的网格连接面数量最少。本算例是二维的，因此z方向不能被分割， :math:`n_{z}` 必须设置为1。本例中decomposeParDict文件书写为：

.. code-block:: C

    FoamFile
    {
        format      ascii;
        class       dictionary;
        location    "system";
        object      decomposeParDict;
    }
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    numberOfSubdomains 4;

    method          simple;

    simpleCoeffs
    {
        n               (2 2 1);
    }

    hierarchicalCoeffs
    {
        n               (1 1 1);
        order           xyz;
    }

    manualCoeffs
    {
        dataFile        "";
    }

    distributed     no;

    roots           ( );


完成后就可以在算例目录终端下输入下面的命令对网格进行分解：

.. code-block:: 

    decomposePar

本例中使用openMPI来进行并行运算：

.. code-block:: 

    mpirun -np 4 interFoam -parallel > log &

算例运行结束之后，需要使用reconstructPar命令来将分割后的场和网格重新合并起来。也可以单独对分割后的求解域的一部分进行后处理，例如

.. code-block:: 

    paraFoam -case processor1





cylinder算例
--------------

下面使用potentialFoam来研究圆柱势流(potential flow)，该求解器假设流场不可压缩、无旋无黏、稳态且忽略重力。控制方程有两个：不可压缩流体的质量守恒方程

.. math::
    \begin{align}
    \nabla \cdot \boldsymbol{U}=0
    \end{align}

不可压缩无旋场的稳态压力方程

.. math::
    \begin{align}
    \nabla ^{2}p=0
    \end{align}


.. note:: 

    potentialFoam求解器能够为其他问题提供符合质量守恒方程的初始场，在运行算例之前首先运行势流求解器可以大大加快收敛且增加求解稳定性。





复制算例tutorials/basic/potentialFoam/cylinder。在这个算例中，圆柱是对称的，所以计算域只取上半部分。左边界是入口Inlet，右边界是出口Outlet，下边界和圆柱边界为symmetryPlane，而上边界我们假设计算域在y方向上无穷大，垂直于上边界的速度梯度特别小，因此上边界选择垂直于上边界速度梯度为0的边界条件，即symmetryPlane。运行blockMesh得到网格。

在本算例中，我们不需要设置流体的性质，因为整个流体是不可压缩、无旋、无黏的。在system/controlDict中记录算例运行的参数，而由于我们处理的是稳态问题，所以算例只应该运行一个时间步。

potentialFoam通过迭代来求解压力方程，并且可以对压力方程中的拉普拉斯项进行非正交修正(压力方程中的显式项会在正交修正迭代之后进行更新)。对压力方程的非正交修正迭代次数由fvSolution当中potentialFlow字典的nNonOrthogonalCorrectors关键字来决定。可以明显观察到nNonOrthogonalCorrectors设置为0或3时结果的不同，非正交修正能够使结果与理论解更加相近。

直接运行potentialFoam的时候只会计算U和phi，额外添加控制语句可以输出其他内容：

.. code-block:: 

    potentialFoam -withFunctionObjects -writePhi -writep





pitzDaily算例
------------------

在tutorials/incompressible/simpleFoam/pitzDaily算例中，计算域是一个二维的、由一个窄的入口、一个后向台阶、一个在出口处收缩的喷管组成。simpleFoam求解器的控制方程有两个：不可压缩流体的质量守恒方程

.. math::
    \begin{align}
    \nabla \cdot \boldsymbol{U} = 0
    \end{align}

稳态动量方程

.. math::
    \begin{align}
    \nabla \cdot (\boldsymbol{U}\boldsymbol{U}) + \nabla \cdot \boldsymbol{R} = -\nabla p
    \end{align}

其中 :math:`p` 是动压， :math:`\boldsymbol{R} = \nu_{\text{eff}} \nabla \boldsymbol{U}` 是带有有效动力粘度系数 :math:`\nu_{\text{eff}}` 的粘性力项。 :math:`\nu_{\text{eff}}` 是通过传递模型和湍流模型计算得到的。初始条件 :math:`\boldsymbol{U}=0~\mathrm{m/s}` 、 :math:`p=0~\mathrm{Pa}` ，进口为固定速度入口， :math:`\boldsymbol{U}=(10,0,0)~\mathrm{m/s}` ，出口为固定压力出口 :math:`p=0~\mathrm{Pa}` ，其他边界都是非滑移边界。空气的运动粘度系数为

.. math::
    \begin{align}
    \nu = \frac{\mu}{\rho} = 18.1 \times 10^{-6} / 1.293 = 14.0 ~\mu\mathrm{m^{2}/s}
    \end{align}

湍流模型选用标准 :math:`k-\epsilon` 模型，常数分别为 :math:`C_{\mu} = 0.09` ； :math:`C_{1}=1.44` ； :math:`C_{2}=1.92` ； :math:`\alpha_{k}=1` ； :math:`\alpha_{\varepsilon}=0.76923` 。

.. note:: 

    simpleFoam利用SIMPLE格式来求解稳态不可压缩流体的问题。这个求解器可以使用incompressibleTurbulenceModel库中所有的湍流模式以及incompressibleTransportModel库中的所有牛顿以及非牛顿流体模型。

一般来说，剪切应力(速度梯度)大的区域网格细化尤其重要，这些区域的网格需要比其他剪切应力较其他剪切应力较低的区域更细。在进行求解之前，我们可以提前估计一下在哪些地方容易出现大的剪切应力。在入口处有一个沿着x方向的稳态流动，在流体经过台阶时，这个稳态流动和下方静止的流体之间会产生一个剪切应力，并且在计算域的下半部分产生漩涡，因此剪切应力比较大的区域应该在计算域的中心线附近和靠近壁面的地方。

在本算例中，需要为速度 :math:`\boldsymbol{U}` 、压力 :math:`p` 、湍流动能 :math:`k` 和耗散率 :math:`\varepsilon` 设置边界条件和初始条件。上下边界设置为wall，左边界设置为Inlet，右边界设置为Outlet，这样的边界组合需要在入口处设定 :math:`U` 、 :math:`k` 、 :math:`\varepsilon` 的类型为fixedValue。

:math:`k` 和 :math:`\varepsilon` 的值如下进行计算：假设入口湍流是各向同性，而且入口处的速度波动为 :math:`5\%` 则有

.. math::
    \begin{align}
    U_{x}' = U_{y}' = U_{z}' = \frac{5}{100} \times 10 = 0.5 ~\mathrm{m/s}
    \end{align}

且有

.. math::
    \begin{align}
    k = 1.5 \times (0.5)^{2} = 0.375 ~\mathrm{m^{2}/s^{2}}
    \end{align}

如果假定湍流尺度为入口边界长度的十分之一则有

.. math::
    \begin{align}
    \varepsilon = \frac{C_{\mu}^{0.75}k^{1.5}}{l} = \frac{0.09^{0.75} \times 0.375^{1.5}}{0.1 \times 25.4 \times 10^{-3}} = 14855 ~\mathrm{m^{2}/s^{2}}
    \end{align}

在出口处只需要将 :math:`p` 设置为 :math:`0~\mathrm{Pa}` 。




forwardStep算例
-----------------

本算例将探究前向台阶的超音速绕流，入口速度马赫数为3，在入口附近有一个台阶，在台阶附近会产生激波。复制tutorials/compressible/rhoCentralFoam/forwardStep算例，将使用rhoCentralFoam求解器进行计算。控制方程有四个，分别是质量守恒方程：

.. math::
    \begin{align}
    \frac{\partial \rho}{\partial t} + \nabla \cdot (\rho \boldsymbol{U}) = 0 
    \end{align}

理想气体状态方程：

.. math::
    \begin{align}
    p = \rho RT
    \end{align}


牛顿流体的动量守恒方程：

.. math::
    \begin{align}
    \frac{\partial \rho \boldsymbol{U}}{\partial t} + \nabla \cdot (\rho \boldsymbol{U}\boldsymbol{U}) - \nabla \cdot \mu \nabla \boldsymbol{U} = -\nabla p 
    \end{align}

能量方程(忽略粘性项)和傅里叶定律：

.. math::
    \begin{align}
    & \frac{\partial \rho e}{\partial t} + \nabla \cdot (\rho \boldsymbol{U}e) - \nabla \cdot \frac{k}{c_{\nu}} \nabla e = -p \nabla \cdot \boldsymbol{U}  \\
    & e = C_{\nu} T \\
    & q = -k\nabla T
    \end{align}


算例的初始条件为： :math:`U = 1~\mathrm{m/s}` ， :math:`p = 1~\mathrm{Pa}` ， :math:`T = 1~\mathrm{K}` 。


在physicalProperties文件中，可以看到模型的设置情况：

.. code-block:: C

    thermoType
    {
        type            hePsiThermo;    // 基于密度计算
        mixture         pureMixture;    
        transport       const;          // 拥有固定的动力黏度和热导热系数(普朗特数)
        thermo          hConst;         // 拥有固定的定压比热容
        equationOfState perfectGas;     // 理想气体
        specie          specie;
        energy          sensibleInternalEnergy;   // 以焓作为能量方程的变量
    }

    mixture
    {
        specie
        {
            molWeight       11640.3;    // 物质的摩尔质量g/mol
        }
        thermodynamics
        {
            Cp              2.5;
            Hf              0;
        }
        transport
        {
            mu              0;          // 动力粘度
            Pr              1;          // 普朗特数
        }
    }




网格生成
========


blockMesh
---------

blockMesh能够创建具有分级和弯曲边缘的参数网格，其运行根据式位于 :code:`constant/polyMesh` 文件中的 :code:`blockMeshDict` 字典文件。 :code:`blockMeshDict` 文件的包含的关键词如下所示：

+-------------------------+----------------------------+---------------------------------------------------------------------------+
| 关键词                  | 含义                       | 例子                                                                      |
+=========================+============================+===========================================================================+
| :code:`convertToMeters` | 顶点坐标的放缩比例         | 取0.01时长度单位为毫米                                                    |
+-------------------------+----------------------------+---------------------------------------------------------------------------+
| :code:`vertices`        | 顶点坐标集合               | 原点坐标为 :code:`(0 0 0)`                                                |
+-------------------------+----------------------------+---------------------------------------------------------------------------+
| :code:`edges`           | 用来指定圆弧或样条曲线边缘 | 用两个顶点标签和中间经过点坐标指定圆弧 :code:`arc 1 4 (0.939 0.342 -0.5)` |
+-------------------------+----------------------------+---------------------------------------------------------------------------+
| :code:`block`           | 顶点标签集合和网格大小     | :code:`hex (0 1 2 3 4 5 6 7) (10 10 1) simpleGrading (1 1 1)`             |
+-------------------------+----------------------------+---------------------------------------------------------------------------+
| :code:`patches`         | 面的集合                   | :code:`symmetryPlan base ( (0 1 2 3) )`                                   |
+-------------------------+----------------------------+---------------------------------------------------------------------------+
| :code:`mergePatchPairs` | 合并的面的集合             |                                                                           |
+-------------------------+----------------------------+---------------------------------------------------------------------------+

 

顶点的描述是按照坐标点列表的方式进行的，从上往下依次表示顶点标签的递增，例如下面是一个block的顶点集合表示方式：

.. code-block:: C

    vertices
    (
            (0     0     0  )    // 标签0
            (1     0     0.1)    // 标签1
            (1.1   1     0.1)    // 标签2
            (0     1     0.1)    // 标签3
            (-0.1  -0.1  1  )    // 标签4
            (1.3   0     1.2)    // 标签5
            (1.4   1.1   1.3)    // 标签6
            (0     1     1.1)    // 标签7
    );


边缘的描述需要使用两个顶点标签，不过同样要用关键词指定边缘类型，不同类型还要求更进一步的补充点坐标信息，下面是可用的关键词：

+----------------------+--------------+--------------------+
| 关键词               | 含义         | 补充信息           |
+======================+==============+====================+
| :code:`arc`          | 圆弧         | 一个中间插值点坐标 |
+----------------------+--------------+--------------------+
| :code:`simpleSpline` | 样条曲线     | 一系列插值点坐标   |
+----------------------+--------------+--------------------+
| :code:`polyLine`     | 一组线       | 一系列插值点坐标   |
+----------------------+--------------+--------------------+
| :code:`polySpline`   | 一组样条曲线 | 一系列插值点坐标   |
+----------------------+--------------+--------------------+
| :code:`line`         | 直线         |                    |
+----------------------+--------------+--------------------+

下面是通过标签1顶点和标签5顶点定义的圆弧边缘，该圆弧通过了坐标为 :code:`(1.1  0.0  0.5)` 的点：

.. code-block:: C

    edges
    (
            arc  1  5  (1.1  0.0  0.5)
    );


网格块的定义涉及到点标签集、三个方向的网格数量、非均匀化比例的定义。一个block将会涉及到8个顶点标签，顶点标签的顺序决定了该网格块的坐标方向，也就会影响加密的设置顺序。顶点标签与坐标方向有下面的关系：

- 第一个顶点标签决定了坐标系的原点；
- 从第一个顶点标签位置指向第二个顶点标签位置决定了 :math:`x_{1}` 方向；
- 从第二个顶点标签位置到第三个顶点标签位置决定了 :math:`x_{2}` 方向；
- 前四个顶点标签位置决定了 :math:`x_{3}=0` 的平面位置；
- 从第一个标签位置指向第五个标签位置决定了 :math:`x_{3}` 方向；
- 剩余三个标签类似地依次从第二、三、四个标签位置沿 :math:`x_{3}` 方向移动得到。



snappyHexMesh
---------------

生成背景网格
^^^^^^^^^^^^

该功能可以通过三角面片模型文件(stl,obj,vtk,...)来创建网格，该模型文件应当放置在constant/triSurface文件夹内。同时还需要背景网格来决定计算域和基本网格密度，通常通过blockMesh来生成，而由于一般来说都是要生成长方体规则网格，所以可以按照下面的格式来书写blockMeshDict文件（根据需要修改大小以及边界面类型）：

.. code-block:: C

    /*--------------------------------*- C++ -*----------------------------------*\
      =========                 |
      \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
       \\    /   O peration     | Website:  https://openfoam.org
        \\  /    A nd           | Version:  10
         \\/     M anipulation  |
    \*---------------------------------------------------------------------------*/
    FoamFile
    {
        format      ascii;
        class       dictionary;
        object      blockMeshDict;
    }
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    convertToMeters 1;

        xmin      -3;
        xmax      3;
        ymin      -3;
        ymax      3;
        zmin      0;
        zmax      10;
        
        xcells    40;
        ycells    40;
        zcells    40;

    vertices
    (
        ($xmin $ymin $zmin)
        ($xmax $ymin $zmin)
        ($xmax $ymax $zmin)
        ($xmin $ymax $zmin)
        
        ($xmin $ymin $zmax)
        ($xmax $ymin $zmax)
        ($xmax $ymax $zmax)
        ($xmin $ymax $zmax)
    );

    blocks
    (
        hex (0 1 2 3 4 5 6 7) ($xcells $ycells $zcells) simpleGrading (1 1 1)
    );

    boundary
    (
        inlet
        {
            type patch;
            faces
            (
                (0 4 7 3)
            );
        }
        outlet
        {
            type patch;
            faces
            (
                (1 2 6 5)
            );
        }
        ground
        {
            type patch;
            faces
            (
                (0 3 2 1)
            );
        }
        top
        {
            type patch;
            faces
            (
                (4 5 6 7)
            );
        }
        side1
        {
            type patch;
            faces
            (
                (0 1 5 4)
            );
        }
        side2
        {
            type patch;
            faces
            (
                (3 7 6 2)
            );
        }
    );


    mergePatchPairs
    (
    );


    // ************************************************************************* //


surfaceFeaturesDict
^^^^^^^^^^^^^^^^^^^

然后需要设置位于system文件夹中的surfaceFeaturesDict文件、snappyHexMeshDict文件以及meshQualityDict文件，这三个文件的模板可以从教程案例中复制得到。

首先说明surfaceFeaturesDict文件，它用来提取模型文件的表面特征，需要指定模型文件以及调用的程序，其模板为：

.. code-block:: C

    /*--------------------------------*- C++ -*----------------------------------*\
      =========                 |
      \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
       \\    /   O peration     | Website:  https://openfoam.org
        \\  /    A nd           | Version:  10
         \\/     M anipulation  |
    \*---------------------------------------------------------------------------*/
    FoamFile
    {
        format      ascii;
        class       dictionary;
        object      surfaceFeaturesDict;
    }
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    surfaces ("combined.stl");
    includedAngle 150;

    #includeEtc "caseDicts/surface/surfaceFeaturesDict.cfg"

    // ************************************************************************* //

完成后就可以在算例目录下在终端输入：

.. code-block:: 

    surfaceFeatures

如此就能从几何文件中提取出特征边缘，并在triSurface文件夹内生成cylinder.eMesh文件。



meshQualityDict
^^^^^^^^^^^^^^^

meshQualityDict文件几乎不需要改动，其内容只有调用相应程序：

.. code-block:: C

    /*--------------------------------*- C++ -*----------------------------------*\
      =========                 |
      \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
       \\    /   O peration     | Website:  https://openfoam.org
        \\  /    A nd           | Version:  10
         \\/     M anipulation  |
    \*---------------------------------------------------------------------------*/
    FoamFile
    {
        format      ascii;
        class       dictionary;
        object      meshQualityDict;
    }
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    #includeEtc "caseDicts/mesh/generation/meshQualityDict.cfg"

    //- minFaceWeight (0 -> 0.5)
    //minFaceWeight 0.02;

    // ************************************************************************* //


snappyHexMeshDict
^^^^^^^^^^^^^^^^^

完成上述文件后就可以开始对snappyHexMeshDict文件进行修改。该文件中涉及的关键词如下：

+-------------------------+-----------------------------------------+----------+
| 关键词                  | 含义                                    | 常见赋值 |
+=========================+=========================================+==========+
| castellatedMesh         | 是否创建堞状网格                        | true     |
+-------------------------+-----------------------------------------+----------+
| snap                    | 是否进行表面贴合                        | true     |
+-------------------------+-----------------------------------------+----------+
| addLayers               | 是否添加表面边界层                      | false    |
+-------------------------+-----------------------------------------+----------+
| mergeTolerance          | 合并公差作为初始网格边界框的分数        | 1e-6     |
+-------------------------+-----------------------------------------+----------+
| debug                   | 控制中间网格和网线打印的写入            |          |
+                         +-----------------------------------------+----------+
|                         | 只写最终网格                            | 0        |
+                         +-----------------------------------------+----------+
|                         | 写中间网格                              | 1        |
+                         +-----------------------------------------+----------+
|                         | 用cellLevel写volScalarField进行后期处理 | 2        |
+                         +-----------------------------------------+----------+
|                         | 将当前交叉点写入.obj文件                | 4        |
+-------------------------+-----------------------------------------+----------+
| geometry                | 所使用的表面图形的信息                  |          |
+-------------------------+-----------------------------------------+----------+
| castellatedMeshControls | 生成蜂窝网格的控制信息                  |          |
+-------------------------+-----------------------------------------+----------+
| snapControls            | 表面贴合的控制信息                      |          |
+-------------------------+-----------------------------------------+----------+
| addLayersControls       | 表面边界层添加的控制信息                |          |
+-------------------------+-----------------------------------------+----------+
| meshQualityControls     | 网格质量的控制信息                      |          |
+-------------------------+-----------------------------------------+----------+


geometry
""""""""

在geometry关键词内设置所需的几何文件以及体加密信息。下面是一个简单的案例：

.. code-block:: C

    geometry
    {
        cylinder    // 模型边界面的自定义命名
        {
            type triSurfaceMesh;
            file "cylinder.stl";    // 所用文件
        }

        refinementBox    // 体加密区域的自定义命名
        {
            type searchableBox;    // 体加密类型
            min  (  -5   -5   -1);
            max  (15 15  5);
        }
    };  


如果在stl文件中已经自行定义了各个solid的名字，那么就可以添加 :code:`regions` 关键字来提取这些面域，进而在后续的面加密中各自进行处理。例如：

.. code-block:: C

    geometry
    {
        cylinder    // 模型边界面的自定义命名
        {
            type triSurfaceMesh;
            file "cylinder.stl";    // 所用文件

            regions
            {
                top { name top; }
                bottom { name bottom; }
                wall { name wall; }
            }
        }

        refinementBox    // 体加密区域的自定义命名
        {
            type searchableBox;    // 体加密类型
            min  (  -5   -5   -1);
            max  (15 15  5);
        }
    };  







体加密除了上述方块体加密设置，还有其他可选加密方式：

+--------------------------+----------------+--------------+-----------------+
| 加密类型                 | 类型含义       | 所需参数     | 参数解释        |
+==========================+================+==============+=================+
| searchableBox            | 立方体         | min          | 最小对角点坐标  |
+                          +                +--------------+-----------------+
|                          |                | max          | 最大对角点坐标  |
+--------------------------+----------------+--------------+-----------------+
| searchableCylinder       | 圆柱           | point1       | 中轴线端点1     |
+                          +                +--------------+-----------------+
|                          |                | point2       | 中轴线端点2     |
+                          +                +--------------+-----------------+
|                          |                | radius       | 外圆半径        |
+--------------------------+----------------+--------------+-----------------+
| searchableSphere         | 球             | Centre       | 中心点坐标      |
+                          +                +--------------+-----------------+
|                          |                | radius       | 球半径          |
+--------------------------+----------------+--------------+-----------------+
| searchableCone           | 圆锥体（空心） | point1       | 中轴线端点1     |
+                          +                +--------------+-----------------+
|                          |                | point2       | 中轴线端点2     |
+                          +                +--------------+-----------------+
|                          |                | radius1      | 断面1外圆半径   |
+                          +                +--------------+-----------------+
|                          |                | radius2      | 断面2外圆半径   |
+                          +                +--------------+-----------------+
|                          |                | innerRadius1 | 断面1内圆半径   |
+                          +                +--------------+-----------------+
|                          |                | innerRadius2 | 断面2内圆半径   |
+--------------------------+----------------+--------------+-----------------+
| searchableRotatedBox     | 旋转立方体     | origin       | 最小对角点坐标  |
+                          +                +--------------+-----------------+
|                          |                | span         | XYZ方向尺寸长度 |
+                          +                +--------------+-----------------+
|                          |                | e1           | 几何i方向向量   |
+                          +                +--------------+-----------------+
|                          |                | e2           | 几何j方向向量   |
+                          +                +--------------+-----------------+
|                          |                | e3           | 几何k方向向量   |
+--------------------------+----------------+--------------+-----------------+
| searchableExtrudedCircle | 圆管           | file         | 导入曲线文件    |
+                          +                +--------------+-----------------+
|                          |                | radius       | 圆管半径        |
+--------------------------+----------------+--------------+-----------------+



castellatedMeshControls
"""""""""""""""""""""""

全局网格细化参数在castellatedMeshControls中设置，其目的为细化背景网格，通过细化背景网格以使几何特征与几何表面上拥有一定网格量，以提高几何特征捕捉的准确性。同时通过参数设置，保证网格细化时尺寸变化尽量平缓。在该关键词内需要设置的内容包括：

+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| 关键词                     | 含义                 | 常用赋值           | 备注                                                                                                                                                                                                                                                                        |
+============================+======================+====================+=============================================================================================================================================================================================================================================================================+
| maxGlobalCells             | 全局最大网格量       | 2e+06              | 该功能主要目的是保证网格细化过程中，避免划分网格量太大，导致计算机内存溢出。当划分网格量超过此值时，细化过程将立即终止。此时，局部细化功能可能终止运行。                                                                                                                    |
+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| maxLocalCells              | 单核最大网格量       | 1e+06              | 该参数主要应用于网格并行计算，其指定了细化网格过程中每个处理器处理的最大数量网格数。设置该参数时请保证一定的富余量，经常重新平衡每个处理器计算量将减慢网格生成过程。                                                                                                        |
+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| maxLoadUnbalance           | 最大负载平衡参数     | 0.1                | 该参数主要应用于网格并行计算。当该参数值为0时，即强制负载平衡，即各处理器间处理的网格量严格保持单元总数/计算核数。较低的值可能会导致系统频繁的均衡网格负载量。而参数值设置为1时，则完全禁用网格均衡操作。                                                                   |
+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minRefinementCells         | 最小细化单元数       | 0                  | 该参数指定了需细化特征的最小单元数。若特征上网格单元数量小于该参数，则停止对其细化。                                                                                                                                                                                        |
+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nCellsBetweenLevels        | 缓冲层数             | 3                  | 若用户设置参数值为1，则表示不添加过渡区域。越大的值可使得网格大小过渡越平缓，但将导致网格量增加。                                                                                                                                                                           |
+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| resolveFeatureAngle        | 自动检测角           | 30                 | 当曲率变化角超过该参数值时，特征区域网格使用最大面细化等级，而低于此角度的特征均采用最小面细化级别。默认参数值为30，参数值设置为360时，表示关闭此功能。该参数生效的前置条件：(1)面细化参数中最小和最大细化等级需不同。(2)面贴合过程中特征捕捉需采用隐式方法。               |
+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| locationInMesh             | 网格域控制点         | (-3.25 -2.25 1.25) | 指定需要保留背景网格表面与封闭几何表面之间的网格，还是封闭几何内部的网格。保留区域网格中需包含指定的参数点，该点的位置不能和网格单元的面或边重合。                                                                                                                          |
+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| allowFreeStandingZoneFaces | 允许有独立面         | false              | 该参数定义是否允许几何中有独立的面存在。若设置参数值为false，则表示在refinementSurfaces中指定的faceZones仅位于相应cellZones的边界上，作为不同域之间交界面。若该参数值为true，则允许此faceZones作为独立面域（例如：挡板界面等）。如果用户没有指定faceZones，则该参数不生效。 |
+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| features                   | 需要细化的特性信息   |                    |                                                                                                                                                                                                                                                                             |
+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| refinementRegions          | 用于细化的区域的信息 |                    |                                                                                                                                                                                                                                                                             |
+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| refinementSurfaces         | 用于细化的曲面的信息 |                    |                                                                                                                                                                                                                                                                             |
+----------------------------+----------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+



一般情况下，castellatedMeshControls可以按照如下方式设置：

.. code-block:: C

    castellatedMeshControls
    {
        features
        (
          { file  "cylinder.eMesh"; level 1; }
        );

        refinementSurfaces
        {
            cylinder    // 对应之前定义的几何表面名称
            {
                level (3 3);
                patchInfo { type wall; }
            }
        }

        refinementRegions
        {
            refinementBox    // 对应之前定义的加密区域名称
            {
                mode    inside;
                level   2;
            }
        }

        locationInMesh (-3.25 -2.25 1.25);
    }



如果在之前 :code:`geometry` 部分指明了不同的regions，那么在 :code:`refinementSurfaces` 就可以针对不同的面域进行不同程度的细化，同时赋予不同的边界类型：

.. code-block:: C

    castellatedMeshControls
    {
        features
        (
          { file  "cylinder.eMesh"; level 1; }
        );

        refinementSurfaces
        {
            cylinder    // 对应之前定义的几何表面名称
            {
                level (0 0);

                regions
                {
                    top
                    {
                        level (1 1);
                        patchInfo { type patch; }
                    }
                    bottom
                    {
                        level (1 1);
                        patchInfo { type patch; }
                    }
                    wall
                    {
                        level (2 2);
                        patchInfo { type wall; }
                    }
                }
            }
        }

        refinementRegions
        {
            refinementBox    // 对应之前定义的加密区域名称
            {
                mode    inside;
                level   2;
            }
        }

        locationInMesh (-3.25 -2.25 1.25);
    }



snapControls
""""""""""""

面贴合参数在snapControls中设置，主要目的是将体网格节点移动到几何表面上，贴合体网格中锯齿状表面。在该关键词内需要设置的内容包括：

+------------------------+----------------------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| 关键词                 | 含义                 | 常用赋值 | 备注                                                                                                                                                                                                                                                                                                                                                                                 |
+========================+======================+==========+======================================================================================================================================================================================================================================================================================================================================================================================+
| tolerance              | 捕捉点最大相对距离   | 5        | 建议2-5之间。该参数指定贴合算法中捕捉与特征面相关网格节点的最大相对距离，实际捕捉距离为tolerance参数值乘以相邻体网格尺寸。参数值必须大于或等于1，如果值太低，则可能无法使偏差较大的网格节点移动到几何表面上。较高的值有助于增加几何的捕捉范围，但如果参数值设置过高，则有可能捕捉到与表面无关的网格节点。                                                                            |
+------------------------+----------------------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nSolveIter             | 网格贴合最大迭代次数 | 100      | 该参数指定了网格贴合算法的最大迭代次数。较高的值会提高网格的质量，网格一致性更好，但网格划分时间会更长。简单模型可以将该参数值设置为100，若贴合后网格质量不太理想，可尝试将该参数值增加到300。                                                                                                                                                                                       |
+------------------------+----------------------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nSmoothPatch           | 面平滑迭代次数       | 0        | 0表示初始网格外形。该参数指定了表面上网格贴合的平滑迭代次数。增加迭代次数可以使曲面上网格平滑、贴合性更好，且能降低曲面上网格的歪斜率，但可能导致曲率突变特征（如直角等）弱化。                                                                                                                                                                                                      |
+------------------------+----------------------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nSmoothInternal        | 体网格平滑迭代次数   | 0        | 建议参数值与nSmoothPatch参数值一致。在执行网格平滑迭代时，边界面网格平滑迭代nSmoothPatch将与内部体网格平滑迭代nSmoothInternal联合使用。平滑迭代顺序为优先执行一次面平滑迭代（nSmoothPatch），再执行一次体网格平滑迭代（nSmoothInterna），以此循环。若用户设置nSmoothInternal参数值大于nSmoothPatch值时，平滑迭代次数统一采用nSmoothPatch参数值。默认值为零，表示禁用体网格平滑迭代。 |
+------------------------+----------------------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nRelaxIter             | 贴合松弛迭代次数     | 8        | 一般为5-8之间。该参数指定贴合过程中松弛迭代次数，用以消除质量较差的单元或网格节点。如果迭代完成后网格仍存在质量较差单元，则用户可以尝试增加此迭代次数，较高的值将确保更好的网格质量，但会花费更多计算时间。                                                                                                                                                                          |
+------------------------+----------------------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nFeatureSnapIter       | 特征边捕捉迭代次数   | 10       | 该参数指定了特征捕捉迭代次数，以将网格点捕捉到表面边缘。如果在nFeatureSnaplter迭代后局部特征区域网格没有达到足够的质量标准，则取消该区域特征边捕捉并恢复到之前状态。未指定该参数，特征捕捉功能将被禁用。                                                                                                                                                                             |
+------------------------+----------------------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nFaceSplitInterval     | 面拆分迭代           | 5        | 当系统执行完特征边捕捉迭代步骤后，若网格边缘与特征边未完全对齐，则有可能在特征边处网格产生凹面。从而导致在添加边界层时，其投影体网格的非正交性增大。如果体网格不满足质量要求，则取消该处边界层生成。nFaceSplitInterval参数默认值为-1（禁用），使用建议参数值设置为特征边捕捉迭代（nFeatureSnaplter）次数的一半。                                                                     |
+------------------------+----------------------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| explicitFeatureSnap    | 显式特征捕捉         | true     | 显示特征捕捉方法需要用户自定义特征边文件（.eMesh），并且指定特征边的细化等级（通过castellatedMeshControls子字典中features参数指定）。                                                                                                                                                                                                                                                |
+------------------------+----------------------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| implicitFeatureSnap    | 隐式特征捕捉         | false    | 隐式方法不需要用户提取几何特征边，其特征识别自动化程度优于显示特征捕捉方法。它使用全局细化参数中resolveFeatureAngle参数识别曲面几何特征（例如：面的相交线、曲率变化较大的曲面特征）。但在尖角特征或者挡板界面处，显示方法捕捉特征效果优于隐式方法。                                                                                                                                  |
+------------------------+----------------------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| multiRegionFeatureSnap | 多域特征捕捉         | false    | 该参数用于捕捉多域网格间的特征面，这对于具有多个区域（例如流体区域和固体区域）的网格进行共轭传热模拟或类似操作很重要。该参数生效的前置条件为采用显示特征捕捉方法explicitFeatureSnap。使用该参数时，它会加强特征面两边网格贴合，即内部区域和外部区域，这可能会导致特征面处网格歪斜率上升。                                                                                            |
+------------------------+----------------------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+


一般情况下，snapControls采用下面的设置就已经能够得到相对可以接受的网格了：

.. code-block:: C

    snapControls
    {
        explicitFeatureSnap    true;
        implicitFeatureSnap    false;
        multiRegionFeatureSnap false;
        
        tolerance           5;
        nSolveIter          100;
        nSmoothPatch        0;
        nSmoothInternal     0;
        nRelaxIter          8;
        nFeatureSnapIter    10;
        nFaceSplitInterval  5;
    }


addLayersControls
"""""""""""""""""""

在划分边界层时，需要在全局参数设置中激活边界层划分功能，即将addLayers值设置为true。边界层配置参数在addLayersControls子字典中设置，其参数类型可分为基本参数与高级控制参数：


+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| 关键词                    | 含义                           | 备注                                                                                                                                                                                                                                                  |
+===========================+================================+=======================================================================================================================================================================================================================================================+
| relativeSizes             | 是否采用相对临近单元尺寸比值   | 设置为true时，边界层厚度参数值为相对于邻近曲面上的体网格单元大小的比值；设置为false时，边界层厚度参数值直接由绝对单位的值(单位.米)定义                                                                                                                |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| expansionRatio            | 边界层膨胀比                   | 两个相邻层的厚度比，该值越大，各层间的高度差越大                                                                                                                                                                                                      |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| finalLayerThickness       | 边界层最后一层厚度             | 确保边界层最后一层网格不大于该值                                                                                                                                                                                                                      |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| firstLayerThickness       | 边界层第一层的厚度             | 指定距离曲面最近的边界层的高度，确保边界层第一层网格不大于该值                                                                                                                                                                                        |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| thickness                 | 边界层总厚度                   | 所有边界层的最大厚度。设置较大的边界层总厚度值会导致体网格收缩位移相应增大，体网格变形量增加将导致网格质量降低。当网格质量小于用户设置网格质量控制参数时，系统将取消此处边界层网格划分。                                                              |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minThickness              | 最小总层厚度                   | 所有边界层的总体最小厚度。若边界层挤出区域厚度小于该值，则该区域将不会生成边界层                                                                                                                                                                      |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nGrow                     | 最大取消边界层单元数           | 指定未设置边界层的相邻面相交处边界层的过渡层数。这有助于将边界层过渡到特征边附近                                                                                                                                                                      |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nSurfaceLayers            | 边界层层数                     | 需在指定面设置边界层基本参数中输入，为强制性参数                                                                                                                                                                                                      |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| maxFaceThicknessRatio     | 表面网格最大纵横比             | 当要在高度扭曲的单元上（特别是在角落）生成边界层时，纵横比高于此值的单元上边界层停止生成，以保证边界层网格质量                                                                                                                                        |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| featureAngle              | 边界层最大面夹角               | 当两个曲面之间的法向夹角小于参数featureAngle值时，允许两个曲面的相交边处体网格向域内收缩，形成边界层划分区域                                                                                                                                          |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| slipFeatureAngle          | 边界层滑移角度                 | 使边界层面边缘处顶点延边界面滑动，以保证边界层在边缘处的划分空间。建议使用70-80之间的最佳值来限制层的滑动，默认值为featureAngle的一半                                                                                                                 |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nBufferCellsNoExtrude     | 边界层终止面的缓冲单元数       | 为边界层终止端创建缓冲收缩区，即逐渐降低边界层数。设置值小于0，则表示在终止端立即停止边界层                                                                                                                                                           |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nSmoothThickness          | 边界层厚度平滑迭代次数         | 边界层网格生成前，需要根据投影厚度值收缩现有体网格，可通过nSmoothThickness值设置投影厚度值的迭代次数                                                                                                                                                  |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nSmoothSurfaceNormals     | 边界层曲面法线平滑迭代次数     | 边界层网格生成前，需要根据曲面法线方向收缩现有体网格，可通过nSmoothSurfaceNormals指定曲面法线平滑迭代次数                                                                                                                                             |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minMedianAxisAngle        | 拾取中间轴点的角度             | 这指定用于拾取中间轴点的角度。建议值为90度                                                                                                                                                                                                            |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| maxThicknessToMedialRatio | 层厚度与中间轴长度的最大比率   | 当比率大于指定值时，层生长减少。建议值为0.3                                                                                                                                                                                                           |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nRelaxIter                | 体网格收缩迭代次数             | 单步投影厚度值的迭代中，系统需根据投影厚度值计算体网格收缩松弛系数。该值越大越有利于提高体网格网格质量。建议值为5                                                                                                                                     |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nSmoothNormals            | 体网格平滑迭代次数             | 体网格收缩时，可通过nSmoothNormals指定体网格间移动方向的迭代次数。该值越高，体网格间平滑性越好，但网格划分时间越长。建议值为3                                                                                                                         |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nLayerIter                | 边界层添加的最大总迭代次数     | 如果达到此迭代次数，边界层网格划分将立即停止，并保留最后一次迭代生成的边界层。建议值为50-60                                                                                                                                                           |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nRelaxedIter              | 宽松质量控制标准的起始迭代次数 | 划分边界层网格时会优先使用meshQualityControls中基础质量控制参数，检测网格是否满足要求。若边界层添加算法迭代次数达到用户设置nRelaxedIter参数值后，网格依然不能达到质量控制要求，则在此后的迭代中软件将采用用户设置的宽松质量控制标准值。参数建议值为20 |
+---------------------------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+



meshQualityControls
"""""""""""""""""""

meshQualityControls关键词中设置网格质量控制参数。在snappyHexMesh执行全局参数控制、面贴合、局部细化以及边界层生成时，程序都会依据网格质量控制参数不断调整网格迭代，同时，当网格位移或拓扑更改操作导致单元或面网格质量降低时，可根据控制参数撤消移动或拓扑更改操作以将网格还原为之前满足网格质量标准的状态。在该关键词内需要设定的内容如下：

+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| 关键词              | 含义                             | 常见赋值 | 备注                                                                                                                                                                                                                                                                        |
+=====================+==================================+==========+=============================================================================================================================================================================================================================================================================+
| maxNonOrtho         | 最大非正交角                     | 65       | 该参数指定允许的最大非正交角，其通过计算相邻两单元中心点向量与公共面法向量的夹角，此值为0时表示相邻两个网格完全正交。默认参考值为65，当设置为180时，表示关闭此项控制。该参数是衡量网格质量的主要指标之一。                                                                  |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| maxBoundarySkewness | 最大边界面网格偏斜度             | 20       | 此参数指定边界面网格允许的最大偏斜度。其定义一个面或体与理想几何(即等边或等角)的接近程度。默认参考值为20，当设置小于0的值时，表示关闭此项控制。                                                                                                                             |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| maxInternalSkewness | 最大内部面网格偏斜度             | 4        | 参数计算方式与最大边界面网格偏斜度一致，不过其主要测试内部网格质量。默认参考值为4，当设置小于0的值时，表示关闭此项控制。该参数是衡量网格质量的主要指标之一。                                                                                                                |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| maxConcave          | 最大凹度                         | 80       | 该参数用于检查构成面的内凹角度，以允许低于该角度的凹面。0表示直面，小于0表示凸面。默认参考值为80，当设置为180时，表示关闭此项控制。                                                                                                                                         |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minFlatness         | 最小平整值                       | 0.5      | 最小投影面积和实际面积的比值，该参数值为1时，表示检测面为平面。默认参数为0.5，设置为-1时，表示禁用此项控制。                                                                                                                                                                |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minVol              | 最小单元体积                     | 1e-13    | 该参数为允许最小金字塔单元体积，其为网格绝对体积参数（单位m3），默认参数为1e-13。设置为较大的负值时（例如-1e30），表示禁用此项控制。该参数是衡量网格质量的主要指标之一。                                                                                                    |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minArea             | 最小网格面面积                   | -1       | 该参数为允许最小网格面的面积，默认为-1，该参数设置为负值时，表示禁用此项控制。                                                                                                                                                                                              |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minTwist            | 最小面扭曲                       | 0.05     | 使用面中心将面分解为三角形单元，并通过相邻两个单元中心点向量与分解后三角形面法向量的点积计算面扭曲值。默认参考值为0.05，当设置参数小于-1时，表示关闭此项控制。                                                                                                              |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minDeterminant      | 最小归一化单元行列式值           | 0.001    | 通过计算每一个六面体的雅可比行列式值，然后标准化行列式的矩阵来表征单元的变形。参数值取值范围为0到1，参数值设置为1 表示只允许有理想六面体网格；如果某单元行列式的值为0，则这个立方体有一个或多个退化的边。参数值设置小于或等于0表示允许有负体积单元，默认参数值为0.001。     |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minFaceWeight       | 相邻网格间面权重最小值           | 0.05     | 其定义了面相对于相邻单元间中心的相对位置（正交时为0.5），计算方法是先计算出单元中心到公共面中心长度L1，再计算出相邻单元中心到公共面中心长度L2，面权重值等于L1与L2的最小值除以L1与L2之和。较小的面权重值表示相邻网格尺寸相差较大。参数值取值范围为0到0.5，默认参考值为0.05。 |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minVolRatio         | 相邻网格间的最小体积膨胀率       | 0.01     | 该参数指定允许相邻网格间的最小体积膨胀率, 参数值取值范围为0到1， 默认参考值为0.01。较大的比值会导致插值结果误差较大。                                                                                                                                                       |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minTriangleTwist    | 最小三角单元扭曲值               | -1       | 该参数表示允许最小三角单元扭曲值，通过使用面中心将面分解为三角形单元，然后依据相邻的三角形单元法向量的点积计算出三角形面扭曲值。默认参数值为-1，表示禁用此功能。若参数值大于0，则启用此功能项。其主要目的为确保生成网格与Fluent网格的兼容性。                               |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| minTetQuality       | ?                                | 1e-30    | 通过网格单元中心和面中心将单元分解为四面体，然后根据圆周半径（Rc）和四面体体积（Vtet）计算四面体单元质量。对于一些跟踪算例时（如流线计算），该参数需要设置为一个较小正值，以确保内部单元质量检查正常运行。默认参数值为1e-30。                                               |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| nSmoothScale        | 每次网格缩放恢复迭代时的平滑次数 | 4        | snappyHexMesh网格划分过程中可将局部网格缩放到之前网格质量满足标准的状态。可通过nSmoothScale参数指定每次网格缩放恢复迭代时的平滑次数，参数默认值为4。                                                                                                                        |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| errorReduction      | 误差点处的缩放位移量             | 0.75     | errorReduction参数同nSmoothScale参数一样应用于网格缩放恢复迭代，用户可通过该参数减小误差点处的缩放位移量，参数默认值为0.75。                                                                                                                                                |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| relaxed             | 相对宽松的上述标准列表           | ?        | 在划分边界层网格时会优先使用meshQualityControls中基础质量控制参数，检测网格是否满足要求。若边界层添加算法迭代次数达到用户设置nRelaxedIter参数值后，网格依然不能达到质量控制要求，则在此后的迭代中软件将采用设置的宽松质量控制标准值，以提高边界层网格的覆盖率。             |
+---------------------+----------------------------------+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+


snappyHexMeshDict模板
^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    /*--------------------------------*- C++ -*----------------------------------*\
      =========                 |
      \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
       \\    /   O peration     | Website:  https://openfoam.org
        \\  /    A nd           | Version:  10
         \\/     M anipulation  |
    \*---------------------------------------------------------------------------*/
    FoamFile
    {
        format      ascii;
        class       dictionary;
        object      snappyHexMeshDict;
    }
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    #includeEtc "caseDicts/mesh/generation/snappyHexMeshDict.cfg"

    castellatedMesh true;
    snap            true;
    addLayers       true;  // create boundary layers

    geometry
    {
        combined
        {
            type triSurfaceMesh;
            file "combined.stl";
            
            regions
            {
                sideFace { name sideFace; }
                topFace { name topFace; }
                leftFace { name leftFace; }
                rightFace { name rightFace; }
            }
        }
        
        /*
        refinementBox    
        {
            type searchableBox;    
            min  (-4 -4 -1);
            max  ( 4  4  4);
        }
        */
    };

    castellatedMeshControls
    {
        features
        (
          { file  "combined.eMesh"; level 0; }
        );

        refinementSurfaces
        {
            combined
            {
            level (0 0);
            
                regions
                {
                sideFace
                {
                    level (0 0);
                    patchInfo { type patch; }
                }
                topFace
                {
                    level (0 0);
                    patchInfo { type patch; }
                }
                leftFace
                {
                    level (0 0);
                    patchInfo { type patch; }
                }
                rightFace
                {
                    level (0 0);
                    patchInfo { type patch; }
                }
                }
            }
        }
        /*
        refinementRegions
        {
            refinementBox  
            {
                mode    inside;
                level   1;
            }
        }
        */
        


        locationInMesh (0 0 2.25);
        
        resolveFeatureAngle    15;
        nCellsBetweenLevels    2;
    }

    snapControls
    {
        explicitFeatureSnap    true;
        implicitFeatureSnap    false;
        multiRegionFeatureSnap false;
        
        nSmoothPatch        0;
        nSmoothInternal     0;
        tolerance           5;
        nSolveIter          100;
        nRelaxIter          10;
        nFeatureSnapIter    10;
        nFaceSplitInterval  5;
    }

    addLayersControls
    {
        layers
        {
            sideFace
            {
                nSurfaceLayers 3;
            }
        }

        relativeSizes       false;
        expansionRatio      1.2;
        finalLayerThickness 0.15;
        minThickness        0.0;
        nGrow               0;
        
        featureAngle             130;
        nRelaxIter               30;
        nSmoothSurfaceNormals    3;
        nSmoothNormals           8;
        nSmoothThickness         10;
        maxFaceThicknessRatio    0.5;
        maxThicknessToMedialRatio  1;
        minMedianAxisAngle       130;
        nBufferCellsNoExtrude    0;
        nLayerIter               50;
    }

    meshQualityControls
    {
        #include "meshQualityDict"
        
        maxNonOrtho             65;
        maxBoundarySkewness     20;
        maxInternalSkewness     4;
        maxConcave              80;
        minFlatness             0.5;
        minArea                 0.01;
    }

    /*
    writeFlags
    (
        scalarLevels
        layerSets
        layerFields
    );
    */

    mergeTolerance 1e-6;

    // ************************************************************************* //






网格检查
--------

在通过blockMesh或snappyHexMesh生成网格之后，可以在算例目录下运行下面的命令来查看网格质量是否合格：

.. code-block:: 

    checkMesh






残差监控
========


在算例目录下输入下面的命令：

.. code-block:: 

    foamGet residuals

选择第一个文件，就会在system文件夹内创建residuals文件，其基本内容如下所示：

.. code-block:: C

    #includeEtc "caseDicts/postProcessing/numerical/residuals.cfg"

    fields (p U);

其中 :code:`fields` 关键词决定了之后运行的时候需要检测残差变化的变量，可以根据需要自行添加变量名。在写好residuals文件之后，还需要进入controlDict文件中添加下面的内容：

.. code-block:: C

    functions
    {
            #includeFunc    residuals
    }


如此就设定好了残差检测。运行算例之后，就会创建postProcessing/residuals/0/residuals.dat文件，其中记录了之前设置变量的残差变化数据集。

该数据文件的数据是右对齐的，而且通过空格分隔。如果将其转换为csv文件然后用Python来读取，则可以通过下面的方式来进行：（核心是指定分隔符为多位空格"\s+"）

.. code-block:: python

    df = pd.read_csv("line.csv", sep="\s+")






physicalProperties文件
========================

physicalProperties文件给定所有流体属性的参数值，按照“物理量名+量纲+数值”的形式进行定义。量纲由方括号内的七个数定义，七个数代表SI标准和USCS标准的量纲的幂：

+------+----------+--------+-----------+
| 编号 | 名称     | SI单位 | USCS单位  |
+======+==========+========+===========+
| 1    | 质量     | kg     | lbm       |
+------+----------+--------+-----------+
| 2    | 长度     | m      | ft        |
+------+----------+--------+-----------+
| 3    | 时间     | s      | s         |
+------+----------+--------+-----------+
| 4    | 温度     | K      | Rankine°R |
+------+----------+--------+-----------+
| 5    | 物质的量 | kg/mol | lbmol     |
+------+----------+--------+-----------+
| 6    | 电流     | A      | A         |
+------+----------+--------+-----------+
| 7    | 光强     | cd     | cd        |
+------+----------+--------+-----------+



常见的物理特性参数的关键字与其对应的量纲如下：

+----------+--------------+-------------+------------------------------------+--------------------------+
| 物理特性 | 符号         | 关键字      | 量纲                               | dimensionSet             |
+==========+==============+=============+====================================+==========================+
| 运动粘度 | :math:`\nu`  | :code:`nu`  | :math:`\mathrm{m^{2}\cdot s^{-1}}` | :code:`[0 2 -1 0 0 0 0]` |
+----------+--------------+-------------+------------------------------------+--------------------------+
| 密度     | :math:`\rho` | :code:`rho` | :math:`\mathrm{kg\cdot m^{-3}}`    | :code:`[1 -3 0 0 0 0 0]` |
+----------+--------------+-------------+------------------------------------+--------------------------+




应力分析是会用到的物理特性参数：


+------------+----------------+----------------+---------------------------------------------+---------------------------+
| 物理特性   | 符号           | 关键字         | 量纲                                        | dimensionSet              |
+============+================+================+=============================================+===========================+
| 密度       | :math:`\rho`   | :code:`rho`    | :math:`\mathrm{kg\cdot m^{-3}}`             | :code:`[1 -3 0 0 0 0 0]`  |
+------------+----------------+----------------+---------------------------------------------+---------------------------+
| 杨氏模量   | :math:`E`      | :code:`E`      | :math:`\mathrm{Pa}`                         | :code:`[1 -1 -2 0 0 0 0]` |
+------------+----------------+----------------+---------------------------------------------+---------------------------+
| 泊松比     | :math:`\nu`    | :code:`nu`     |                                             | :code:`[0 0 0 0 0 0 0]`   |
+------------+----------------+----------------+---------------------------------------------+---------------------------+
| 比热容     | :math:`C_{p}`  | :code:`Cp`     | :math:`\mathrm{J\cdot kg^{-1}\cdot K^{-1}}` | :code:`[0 2 -2 -1 0 0 0]` |
+------------+----------------+----------------+---------------------------------------------+---------------------------+
| 热导率     | :math:`\kappa` | :code:`kappa`  | :math:`\mathrm{W\cdot m^{-1}\cdot K^{-1}}`  | :code:`[1 1 -3 -1 0 0 0]` |
+------------+----------------+----------------+---------------------------------------------+---------------------------+
| 热膨胀系数 | :math:`\alpha` | :code:`alphav` | :math:`\mathrm{K^{-1}}`                     | :code:`[0 0 0 -1 0 0 0]`  |
+------------+----------------+----------------+---------------------------------------------+---------------------------+





热物理模型
=============


每个调用热物理模型库的求解器均会构建一个具体的热物理模型类。每个组分都需要输入基本的热物理参数。他们必须以组分名作为关键词，其后是子字典，包含的参数主要有specie、thermoDynamics、transport。下面是一个经典的设置案例：

.. code-block:: C

    thermoType
    {
        type            hePsiThermo;
        mixture         pureMixture;
        transport       const;
        thermo          hConst;
        equationOfState perfectGas;
        specie          specie;
        energy          sensibleInternalEnergy;
    }

    mixture
    {
        specie
        {
            molWeight       352;  // 摩尔质量g/mol
        }
        thermodynamics
        {
            Cp              385;  // J/(kg.K)
            Hf              0;
        }
        transport
        {
            mu              1.83e-5;  // Pa.s
            Pr              1.155;    // 普朗特数
        }
    }


thermoType
------------

在physicalProperties文件中的thermoType关键词下指定运行中的热物理模型。

+-------------------------+--------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| 热物理模型类            | 简介                                                                                                         | 涉及求解器                                                                                                                                                                              |
+=========================+==============================================================================================================+=========================================================================================================================================================================================+
| psiThermo               | 固定组分、基于可压缩性 :math:`\psi = (RT)^{-1}` 的热物理模型库， :math:`R` 为理想气体常数， :math:`T` 为温度 | 调用该类的求解器主要为可压缩求解器，例如rhoCentralFoam、uncoupledKinematicParcelFoam以及coldEngineFoam                                                                                  |
+-------------------------+--------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| rhoThermo               | 固定组分、基于密度 :math:`\rho` 的热物理模型库                                                               | 调用该类的求解器主要为传热类求解器，例如 buoyantSimpleFoam、buoyantPimpleFoam、rhoPorousSimpleFoam、twoPhaseEulerFoam以及thermoFoam                                                     |
+-------------------------+--------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| psiReactionThermo       | 基于可压缩性 :math:`\psi` 的附加反应的热物理模型库                                                           | 调用该类的求解器主要为燃烧求解器，例如sprayFoam、engineFoam、fireFoam、reactingFoam，以及一些拉格朗日求解器，例如coalChemistryFoam                                                      |
+-------------------------+--------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| psiuReactionThermo      | 基于未燃气体可压缩性 :math:`\psi u` 的反应混合热物理模型库                                                   | 调用该类的求解器主要为燃烧求解器，这些求解器的物理模型基于层流火焰速度以及回归变量，如XiFoam、XiEngineFoam和PDRFoam                                                                     |
+-------------------------+--------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| rhoReactionThermo       | 基于密度 :math:`\rho` 的反应混合热物理模型库                                                                 | 调用该类的求解器主要为chtMultiRegionFoam以及一些燃烧求解器，如chemFoam、rhoReactinFoam、rhoReactingBuoyantFoam， 以及一些拉格朗日求解器，如reactingParcelFoam和simpleReactingParcelFoam |
+-------------------------+--------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| multiPhaseMixtureThermo | 多相流热物理模型库                                                                                           | 调用该类的求解器主要为可压缩多相界面捕获求解器，如compressibleInterFoam、compressibleMultiphaseInterFoam                                                                                |
+-------------------------+--------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+


heThermo
^^^^^^^^^^^

进入src/thermophysicalModels/basic/heThermo/heThermo.C文件中，可以看到如下代码：

.. code-block:: C

    template<class BasicThermo, class MixtureType>
    template
    <
        class CellMixture,
        class PatchFaceMixture,
        class Method,
        class ... Args
    >
    Foam::tmp<Foam::volScalarField>
    Foam::heThermo<BasicThermo, MixtureType>::volScalarFieldProperty    // volScalarFieldProperty操作模板
    (
        const word& psiName,
        const dimensionSet& psiDim,
        CellMixture cellMixture,
        PatchFaceMixture patchFaceMixture,
        Method psiMethod,
        const Args& ... args
    ) const
    {
        tmp<volScalarField> tPsi    // 创建定义在体中心的标量场对象
        (
            volScalarField::New
            (
                IOobject::groupName(psiName, this->group()),
                this->T_.mesh(),
                psiDim
            )
        );

        volScalarField& psi = tPsi.ref();

        forAll(this->T_, celli)    // 在温度场所在网格单元中进行计算
        {
            psi[celli] = ((this->*cellMixture)(celli).*psiMethod)(args[celli] ...);
        }

        volScalarField::Boundary& psiBf = psi.boundaryFieldRef();    // 获取输入场的边界

        forAll(psiBf, patchi)    // 在输入场的边界处的计算
        {
            fvPatchScalarField& pPsi = psiBf[patchi];    // 获取输入场的边界值

            forAll(this->T_.boundaryField()[patchi], facei)    // 在温度场的边界处
            {
                pPsi[facei] =
                    ((this->*patchFaceMixture)(patchi, facei).*psiMethod)
                    (
                        args.boundaryField()[patchi][facei] ...
                    );
            }
        }

        return tPsi;
    }


.. code-block:: C

    template<class BasicThermo, class MixtureType>
    template<class CellMixture, class Method, class ... Args>
    Foam::tmp<Foam::scalarField>
    Foam::heThermo<BasicThermo, MixtureType>::cellSetProperty    // cellSetProperty操作模板
    (
        CellMixture cellMixture,
        Method psiMethod,
        const labelList& cells,
        const Args& ... args
    ) const
    {
        // Note: Args are fields for the set, not for the mesh as a whole. The
        // cells list is only used to get the mixture.

        tmp<scalarField> tPsi(new scalarField(cells.size()));
        scalarField& psi = tPsi.ref();

        forAll(cells, celli)
        {
            psi[celli] =
                ((this->*cellMixture)(cells[celli]).*psiMethod)(args[celli] ...);
        }

        return tPsi;
    }


.. code-block:: C

    template<class BasicThermo, class MixtureType>
    template<class PatchFaceMixture, class Method, class ... Args>
    Foam::tmp<Foam::scalarField>
    Foam::heThermo<BasicThermo, MixtureType>::patchFieldProperty    // patchFieldProperty操作模板
    (
        PatchFaceMixture patchFaceMixture,
        Method psiMethod,
        const label patchi,
        const Args& ... args
    ) const
    {
        tmp<scalarField> tPsi
        (
            new scalarField(this->T_.boundaryField()[patchi].size())    // 创建一个与温度边界结构相同的临时场
        );
        scalarField& psi = tPsi.ref();

        forAll(this->T_.boundaryField()[patchi], facei)    // 在温度场的边界处进行计算
        {
            psi[facei] =
                ((this->*patchFaceMixture)(patchi, facei).*psiMethod)
                (
                    args[facei] ...
                );
        }

        return tPsi;
    }


使用上述的构建模板，heThermo建立了如下的场：

+----------+------------------------------------------------------------------------------------------------------------------------------------------+
| 符号     | 含义                                                                                                                                     |
+==========+==========================================================================================================================================+
| he       | 焓/内能                                                                                                                                  |
+----------+------------------------------------------------------------------------------------------------------------------------------------------+
| Cp       | 定压比热容                                                                                                                               |
+----------+------------------------------------------------------------------------------------------------------------------------------------------+
| Cv       | 定体比热容                                                                                                                               |
+----------+------------------------------------------------------------------------------------------------------------------------------------------+
| hs       | 显焓                                                                                                                                     |
+----------+------------------------------------------------------------------------------------------------------------------------------------------+
| ha       | 绝对焓                                                                                                                                   |
+----------+------------------------------------------------------------------------------------------------------------------------------------------+
| hc       | 生成焓                                                                                                                                   |
+----------+------------------------------------------------------------------------------------------------------------------------------------------+
| THE      | 由焓/内能得到的温度                                                                                                                      |
+----------+------------------------------------------------------------------------------------------------------------------------------------------+
| gamma    | 比热容比，为 :math:`c_{p}/c_{v}`                                                                                                         |
+----------+------------------------------------------------------------------------------------------------------------------------------------------+
| Cpv      | 在恒压/恒容条件下的比热容，当使用焓时为 :math:`c_{p}` ；当使用内能时为 :math:`c_{v}`                                                     |
+----------+------------------------------------------------------------------------------------------------------------------------------------------+
| W        | 分子量                                                                                                                                   |
+----------+------------------------------------------------------------------------------------------------------------------------------------------+
| alphahe  | 混合物能量的热扩散率，当使用焓时为 :math:`\kappa/c_{p}` ；当使用内能时为 :math:`\kappa/c_{v}`                                            |
+----------+------------------------------------------------------------------------------------------------------------------------------------------+
| kappaEff | 混合物的有效热湍导率，为 :math:`\kappa + c_{p}\alpha_{t}`                                                                                |
+----------+------------------------------------------------------------------------------------------------------------------------------------------+
| alphaEff | 混合物能量的有效湍流热扩散系数，当使用焓时为 :math:`\kappa/c_{p} + \alpha_{t}` ；当使用内能时为 :math:`(\kappa + c_{p}\alpha_{t})/c_{v}` |
+----------+------------------------------------------------------------------------------------------------------------------------------------------+





psiThermo
^^^^^^^^^^^

进入src/thermophysicalModels/basic/psiThermo/psiThermo.C文件，可以看到如下代码：

.. code-block:: C

    void Foam::psiThermo::correctRho(const Foam::volScalarField& deltaRho)
    {}


    Foam::tmp<Foam::volScalarField> Foam::psiThermo::implementation::rho() const
    {
        return p()*psi_;    // 利用可压缩性计算密度场的方式为 p*psi
    }


    Foam::tmp<Foam::scalarField> Foam::psiThermo::implementation::rho
    (
        const label patchi
    ) const
    {
        return p().boundaryField()[patchi]*psi_.boundaryField()[patchi];    // 边界处的密度场计算方式
    }


    Foam::tmp<Foam::volScalarField> Foam::psiThermo::implementation::rho0() const
    {
        return p().oldTime()*psi_.oldTime();    // 上一个时间步的密度场
    }


    const Foam::volScalarField& Foam::psiThermo::implementation::psi() const
    {
        return psi_;    // 可压缩性场
    }


    Foam::tmp<Foam::volScalarField> Foam::psiThermo::implementation::mu() const
    {
        return mu_;    // 动力粘度场
    }


    Foam::tmp<Foam::scalarField> Foam::psiThermo::implementation::mu
    (
        const label patchi
    ) const
    {
        return mu_.boundaryField()[patchi];    // 边界处的动力粘度场
    }




type
------

type关键词用来指定具体的热物理模型库：

+----------------+-------------------------------------------------------------------------------+
| 热物理模型库   | 使用场景                                                                      |
+================+===============================================================================+
| hePsiThermo    | 调用fluidThermo，fluidReactionThermo以及psiThermo的求解器需指定               |
+----------------+-------------------------------------------------------------------------------+
| heRhoThermo    | 调用fluidThermo，fluidReactionThermo以及multiphaseMixtureThermo的求解器需指定 |
+----------------+-------------------------------------------------------------------------------+
| heheuPsiThermo | 调用psiuReactionThermo的求解器需指定                                          |
+----------------+-------------------------------------------------------------------------------+



hePsiThermo
^^^^^^^^^^^^^^

这是一个基于压缩性的混合物能量类，进入src/thermophysicalModels/basic/psiThermo/hePsiThermo.C文件中可以看到如下代码：

.. code-block:: C

    template<class BasicPsiThermo, class MixtureType>
    void Foam::hePsiThermo<BasicPsiThermo, MixtureType>::calculate()
    {
        const scalarField& hCells = this->he_;    // 焓或内能
        const scalarField& pCells = this->p_;     // 压强

        scalarField& TCells = this->T_.primitiveFieldRef();            // 温度
        scalarField& CpCells = this->Cp_.primitiveFieldRef();          // 定压比热容
        scalarField& CvCells = this->Cv_.primitiveFieldRef();          // 定体比热容
        scalarField& psiCells = this->psi_.primitiveFieldRef();        // 可压缩性
        scalarField& muCells = this->mu_.primitiveFieldRef();          // 动力粘度
        scalarField& kappaCells = this->kappa_.primitiveFieldRef();    // 热导率

        forAll(TCells, celli)    // 在温度场内的网格单元内的计算
        {
            const typename MixtureType::thermoMixtureType& thermoMixture =
                this->cellThermoMixture(celli);

            const typename MixtureType::transportMixtureType& transportMixture =
                this->cellTransportMixture(celli, thermoMixture);

            TCells[celli] = thermoMixture.THE    // 由焓或内能得到的温度，该函数定义在thermoI.H文件中
            (
                hCells[celli],
                pCells[celli],
                TCells[celli]
            );

            CpCells[celli] = thermoMixture.Cp(pCells[celli], TCells[celli]);      // 根据thermo设置方式得到的定压比热容
            CvCells[celli] = thermoMixture.Cv(pCells[celli], TCells[celli]);      // 根据thermo设置方式得到的定体比热容
            psiCells[celli] = thermoMixture.psi(pCells[celli], TCells[celli]);    // 根据thermo设置方式得到的可压缩性

            muCells[celli] = transportMixture.mu(pCells[celli], TCells[celli]);    // 根据transport设置方式得到的动力粘度
            kappaCells[celli] =
                transportMixture.kappa(pCells[celli], TCells[celli]);    // 根据transport设置方式得到的热导率
        }

        volScalarField::Boundary& pBf =    // 边界处的压强
            this->p_.boundaryFieldRef();

        volScalarField::Boundary& TBf =    // 边界处的温度
            this->T_.boundaryFieldRef();

        volScalarField::Boundary& CpBf =    // 边界处的定压比热容
            this->Cp_.boundaryFieldRef();

        volScalarField::Boundary& CvBf =    // 边界处的定体比热容
            this->Cv_.boundaryFieldRef();

        volScalarField::Boundary& psiBf =    // 边界处的可压缩性
            this->psi_.boundaryFieldRef();

        volScalarField::Boundary& heBf =    // 边界处的焓或内能
            this->he().boundaryFieldRef();

        volScalarField::Boundary& muBf =    // 边界处的动力粘度
            this->mu_.boundaryFieldRef();

        volScalarField::Boundary& kappaBf =    // 边界处的热导率
            this->kappa_.boundaryFieldRef();

        forAll(this->T_.boundaryField(), patchi)    // 在温度场的边界处的计算
        {
            fvPatchScalarField& pp = pBf[patchi];            // 边界处的压强
            fvPatchScalarField& pT = TBf[patchi];            // 边界处的温度
            fvPatchScalarField& pCp = CpBf[patchi];          // 边界处的定压比热容
            fvPatchScalarField& pCv = CvBf[patchi];          // 边界处的定体比热容
            fvPatchScalarField& ppsi = psiBf[patchi];        // 边界处的可压缩性
            fvPatchScalarField& phe = heBf[patchi];          // 边界处的焓或内能
            fvPatchScalarField& pmu = muBf[patchi];          // 边界处的动力粘度
            fvPatchScalarField& pkappa = kappaBf[patchi];    // 边界处的热导率

            if (pT.fixesValue())    // 如果边界处的温度设置为了固定值
            {
                forAll(pT, facei)
                {
                    const typename MixtureType::thermoMixtureType&
                        thermoMixture = this->patchFaceThermoMixture(patchi, facei);

                    const typename MixtureType::transportMixtureType&
                        transportMixture =
                        this->patchFaceTransportMixture
                        (patchi, facei, thermoMixture);

                    phe[facei] = thermoMixture.HE(pp[facei], pT[facei]);    // 根据thermo的设置方式获取焓或内能

                    pCp[facei] = thermoMixture.Cp(pp[facei], pT[facei]);    // 根据thermo的设置方式获取定压比热容
                    pCv[facei] = thermoMixture.Cv(pp[facei], pT[facei]);    // 根据thermo的设置方式获取定体比热容
                    ppsi[facei] = thermoMixture.psi(pp[facei], pT[facei]);    // 根据thermo的设置方式获取可压缩性

                    pmu[facei] = transportMixture.mu(pp[facei], pT[facei]);    // 根据tansport的设置方式获取动力粘度
                    pkappa[facei] = transportMixture.kappa(pp[facei], pT[facei]);    // 根据transport的设置方式获取热导率
                }
            }
            else    // 如果边界处的温度没有设置为固定值
            {
                forAll(pT, facei)
                {
                    const typename MixtureType::thermoMixtureType& thermoMixture =
                        this->patchFaceThermoMixture(patchi, facei);

                    const typename MixtureType::transportMixtureType&
                        transportMixture =
                        this->patchFaceTransportMixture
                        (patchi, facei, thermoMixture);

                    pT[facei] = thermoMixture.THE(phe[facei], pp[facei], pT[facei]);    // 根据thermo的设置方式获取由焓或内能得到的温度

                    pCp[facei] = thermoMixture.Cp(pp[facei], pT[facei]);    // 根据thermo的设置方式获取定压比热容
                    pCv[facei] = thermoMixture.Cv(pp[facei], pT[facei]);    // 根据thermo的设置方式获取定体比热容
                    ppsi[facei] = thermoMixture.psi(pp[facei], pT[facei]);    // 根据thermo的设置方式获取可压缩性

                    pmu[facei] = transportMixture.mu(pp[facei], pT[facei]);    // 根据tansport的设置方式获取动力粘度
                    pkappa[facei] = transportMixture.kappa(pp[facei], pT[facei]);    // 根据transport的设置方式获取热导率
                }
            }
        }
    }




mixture
-----------

mixture关键词指定混合组分。无反应的热物理模型库通常使用pureMixture，也即固定组分。当指定pureMixture的时候，相关的热物理模型系数在mixture子字典中指定。


pureMixture
^^^^^^^^^^^^^

进入src/thermophysicalModels/basic/mixtures/pureMixture/pureMixture.C文件，可以看到如下代码：

.. code-block:: C

    template<class ThermoType>
    Foam::pureMixture<ThermoType>::pureMixture
    (
        const dictionary& thermoDict,
        const fvMesh& mesh,
        const word& phaseName
    )
    :
        basicMixture(thermoDict, mesh, phaseName),
        mixture_(thermoDict.subDict("mixture"))
    {}

    template<class ThermoType>
    void Foam::pureMixture<ThermoType>::read(const dictionary& thermoDict)
    {
        mixture_ = ThermoType(thermoDict.subDict("mixture"));    // 读取thermoType字典中mixture关键词的设置
    }




transport
-------------


transport传递模型需要计算动力粘度 :math:`\mu` 、热导率 :math:`\kappa` 、扩散率(用于内能方程或焓方程中) :math:`\alpha` 。可选的transport模型有：

+---------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| transport模型 | 含义                                                                                                                                                                                     |
+===============+==========================================================================================================================================================================================+
| const         | 粘度 :math:`\mu` 为常数，普朗特数由 :math:`P_{r} = C_{p}\mu / \kappa` 来计算，需要指定 :math:`\mu` 和 :math:`P_{r}`                                                                      |
+---------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| sutherland    | 通过温度 :math:`T` 和两个系数 :math:`A_{s},T_{s}` 的函数来计算粘度 :math:`\mu` ，即 :math:`\mu = \frac{A_{s}\sqrt{T}}{1+T_{s}/T}` ，需要指定 :math:`A_{s}` 和 :math:`T_{s}`              |
+---------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| polynomial    | 从一个可以指定任意阶数的函数通过温度 :math:`T` 来计算粘度 :math:`\mu` 和热导率 :math:`\varepsilon` ，即 :math:`\mu = \sum\limits_{i=0}^{N-1}a_{i}T^{i}`                                  |
+---------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| logPolynomial | 从任意阶数依据 :math:`\ln(T)` 来计算 :math:`\ln(\mu)` 和 :math:`\ln(k)` ，即 :math:`\ln(\mu)=\sum\limits_{i=0}^{N-1}a_{i}(\ln T)^{i}`                                                    |
+---------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| icoTabulated  | 使用粘度和热导率的非均匀列表数据作为温度函数                                                                                                                                             |
+---------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| WLF           | 计算 :math:`\ln(\mu)` 和 :math:`\ln(\kappa)` 作为 :math:`\ln(T)` 的函数由任意阶N的多项式通过指数来计算 :math:`\mu,\kappa` ，即 :math:`\ln(\mu)=\sum\limits_{i=0}^{N-1}a_{i}[\ln(T)]^{i}` |
+---------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+


const
^^^^^^^^

进入src/thermophysicalModels/specie/transport/const/constTransport.C文件中可以看到如下代码：

.. code-block:: C

    template<class Thermo>
    void Foam::constTransport<Thermo>::constTransport::write(Ostream& os) const
    {
        os  << this->name() << endl;
        os  << token::BEGIN_BLOCK  << incrIndent << nl;

        Thermo::write(os);

        dictionary dict("transport");
        dict.add("mu", mu_);
        if (constPr_)
        {
            dict.add("Pr", 1.0/rPr_);
        }
        else
        {
            dict.add("kappa", kappa_);
        }

        os  << indent << dict.dictName() << dict;

        os  << decrIndent << token::END_BLOCK << nl;
    }

上面的代码表明，设置为const时将会查看transport字典中的mu关键词，并会检查是否存在Pr关键词，如果存在该关键词，则读取Pr关键词的值来计算普朗特数的倒数rPr；如果不存在该关键词，则会读取kappa关键词。


进入src/thermophysicalModels/specie/transport/const/constTransportI.H文件，可以看到以下代码：

.. code-block:: C

    template<class Thermo>
    inline Foam::scalar Foam::constTransport<Thermo>::mu
    (
        const scalar p,
        const scalar T
    ) const
    {
        return mu_;    // 直接返回mu值
    }


    template<class Thermo>
    inline Foam::scalar Foam::constTransport<Thermo>::kappa
    (
        const scalar p,
        const scalar T
    ) const
    {
        return constPr_ ? this->Cp(p, T)*mu(p, T)*rPr_ : kappa_;    // 判断是否设置Pr关键词计算kappa
    }

从上面的代码可知，设置为const时，单组分的热传导率的计算方式为

.. math::
    \begin{align}
    \kappa = 
    \left \{ \begin{array}{l}
    \frac{c_{p}\mu}{\text{Pr}} ,\quad \text{if Pr exists} \\
    \kappa_{0},  \quad \text{if Pr not exists} 
    \end{array} \right .
    \end{align}


.. code-block:: C

    template<class Thermo>
    inline void Foam::constTransport<Thermo>::operator+=
    (
        const constTransport<Thermo>& st
    )
    {
        scalar Y1 = this->Y();

        Thermo::operator+=(st);

        if (mag(this->Y()) > small)
        {
            if
            (
                constTransport<Thermo>::debug
             && (constPr_ != st.constPr_)
            )
            {
                FatalErrorInFunction
                    << "Constant " << (constPr_ ? "Pr" : "kappa") << " for "
                    << (this->name().size() ? this->name() : "others") << " but "
                    << "constant " << (st.constPr_ ? "Pr" : "kappa") << " for "
                    << (st.name().size() ? st.name() : "others")
                    << exit(FatalError);
            }

            Y1 /= this->Y();    // 第一组分的质量分数
            scalar Y2 = st.Y()/this->Y();    // 第二组分的质量分数

            mu_ = Y1*mu_ + Y2*st.mu_;
            rPr_ = constPr_ ? 1/(Y1/rPr_ + Y2/st.rPr_) : NaN;
            kappa_ = constPr_ ? NaN : Y1*kappa_ + Y2*st.kappa_;
        }
    }

上面的代码表明，设置为const时，双组分的动力粘度计算方式为

.. math::
    \begin{align}
    \mu = Y_{1}\mu_{1} + Y_{2}\mu_{2}
    \end{align}

如果设置了Pr值，那么Pr值的倒数的计算方式为

.. math::
    \begin{align}
    \frac{1}{\mathrm{Pr}} = \frac{1}{Y_{1}\mathrm{Pr} + Y_{2}\mathrm{Pr}}
    \end{align}

如果没有设置Pr值，而是设置了kappa值，则双组分的热传导率的计算方式为

.. math::
    \begin{align}
    \kappa = Y_{1}\kappa_{1} + Y_{2}\kappa_{2}
    \end{align}



thermo
---------

thermo热力模型参数和比热容 :math:`C_{p}` 有关，别的相关特性可以从比热容计算而来。可选的模型有：

+---------------+-------------------------------------------------------------------------------------------------------------------+
| thermo模型    | 含义                                                                                                              |
+===============+===================================================================================================================+
| hConst        | 指定 :math:`C_{p}` 以及 :math:`H_{f}` 为常量                                                                      |
+---------------+-------------------------------------------------------------------------------------------------------------------+
| eConst        | 指定 :math:`C_{\nu}` 以及 :math:`H_{f}` 为常量                                                                    |
+---------------+-------------------------------------------------------------------------------------------------------------------+
| eIcoTabulated | 通过插值 :math:`(T,C_{p})` 键值对的非均匀数据列表计算 :math:`C_{\nu}`                                             |
+---------------+-------------------------------------------------------------------------------------------------------------------+
| hIcoTabulated | 通过插值 :math:`(T,C_{p})` 键值对的均匀数据列表计算 :math:`C_{\nu}`                                               |
+---------------+-------------------------------------------------------------------------------------------------------------------+
| ePolynomial   | 通过任意N阶多项式计算 :math:`C_{\nu}` 作为温度的函数，即 :math:`C_{\nu}=\sum\limits_{i=0}^{N-1}a_{i}T^{i}`        |
+---------------+-------------------------------------------------------------------------------------------------------------------+
| hPower        | 将 :math:`C_{p}` 作为温度的指数来计算，即 :math:`C_{p}=c_{0}\left ( \frac{T}{T_{\text{ref}}}\right )^{n_{0}}`     |
+---------------+-------------------------------------------------------------------------------------------------------------------+
| ePower        | 将 :math:`C_{\nu}` 作为温度的指数来计算，即 :math:`C_{\nu}=c_{0}\left ( \frac{T}{T_{\text{ref}}}\right )^{n_{0}}` |
+---------------+-------------------------------------------------------------------------------------------------------------------+
| janaf         | 从JANAF热力学表来选择参数，以温度的函数来计算                                                                     |
+---------------+-------------------------------------------------------------------------------------------------------------------+


在src/thermophysicalModels/specie/thermo/thermo/thermoI.H文件中定义了通过thermo进行物理量计算的各个函数：

.. code-block:: C

    template<class Thermo, template<class> class Type>
    inline bool
    Foam::species::thermo<Thermo, Type>::enthalpy()
    {
        return Type<thermo<Thermo, Type>>::enthalpy();
    }

上面的代码表明thermo.enthalpy()函数将会返回一个bool值，标识是否要使用焓作为能量。

.. code-block:: C

    template<class Thermo, template<class> class Type>
    inline Foam::word
    Foam::species::thermo<Thermo, Type>::heName()
    {
        return Type<thermo<Thermo, Type>>::energyName();
    }

上面的代码表明thermo.heName()函数将会返回所设定的energyName名称。

.. code-block:: C

    template<class Thermo, template<class> class Type>
    inline Foam::scalar
    Foam::species::thermo<Thermo, Type>::Cpv(const scalar p, const scalar T) const
    {
        return Type<thermo<Thermo, Type>>::Cpv(*this, p, T);
    }

上面的代码表明thermo.Cpv()函数返回的内容与Cpv()相同。

.. code-block:: C

    template<class Thermo, template<class> class Type>
    inline Foam::scalar
    Foam::species::thermo<Thermo, Type>::gamma(const scalar p, const scalar T) const
    {
        const scalar Cp = this->Cp(p, T);
        return Cp/(Cp - this->CpMCv(p, T));
    }

上面的代码表明thermo.gamma()函数返回的值为

.. math::
    \begin{align}
    \gamma = \frac{c_{p}}{c_{p} - (c_{p} - c_{v})} 
    \end{align}

.. code-block:: C

    template<class Thermo, template<class> class Type>
    inline Foam::scalar
    Foam::species::thermo<Thermo, Type>::HE(const scalar p, const scalar T) const
    {
        return Type<thermo<Thermo, Type>>::HE(*this, p, T);
    }

上面的代码表明thermo.HE()函数返回的抽象出来的HE()，实际调用的是Hs()或Es()或Ha()或Ea()，根据能量形式自动选择。


.. code-block:: C

    template<class Thermo, template<class> class Type>
    inline Foam::scalar
    Foam::species::thermo<Thermo, Type>::G(const scalar p, const scalar T) const
    {
        return this->Ha(p, T) - T*this->S(p, T);
    }

上面的代码表明thermo.G()返回的值为

.. math::
    \begin{align}
    G = H_{a} - TS
    \end{align}

.. code-block:: C

    template<class Thermo, template<class> class Type>
    inline Foam::scalar
    Foam::species::thermo<Thermo, Type>::A(const scalar p, const scalar T) const
    {
        return this->Ea(p, T) - T*this->S(p, T);
    }




hConst
^^^^^^^^^

这时一个基于焓的热力学包，它在恒压条件下使用恒定热容，满足：

.. math::
    \begin{align}
    h = c_{p}(T - T_{\text{ref}}) + H_{s_{\text{ref}}}
    \end{align}

进入src/thermophysicalModels/specie/thermo/hConst/hConstThermo.C文件中，可以看到如下代码：

.. code-block:: C

    template<class EquationOfState>
    Foam::hConstThermo<EquationOfState>::hConstThermo(const dictionary& dict)
    :
        EquationOfState(dict),
        Cp_(dict.subDict("thermodynamics").lookup<scalar>("Cp")),    // 定压比热容
        Hf_(dict.subDict("thermodynamics").lookup<scalar>("Hf")),    // 生成热（生成焓）
        Tref_(dict.subDict("thermodynamics").lookupOrDefault<scalar>("Tref", Tstd)),    // 线性化的参考温度
        Hsref_(dict.subDict("thermodynamics").lookupOrDefault<scalar>("Hsref", 0))    // 参考显焓，围绕它进行线性化
    {}

    template<class EquationOfState>
    void Foam::hConstThermo<EquationOfState>::write(Ostream& os) const
    {
        EquationOfState::write(os);

        dictionary dict("thermodynamics");
        dict.add("Cp", Cp_);
        dict.add("Hf", Hf_);
        if (Tref_ != Tstd)
        {
            dict.add("Tref", Tref_);
        }
        if (Hsref_ != 0)
        {
            dict.add("Hsref", Hsref_);
        }
        os  << indent << dict.dictName() << dict;
    }

从上面的代码可知，设置为hConst时将会读取thermodynamics字典中的Cp和Hf关键词；如果存在Tref关键词也会读取，否则默认值使用Tstd；如果存在Hsref关键词也会读取，否则默认值使用0。

进入src/thermophysicalModels/specie/thermo/hConst/hConstThermoI.H文件中，可以看到如下代码：

.. code-block:: C

    template<class EquationOfState>
    inline Foam::scalar Foam::hConstThermo<EquationOfState>::limit    // 将温度限制在从Tlow到Thigh的范围内
    (
        const scalar T
    ) const
    {
        return T;
    }

    template<class EquationOfState>
    inline Foam::scalar Foam::hConstThermo<EquationOfState>::Cp    // 定压比热容
    (
        const scalar p,
        const scalar T
    ) const
    {
        return Cp_ + EquationOfState::Cp(p, T);    // 其中EquationOfState::Cp表示由于状态方程而产生的定压比热容的贡献
    }

    template<class EquationOfState>
    inline Foam::scalar Foam::hConstThermo<EquationOfState>::Hs    // 显焓
    (
        const scalar p,
        const scalar T
    ) const
    {
        return Cp_*(T - Tref_) + Hsref_ + EquationOfState::H(p, T);    // 其中EquationOfState::H表示由于状态方程而产生的焓的贡献
    }

    template<class EquationOfState>
    inline Foam::scalar Foam::hConstThermo<EquationOfState>::Ha    // 绝对焓
    (
        const scalar p,
        const scalar T
    ) const
    {
        return Hs(p, T) + Hf();
    }

    template<class EquationOfState>
    inline Foam::scalar Foam::hConstThermo<EquationOfState>::Hf() const    // 生成焓
    {
        return Hf_;
    }

    template<class EquationOfState>
    inline Foam::scalar Foam::hConstThermo<EquationOfState>::S    // 熵
    (
        const scalar p,
        const scalar T
    ) const
    {
        return Cp_*log(T/Tstd) + EquationOfState::Sp(p, T);    // 其中EquationOfState::Sp表示由于状态方程而产生的熵对Cp/T积分的贡献
    }

    template<class EquationOfState>
    inline Foam::scalar Foam::hConstThermo<EquationOfState>::Gstd    // 混合物在标准态下的吉布斯自由能
    (
        const scalar T
    ) const
    {
        return Cp_*(T - Tref_) + Hsref_ + Hf() - Cp_*T*log(T/Tstd);
    }

    template<class EquationOfState>
    inline Foam::scalar Foam::hConstThermo<EquationOfState>::dCpdT    // 定压比热容关于温度的导数
    (
        const scalar p,
        const scalar T
    ) const
    {
        return 0;
    }

从上面的代码可知，各量的计算方式为

.. math::
    \begin{align}
    & c_{p} = c_{p_{0}} + c_{p_{\text{contribution}}} \\
    & H_{s} = c_{p_{0}}(T - T_{\text{ref}}) + H_{s_{\text{ref}}} + H_{\text{contribution}} \\
    & H_{a} = H_{s} + H_{f} \\
    & H_{f} = H_{f_{0}} \\
    & S = c_{p_{0}} \log\Big(\frac{T}{T_{\text{std}}}\Big) + S_{p_{\text{contribution}}} \\
    & G_{\text{std}} = c_{p_{0}} (T - T_{\text{ref}}) + H_{s_{\text{ref}}} + H_{f_{0}} - c_{p}T \log\Big( \frac{T}{T_{\text{std}}} \Big) \\
    & \frac{\mathrm{d}c_{p}}{\mathrm{d}T} = 0
    \end{align}



equationOfState
-------------------

状态方程equationOfState可选的有：

+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| 状态方程                 | 含义                                                                                                                                                            |
+==========================+=================================================================================================================================================================+
| rhoConst                 | 密度为常量                                                                                                                                                      |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| perfectGas               | 理想气体，即 :math:`\rho=\frac{1}{RT}p`                                                                                                                         |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| incompressiblePerfectGas | 不可压缩理想气体，即 :math:`\rho=\frac{1}{RT}p_{\text{ref}}` ，其中 :math:`p_{\text{ref}}` 为参考压力                                                           |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| perfectFluid             | 理想液体，即 :math:`\rho=\frac{1}{RT}p+\rho_{0}` ，其中 :math:`p_{0}` 为 :math:`T=0` 下的密度                                                                   |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| linear                   | 线性状态方程，即 :math:`\rho=\varphi p+\rho_{0}` ，其中 :math:`\varphi` 为可压缩性                                                                              |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| adiabaticPerfectFluid    | 绝热理想气体，即 :math:`\rho=\rho_{0}\left ( \frac{p+B}{p_{0}B}\right ) ^{1/\gamma}` ，其中 :math:`\rho_{0},p_{0}` 为参考密度和参考压力， :math:`B` 为模型常数  |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Boussinesq               | 布辛涅司克近似，即 :math:`\rho=\rho_{0}\big(1-\beta(T-T_{0})\big)` ，其中 :math:`\beta` 表示体膨胀率， :math:`\rho_{0}` 表示参考温度 :math:`T_{0}` 下的参考密度 |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| PengRobinsonGas          | 彭-罗宾森状态方程，即 :math:`\rho=\frac{1}{zRT}p` ，其中 :math:`z=z(p,T)`                                                                                       |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| icoPolynomial            | 不可压缩多项式状态方程 :math:`\rho=\sum\limits_{i=0}^{N-1}a_{i}T^{i}` ，其中 :math:`\varphi` 为可压缩性                                                         |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| icoTabulated             | 提供不可压缩流体 :math:`(T,\rho)` 键值对的数据列表                                                                                                              |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| rhoTabulated             | 可压缩流体的统一表格数据，计算 :math:`\rho` 作为 :math:`T` 和 :math:`T` 的函数                                                                                  |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| rPolynomial              | 液体或固体的倒数多项式状态方程，即 :math:`\frac{1}{\rho}=C_{0}+C_{1}T+C_{2}T^{2}-C_{3}p-C_{4}pT` ，其中的 :math:`C_{i}` 为系数                                  |
+--------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+


perfectGas
^^^^^^^^^^^^

理想气体状态方程，所使用的气体常数 :math:`R` 直接从specie或者混合物的分子量得到，所以不需要额外设定：

.. math::
    \begin{align}
    \rho = \frac{p}{RT} 
    \end{align}

进入src/thermophysicalModels/specie/equationOfState/perfectGas/perfectGasI.H文件，可以看到如下代码：

.. code-block:: C

    template<class Specie>
    inline Foam::scalar Foam::perfectGas<Specie>::rho(scalar p, scalar T) const    // 密度场
    {
        return p/(this->R()*T);    // 通过理想气体方程求解密度
    }

    template<class Specie>
    inline Foam::scalar Foam::perfectGas<Specie>::H(scalar p, scalar T) const    // 焓的贡献
    {
        return 0;
    }

    template<class Specie>
    inline Foam::scalar Foam::perfectGas<Specie>::Cp(scalar p, scalar T) const    // 定压比热容的贡献
    {
        return 0;
    }

    template<class Specie>
    inline Foam::scalar Foam::perfectGas<Specie>::E(scalar p, scalar T) const    // 内能贡献
    {
        return 0;
    }

    template<class Specie>
    inline Foam::scalar Foam::perfectGas<Specie>::Cv(scalar p, scalar T) const    // 定体比热容贡献
    {
        return 0;
    }

    template<class Specie>
    inline Foam::scalar Foam::perfectGas<Specie>::Sp(scalar p, scalar T) const    // 熵对Cp/T积分的贡献
    {
        return -this->R()*log(p/Pstd);
    }

    template<class Specie>
    inline Foam::scalar Foam::perfectGas<Specie>::Sv(scalar p, scalar T) const    // 熵对Cv/T积分的贡献
    {
        NotImplemented;
        return 0;
    }

    template<class Specie>
    inline Foam::scalar Foam::perfectGas<Specie>::psi(scalar p, scalar T) const    // 可压缩性场
    {
        return 1.0/(this->R()*T);
    }

    template<class Specie>
    inline Foam::scalar Foam::perfectGas<Specie>::Z(scalar p, scalar T) const    // 压缩因子
    {
        return 1;
    }

    template<class Specie>
    inline Foam::scalar Foam::perfectGas<Specie>::CpMCv(scalar p, scalar T) const    // Cp与Cv的差
    {
        return this->R();
    }

    template<class Specie>
    inline Foam::scalar Foam::perfectGas<Specie>::alphav(scalar p, scalar T) const    // 热膨胀的体积系数
    {
        return 1/T;
    }

从上面的代码可知，各量的计算方式为

.. math::
    \begin{align}
    & \rho = \frac{p}{RT} \\
    & H_{_\text{contribution}} = 0 \\
    & c_{p_{\text{contribution}}} = 0 \\
    & E_{_\text{contribution}} = 0 \\
    & c_{v_{\text{contribution}}} = 0 \\
    & S_{p_{\text{contribution}}} = -R \log\Big( \frac{p}{p_{\text{std}}} \Big) \\
    & S_{v_{\text{conmtribution}}} = 0 \\
    & \psi = \frac{1}{RT} \\
    & Z = 1 \\
    & c_{p} - c_{v} = R \\
    & \alpha_{v} = \frac{1}{T} 
    \end{align}



specie
---------

这是热物理性质类型的基类。组分的量只有一种选择specie，后续需要进一步输入下面的信息：

+----------------+---------------------------------------------------------------------------+
| specie组分信息 | 含义                                                                      |
+================+===========================================================================+
| nMoles         | 摩尔数。仅仅在使用反应组分均一混合回归变量燃烧模型的时候起作用，否则其为1 |
+----------------+---------------------------------------------------------------------------+
| molWeight      | 摩尔质量g/mol                                                             |
+----------------+---------------------------------------------------------------------------+



进入src/thermophysicalModels/specie/specie/specie.C文件，可以看到如下代码：

.. code-block:: C

    Foam::specie::specie(const dictionary& dict)
    :
        name_(dict.dictName()),
        Y_(dict.subDict("specie").lookupOrDefault("massFraction", 1.0)),    // 质量分数
        molWeight_(dict.subDict("specie").lookup<scalar>("molWeight"))      // 摩尔质量
    {}

    void Foam::specie::write(Ostream& os) const
    {
        dictionary dict("specie");    // 查找specie字典
        if (Y_ != 1)    // 如果质量分数不等于1
        {
            dict.add("massFraction", Y_);    // 则需要进一步读取massFraction关键词获取所设置的质量分数
        }
        dict.add("molWeight", molWeight_);    // 读取molWeight关键词获取摩尔质量
        os  << indent << dict.dictName() << dict;
    }

进入src/thermophysicalModels/specie/specie/specieI.H文件，可以看到如下代码：

.. code-block:: C

    inline const word& specie::name() const    // 组分名称
    {
        return name_;
    }

    inline scalar specie::W() const    // 摩尔质量
    {
        return molWeight_;
    }

    inline scalar specie::Y() const    // 组分的质量分数
    {
        return Y_;
    }

    inline scalar specie::R() const    // 个别气体常数
    {
        return RR/molWeight_;    // 通过气体常数除以该组分的摩尔质量得到
    }




energy
---------

可以对能量方程求解的变量进行指定，其可为内能 :math:`e` 也可以为焓 :math:`h` ，并可以选择是否包含热源 :math:`\Delta h_{f}` 。其可以通过指定energy关键字来实现：

+------------------------+------------------------------+
| 能量方程变量           | 含义                         |
+========================+==============================+
| sensibleEnthalpy       | 利用焓值求解温度             |
+------------------------+------------------------------+
| sensibleInternalEnergy | 利用内能求解温度             |
+------------------------+------------------------------+
| absoluteEnthalpy       | 使用绝对焓表示包含热源的情况 |
+------------------------+------------------------------+
| absoluteInternalEnergy | 使用绝对内能求解温度         |
+------------------------+------------------------------+



sensibleEnthalpy
^^^^^^^^^^^^^^^^^^

这是一个热力学映射类，以使用关于显式焓的函数。

进入src/thermophysicalModels/specie/thermo/sensibleEnthalpy/sensibleEnthalpy.H文件，可以看到如下代码：

.. code-block:: C

    static bool enthalpy()
    {
        return true;    // 使用焓
    }

    static word energyName()
    {
        return "h";    // 将energyName设置为焓h
    }

    // Heat capacity at constant pressure [J/kg/K]
    scalar Cpv    // 定压比热容
    (
        const Thermo& thermo,
        const scalar p,
        const scalar T
    ) const
    {
        return thermo.Cp(p, T);
    }

    // Sensible enthalpy [J/kg]
    scalar HE    // 显内能
    (
        const Thermo& thermo,
        const scalar p,
        const scalar T
    ) const
    {
        return thermo.Hs(p, T);
    }

    //- Temperature from sensible enthalpy
    //  given an initial temperature T0
    scalar THE    // 在给定初始温度T0的条件下，由显内能得到的温度
    (
        const Thermo& thermo,
        const scalar h,
        const scalar p,
        const scalar T0
    ) const
    {
        return thermo.THs(h, p, T0);
    }



sensibleInternalEnergy
^^^^^^^^^^^^^^^^^^^^^^^^^

这是一个热力学映射类，以使用关于显式内能的函数。

进入src/thermophysicalModels/specie/thermo/sensibleInternalEnergy/sensibleInternalEnergy.H文件，可以看到如下代码：

.. code-block:: C

    static bool enthalpy()
    {
        return false;    // 不使用焓
    }

    static word energyName()
    {
        return "e";    // 将energyName设置为内能e
    }

    //- Heat capacity at constant volume [J/kg/K]
    scalar Cpv    // 定体比热容
    (
        const Thermo& thermo,
        const scalar p,
        const scalar T
    ) const
    {
        return thermo.Cv(p, T);
    }

    //- Sensible internal energy [J/kg]
    scalar HE    // 显内能
    (
        const Thermo& thermo,
        const scalar p,
        const scalar T
    ) const
    {
        return thermo.Es(p, T);
    }

    //- Temperature from sensible internal energy
    //  given an initial temperature T0
    scalar THE    // 在给定初始温度T0的条件下，由显内能得到的温度
    (
        const Thermo& thermo,
        const scalar e,
        const scalar p,
        const scalar T0
    ) const
    {
        return thermo.TEs(e, p, T0);
    }        


absoluteEnthalpy
^^^^^^^^^^^^^^^^^^^

这是一个热力学映射类，以使用关于绝对焓的函数。

进入src/thermophysicalModels/specie/thermo/absoluteEnthalpy/absoluteEnthalpy.H文件，可以看到如下代码：

.. code-block:: C

    static bool enthalpy()
    {
        return true;    // 使用焓
    }

    static word energyName()
    {
        return "ha";    // 将energyName设置为绝对焓he
    }

    // Heat capacity at constant pressure [J/kg/K]
    scalar Cpv    // 定压比热容
    (
        const Thermo& thermo,
        const scalar p,
        const scalar T
    ) const
    {
        return thermo.Cp(p, T);
    }

    // Absolute enthalpy [J/kg]
    scalar HE    // 绝对焓
    (
        const Thermo& thermo,
        const scalar p,
        const scalar T
    ) const
    {
        return thermo.Ha(p, T);
    }

    //- Temperature from absolute enthalpy
    //  given an initial temperature T0
    scalar THE    // 给定初始温度T0，由绝对焓得到的温度
    (
        const Thermo& thermo,
        const scalar h,
        const scalar p,
        const scalar T0
    ) const
    {
        return thermo.THa(h, p, T0);
    }



absoluteInternalEnergy
^^^^^^^^^^^^^^^^^^^^^^^^

这是一个热力学映射类，以使用关于绝对内能的函数。

进入src/thermophysicalModels/specie/thermo/absoluteInternalEnergy/absoluteInternalEnergy.H文件，可以看到如下代码：

.. code-block:: C

    static bool enthalpy()
    {
        return false;    // 不适用焓
    }

    static word energyName()
    {
        return "ea";    // 设置energyName为绝对内能ea
    }

    // Heat capacity at constant volume [J/kg/K]
    scalar Cpv    // 定体比热容
    (
        const Thermo& thermo,
        const scalar p,
        const scalar T
    ) const
    {
        return thermo.Cv(p, T);
    }

    // Absolute internal energy [J/kg]
    scalar HE    // 绝对内能
    (
        const Thermo& thermo,
        const scalar p,
        const scalar T
    ) const
    {
        return thermo.Ea(p, T);
    }

    //- Temperature from absolute internal energy
    //  given an initial temperature T0
    scalar THE    // 给定初始温度T0，由绝对内能得到的温度
    (
        const Thermo& thermo,
        const scalar e,
        const scalar p,
        const scalar T0
    ) const
    {
        return thermo.TEa(e, p, T0);
    }




场设置
=========


常用的场文件名称及其意义如下所示：

+---------+---------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| 文件名  | 含义                                                                                  | 量纲                                                                                                 |
+=========+=======================================================================================+======================================================================================================+
| U       | 速度                                                                                  | :math:`\mathrm{m\cdot s^{-1}}`                                                                       |
+---------+---------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| U_0     | 前一个时间步长的速度(需要重新启动更高阶时间步长的格式时建立)                          | :math:`\mathrm{m\cdot s^{-1}}`                                                                       |
+---------+---------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| phi     | 流量                                                                                  | 对于不可压缩流为 :math:`\mathrm{m^{3}\cdot s^{-1}}` ；对于可压缩流为 :math:`\mathrm{kg\cdot s^{-1}}` |
+---------+---------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| p       | 压力。对于不可压缩求解器，这个场实际上是由恒定流体密度归一化的压力，                  | 对于不可压缩流为 :math:`\mathrm{m^{3}\cdot s^{-1}}` ；                                               |
+         +                                                                                       +                                                                                                      +
|         | 如果要得到真实的压力则需要在后期处理中乘以流体的密度。对于可压缩解算器，p是真实压力。 | 对于可压缩流为 :math:`\mathrm{kg\cdot s^{-1}}`                                                       |
+---------+---------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| epsilon | 湍流耗散率                                                                            | :math:`\mathrm{m^{2}\cdot s^{-3}}`                                                                   |
+---------+---------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| k       | 湍流动能                                                                              | :math:`\mathrm{m^{2}\cdot s^{-2}}`                                                                   |
+---------+---------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| rho     | 密度                                                                                  | :math:`\mathrm{kg\cdot m^{-3}}`                                                                      |
+---------+---------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| alpha   | 分散相体积分数                                                                        |                                                                                                      |
+---------+---------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| Theta   | 颗粒温度                                                                              | :math:`\mathrm{m^{2}\cdot s^{-2}}`                                                                   |
+---------+---------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| rDeltaT | 时间步长的倒数。对于改变局部时间步长的求解器，这表示局部时间步长。                    | :math:`\mathrm{s^{-1}}`                                                                              |
+         +                                                                                       +                                                                                                      +
|         | 这对于调试尤其有用。rDeltaT的高值可能表明需要在一个区域内进一步细化网格。             |                                                                                                      |
+---------+---------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+





边界条件
==================

边界上的某个场值，或者梯度值，其计算方法可以用如下通式表示：

.. math::
    \begin{align}
    & \phi_{f} = A_{1} \phi_{c} + B_{1} \\
    & \nabla \phi_{f} = A_{2} \phi_{c} + B_{2}
    \end{align}

其中 :math:`\phi_{c}` 表示 :math:`\phi` 在邻近边界的网格中心的值，四个系数 :math:`A_{1},B_{1},A_{2},B_{2}` 分别通过 :code:`valueInternalCoeffs` 、 :code:`valueBoundaryCoeffs` 、 :code:`gradientInternalCoeffs` 、 :code:`gradientBoundaryCoeffs` 来表示。

:code:`updateCoeffs()` 主要用来显式地计算并更新变量在边界上的值，当边界上的值是通过某个依赖于外部参数的公式来计算，并且值会随着迭代的进行而不断改变时，则需要用 :code:`updateCoeffs()` 。有些边界条件，比如最基本的 :code:`zeroGradient()` ，不需要外部的参数，只需要每一次将临近网格的值赋给边界就可以了，这时就可以用 :code:`evaluate()` 。

而有些边界条件继承于transform边界，里面额外定义了通过snGrad()和snGradTransformDiag()确定系数的方式，查看src/finiteVolume/fields/fvPatchFields/basic/transform中的transformFvPatchField.C可以看到它们之间的关系：


.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::transformFvPatchField<Type>::valueInternalCoeffs
    (
        const tmp<scalarField>&
    ) const
    {
        return pTraits<Type>::one - snGradTransformDiag();
    }

:code:`pTraits<Type>::one` 表示的是全一向量。上面的代码说明transform边界设定的系数 :math:`A_{1}` 表达式为

.. math::
    \begin{align}
    A_{1} = (1, 1,1) - \text{snGradTransformDiag} = 
    \begin{bmatrix}
    1 - \text{snGradTransformDiag}_{x} \\
    1 - \text{snGradTransformDiag}_{y} \\
    1 - \text{snGradTransformDiag}_{z}
    \end{bmatrix}
    \end{align}


.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::transformFvPatchField<Type>::valueBoundaryCoeffs
    (
        const tmp<scalarField>&
    ) const
    {
        return
            *this
          - cmptMultiply
            (
                valueInternalCoeffs(this->patch().weights()),
                this->patchInternalField()
            );
    }

:code:`cmptMultiply` 表示的是按位相乘。上面的代码说明transform边界设定的系数 :math:`B_{1}` 表达式为

.. math::
    \begin{align}
    B_{1} = \vec{\phi}_{p} - [(1, 1, 1) - \text{snGradTransformDiag}] * \vec{\phi}_{c} = 
    \begin{bmatrix}
    \phi_{px} - (1 - \text{snGradTransformDiag}_{x})\cdot \phi_{cx} \\
    \phi_{py} - (1 - \text{snGradTransformDiag}_{y})\cdot \phi_{cy} \\
    \phi_{pz} - (1 - \text{snGradTransformDiag}_{z})\cdot \phi_{cz}
    \end{bmatrix}
    \end{align}


.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::transformFvPatchField<Type>::gradientInternalCoeffs() const
    {
        return -this->patch().deltaCoeffs()*snGradTransformDiag();
    }

其中 :code:`this->patch().deltaCoeffs()` 可以认为返回的是 :math:`1/d` 。上面的代码说明transform边界条件设定的系数 :math:`A_{2}` 表达式为

.. math::
    \begin{align}
    A_{2} = - \frac{1}{d} \times \text{snGradTransformDiag} =
    \begin{bmatrix}
    - \frac{1}{d} \times \text{snGradTransformDiag}_{x} \\
    - \frac{1}{d} \times \text{snGradTransformDiag}_{y} \\
    - \frac{1}{d} \times \text{snGradTransformDiag}_{z}
    \end{bmatrix}
    \end{align}


.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::transformFvPatchField<Type>::gradientBoundaryCoeffs() const
    {
        return
            snGrad()
          - cmptMultiply(gradientInternalCoeffs(), this->patchInternalField());
    }

上面的代码说明transform边界条件设定的系数 :math:`B_{2}` 表达式为

.. math::
    \begin{align}
    B_{2} = \text{snGrad} - \big( -(\frac{1}{d}) \times \text{snGradTransformDiag} \big) \cdot \vec{\phi}_{c} =
    \begin{bmatrix}
    \text{snGrad}_{x} + \frac{1}{d} \times \text{snGradTransformDiag}_{x} \times \phi_{cx} \\
    \text{snGrad}_{y} + \frac{1}{d} \times \text{snGradTransformDiag}_{y} \times \phi_{cy} \\
    \text{snGrad}_{z} + \frac{1}{d} \times \text{snGradTransformDiag}_{z} \times \phi_{cz} 
    \end{bmatrix}
    \end{align}


部分派生类在定义自己的snGrad()和snGradTransformDiag()会涉及到 :code:`transform` 函数和 :code:`transformFieldMask` 。参考 `OpenFOAM 中的边界条件（三） <http://xiaopingqiu.github.io/2016/04/02/Boundary-conditions-in-OpenFOAM3/>`_ transform 函数的作用为：

.. code-block:: C

    inline scalar transform(constsymmTensor&, const scalar s)
    {
        return s;
    }

    template<class Cmpt>
    inline Vector<Cmpt> transform(const symmTensor& stt, const Vector<Cmpt>& v)
    {
        return stt & v;
    }

而与transformFieldMask有关的下述代码经过测试返回的是 :code:`diag` 本身：

.. code-block:: C

    transformFieldMask<Type>(pow<vector, pTraits<Type>::rank>(diag))



通用边界条件
---------------


fixedValue
^^^^^^^^^^^^

fixedValue边界条件对边界值和梯度值的计算方式如下：

.. math::
    \begin{align}
    x_{p} & = a \\
    \nabla x_{p} & = \frac{a - x_{c}}{d} 
    \end{align}

其中 :math:`a` 是自己通过value关键词设定的值， :math:`d` 是面心与面所属网格中心的距离。于是四个参数的设置应当如下：

.. math::
    \begin{align}
    & A_{1} = 0, && B_{1}=a \\
    & A_{2} = -\frac{1}{d} , && B_{2} = \frac{a}{d} 
    \end{align}

可以通过位于src/finiteVolume/fields/fvPatchFields/basic/fixedValue的fixedValueFvPatchField.C文件查看其内容：

.. code-block:: C

    template<class Type>
    void Foam::fixedValueFvPatchField<Type>::write(Ostream& os) const
    {
        fvPatchField<Type>::write(os);
        writeEntry(os, "value", *this);
    }

上面代码说明fixedValue边界条件需要读取value关键词的值，来赋值给 :code:`*this`


.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::fixedValueFvPatchField<Type>::valueInternalCoeffs
    (
        const tmp<scalarField>&
    ) const
    {
        return tmp<Field<Type>>
        (
            new Field<Type>(this->size(), Zero)
        );
    }

上面的代码是将valueInternalCoeffs也就是 :math:`A_{1}` 直接设置成了零，其中 :code:`Zero` 是OpenFOAM自行定义的可变维度零。


.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::fixedValueFvPatchField<Type>::valueBoundaryCoeffs
    (
        const tmp<scalarField>&
    ) const
    {
        return *this;
    }

上面的代码是将valueBoundaryCoeffs也就是 :math:`B_{1}` 设置为value关键词的值，:code:`*this` 表示类本身也即当前边界上的值。


.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::fixedValueFvPatchField<Type>::gradientInternalCoeffs() const
    {
        return -pTraits<Type>::one*this->patch().deltaCoeffs();
    }

上面的代码是将gradientInternalCoeffs也就是 :math:`A_{2}` 设置为 :math:`-1/d` 。其中 :code:`pTraits<Type>::one` 返回的是可变维度的一；可以近似认为 :code:`this->patch().deltaCoeffs()` 返回的是 :math:`1/d` ，严格来说应该是两个网格中心的距离往接触面法向的投影的倒数。


.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::fixedValueFvPatchField<Type>::gradientBoundaryCoeffs() const
    {
        return this->patch().deltaCoeffs()*(*this);
    }

上面的代码是将gradientBoundaryCoeffs也就是 :math:`B_{2}` 设置为 :math:`1/d \times \text{value}` 。



zeroGradient
^^^^^^^^^^^^^^^

zeroGradient对边界的值和梯度值的计算方式如下：

.. math::
    \begin{align}
    x_{p} &= x_{c} \\
    \nabla x_{p} &= 0
    \end{align}

于是可知四个参数的设置应当如下：

.. math::
    \begin{align}
    & A_{1}=1, && B_{1}=0 \\
    & A_{2}=0, && B_{2}=0
    \end{align}


位于src/finiteVolume/fields/fvPatchFields/basic/zeroGradient的zeroGradientFvPatchField.C如下所示：

.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::zeroGradientFvPatchField<Type>::valueInternalCoeffs
    (
        const tmp<scalarField>&
    ) const
    {
        return tmp<Field<Type>>
        (
            new Field<Type>(this->size(), pTraits<Type>::one)
        );
    }

上面的代码说明zeroGradient边界条件将valueInternalCoeffs也就是 :math:`A_{1}` 设置为 :math:`1` 。 

.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::zeroGradientFvPatchField<Type>::valueBoundaryCoeffs
    (
        const tmp<scalarField>&
    ) const
    {
        return tmp<Field<Type>>
        (
            new Field<Type>(this->size(), Zero)
        );
    }

上面的代码说明zeroGradient边界条件将valueBoundaryCoeffs也就是 :math:`B_{1}` 设置为 :math:`0` 。 

.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::zeroGradientFvPatchField<Type>::gradientInternalCoeffs() const
    {
        return tmp<Field<Type>>
        (
            new Field<Type>(this->size(), Zero)
        );
    }

上面的代码说明zeroGradient边界条件将gradientInternalCoeffs也就是 :math:`A_{2}` 设置为 :math:`0` 。 

.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::zeroGradientFvPatchField<Type>::gradientBoundaryCoeffs() const
    {
        return tmp<Field<Type>>
        (
            new Field<Type>(this->size(), Zero)
        );
    }

上面的代码说明zeroGradient边界条件将gradientBoundaryCoeffs也就是 :math:`B_{2}` 设置为 :math:`0` 。 



fixedGradient
^^^^^^^^^^^^^^^

fixedGradient对边界的值和梯度值的计算方式如下：

.. math::
    \begin{align}
    x_{p} &= x_{c} + a\cdot d \\
    \nabla x_{p} &= a
    \end{align}

其中 :math:`a` 是自行通过gradient关键词设定的固定梯度值， :math:`d` 是面心与面所属网格中心的距离。于是可知四个参数的设置应当如下：

.. math::
    \begin{align}
    & A_{1}=1, && B_{1}=a \cdot d \\
    & A_{2}=0, && B_{2}=a
    \end{align}

位于src/finiteVolume/fields/fvPatchFields/basic/fixedGradient的fixedGradientFvPatchField.C如下所示：

.. code-block:: C

    template<class Type>
    void Foam::fixedGradientFvPatchField<Type>::write(Ostream& os) const
    {
        fvPatchField<Type>::write(os);
        writeEntry(os, "gradient", gradient_);
    }

上面的代码说明fixedGradient边界条件需要读取字典中gradient关键词赋值给 :code:`gradient_` 变量。

.. code-block:: C

    template<class Type>
    void Foam::fixedGradientFvPatchField<Type>::evaluate(const Pstream::commsTypes)
    {
        if (!this->updated())
        {
            this->updateCoeffs();
        }

        Field<Type>::operator=
        (
            this->patchInternalField() + gradient_/this->patch().deltaCoeffs()
        );

        fvPatchField<Type>::evaluate();
    }

上面的代码定义了evaluate操作的内容为 :math:`x_{c} + \frac{a}{(1/d)}` ，其中 :code:`this->patchInternalField()` 返回 :math:`x_{c}` ， :code:`this->patch().deltaCoeffs()` 返回 :math:`1/d` 。

.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::fixedGradientFvPatchField<Type>::valueInternalCoeffs
    (
        const tmp<scalarField>&
    ) const
    {
        return tmp<Field<Type>>(new Field<Type>(this->size(), pTraits<Type>::one));
    }

上面的代码说明fixedGradient边界条件设定了valueInternalCoeffs也就是 :math:`A_{1}` 的值为 :math:`1` 。其中 :code:`pTraits<Type>::one` 返回的是 :math:`1` 。

.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::fixedGradientFvPatchField<Type>::valueBoundaryCoeffs
    (
        const tmp<scalarField>&
    ) const
    {
        return gradient()/this->patch().deltaCoeffs();
    }

上面的代码说明fixedGradient边界条件设定了valueBoundaryCoeffs也就是 :math:`B_{1}` 的值为 :math:`\frac{a}{(1/d)}` 。其中 :code:`gradient()` 返回的是已经映射到场上的 :code:`gradient_` 变量，即 :math:`a` ； :code:`this->patch().deltaCoeffs()` 返回的是 :math:`1/d` 。

.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::fixedGradientFvPatchField<Type>::gradientInternalCoeffs() const
    {
        return tmp<Field<Type>>
        (
            new Field<Type>(this->size(), Zero)    // 设定A2的值为 0
        );
    }

上面的代码说明fixedGradient边界条件设定了gradientInternalCoeffs也就是 :math:`A_{2}` 的值为 :math:`0` 。

.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::fixedGradientFvPatchField<Type>::gradientBoundaryCoeffs() const
    {
        return gradient();    // 设定B2的值为已经映射到场上的gradient_变量，即a
    }

上面的代码说明fixedGradient边界条件设定了gradientBoundaryCoeffs也就是 :math:`B_{2}` 的值为已经映射到场上的 :code:`gradient_` 变量，即 :math:`a` 。



mixed
^^^^^^^^^^^^

mixed边界条件对边界的值和梯度值的计算方式如下：

.. math::
    \begin{align}
    x_{p} &= [(1-\text{valueFraction})x_{c} + \text{valueFraction}\cdot \text{refValue}] + (1-\text{valueFraction}) \cdot \text{refGradient} \cdot d \\
    \nabla x_{p} &= \text{valueFraction}\cdot\frac{\text{refValue} - x_{c}}{d} + (1-\text{valueFraction}) \cdot \text{refGradient} 
    \end{align}

其中refValue是自行通过refValue关键词设定的参考值，refGradient是自行通过refGradient关键词设定的参考梯度，valueFraction是自行通过valueFraction关键词设定的权重值， :math:`d` 是面心与面所属网格中心的距离。于是可知四个参数的设置应当如下：

.. math::
    \begin{align}
    & A_{1}=1-\text{valueFraction}, && B_{1}=\text{valueFraction}\cdot \text{refValue} + (1-\text{valueFraction})\cdot \text{refGradient}\cdot d \\
    & A_{2}=\frac{-\text{valueFraction}}{d}, && B_{2}=\frac{\text{valueFraction}\cdot \text{refValue}}{d} +(1-\text{valueFraction}) \cdot \text{refGradient}
    \end{align}

位于src/finiteVolume/fields/fvPatchFields/basic/mixed的mixedFvPatchField.C如下所示：


.. code-block:: C

    template<class Type>
    void Foam::mixedFvPatchField<Type>::write(Ostream& os) const
    {
        fvPatchField<Type>::write(os);
        writeEntry(os, "refValue", refValue_);
        writeEntry(os, "refGradient", refGrad_);
        writeEntry(os, "valueFraction", valueFraction_);
        writeEntry(os, "value", *this);
    }

上面的代码说明mixed边界条件需要分别读取字典中的refValue、refGradient、valueFraction和value关键词的值，来赋给 :code:`refValue_` 、 :code:`refGrad_` 、 :code:`valueFraction_` 和 :code:`*this` 变量。其中value关键词是由于C++特性导致的，其实并不是必须的。


.. code-block:: C

    template<class Type>
    void Foam::mixedFvPatchField<Type>::evaluate(const Pstream::commsTypes)
    {
        if (!this->updated())
        {
            this->updateCoeffs();
        }

        Field<Type>::operator=    // 定义evaluate操作内容为 w*a + (1-w)*(x_c + b/(1/d) )
        (
            valueFraction_*refValue_
          +
            (1.0 - valueFraction_)*
            (
                this->patchInternalField()
              + refGrad_/this->patch().deltaCoeffs()
            )
        );

        fvPatchField<Type>::evaluate();
    }

上面的代码定义了mixed边界条件的evaluate操作内容为

.. math::
    \begin{align}
    \text{valueFraction} \times \text{refValue}
    + (1.0 - \text{valueFraction}) \times 
    (x_{c} + \frac{\text{refGrad}}{(1/d)})  
    \end{align}


.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::mixedFvPatchField<Type>::valueInternalCoeffs
    (
        const tmp<scalarField>&
    ) const
    {
        return Type(pTraits<Type>::one)*(1.0 - valueFraction_);
    }

上面的代码表明mixed边界条件设定valueInternalCoeffs也就是 :math:`A_{1}` 的值为 :math:`(1 - \text{valueFraction})` 。其中 :code:`pTraits<Type>::one` 作用是调整维度。


.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::mixedFvPatchField<Type>::valueBoundaryCoeffs
    (
        const tmp<scalarField>&
    ) const
    {
        return
             valueFraction_*refValue_                                        // 设定B1的值为 w*a + (1-w)*b/(1/d)
           + (1.0 - valueFraction_)*refGrad_/this->patch().deltaCoeffs();    // this->patch().deltaCoeffs()返回的是 1/d
    }

上面的代码表明mixed边界条件设定valueBoundaryCoeffs也就是 :math:`B_{1}` 的值为 :math:`\text{valueFraction} \times \text{refValue} + (1.0 - \text{valueFraction}) \times \frac{\text{refGrad}}{(1/d)}` 。

.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::mixedFvPatchField<Type>::gradientInternalCoeffs() const
    {
        return -Type(pTraits<Type>::one)*valueFraction_*this->patch().deltaCoeffs();
    }

上面的代码表明mixed边界条件设定gradientInternalCoeffs也就是 :math:`A_{2}` 的值为 :math:`- \text{valueFraction} \times (1/d)` 。


.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::mixedFvPatchField<Type>::gradientBoundaryCoeffs() const
    {
        return
            valueFraction_*this->patch().deltaCoeffs()*refValue_    // 设定B2的值为 w*(1/d)*a + (1-w)*b
          + (1.0 - valueFraction_)*refGrad_;                        // this->patch().deltaCoeffs()返回的是 1/d
    }

上面的代码表明mixed边界条件设定gradientBoundaryCoeffs也就是 :math:`B_{2}` 的值为 :math:`\text{valueFraction} \times (1/d) \times \text{refValue} + (1.0 - \text{valueFraction}) \times \text{refGrad}` 。


directionMixed
^^^^^^^^^^^^^^^^

该类是所有方向混合类型边界条件的基类。该类继承于transform边界条件，通过定义其自身的snGrad()和snGradTransformDiag()函数返回内容来实现。

.. code-block:: C

    template<class Type>
    void Foam::directionMixedFvPatchField<Type>::write(Ostream& os) const
    {
        transformFvPatchField<Type>::write(os);
        writeEntry(os, "refValue", refValue_);               // 读取字典中的关键词refValue赋值给refValue_变量
        writeEntry(os, "refGradient", refGrad_);             // 读取字典中的关键词refGradient赋值给refGrad_变量
        writeEntry(os, "valueFraction", valueFraction_);     // 读取字典中的关键词valueFraction赋值给valueFraction_变量
        writeEntry(os, "value", *this);
    }

上面的代码表明，directionMixed需要读取关键词refValue、refGradient、valueFraction的赋值。


.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::directionMixedFvPatchField<Type>::snGrad() const    // 定义snGrad函数操作内容
    {
        const Field<Type> pif(this->patchInternalField());    // pif用来代表内部场x_c

        tmp<Field<Type>> normalValue = transform(valueFraction_, refValue_);    // 定义normalValue的值，通过transform函数来计算

        tmp<Field<Type>> gradValue = pif + refGrad_/this->patch().deltaCoeffs();    // 定义gradValue的值为 x_c + refGrad / (1/d)

        tmp<Field<Type>> transformGradValue =    // 定义transformGradValue的值，通过transform函数来计算。其中I是单位矩阵
            transform(I - valueFraction_, gradValue);

        return
            (normalValue + transformGradValue - pif)*    // 定义snGrad函数返回结果为 (normalValue + transformGradValue - x_c) * (1/d)
            this->patch().deltaCoeffs();
    }

上面的代码表明，在directionMixed边界条件中，snGrad的具体定义内容为

.. math::
    \begin{align}
    \text{snGrad} &= 
    \frac{1}{d}\Big( \text{valueFraction} \cdot \text{refValue} + (\mathbf{I} - \text{valueFraction}) \cdot (\vec{\phi}_{c} + \text{refGrad}\cdot d) - \vec{\phi}_{c}\Big) \\
    & = \frac{1}{d}
    \begin{bmatrix}
    \text{valueFraction} \times (\text{refValue} -  \phi_{cx}) + (1 - \text{valueFraction}) \times \text{refGrad}\times d) \\
    \text{valueFraction} \times (\text{refValue} -  \phi_{cy}) + (1 - \text{valueFraction}) \times \text{refGrad}\times d) \\
    \text{valueFraction} \times (\text{refValue} -  \phi_{cz}) + (1 - \text{valueFraction}) \times \text{refGrad}\times d)
    \end{bmatrix} 
    \end{align}


.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::directionMixedFvPatchField<Type>::snGradTransformDiag() const    // 定义snGradTransformDiag函数的操作内容
    {
        vectorField diag(valueFraction_.size());    // 定义向量场diag

        diag.replace
        (
            vector::X,
            sqrt(mag(valueFraction_.component(symmTensor::XX)))    // 将diag向量的x分量替换为 \sqrt{ |valueFraction_xx| }
        );
        diag.replace
        (
            vector::Y,
            sqrt(mag(valueFraction_.component(symmTensor::YY)))    // 将diag向量的y分量替换为 \sqrt{ |valueFraction_yy| }
        );
        diag.replace
        (
            vector::Z,
            sqrt(mag(valueFraction_.component(symmTensor::ZZ)))    // 将diag向量的z分量替换为 \sqrt{ |valueFraction_zz| }
        );

        return transformFieldMask<Type>(pow<vector, pTraits<Type>::rank>(diag));
    }

上面的代码表明，在directionMixed边界条件中，snGradTransformDiag的具体定义内容为

.. math::
    \begin{align}
    \text{snGradTransformDiag} = 
    \begin{bmatrix}
    \sqrt{|\text{valueFraction}|} \\
    \sqrt{|\text{valueFraction}|} \\
    \sqrt{|\text{valueFraction}|} 
    \end{bmatrix} 
    \end{align}

因此在directionMixed边界条件中，四个系数的具体定义分别为

.. math::
    \begin{align}
    A_{1} = 
    \begin{bmatrix}
    1 - \sqrt{|\text{valueFraction}|} \\
    1 - \sqrt{|\text{valueFraction}|} \\
    1 - \sqrt{|\text{valueFraction}|}
    \end{bmatrix}
    \end{align}

.. math::
    \begin{align}
    B_{1} = 
    \begin{bmatrix}
    \phi_{px} - (1 - \sqrt{|\text{valueFraction}|}) \times \phi_{cx} \\
    \phi_{py} - (1 - \sqrt{|\text{valueFraction}|}) \times \phi_{cy} \\
    \phi_{pz} - (1 - \sqrt{|\text{valueFraction}|}) \times \phi_{cz}
    \end{bmatrix}
    \end{align}

.. math::
    \begin{align}
    A_{2} = -\frac{1}{d} 
    \begin{bmatrix}
    \sqrt{|\text{valueFraction}|} \\
    \sqrt{|\text{valueFraction}|} \\
    \sqrt{|\text{valueFraction}|}
    \end{bmatrix}
    \end{align}

.. math::
    \begin{align}
    B_{2} = 
    \begin{bmatrix}
    \frac{1}{d}\times  \text{valueFraction} \times \text{refValue} + \frac{1}{d}\times (\sqrt{|\text{valueFraction}|} - \text{valueFraction} ) \times \phi_{cx} + (1 - \text{valueFraction}) \times \text{refGrad} \\
    \frac{1}{d}\times  \text{valueFraction} \times \text{refValue} + \frac{1}{d}\times (\sqrt{|\text{valueFraction}|} - \text{valueFraction} ) \times \phi_{cy} + (1 - \text{valueFraction}) \times \text{refGrad} \\
    \frac{1}{d}\times  \text{valueFraction} \times \text{refValue} + \frac{1}{d}\times (\sqrt{|\text{valueFraction}|} - \text{valueFraction} ) \times \phi_{cz} + (1 - \text{valueFraction}) \times \text{refGrad} 
    \end{bmatrix}
    \end{align}


basicSymmetry
^^^^^^^^^^^^^^^^^

对于标量，该边界条件等价于zeroGradient。对于矢量的情况，边界上的值等于其临近网格中心的值的切向分量，满足：

.. math::
    \begin{align}
    \vec{\phi}_{p} = \vec{\phi}_{c} - (\vec{\phi}_{c} \cdot \vec{n}) \cdot \vec{n} = [\vec{\phi}_{c} + (I - 2\vec{n} \otimes \vec{n}) \cdot \vec{\phi}_{c}] \times \frac{1}{2} 
    \end{align}

各系数在OpenFOAM中的矩阵表示如下：

.. math::
    \begin{align}
    A_{1} =  \begin{bmatrix} 1-|n_{x}| \\ 1-|n_{y}| \\ 1-|n_{z}| \end{bmatrix}
    \end{align}

.. math::
    \begin{align}
    B_{1} =  \begin{bmatrix} \phi_{px} \\ \phi_{py} \\ \phi_{pz} \end{bmatrix}
           - \begin{bmatrix} (1-|n_{x}|)\phi_{cx} \\ (1-|n_{y}|)\phi_{cy} \\ (1-|n_{z}|)\phi_{cz} \end{bmatrix}
    \end{align}

.. math::
    \begin{align}
    A_{2} = -\frac{1}{d}\begin{bmatrix} |n_{x}| \\ |n_{y}| \\ |n_{z}| \end{bmatrix} 
    \end{align}

.. math::
    \begin{align}
    B_{2} = -\frac{1}{d}
            \begin{bmatrix} 
            n_{x}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z}) \\ 
            n_{y}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z}) \\
            n_{z}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z})
            \end{bmatrix} 
            + \frac{1}{d}
            \begin{bmatrix}
            |n_{x}|\phi_{cx} \\
            |n_{y}|\phi_{cy} \\
            |n_{z}|\phi_{cz}
            \end{bmatrix} 
    \end{align}


位于src/finiteVolume/fields/fvPatchFields/basic/basicSymmetry的basicSymmetryFvPatchField.C中定义系数的相关内容如下所示：

.. code-block:: C

    // * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::basicSymmetryFvPatchField<Type>::snGrad() const    // 定义snGrad的具体操作内容
    {
        tmp<vectorField> nHat = this->patch().nf();    // 用nHat表示面法向量

        const Field<Type> iF(this->patchInternalField());    // 用iF表示 \vec{\phi}_{c}

        return
        /*  snGrad的操作定义为 ((I - 2\vec{n} \otimes \vec{n}) \cdot \vec{\phi}_{c} - \vec{\phi}_{c} )\times \frac{1}{2d} 
            分量形式为
            \text{snGrad}_{x} = -\frac{1}{d}n_{x}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z}),
            \text{snGrad}_{y} = -\frac{1}{d}n_{y}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z}),
            \text{snGrad}_{z} = -\frac{1}{d}n_{z}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z})
        */
            (transform(I - 2.0*sqr(nHat), iF) - iF)
           *(this->patch().deltaCoeffs()/2.0);
    }


    template<class Type>
    void Foam::basicSymmetryFvPatchField<Type>::evaluate(const Pstream::commsTypes)
    {
        if (!this->updated())
        {
            this->updateCoeffs();
        }

        tmp<vectorField> nHat = this->patch().nf();    // 用nHat表示面法向量

        const Field<Type> iF(this->patchInternalField());    // 用iF表示 \vec{\phi}_{c}

        Field<Type>::operator=
        (
        /*  定义evaluate操作内容为 \frac{1}{2}(\vec{\phi}_{c} + (I - 2\vec{n} \otimes \vec{n}) \cdot \vec{\phi}_{c})
            分量形式为
            \phi_{cx} - n_{x}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z}),
            \phi_{cy} - n_{y}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z}),
            \phi_{cz} - n_{z}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z})
        */
            (iF + transform(I - 2.0*sqr(nHat), iF))/2.0
        );

        transformFvPatchField<Type>::evaluate();
    }


    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::basicSymmetryFvPatchField<Type>::snGradTransformDiag() const    // 定义snGradTransformDiag具体操作内容
    {
        const vectorField nHat(this->patch().nf());    // 用nHat表示面法向量

        vectorField diag(nHat.size());    // 定义向量 diag = (|n_{x}|, |n_{y}|, |n_{z}|)

        diag.replace(vector::X, mag(nHat.component(vector::X)));
        diag.replace(vector::Y, mag(nHat.component(vector::Y)));
        diag.replace(vector::Z, mag(nHat.component(vector::Z)));

        return transformFieldMask<Type>(pow<vector, pTraits<Type>::rank>(diag));    // snGradTransformDiag返回 diag = (|n_{x}|, |n_{y}|, |n_{z}|)
    }


inletOutlet
^^^^^^^^^^^^^^^^

inletOutlet边界条件是一个一般性的出流条件，同时给定了特定的入流条件。对于入流，该条件相当于fixedValue；对于出流，该条件相当于zeroGradient。该条件继承于mixed边界条件，通过设置不同的refValue、refGrad和valueFraction来实现。


位于src/finiteVolume/fields/fvPatchFields/derived/inletOutlet的inletOutletFvPatchField.C如下所示：

.. code-block:: C

    template<class Type>
    Foam::inletOutletFvPatchField<Type>::inletOutletFvPatchField
    (
        const fvPatch& p,
        const DimensionedField<Type, volMesh>& iF
    )
    :
        mixedFvPatchField<Type>(p, iF),    // 继承于mixed边界条件
        phiName_("phi")
    {
        this->refValue() = Zero;        // 初始化refValue的值为0
        this->refGrad() = Zero;         // 初始化refGrad的值为0
        this->valueFraction() = 0.0;    // 初始化valueFraction的值为0.0
    }

上面的代码表明inletOutlet边界条件继承于mixed边界条件，并且先将refValue、refGradient、valueFraction的值初始化为了 :math:`0` 。


.. code-block:: C

    template<class Type>
    Foam::inletOutletFvPatchField<Type>::inletOutletFvPatchField
    (
        const fvPatch& p,
        const DimensionedField<Type, volMesh>& iF,
        const dictionary& dict
    )
    :
        mixedFvPatchField<Type>(p, iF),    
        phiName_(dict.lookupOrDefault<word>("phi", "phi"))    // 读取子字典中phi关键词的值赋给phiName_变量，默认就是phi
    {
        this->refValue() = Field<Type>("inletValue", dict, p.size());

        if (dict.found("value"))    // 如果子字典中存在value关键词的赋值
        {
            fvPatchField<Type>::operator=
            (
                Field<Type>("value", dict, p.size())    // 将边界的值初始化为value的值
            );
        }
        else
        {
            fvPatchField<Type>::operator=(this->refValue());    // 如果不存在value关键词则将边界的值初始化为refValue的值
        }

        this->refGrad() = Zero;         // 设置refGradient的值为0
        this->valueFraction() = 0.0;    // 设置valueFraction的值为0
    }

上面的代码对边界上的情况进行了初始化。

.. code-block:: C

    template<class Type>
    void Foam::inletOutletFvPatchField<Type>::updateCoeffs()    // 通过updateCoeffs函数来修改mixed边界条件的参数来实现
    {
        if (this->updated())
        {
            return;
        }

        const Field<scalar>& phip =    // 定义phip为通量场的值
            this->patch().template lookupPatchField<surfaceScalarField, scalar>
            (
                phiName_
            );

        this->valueFraction() = neg(phip);    // 设置valueFraction的值为 neg(phip)

        mixedFvPatchField<Type>::updateCoeffs();    // 更新mixed边界条件的参数
    }

上面的代码表明intletOutlet边界条件根据通量场phi的大小来设置valueFraction的值，设置方式为

.. math::
    \begin{align}
    \text{valueFraction} = 
    \left\{\begin{array}{l}
    1, \quad \phi < 0, \\
    0, \quad \phi \ge 0
    \end{array}\right .
    \end{align}

其中 :code:`neg(phip)` 表示当phip小于零时取1，当phip大于等于零时取0，具体定义可以查看src/OpenFOAM/lnInclude/Scalar.H文件。


.. code-block:: C

    template<class Type>
    void Foam::inletOutletFvPatchField<Type>::write(Ostream& os) const
    {
        fvPatchField<Type>::write(os);
        if (phiName_ != "phi")
        {
            writeEntry(os, "phi", phiName_);    // 遇到不是默认的phi的情况时则读取phi关键词赋给的名字
        }
        writeEntry(os, "inletValue", this->refValue());    // 读取子字典的inletValue的值赋给refValue
        writeEntry(os, "value", *this);
    }

上面的代码表明inletOutlet边界条件将会读取字典里inletValue的值赋给refValue，同时会读取value关键词。

inletOutlet边界条件的一般设置方式如下所示：

.. code-block:: C

    patchName
    {
        type            inletOutlet;
        phi             phi;
        inletValue      uniform 0;
        value           uniform 0;
    }



freestream
^^^^^^^^^^^^

这个边界条件提供了一个自由流条件。它是由inletOutlet条件衍生而来的混合条件，其中操作模式根据通量的符号在固定(自由流)值和零梯度之间切换。该边界条件继承于inletOutlet边界条件。

.. code-block:: C

    const Field<Type>& freestreamValue() const
    {
        return this->refValue();
    }

    Field<Type>& freestreamValue()
    {
        return this->refValue();
    }

上面的代码表明freestreamValue和refValue是等价的。


.. code-block:: C

    template<class Type>
    Foam::freestreamFvPatchField<Type>::freestreamFvPatchField
    (
        const fvPatch& p,
        const DimensionedField<Type, volMesh>& iF,
        const dictionary& dict
    )
    :
        inletOutletFvPatchField<Type>(p, iF)
    {
        this->phiName_ = dict.lookupOrDefault<word>("phi","phi");    // 查找通量场phi

        freestreamValue() = Field<Type>("freestreamValue", dict, p.size());    // 读取freestreamValue的值赋给freestreamValue

        if (dict.found("value"))
        {
            fvPatchField<Type>::operator=
            (
                Field<Type>("value", dict, p.size())    // 如果有value关键词则初始化边界值为value的值
            );
        }
        else
        {
            fvPatchField<Type>::operator=(freestreamValue());    // 否则初始化边界值为freestreamValue的值
        }
    }

上面的代码表明freestream继承于inletOutlet边界条件，上面进行了边界情况的初始化，其余操作均与inletOutlet边界条件相同。可以认为freestreamValue和inletValue的作用是等价的。

.. code-block:: C

    template<class Type>
    void Foam::freestreamFvPatchField<Type>::write(Ostream& os) const
    {
        fvPatchField<Type>::write(os);
        if (this->phiName_ != "phi")
        {
            writeEntry(os, "phi", this->phiName_);
        }
        writeEntry(os, "freestreamValue", freestreamValue());
        writeEntry(os, "value", *this);
    }

freestream边界条件的一般设置方式如下所示：

.. code-block:: C

    patchName
    {
        type            freestream;
        freestreamValue uniform (300 0 0);
    }


速度边界条件
---------------

noSlip
^^^^^^^^^

这个边界条件使壁面处的速度固定为零。它继承于fixedValue边界条件。

.. code-block:: C

    Foam::noSlipFvPatchVectorField::noSlipFvPatchVectorField
    (
        const fvPatch& p,
        const DimensionedField<vector, volMesh>& iF,
        const dictionary& dict
    )
    :
        fixedValueFvPatchVectorField(p, iF, dict, false)
    {
        operator==(Zero);    // 继承fixedValue边界条件，设定为固定值 0
    }


partialSlip
^^^^^^^^^^^^^^

对于partialSlip边界，流体在边界法向上的速度为零，边界切向上的速度沿法向成梯度下降，满足：

.. math::
    \begin{align}
    \vec{\phi}_{p} = (1 - \text{valueFraction})[\vec{\phi}_{c} - (\vec{\phi}_{c} \cdot \vec{n}) \cdot \vec{n}] 
                   = (1 - \text{valueFraction})(I - \vec{n} \otimes \vec{n}) \cdot \vec{\phi}_{c}
    \end{align}

其中valueFraction为自行定义的衰减系数。各系数的表达式如下：

.. math::
    \begin{align}
    A_{1} = \begin{bmatrix} 
            (1 - \text{valueFraction})(1 - |n_{x}|) \\
            (1 - \text{valueFraction})(1 - |n_{y}|) \\
            (1 - \text{valueFraction})(1 - |n_{z}|) \\
            \end{bmatrix}
    \end{align}

.. math::
    \begin{align}
    B_{1} = \begin{bmatrix}
            \phi_{px} \\
            \phi_{py} \\
            \phi_{pz}
            \end{bmatrix}
          - \begin{bmatrix} 
            (1 - \text{valueFraction})(1 - |n_{x}|)\phi_{cx} \\
            (1 - \text{valueFraction})(1 - |n_{y}|)\phi_{cy} \\
            (1 - \text{valueFraction})(1 - |n_{z}|)\phi_{cz} \\
            \end{bmatrix}
    \end{align}

.. math::
    \begin{align}
    A_{2} = -\frac{1}{d}
            \begin{bmatrix}
            \text{valueFraction} + (1 - \text{valueFraction})|n_{x}| \\
            \text{valueFraction} + (1 - \text{valueFraction})|n_{y}| \\
            \text{valueFraction} + (1 - \text{valueFraction})|n_{z}|
            \end{bmatrix}
    \end{align}

.. math::
    \begin{align}
    B_{2} = \frac{1}{d} 
            \begin{bmatrix}
            (1 - \text{valueFraction})\big( n_{x} - n_{x}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z}) \big) - \phi_{cx} \\
            (1 - \text{valueFraction})\big( n_{y} - n_{y}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z}) \big) - \phi_{cy} \\
            (1 - \text{valueFraction})\big( n_{z} - n_{z}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z}) \big) - \phi_{cz}
            \end{bmatrix}
          + \frac{1}{d}
            \begin{bmatrix}
            \big( \text{valueFraction} + (1 - \text{valueFraction})|n_{x}| \big) \phi_{cx} \\
            \big( \text{valueFraction} + (1 - \text{valueFraction})|n_{y}| \big) \phi_{cy} \\
            \big( \text{valueFraction} + (1 - \text{valueFraction})|n_{z}| \big) \phi_{cz}
            \end{bmatrix}
    \end{align}

位于src/finiteVolume/fields/fvPatchFields/derived/partialSlip的partialSlipFvPatchField.C中定义系数的相关内容如下所示：

.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::partialSlipFvPatchField<Type>::snGrad() const    // 定义snGrad函数的操作内容
    {
        tmp<vectorField> nHat = this->patch().nf();    // 用nHat来表示面法向量
        const Field<Type> pif(this->patchInternalField());    // 用pif来表示内部场的值 \vec{\phi}_{c}

        return
        /*  snGrad函数的操作内容为 [ (1 - \text{valueFraction}) \times ( I-\vec{n} \otimes \vec{n} ) \cdot \vec{\phi}_{c} - \vec{\phi}_{c} ] * (1/d)
            分量形式为
            \text{snGrad}_{x} = [ (1 - \text{valueFraction}) \times (n_{x} - n_{x}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z})) - \phi_{cx} ] \times (1/d),
            \text{snGrad}_{y} = [ (1 - \text{valueFraction}) \times (n_{y} - n_{y}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z})) - \phi_{cy} ] \times (1/d),
            \text{snGrad}_{z} = [ (1 - \text{valueFraction}) \times (n_{z} - n_{z}(\phi_{cx}n_{x} + \phi_{cy}n_{y} + \phi_{cz}n_{z})) - \phi_{cz} ] \times (1/d)
        */
        (
            (1.0 - valueFraction_)*transform(I - sqr(nHat), pif) - pif
        )*this->patch().deltaCoeffs();
    }


    template<class Type>
    void Foam::partialSlipFvPatchField<Type>::evaluate
    (
        const Pstream::commsTypes
    )
    {
        if (!this->updated())
        {
            this->updateCoeffs();
        }

        tmp<vectorField> nHat = this->patch().nf();

        Field<Type>::operator=    // 定义evaluate的具体操作内容
        (
        /*
            (1 - \text{valueFraction}) \times [( I-\vec{n} \otimes \vec{n} ) \cdot \vec{\phi}_{c}]
        */
            (1.0 - valueFraction_)
           *transform(I - sqr(nHat), this->patchInternalField())
        );

        transformFvPatchField<Type>::evaluate();
    }


    template<class Type>
    Foam::tmp<Foam::Field<Type>>
    Foam::partialSlipFvPatchField<Type>::snGradTransformDiag() const    // 定义snGradTransformDiag函数的操作内容
    {
        const vectorField nHat(this->patch().nf());    // 用nHat来表示面法向量
        vectorField diag(nHat.size());    // 定义一个矢量场diag

        diag.replace(vector::X, mag(nHat.component(vector::X)));    // 替换对角矩阵x分量值为 |n_x| 
        diag.replace(vector::Y, mag(nHat.component(vector::Y)));    // 替换对角矩阵y分量值为 |n_y|
        diag.replace(vector::Z, mag(nHat.component(vector::Z)));    // 替换对角矩阵z分量值为 |n_z|
        /* 也即该向量场为 diag = ( |n_x| , |n_y| , |n_z|) */
        return
        /*  snGradTransformDiag函数的操作内容为 valueFraction * (1, 1, 1) + (1 - valueFraction) * diag
            分量形式为
            \text{snGradTransformDiag}_{x} = \text{valueFraction} + (1 - \text{valueFraction}) \times |n_{x}|,
            \text{snGradTransformDiag}_{y} = \text{valueFraction} + (1 - \text{valueFraction}) \times |n_{y}|,
            \text{snGradTransformDiag}_{z} = \text{valueFraction} + (1 - \text{valueFraction}) \times |n_{z}| 
        */
            valueFraction_*pTraits<Type>::one
          + (1.0 - valueFraction_)
           *transformFieldMask<Type>(pow<vector, pTraits<Type>::rank>(diag));
    }


    template<class Type>
    void Foam::partialSlipFvPatchField<Type>::write(Ostream& os) const
    {
        transformFvPatchField<Type>::write(os);
        writeEntry(os, "valueFraction", valueFraction_);    // 读取子字典中的valueFraction关键词赋值给valueFraction_变量
    }



freestreamVelocity
^^^^^^^^^^^^^^^^^^^^^^

该边界条件为速度提供了自由流条件。这是一种使用速度方向在正常入口的固定值和正常出口流量的零梯度之间连续混合的进出口条件。该边界条件继承于mixed边界条件。

.. code-block:: C

    const vectorField& freestreamValue() const
    {
        return refValue();
    }

    vectorField& freestreamValue()
    {
        return refValue();
    }

上面的代码表明freestreamValue等价与refValue。

.. code-block:: C

    void Foam::freestreamVelocityFvPatchVectorField::write(Ostream& os) const
    {
        fvPatchVectorField::write(os);
        writeEntry(os, "freestreamValue", freestreamValue());
        writeEntry(os, "value", *this);
    }

上面的代码表明freestreamVelocity边界条件将会读取设置中freestreamValue和value关键词的赋值。

.. code-block:: C

    Foam::freestreamVelocityFvPatchVectorField::freestreamVelocityFvPatchVectorField
    (
        const fvPatch& p,
        const DimensionedField<vector, volMesh>& iF,
        const dictionary& dict
    )
    :
        mixedFvPatchVectorField(p, iF)
    {
        freestreamValue() = vectorField("freestreamValue", dict, p.size());    // 读取freestreamValue的值赋给freestreamValue变量

        if (dict.found("value"))
        {
            fvPatchVectorField::operator=
            (
                vectorField("value", dict, p.size())    // 如果有value关键词则初始化边界值为value的值
            );
        }
        else
        {
            fvPatchVectorField::operator=(freestreamValue());    // 否则初始化边界值为freestreamValue的值
        }

        refGrad() = Zero;       // 初始化refGradient的值为0
        valueFraction() = 1;    // 初始化valueFraction的值为1
    }

上面的代码表明freestreamVelocity继承于mixed边界条件，并进行了边界情况的初始化，并初始化refGradient的值为 :math:`0` ，初始化valueFraction的值为 :math:`1` 。

.. code-block:: C

    void Foam::freestreamVelocityFvPatchVectorField::updateCoeffs()
    {
        if (updated())
        {
            return;
        }

        const Field<vector> Up(0.5*(patchInternalField() + *this));    // 定义Up，通过内部速度场和value的设置进行计算
        const Field<scalar> magUp(mag(Up));    // 定义magUp为Up的模长大小

        const Field<vector> nf(patch().nf());    // 定义nf为网格面单位法向量

        Field<scalar>& vf = valueFraction();    // 定义vf为valueFraction的值

        forAll(vf, i)
        {
            if (magUp[i] > vSmall)
            {
                vf[i] = 0.5 - 0.5*(Up[i] & nf[i])/magUp[i];    // 当Up的模长大小不是小量时valueFraction的设置方法
            }
            else
            {
                vf[i] = 0.5;    // 当Up的模长为小量时设置valueFraction为0.5
            }
        }

        mixedFvPatchField<vector>::updateCoeffs();    // 更新mixed边界条件的参数
    }

上面的代码给出了valueFraction的设置方式：

.. math::
    \begin{align}
    \text{valueFraction} = 
    \left \{\begin{array}{l}
    0.5 - 0.5 \times \frac{0.5\times (\mathbf{U}_{c} + \text{value}) \cdot \mathbf{n}}{|0.5\times (\mathbf{U}_{c} + \text{value})|} , \quad |0.5\times (\mathbf{U}_{c} + \text{value})| > \text{vSmall} \\
    0.5, \qquad\qquad\qquad\qquad\qquad\quad  |0.5\times (\mathbf{U}_{c} + \text{value})| \le \text{vSmall}
    \end{array}\right . 
    \end{align}


pressureInletVelocity
^^^^^^^^^^^^^^^^^^^^^^^^

这个速度入口边界条件适用于指定压力的边界面。流入速度由与边界面法线方向的通量得到。该边界条件继承于fixedValue边界条件，并且一般需要压力场配合使用totalPressure边界条件。

进入src/finiteVolume/fields/fvPatchFields/derived/pressureInletVelocity/pressureInletVelocityFvPatchVectorField.C文件，可以看到如下代码：

.. code-block:: C

    void Foam::pressureInletVelocityFvPatchVectorField::write(Ostream& os) const
    {
        fvPatchVectorField::write(os);
        writeEntryIfDifferent<word>(os, "phi", "phi", phiName_);    // 读取通量场的名字
        writeEntryIfDifferent<word>(os, "rho", "rho", rhoName_);    // 读取密度场的名字
        writeEntry(os, "value", *this);
    }


.. code-block:: C

    void Foam::pressureInletVelocityFvPatchVectorField::updateCoeffs()
    {
        if (updated())
        {
            return;
        }

        const surfaceScalarField& phi =
            db().lookupObject<surfaceScalarField>(phiName_);

        const fvsPatchField<scalar>& phip =    // 边界面的通量场
            patch().patchField<surfaceScalarField, scalar>(phi);

        tmp<vectorField> n = patch().nf();    // 边界面的单位面法向量
        const Field<scalar>& magS = patch().magSf();    // 边界面的面积

        if (phi.dimensions() == dimFlux)    // 不可压缩流的情况，通量为体积通量
        {
            operator==(n*phip/magS);
        }
        else if (phi.dimensions() == dimMassFlux)    // 可压缩流的情况，通量为质量通量
        {
            const fvPatchField<scalar>& rhop =    // 边界面的密度场
                patch().lookupPatchField<volScalarField, scalar>(rhoName_);

            operator==(n*phip/(rhop*magS));
        }
        else
        {
            FatalErrorInFunction
                << "dimensions of phi are not correct"
                << "\n    on patch " << this->patch().name()
                << " of field " << this->internalField().name()
                << " in file " << this->internalField().objectPath()
                << exit(FatalError);
        }

        fixedValueFvPatchVectorField::updateCoeffs();
    }

上面的代码表明，pressureInletVelocity所设置的边界速度计算方式为：

.. math::
    \begin{align}
    \mathbf{U} =
    \left \{ \begin{array}{l}
    \frac{\phi\mathbf{n}}{|\mathbf{S}_{f}|} ,\quad   ~\text{if}~\phi~\text{is volume flux}  \\
    \frac{\phi\mathbf{n}}{\rho|\mathbf{S}_{f}|},\quad \text{if}~\phi~\text{is mass flux}  
    \end{array} \right .
    \end{align}


pressureInletUniformVelocity
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

该速度入口边界条件适用于指定了压力的边界面。通过求边界面上通量的平均值来得到均一的入流速度，然后将其应用到边界面的法线方向。该边界条件继承于pressureInletUniformVelocity边界条件。

进入src/finiteVolume/fields/fvPatchFields/derived/pressureInletUniformVelocity/pressureInletUniformVelocityFvPatchVectorField.C文件，可以看到如下代码：

.. code-block:: C

    void Foam::pressureInletUniformVelocityFvPatchVectorField::updateCoeffs()
    {
        if (updated())
        {
            return;
        }

        pressureInletVelocityFvPatchVectorField::updateCoeffs();

        operator==(patch().nf()*gSum(patch().Sf() & *this)/gSum(patch().magSf()));
    }

由上面的代码可知，pressureInletUniformVelocity设置的边界速度计算方式为

.. math::
    \begin{align}
    \mathbf{U} = \frac{\mathbf{n} \sum\limits_{\text{global}}(\mathbf{S}_{f}\cdot \mathbf{U}_{p})}{\sum\limits_{\text{global}}|\mathbf{S}_{f}|}
    \end{align}


pressureDirectedInletVelocity
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

这个速度入口边界条件适用于指定压力的补丁。流入速度由指定进口方向“方向”的通量得到。该边界条件继承于fixedValue边界条件。


.. code-block:: C

    void Foam::pressureDirectedInletVelocityFvPatchVectorField::updateCoeffs()
    {
        if (updated())
        {
            return;
        }

        const surfaceScalarField& phi =
            db().lookupObject<surfaceScalarField>(phiName_);

        const fvsPatchField<scalar>& phip =    // 获取通量场
            patch().patchField<surfaceScalarField, scalar>(phi);

        tmp<vectorField> n = patch().nf();    // 边界面的法向量
        tmp<scalarField> ndmagS = (n & inletDir_)*patch().magSf();

        if (phi.dimensions() == dimFlux)    // 不可压缩流的情况，通量为体积通量
        {
            operator==(inletDir_*phip/ndmagS);    // 计算边界值
        }
        else if (phi.dimensions() == dimMassFlux)    // 可压缩流的情况，通量为质量通量
        {
            const fvPatchField<scalar>& rhop =    // 获取密度场
                patch().lookupPatchField<volScalarField, scalar>(rhoName_);

            operator==(inletDir_*phip/(rhop*ndmagS));    // 计算边界值
        }
        else
        {
            FatalErrorInFunction
                << "dimensions of phi are not correct"
                << "\n    on patch " << this->patch().name()
                << " of field " << this->internalField().name()
                << " in file " << this->internalField().objectPath()
                << exit(FatalError);
        }

        fixedValueFvPatchVectorField::updateCoeffs();
    }

上面的代码表明，pressureDirectedInletVelocity所设置的边界处的速度计算方式为

.. math::
    \begin{align}
    \mathbf{U} = 
    \left \{ \begin{array}{l}
    \mathbf{V}_{\text{dir}}\frac{\phi}{(\mathbf{n} \cdot \mathbf{V}_{\text{dir}})|\mathbf{S}_{f}|} , \quad \text{if}~\phi~\text{is volume flux}   \\
    \mathbf{V}_{\text{dir}}\frac{\phi}{\rho (\mathbf{n} \cdot \mathbf{V}_{\text{dir}})|\mathbf{S}_{f}| } ,\quad \text{if}~\phi~\text{is mass flux}
    \end{array} \right .
    \end{align}

.. code-block:: C

    void Foam::pressureDirectedInletVelocityFvPatchVectorField::write
    (
        Ostream& os
    ) const
    {
        fvPatchVectorField::write(os);
        writeEntryIfDifferent<word>(os, "phi", "phi", phiName_);
        writeEntryIfDifferent<word>(os, "rho", "rho", rhoName_);
        writeEntry(os, "inletDirection", inletDir_);
        writeEntry(os, "value", *this);
    }



pressureInletOutletVelocity
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

这是一个速度入口/出口边界条件，其中需要压力场配合使用fixedValue、totalPressure、entrainmentPressure等边界条件。该边界条件继承于directioniMixed边界，对于出流等价于zeroGradient边界条件；对于入流将会为法向分量设置为zeroGradient而为切向分量设置为fixedValue。外部切向速度可以被任意指定，如果没有设置则视为零。

进入src/finiteVolume/fields/fvPatchFields/derived/pressureInletOutletVelocityFvPatchVectorField.C文件，可以看到如下代码：

.. code-block:: C

    Foam::pressureInletOutletVelocityFvPatchVectorField::
    pressureInletOutletVelocityFvPatchVectorField
    (
        const fvPatch& p,
        const DimensionedField<vector, volMesh>& iF,
        const dictionary& dict
    )
    :
        directionMixedFvPatchVectorField(p, iF),    // 继承于directionMixed边界条件
        phiName_(dict.lookupOrDefault<word>("phi", "phi"))    // 读取phi关键词设置，默认为通量场名称为phi
    {
        fvPatchVectorField::operator=(vectorField("value", dict, p.size()));    // 读取value关键词赋值进行初始化

        if (dict.found("tangentialVelocity"))    // 如果设置了tangentialVelocity关键词则读取赋值
        {
            tangentialVelocity_ =
                Function1<vector>::New("tangentialVelocity", dict);
        }

        refValue() = Zero;         // 初始化refValue为零
        refGrad() = Zero;          // 初始化refGrad为零
        valueFraction() = Zero;    // 初始化valueFraction为零
    }


.. code-block:: C

    void Foam::pressureInletOutletVelocityFvPatchVectorField::updateCoeffs()
    {
        if (updated())
        {
            return;
        }

        if (tangentialVelocity_.valid())    // 如果设置了tangentialVelocity的值
        {
            const scalar t = this->db().time().userTimeValue();    // 获取时间t
            const vector tangentialVelocity = tangentialVelocity_->value(t);    // 获取在时间t时候tangentialVelocity的值
            const vectorField n(patch().nf());    // 边界面的单位面法向量
            refValue() = tangentialVelocity - n*(n & tangentialVelocity);    // 计算refValue
        }

        const fvsPatchField<scalar>& phip =    // 边界面的通量场
            patch().lookupPatchField<surfaceScalarField, scalar>(phiName_);

        valueFraction() = neg(phip)*(I - sqr(patch().nf()));    // 计算valueFraction

        directionMixedFvPatchVectorField::updateCoeffs();
        directionMixedFvPatchVectorField::evaluate();
    }

上面的代码表明，在pressureInletOutletVelocity边界条件中，在没有设置tangentialVelocity关键词的时候，refValue和refGrad的值被默认设置为了零，而valueFraction的计算方式为

.. math::
    \begin{align}
    \text{valueFraction} = 
    \left \{ \begin{array}{l}
    \mathbf{0}, \quad \phi \ge 0 \\
    \mathbf{I} - \mathbf{n}^{2} =
    \begin{bmatrix}
    1 - n_{x}^{2} \\
    1 - n_{y}^{2} \\
    1 - n_{z}^{2}
    \end{bmatrix}
    , \quad \phi < 0
    \end{array} \right . 
    \end{align}

如果设置了tangentialVelocity关键词，那么refValue将不再是零，其计算方式为

.. math::
    \begin{align}
    \text{refValue} = \mathbf{U_{\text{tan}}}(t) - \big(\mathbf{n} \cdot \mathbf{U_{\text{tan}}}(t)\big)\mathbf{n} 
    \end{align}



pressureDirectedInletOutletVelocity
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

该速度入口/出口边界条件应用于指定了压力的边界。对于出流，该边界条件等价于zeroGradient(由通量定义)；对于入流，速度由指定进口方向的通量得到。该边界条件继承于mixed边界条件。


.. code-block:: C

    Foam::pressureDirectedInletOutletVelocityFvPatchVectorField::
    pressureDirectedInletOutletVelocityFvPatchVectorField
    (
        const fvPatch& p,
        const DimensionedField<vector, volMesh>& iF,
        const dictionary& dict
    )
    :
        mixedFvPatchVectorField(p, iF),    // 继承于mixed边界条件
        phiName_(dict.lookupOrDefault<word>("phi", "phi")),    // 读取通量场名称，默认为phi
        rhoName_(dict.lookupOrDefault<word>("rho", "rho")),    // 读取密度场名称，默认为rho
        inletDir_("inletDirection", dict, p.size())    // 读取指定的进口速度
    {
        fvPatchVectorField::operator=(vectorField("value", dict, p.size()));    // 读取value关键词进行初始化
        refValue() = *this;    // 初始化refValue为当前值
        refGrad() = Zero;    // 初始化refGrad为零
        valueFraction() = 0.0;    // 初始化valueFraction为零
    }



.. code-block:: C

    void Foam::pressureDirectedInletOutletVelocityFvPatchVectorField::updateCoeffs()
    {
        if (updated())
        {
            return;
        }

        const surfaceScalarField& phi =
            db().lookupObject<surfaceScalarField>(phiName_);

        const fvsPatchField<scalar>& phip =    // 获取通量场
            patch().patchField<surfaceScalarField, scalar>(phi);

        tmp<vectorField> n = patch().nf();    // 获取边界面单位面法向量
        tmp<scalarField> ndmagS = (n & inletDir_)*patch().magSf();

        if (phi.dimensions() == dimFlux)    // 不可压缩流体，通量为体积通量
        {
            refValue() = inletDir_*phip/ndmagS;    // 计算refValue
        }
        else if (phi.dimensions() == dimMassFlux)    // 可压缩流体，通量为质量通量
        {
            const fvPatchField<scalar>& rhop =    // 获取密度场
                patch().lookupPatchField<volScalarField, scalar>(rhoName_);

            refValue() = inletDir_*phip/(rhop*ndmagS);    // 计算refValue
        }
        else
        {
            FatalErrorInFunction
                << "dimensions of phi are not correct"
                << "\n    on patch " << this->patch().name()
                << " of field " << this->internalField().name()
                << " in file " << this->internalField().objectPath()
                << exit(FatalError);
        }

        valueFraction() = neg(phip);    // 根据通量正负号设置valueFraction

        mixedFvPatchVectorField::updateCoeffs();
    }

上面的代码表明，refGrad默认被设置为零；valueFraction在入流的时候为设置为 :math:`1` ，在出流的时候设置为 :math:`0` ；refValue的计算方式为

.. math::
    \begin{align}
    \text{refValue} = 
    \left \{ \begin{array}{l}
    \mathbf{V}_{\text{dir}}\frac{\phi}{(\mathbf{n}_{f} \cdot \mathbf{V}_{\text{dir}})|\mathbf{S}_{f}|} , \quad \text{if}~\phi~\text{is volume flux} \\
    \mathbf{V}_{\text{dir}}\frac{\phi}{\rho (\mathbf{n}_{f} \cdot \mathbf{V}_{\text{dir}})|\mathbf{S}_{f}|} , \quad \text{if}~\phi~\text{is mass flux}
    \end{array} \right . 
    \end{align}


.. code-block:: C

    void Foam::pressureDirectedInletOutletVelocityFvPatchVectorField::write
    (
        Ostream& os
    ) const
    {
        fvPatchVectorField::write(os);
        writeEntryIfDifferent<word>(os, "phi", "phi", phiName_);
        writeEntryIfDifferent<word>(os, "rho", "rho", rhoName_);
        writeEntry(os, "inletDirection", inletDir_);
        writeEntry(os, "value", *this);
    }




压强边界条件
--------------

pressure
^^^^^^^^^^^^

静压边界条件。用作静态压力边界条件的基类，强迫替代压力变量，例如p_rgh。该边界条件继承于fixedValue边界条件。

.. code-block:: C

    Foam::pressureFvPatchScalarField::pressureFvPatchScalarField
    (
        const fvPatch& p,
        const DimensionedField<scalar, volMesh>& iF,
        const dictionary& dict
    )
    :
        fixedValueFvPatchScalarField(p, iF, dict, false),
        p_("p", dict, p.size())
    {
        if (dict.found("value"))
        {
            fvPatchScalarField::operator=
            (
                scalarField("value", dict, p.size())
            );
        }
        else
        {
            fvPatchField<scalar>::operator=(p_);
        }
    }


.. code-block:: C

    void Foam::pressureFvPatchScalarField::updateCoeffs()
    {
        if (updated())
        {
            return;
        }

        operator==(p_);

        fixedValueFvPatchScalarField::updateCoeffs();
    }


.. code-block:: C

    void Foam::pressureFvPatchScalarField::write(Ostream& os) const
    {
        fvPatchScalarField::write(os);
        writeEntry(os, "p", p_);
        writeEntry(os, "value", *this);
    }




freestreamPressure
^^^^^^^^^^^^^^^^^^^^^

该边界条件为压力提供了自由流动条件。这是一种出口-进口条件，使用速度方向在正常入口的零梯度和正常出口流量的固定值之间连续混合。该边界条件继承于mixed边界条件，通过利用速度设置valueFraction的值来实现。

进入src/finiteVolume/fields/fvPatchFields/derived/freestreamPressure/freestreamPressureFvPatchScalarField.H文件中，可以看到下面定义了一个成员函数：

.. code-block:: C

    const scalarField& freestreamValue() const
    {
        return refValue();
    }

    scalarField& freestreamValue()
    {
        return refValue();
    }

上面的代码表明freestreamValue等价于mixed边界条件里面的refValue。

进入src/finiteVolume/fields/fvPatchFields/derived/freestreamPressure/freestreamPressureFvPatchScalarField.C文件中，可以看到相关参数设置方式：

.. code-block:: C

    void Foam::freestreamPressureFvPatchScalarField::write(Ostream& os) const
    {
        fvPatchScalarField::write(os);
        writeEntryIfDifferent<word>(os, "U", "U", UName_);
        writeEntry(os, "freestreamValue", freestreamValue());
        writeEntry(os, "supersonic", supersonic_);
        writeEntry(os, "value", *this);
    }

上面的代码说明freestreamPressure将会读取速度场的名称，并且查找边界设置的freestreamValue、supersonic和value三个关键词。

.. code-block:: C

    Foam::freestreamPressureFvPatchScalarField::
    freestreamPressureFvPatchScalarField
    (
        const fvPatch& p,
        const DimensionedField<scalar, volMesh>& iF,
        const dictionary& dict
    )
    :
        mixedFvPatchScalarField(p, iF),
        UName_(dict.lookupOrDefault<word>("U", "U")),
        supersonic_
        (
            dict.lookupOrDefault<Switch>("supersonic", false)    // 读取字典关键词supersonic的赋值，默认是false
        )
    {
        freestreamValue() = scalarField("freestreamValue", dict, p.size());

        if (dict.found("value"))
        {
            fvPatchScalarField::operator=
            (
                scalarField("value", dict, p.size())    // 如果字典中有value关键词就先将边界的值初始化为value的值
            );
        }
        else
        {
            fvPatchScalarField::operator=(freestreamValue());    // 如果没有value关键词就将边界初始化为freestreamValue的值
        }

        refGrad() = Zero;       // 初始化refGradient的值为0
        valueFraction() = 0;    // 初始化valueFraction的值为0
    }

上面的代码表明freestreamPreassure边界条件继承于mixed边界条件，并且refGradient的值被设置为了 :math:`0` ，而refValue则设置为了freestreamValue的值。

.. code-block:: C

    void Foam::freestreamPressureFvPatchScalarField::updateCoeffs()
    {
        if (updated())
        {
            return;
        }

        const Field<vector>& Up =    // 定义Up为当前的速度场
            patch().template lookupPatchField<volVectorField, vector>
            (
                UName_
            );

        const Field<scalar> magUp(mag(Up));    // 定义magUp为当前速度场的模长大小

        const Field<vector> nf(patch().nf());    // 定义nf为网格面单位法向量

        Field<scalar>& vf = valueFraction();    // 定义vf为valueFraction的值

        if (supersonic_)    // 如果设置supersonic为true
        {
            forAll(vf, i)
            {
                if (magUp[i] > vSmall)    // 如果速度场大小不是一个小量
                {
                    vf[i] = 0.5 - 0.5*(Up[i] & nf[i])/magUp[i];    // 设置valueFraction的值
                }
                else
                {
                    vf[i] = 0.5;    // 如果速度场大小是一个小量则取valueFraction = 0.5
                }
            }
        }
        else    // 如果设置supersonic为false
        {
            forAll(vf, i)
            {
                if (magUp[i] > vSmall)    // 如果速度场大小不是一个小量
                {
                    vf[i] = 0.5 + 0.5*(Up[i] & nf[i])/magUp[i];    // 设置valueFraction的值
                }
                else
                {
                    vf[i] = 0.5;    // 如果速度场大小是一个小量则取valueFraction = 0.5
                }
            }
        }

        mixedFvPatchField<scalar>::updateCoeffs();    // 更新mixed边界条件参数设置
    }

上面的代码表明，当设置supersonic为true时，valueFraction的计算方式为

.. math::
    \begin{align}
    \text{valueFraction} = 
    \left\{\begin{array}{l}
    0.5 - 0.5\times \frac{\mathbf{U} \cdot \mathbf{n}}{|\mathbf{U}|}, \quad |\mathbf{U}| > \text{vSmall} \\
    0.5 , \qquad\qquad\qquad ~~ |\mathbf{U}| \le \text{vSmall}
    \end{array}\right .
    \end{align}

当设置supersonic为false时，valueFraction的计算方式为

.. math::
    \begin{align}
    \text{valueFraction} = 
    \left\{\begin{array}{l}
    0.5 + 0.5\times \frac{\mathbf{U} \cdot \mathbf{n}}{|\mathbf{U}|}, \quad |\mathbf{U}| > \text{vSmall} \\
    0.5 , \qquad\qquad\qquad ~~ |\mathbf{U}| \le \text{vSmall}
    \end{array}\right .
    \end{align}

于是，freestreamPressure边界条件的四个参数的具体计算方式为

.. math::
    \begin{align}
    & A_{1} = 1 - \text{valueFraction}, && B_{1} = \text{valueFraction} \times \text{freestreamValue} \\
    & A_{2} = \frac{-\text{valueFraction}}{d}, && B_{2} = \frac{\text{valueFraction} \times \text{freestreamValue}}{d}   
    \end{align}


下面是使用该边界条件的一般设置方式：

.. code-block:: C

    patchName
    {
        type            freestreamPressure;
        freestreamValue uniform 1e5;
    }



dynamicPressure
^^^^^^^^^^^^^^^^^^^


这个边界条件提供了一个动态压力条件。它从参考压力中减去动能项得到边界上固定的值。它构成了总压力和夹带压力条件的基类。

.. code-block:: C

    void Foam::dynamicPressureFvPatchScalarField::updateCoeffs
    (
        const scalarField& p0p,    // 静压
        const scalarField& K0mKp   // 单位动能
    )
    {
        if (updated())
        {
            return;
        }

        if (internalField().dimensions() == dimPressure)    // 如果内部场单位是Pa，即可压缩流情况
        {
            if (psiName_ == "none")    // 变密度和低速可压缩流的情况
            {
                // Variable density and low-speed compressible flow

                const fvPatchField<scalar>& rho =    // 定义密度场
                    patch().lookupPatchField<volScalarField, scalar>(rhoName_);

                operator==(p0p + rho*K0mKp);    // 计算值设置为fixedValue
            }
            else    // 高速可压缩流的情况
            {
                // High-speed compressible flow

                const fvPatchField<scalar>& psip =    // 定义可压缩性场
                    patch().lookupPatchField<volScalarField, scalar>(psiName_);

                if (gamma_ > 1)    // 比热容比大于1的情况
                {
                    const scalar gM1ByG = (gamma_ - 1)/gamma_;

                    operator==
                    (
                        p0p/pow(scalar(1) - psip*gM1ByG*K0mKp, 1/gM1ByG)
                    );
                }
                else    // 比热容小于等于1的情况
                {
                    operator==(p0p/(scalar(1) - psip*K0mKp));
                }
            }
        }
        else if (internalField().dimensions() == dimPressure/dimDensity)    // 不可压缩流情况
        {
            // Incompressible flow

            operator==(p0p + K0mKp);
        }
        else
        {
            FatalErrorInFunction
                << " Incorrect pressure dimensions " << internalField().dimensions()
                << nl
                << "    Should be " << dimPressure
                << " for compressible/variable density flow" << nl
                << "    or " << dimPressure/dimDensity
                << " for incompressible flow," << nl
                << "    on patch " << this->patch().name()
                << " of field " << this->internalField().name()
                << " in file " << this->internalField().objectPath()
                << exit(FatalError);
        }

        fixedValueFvPatchScalarField::updateCoeffs();    // 调用fixedValue边界条件的updateCoeffs
    }

从上面的代码可以看到，dynamicPressure边界条件实际上是通过某些方式计算得到压强值以fixedValue的方式进行边界设置的。对于变密度和低速可压缩流的情况，需要设置psi场的名为none，且计算方式为

.. math::
    \begin{align}
    p = p_{0} + \rho \cdot K
    \end{align}

对于高速可压缩流的情况，需要给定psi场的名，且计算方式为

.. math::
    \begin{align}
    p = 
    \left \{ \begin{array}{l}
    \frac{p_{0}}{\Big(1 - \psi \cdot \frac{\gamma - 1}{\gamma} \cdot K \Big)^{\frac{\gamma}{\gamma -1}}} , \quad \gamma > 1 \\
    \frac{p_{0}}{1 - \psi \cdot K} , \qquad\qquad\quad  \gamma \le 1
    \end{array} \right.
    \end{align}

对于不可压缩流的情况，计算方式为

.. math::
    \begin{align}
    p = p_{0} + K
    \end{align}


.. code-block:: C

    Foam::dynamicPressureFvPatchScalarField::dynamicPressureFvPatchScalarField
    (
        const fvPatch& p,
        const DimensionedField<scalar, volMesh>& iF,
        const dictionary& dict
    )
    :
        fixedValueFvPatchScalarField(p, iF, dict, false),
        rhoName_(dict.lookupOrDefault<word>("rho", "rho")),
        psiName_(dict.lookupOrDefault<word>("psi", "none")),
        gamma_(dict.lookupOrDefault<scalar>("gamma", 1)),
        p0_("p0", dict, p.size())
    {
        if (dict.found("value"))
        {
            fvPatchField<scalar>::operator=
            (
                scalarField("value", dict, p.size())
            );
        }
        else
        {
            fvPatchField<scalar>::operator=(p0_);
        }
    }

从上面的代码可知，初始化时会将psi的名设置为none，gamma的值初始化为 :math:`1` 。

.. code-block:: C

    void Foam::dynamicPressureFvPatchScalarField::write(Ostream& os) const
    {
        fvPatchScalarField::write(os);
        writeEntry(os, "rho", rhoName_);
        writeEntry(os, "psi", psiName_);
        writeEntry(os, "gamma", gamma_);
        writeEntry(os, "p0", p0_);
        writeEntry(os, "value", *this);
    }


totalPressure
^^^^^^^^^^^^^^^^^

基于恒定总压假设的流入、流出和夹带压力边界条件。对于流出，贴片压力设置为外部静压。对于流入，贴片压力是根据贴片速度和外部静压p0和外部速度U0来评估的，外部速度U0是根据贴片速度边界条件(如果使用该边界条件)中的可选tangentialVelocity入口查找的，否则U0被假设为零，外部总压力等于外部静压。

.. code-block:: C

    void Foam::totalPressureFvPatchScalarField::updateCoeffs()
    {
        const fvsPatchField<scalar>& phip =    // 获取通量场，用来表明方向，后续根据其正负号来运算
            patch().lookupPatchField<surfaceScalarField, scalar>(phiName_);

        const fvPatchField<vector>& Up =   // 获取速度场
            patch().lookupPatchField<volVectorField, vector>(UName_);

        if (isA<pressureInletOutletVelocityFvPatchVectorField>(Up))    // 如果速度场的边界条件设为了pressureInletOutletVelocity
        {
            const pressureInletOutletVelocityFvPatchVectorField& Upiov =
                refCast<const pressureInletOutletVelocityFvPatchVectorField>(Up);

            if (Upiov.tangentialVelocity().valid())
            {
                const scalar t = this->db().time().userTimeValue();

                dynamicPressureFvPatchScalarField::updateCoeffs
                (
                    p0_,
                    0.5*neg(phip)*magSqr(Upiov.tangentialVelocity()->value(t))
                  - 0.5*neg(phip)*magSqr(Up)
                );

                return;
            }
        }

        dynamicPressureFvPatchScalarField::updateCoeffs
        (
            p0_,
            -0.5*neg(phip)*magSqr(Up)
        );
    }

可以看到totalPressure边界条件继承于dynamicPressure边界条件，就是通过字典关键词p0来设置dynamicPressure中p0p的值，并且确定了单位动能的计算方式为

.. math::
    \begin{align}
    K = 
    \left \{ \begin{array}{l}
    0, \quad \phi \ge 0 \\
    -\frac{1}{2}|\mathbf{U}|^{2} ,\quad \phi < 0 
    \end{array} \right .
    \end{align}

而当速度边界条件设置为pressureInletOutletVelocity时，单位动能的计算方式则有所不同：

.. math::
    \begin{align}
    K = 
    \left \{ \begin{array}{l}
    0, \quad \phi \ge 0 \\
    \frac{1}{2}|\mathbf{U}_{\text{tan}}(t)|^{2} - \frac{1}{2}|\mathbf{U}|^{2}, \quad \phi < 0
    \end{array} \right .
    \end{align}


温度边界条件
---------------

totalTemperature
^^^^^^^^^^^^^^^^^^^

这个边界条件提供了一个总温度条件。该边界条件继承于fixedValue边界条件。

进入src/finiteVolume/fields/fvPatchFields/derived/totalTemperature/totalTemperatureFvPatchScalarField.C文件，可以看到如下代码：

.. code-block:: C

    Foam::totalTemperatureFvPatchScalarField::totalTemperatureFvPatchScalarField
    (
        const fvPatch& p,
        const DimensionedField<scalar, volMesh>& iF,
        const dictionary& dict
    )
    :
        fixedValueFvPatchScalarField(p, iF, dict, false),
        UName_(dict.lookupOrDefault<word>("U", "U")),    // 读取速度场名称，默认为U
        phiName_(dict.lookupOrDefault<word>("phi", "phi")),    // 读取通量场名称，默认为phi
        psiName_(dict.lookupOrDefault<word>("psi", "thermo:psi")),    // 读取可压缩性场名称，默认为thermo:psi
        gamma_(dict.lookup<scalar>("gamma")),    // 读取比热容比的赋值
        T0_("T0", dict, p.size())    // 读取参考温度的赋值
    {
        if (dict.found("value"))    // 如果有value关键词则用value关键词的赋值进行初始化
        {
            fvPatchField<scalar>::operator=
            (
                scalarField("value", dict, p.size())
            );
        }
        else
        {
            fvPatchField<scalar>::operator=(T0_);    // 否则使用T0的值进行初始化
        }
    }

.. code-block:: C

    void Foam::totalTemperatureFvPatchScalarField::updateCoeffs()
    {
        if (updated())
        {
            return;
        }

        const fvPatchVectorField& Up =    // 获取速度场
            patch().lookupPatchField<volVectorField, vector>(UName_);

        const fvsPatchField<scalar>& phip =    // 获取通量场
            patch().lookupPatchField<surfaceScalarField, scalar>(phiName_);

        const fvPatchField<scalar>& psip =    // 获取可压缩性场
            patch().lookupPatchField<volScalarField, scalar>(psiName_);

        scalar gM1ByG = (gamma_ - 1.0)/gamma_;

        operator==
        (
            T0_/(1.0 + 0.5*psip*gM1ByG*neg(phip)*magSqr(Up))    // 计算边界处的赋值
        );

        fixedValueFvPatchScalarField::updateCoeffs();
    }

上面的代码表明，totalTemperature边界条件的边界温度计算方式为

.. math::
    \begin{align}
    T = 
    \left \{ \begin{array}{l}
    T_{0}, \quad \phi \ge 0 \\
    \frac{T_{0}}{1 + \frac{1}{2}\psi \frac{\gamma - 1}{\gamma}|\mathbf{U}|^{2}}, \quad \phi <0
    \end{array} \right .
    \end{align}

.. code-block:: C

    void Foam::totalTemperatureFvPatchScalarField::write(Ostream& os) const
    {
        fvPatchScalarField::write(os);
        writeEntryIfDifferent<word>(os, "U", "U", UName_);
        writeEntryIfDifferent<word>(os, "phi", "phi", phiName_);
        writeEntryIfDifferent<word>(os, "psi", "thermo:psi", psiName_);
        writeEntry(os, "gamma", gamma_);
        writeEntry(os, "T0", T0_);
        writeEntry(os, "value", *this);
    }



无反射边界条件
-----------------

advective
^^^^^^^^^^^^

可以参考 `OpenFOAM无反射边界条件源码学习 <https://blog.csdn.net/weixin_39124457/article/details/120152679>`_ 

该边界条件提供了一个平流流出条件，基于求解边界处的DDt(W, field) = 0，其中W为波速，field为应用该边界条件的场。该边界条件支持标准时间格式(Euler, backward, CrankNicolson, localEuler)。此外，还提供了一种可选机制，通过指定松弛长度尺度lInf和远场值fieldInf，将边界处的值放松到指定的远场值。出口的流/波速度(w)由虚函数advectionSpeed()提供，该函数的默认实现需要通量场的名称(phi)，如果给出的是质量通量而不是体积通量则还需要密度(rho)。

.. note:: 出口的流/波速度可以通过从这个类中派生一个专门的BC并覆盖advectionSpeed()来改变，例如在waveTransmissiveFvPatchField中，advectionSpeed()计算并返回流速度加上声波速度，从而创建一个声波传输边界条件。

边界处无反射在物理意义上可以认为是该物理量在边界处的物质导数为零，即由当地时间变化所引起的变化率与由流体通过边界流出引起的变化率的和恒为零：

.. math::
    \begin{align}
    \frac{D\phi}{Dt} = \frac{\partial \phi}{\partial t} + \mathbf{U} \cdot \nabla \phi 
    \approx \frac{\partial \phi}{\partial t} + U_{n}\cdot \frac{\partial \phi}{\partial \mathbf{n}} = 0
    \end{align}

其中 :math:`\phi` 就是需要无反射处理的流场变量。在后续， :math:`\frac{\partial \phi}{\partial t}` 项需要根据时间离散格式进行不同的处理， :math:`U_{n}` 则通过advectionSpeed()函数计算。

.. code-block:: C

    template<class Type>
    Foam::advectiveFvPatchField<Type>::advectiveFvPatchField
    (
        const fvPatch& p,
        const DimensionedField<Type, volMesh>& iF,
        const dictionary& dict
    )
    :
        mixedFvPatchField<Type>(p, iF),    // 继承于mixed边界条件
        phiName_(dict.lookupOrDefault<word>("phi", "phi")),    // 获取通量场的名称
        rhoName_(dict.lookupOrDefault<word>("rho", "rho")),    // 获取密度场的名称
        fieldInf_(Zero),    // 远场值初始化为零
        lInf_(-great)       // 松弛长度尺度初始化为-great
    {
        if (dict.found("value"))    // 如果设置了value
        {
            fvPatchField<Type>::operator=
            (
                Field<Type>("value", dict, p.size())    // 则用value初始化边界值
            );
        }
        else
        {
            fvPatchField<Type>::operator=(this->patchInternalField());   // 否则使用内部场的值初始化
        }

        this->refValue() = *this;       // refValue初始化为边界的当前值
        this->refGrad() = Zero;         // refGrad初始化为零
        this->valueFraction() = 0.0;    // valueFraction初始化为零

        if (dict.readIfPresent("lInf", lInf_))    // 如果设置了松弛长度尺度则读取
        {
            dict.lookup("fieldInf") >> fieldInf_;    // 并进一步读取远场值

            if (lInf_ < 0.0)    // 如果松弛长度尺度为负数则报错
            {
                FatalIOErrorInFunction
                (
                    dict
                )   << "unphysical lInf specified (lInf < 0)" << nl
                    << "    on patch " << this->patch().name()
                    << " of field " << this->internalField().name()
                    << " in file " << this->internalField().objectPath()
                    << exit(FatalIOError);
            }
        }
    }

上面的代码表明，refGrad被初始化为零，并且后续也没有修改。如果在字典中设置了松弛长度尺度lInf，那么它必须大于等于0，否则将会报错；而且只有设置了lInf之后才会进一步读取远场值fieldInf。

.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::scalarField>
    Foam::advectiveFvPatchField<Type>::advectionSpeed() const
    {
        const surfaceScalarField& phi =
            this->db().objectRegistry::template lookupObject<surfaceScalarField>
            (phiName_);

        const fvsPatchField<scalar>& phip =    // 获取通量场
            this->patch().template lookupPatchField<surfaceScalarField, scalar>
            (
                phiName_
            );

        if (phi.dimensions() == dimMassFlux)    // 可压缩流的情况，通量为质量通量
        {
            const fvPatchScalarField& rhop =    // 获取密度场
                this->patch().template lookupPatchField<volScalarField, scalar>
                (
                    rhoName_
                );

            return phip/(rhop*this->patch().magSf());
        }
        else
        {
            return phip/this->patch().magSf();
        }
    }

上面的代码定义了advectionSpeed()函数返回的内容，返回值为

.. math::
    \begin{align}
    w = 
    \left\{\begin{array}{l}
    \frac{\phi}{|\mathbf{S}_{f}|} ,\quad \text{if}~\phi~\text{is volume flux}  \\
    \frac{\phi}{\rho |\mathbf{S}_{f}|} ,\quad \text{if}~\phi~\text{is mass flux}  
    \end{array}\right .
    \end{align}

.. code-block:: C

    template<class Type>
    void Foam::advectiveFvPatchField<Type>::updateCoeffs()
    {
        if (this->updated())
        {
            return;
        }

        const fvMesh& mesh = this->internalField().mesh();

        word ddtScheme
        (
            mesh.schemes().ddt(this->internalField().name())
        );
        scalar deltaT = this->db().time().deltaTValue();    // 获取时间步长

        const GeometricField<Type, fvPatchField, volMesh>& field =    // 获取内部场
            this->db().objectRegistry::template
            lookupObject<GeometricField<Type, fvPatchField, volMesh>>
            (
                this->internalField().name()
            );

        // Calculate the advection speed of the field wave
        // If the wave is incoming set the speed to 0.
        const scalarField w(Foam::max(advectionSpeed(), scalar(0)));    // 计算advectionSpeed，如果是入流则取0

        // Calculate the field wave coefficient alpha (See notes)
        const scalarField alpha(w*deltaT*this->patch().deltaCoeffs());    // 计算场波系数alpha

        label patchi = this->patch().index();

        // Non-reflecting outflow boundary
        // If lInf_ defined setup relaxation to the value fieldInf_.
        if (lInf_ > 0)    // 如果松弛长度尺度大于0
        {
            // Calculate the field relaxation coefficient k (See notes)
            const scalarField k(w*deltaT/lInf_);    // 计算场松弛系数k

            if    // 如果时间离散格式设置的是Euler或CrankNicolson格式
            (
                ddtScheme == fv::EulerDdtScheme<scalar>::typeName
             || ddtScheme == fv::CrankNicolsonDdtScheme<scalar>::typeName
            )
            {
                this->refValue() =    // 计算refValue
                (
                    field.oldTime().boundaryField()[patchi] + k*fieldInf_
                )/(1.0 + k);

                this->valueFraction() = (1.0 + k)/(1.0 + alpha + k);    // 计算valueFraction
            }
            else if (ddtScheme == fv::backwardDdtScheme<scalar>::typeName)    // 如果时间离散格式设置的是backward格式
            {
                this->refValue() =    // 计算refValue
                (
                    2.0*field.oldTime().boundaryField()[patchi]
                  - 0.5*field.oldTime().oldTime().boundaryField()[patchi]
                  + k*fieldInf_
                )/(1.5 + k);

                this->valueFraction() = (1.5 + k)/(1.5 + alpha + k);    // 计算valueFraction
            }
            else if    // 如果时间离散格式设置的是localEuler格式
            (
                ddtScheme == fv::localEulerDdtScheme<scalar>::typeName
            )
            {
                const volScalarField& rDeltaT =
                    fv::localEulerDdt::localRDeltaT(mesh);

                // Calculate the field wave coefficient alpha (See notes)
                const scalarField alpha    // 更新场波系数alpha
                (
                    w*this->patch().deltaCoeffs()/rDeltaT.boundaryField()[patchi]
                );

                // Calculate the field relaxation coefficient k (See notes)
                const scalarField k(w/(rDeltaT.boundaryField()[patchi]*lInf_));    // 更新场松弛系数k

                this->refValue() =    // 计算refValue
                (
                    field.oldTime().boundaryField()[patchi] + k*fieldInf_
                )/(1.0 + k);

                this->valueFraction() = (1.0 + k)/(1.0 + alpha + k);    // 计算valueFraction
            }
            else    // 当设置的时间离散格式不是Euler,CrankNicolson,backward,localEuler中的其中一种时将报错
            {
                FatalErrorInFunction
                    << ddtScheme << nl
                    << "    on patch " << this->patch().name()
                    << " of field " << this->internalField().name()
                    << " in file " << this->internalField().objectPath()
                    << exit(FatalError);
            }
        }
        else    // 如果松弛长度尺度等于0
        {
            if    // 如果时间离散格式设置的是Euler或CrankNicolson格式
            (
                ddtScheme == fv::EulerDdtScheme<scalar>::typeName
             || ddtScheme == fv::CrankNicolsonDdtScheme<scalar>::typeName
            )
            {
                this->refValue() = field.oldTime().boundaryField()[patchi];    // 计算refValue

                this->valueFraction() = 1.0/(1.0 + alpha);    // 计算valueFraction
            }
            else if (ddtScheme == fv::backwardDdtScheme<scalar>::typeName)    // 如果时间离散格式设置的是backward格式
            {
                this->refValue() =    // 计算refValue
                (
                    2.0*field.oldTime().boundaryField()[patchi]
                  - 0.5*field.oldTime().oldTime().boundaryField()[patchi]
                )/1.5;

                this->valueFraction() = 1.5/(1.5 + alpha);    // 计算valueFraction
            }
            else if    // 如果时间离散格式设置的是localEuler格式
            (
                ddtScheme == fv::localEulerDdtScheme<scalar>::typeName
            )
            {
                const volScalarField& rDeltaT =
                    fv::localEulerDdt::localRDeltaT(mesh);

                // Calculate the field wave coefficient alpha (See notes)
                const scalarField alpha    // 更新场波系数alpha
                (
                    w*this->patch().deltaCoeffs()/rDeltaT.boundaryField()[patchi]
                );

                this->refValue() = field.oldTime().boundaryField()[patchi];    // 计算refValue

                this->valueFraction() = 1.0/(1.0 + alpha);    // 计算valueFraction
            }
            else    // 当设置的时间离散格式不是Euler,CrankNicolson,backward,localEuler中的其中一种时将报错
            {
                FatalErrorInFunction
                    << ddtScheme
                    << "\n    on patch " << this->patch().name()
                    << " of field " << this->internalField().name()
                    << " in file " << this->internalField().objectPath()
                    << exit(FatalError);
            }
        }

        mixedFvPatchField<Type>::updateCoeffs();
    }

上面的代码表明，advective边界条件设置的边界值与松弛长度尺度的设置以及时间离散格式的设置有关。当松弛长度尺度lInf设置为0时，refValue设置方式如下：

1. 如果时间离散格式为Euler或CrankNicolson或localEuler，则
   
.. math::
    \begin{align}
    \text{refValue} = \phi_{p_{\text{old}}}
    \end{align}

2. 如果时间离散格式为backward，则

.. math::
    \begin{align}
    \text{refValue} = \frac{2}{3}\times (2\phi_{p_{\text{old}}} - \frac{1}{2}\phi_{p_{\text{oldold}}})
    \end{align}

当松弛长度尺度lInf设置为0时，valueFraction的设置方式如下：

1. 如果时间离散格式为Euler或CrankNicolson，则

.. math::
    \begin{align}
    \text{valueFraction} = \frac{1}{1 + \alpha} = \frac{1}{1 + w\Delta t \times \frac{1}{d}}
    \end{align}

2. 如果时间离散格式为backward，则

.. math::
    \begin{align}
    \text{valueFraction} = \frac{1.5}{1.5 + \alpha} = \frac{1.5}{1.5 + w\Delta t \times \frac{1}{d}}
    \end{align}

3. 如果时间离散格式为localEuler，则

.. math::
    \begin{align}
    \text{valueFraction} = \frac{1}{1 + \alpha'} = \frac{1}{1 + (w\times\frac{1}{d})/ \text{rDeltaT}}
    \end{align}

当松弛长度尺度lInf设置为大于零的时候，refValue的设置方式如下：

1. 如果时间离散格式为Euler或CrankNicolson，则
   
.. math::
    \begin{align}
    \text{refValue} = \frac{\phi_{p_{\text{old}}} + k \times \text{fieldInf}}{1 + k} 
    = \frac{\phi_{p_{\text{old}}} + \frac{w\Delta t}{\text{lInf}}\times \text{fieldInf}}{1 + \frac{w\Delta t}{\text{lInf}}} 
    \end{align}

2. 如果时间离散格式为backward，则
   
.. math::
    \begin{align}
    \text{refValue} = \frac{2\phi_{p_{\text{old}}} - 0.5\phi_{p_{\text{oldold}}} + k\times \text{fieldInf}}{1.5 + k}
    = \frac{2\phi_{p_{\text{old}}} - 0.5\phi_{p_{\text{oldold}}} + \frac{w\Delta t}{\text{lInf}}\times \text{fieldInf}}{1.5 + \frac{w\Delta t}{\text{lInf}}}
    \end{align}

3. 如果时间离散格式为localEuler，则

.. math::
    \begin{align}
    \text{refValue} = \frac{\phi_{p_{\text{old}}} + k' \times \text{fieldInf}}{1 + k'}
    = \frac{\phi_{p_{\text{old}} + \frac{w}{\text{rDeltaT} \times \text{lInf}}\times \text{fieldInf}}}{1 + \frac{w}{\text{rDeltaT} \times \text{lInf}}}
    \end{align}

当松弛长度尺度lInf设置为大于零的时候，valueFraction的设置方式如下：

1. 如果时间离散格式为Euler或CrankNicolson，则
   
.. math::
    \begin{align}
    \text{valueFraction} = \frac{1 + k}{1 + \alpha + k}
    = \frac{1 + \frac{w\Delta t}{\text{lInf}}}{1 + \frac{w\Delta t}{d} + \frac{w\Delta t}{\text{lInf}}}
    \end{align}

2. 如果时间离散格式为backward，则

.. math::
    \begin{align}
    \text{valueFraction} = \frac{1.5 + k}{1.5 + \alpha + k}
    = \frac{1.5 + \frac{w\Delta t}{\text{lInf}}}{1.5 + \frac{w\Delta t}{d} + \frac{w\Delta t}{\text{lInf}}}
    \end{align}

3. 如果时间离散格式为localEuler，则
   
.. math::
    \begin{align}
    \text{valueFraction} = \frac{1 + k'}{1 + \alpha' + k'}
    = \frac{1 + \frac{w}{\text{rDeltaT} \times \text{lInf}}}{1 + \frac{w}{d\times \text{rDeltaT}} + \frac{w}{\text{rDeltaT}\times \text{lInf}}}
    \end{align}

.. note:: 

    下面以Euler格式以及lInf设置为0的情况为例，说明各个系数为何设置成如上形式：

    .. math::
        \begin{align}
        \frac{\partial \phi}{\partial t} + U_{n}\cdot \frac{\partial \phi}{\partial \mathbf{n}}
        = \frac{\phi_{p} - \phi_{\text{old}}}{\Delta t} + w \times \frac{\phi_{p} - \phi_{c}}{d}  
        \end{align}

    于是可以得到

    .. math::
        \begin{align}
        \phi_{p} = \frac{\frac{1}{\Delta t}\phi_{\text{old}}}{\frac{1}{\Delta t} + w\times \frac{1}{d}} 
        + \frac{w\times \frac{1}{d} \phi_{c}}{\frac{1}{\Delta t} + w \times \frac{1}{d}}
        = \Big( 1 - \frac{1}{1 + w\Delta t\times \frac{1}{d}} \Big)\phi_{c}
        + \frac{1}{1 + w\Delta t \times \frac{1}{d}}\phi_{\text{old}} 
        \end{align}

    据此可以得到refValue、refGrad和valueFraction的表达式。



.. code-block:: C

    template<class Type>
    void Foam::advectiveFvPatchField<Type>::write(Ostream& os) const
    {
        fvPatchField<Type>::write(os);

        writeEntryIfDifferent<word>(os, "phi", "phi", phiName_);
        writeEntryIfDifferent<word>(os, "rho", "rho", rhoName_);

        if (lInf_ > 0)
        {
            writeEntry(os, "fieldInf", fieldInf_);
            writeEntry(os, "lInf", lInf_);
        }

        writeEntry(os, "value", *this);
    }


下面是advective边界条件一般的设置方式：

.. code-block:: C

    patchName
    {
        type            advective;
        phi             phi;
        rho             rho;     // 可压缩流的情况
        lInf            0;       // 松弛长度尺度
        fieldInf        2902;    // 远场值
    }



waveTransmissive
^^^^^^^^^^^^^^^^^^

该边界条件通过求解边界处滴滴涕(W, field) = 0提供了一个波透射流出条件，W为波速，field为应用该边界条件的场。该边界条件继承于advective边界条件，不过求解的方程改为了

.. math::
    \begin{align}
    \frac{D\phi}{Dt} \approx \frac{\partial \phi}{\partial t} + (U_{n} + c) \cdot \frac{\partial \phi}{\partial \mathbf{n}} = 0 
    \end{align}

所以waveTransmissive边界条件就是设置了自己的advectionSpeed()函数，其中添加了音速。

进入src/finiteVolume/fields/fvPatchFields/derived/waveTransmissive/waveTransmissiveFvPatchField.C文件，可以看到如下代码：

.. code-block:: C

    template<class Type>
    Foam::tmp<Foam::scalarField>
    Foam::waveTransmissiveFvPatchField<Type>::advectionSpeed() const
    {
        // Lookup the velocity and compressibility of the patch
        const fvPatchField<scalar>& psip =
            this->patch().template
                lookupPatchField<volScalarField, scalar>(psiName_);

        const surfaceScalarField& phi =
            this->db().template lookupObject<surfaceScalarField>(this->phiName_);

        scalarField phip
        (
            this->patch().template
                lookupPatchField<surfaceScalarField, scalar>(this->phiName_)
        );

        if (phi.dimensions() == dimMassFlux)
        {
            const fvPatchScalarField& rhop =
                this->patch().template
                    lookupPatchField<volScalarField, scalar>(this->rhoName_);

            phip /= rhop;
        }

        // Calculate the speed of the field wave w
        // by summing the component of the velocity normal to the boundary
        // and the speed of sound (sqrt(gamma_/psi)).
        return phip/this->patch().magSf() + sqrt(gamma_/psip);
    }


.. code-block:: C

    template<class Type>
    void Foam::waveTransmissiveFvPatchField<Type>::write(Ostream& os) const
    {
        fvPatchField<Type>::write(os);

        writeEntryIfDifferent<word>(os, "phi", "phi", this->phiName_);
        writeEntryIfDifferent<word>(os, "rho", "rho", this->rhoName_);
        writeEntryIfDifferent<word>(os, "psi", "thermo:psi", psiName_);

        writeEntry(os, "gamma", gamma_);

        if (this->lInf_ > small)
        {
            writeEntry(os, "fieldInf", this->fieldInf_);
            writeEntry(os, "lInf", this->lInf_);
        }

        writeEntry(os, "value", *this);
    }

下面是waveTransmissive边界条件的一般设置方式：

.. code-block:: C

    patchName
    {
        type            waveTransmissive;
        phi             phi;
        psi             psi;
        gamma           1.4;
        lInf            0;
        fieldInf        2900;
    }


自定义边界条件
----------------


codedFixedValue
^^^^^^^^^^^^^^^^^^

下面是在射流外设置一个线性分布的速度场的例子：

.. code-block:: C

    AirInlet
        {
            type        codedFixedValue;
            value       uniform (0 0 6.10);

            name    linearVelocity;
            code
            #{
                const vectorField& Cf = patch().Cf();   //center of the patch
                vectorField& field = *this;             //the target velocity field

                const scalar Umax = 6.1;
                const scalar r1 = 0.02;                 //radius of the hot coflow
                const scalar r2 = 0.06;                 //radius of the domain

                forAll(Cf, faceI)
                {
                    const scalar x = Cf[faceI][0];
                    const scalar y = Cf[faceI][1];
                    const scalar R = sqrt(x*x+y*y);

                    if(R>r1){
                        field[faceI] = vector(0,0,Umax*(r2-R)/(r2-r1));
                    }
                }
            #};
        }

另外一个应用案例：

.. code-block:: C

    code
    #{
        const fvPatch& boundaryPatch = patch();   
        const vectorField& Cf = boundaryPatch.Cf();
        vectorField& field = *this;

        const scalar pi = constant::mathematical::pi;
        scalar x0=0.654157, z0=0.115013, d=0.004554;
        scalar umax=26.6,   fjet=138.5;
        scalar theta = 18.31163/pi;
           
        forAll(Cf, faceI)
        {
            scalar x  = Cf[faceI].x();
            scalar z  = Cf[faceI].z();
            scalar t  = this->db().time().value();

            scalar kesi  = pow( (x-x0)*(x-x0)+(z-z0)*(z-z0),0.5);
            scalar ujmag = 6*umax*( (kesi/d)-pow(kesi/d,2) )*sin(2*pi*fjet*t);
            scalar ujet  = ujmag*sin(theta);
            scalar vjet  = ujmag*cos(theta);
                
            field[faceI] = vector(ujet,0,vjet);
        }
    #};     


更多的案例：

.. code-block:: C

    inlet
    {
        type            codedFixedValue;
        value           uniform 0;
        name            codeinlet_air;
                    
        code            
        #{
            const vectorField& Cf = patch().Cf(); 

            scalarField& field = *this;

            scalar D = 0.0252;
            scalar ymax = 5.82*D; 

            forAll(Cf,faceI)
            {
                if ( Cf[faceI].y() > ymax ) 
                   {
                     field[faceI] = 1;
                   }
            }

        #};
    
    }


.. code-block:: C

    inlet
    {
        type            codedFixedValue;
        value           uniform (0 0 0);  //default value
        name            powvelocity;      //name of new BC type

        code
        #{
            const fvPatch &boundaryPatch = patch();
            const fvBoundaryMesh &boundaryMesh = boundaryPatch.boundaryMesh();
            const fvMesh &mesh = boundaryMesh.mesh();
            const fvPatchField<vector> &U = boundaryPatch.lookupPatchField<volVectorField, vector>("U");

            const vectorField FC = mesh.Cf();
            const scalarField y = FC&vector(0,1,0);
            
            vectorField U1 (U.size(), Zero);
            // const scalar pi = M_PI;
            const scalar U_0 = 0.5;
            const scalar D = 0.03;

            forAll(boundaryPatch, i)
            {
                U1[i] = vector(U_0*(pow(y[i]/D,1/7)), 0., 0.);
            }

            operator==(U1);
        #};
    }


如需要设置随时间变化的边界条件，可采用如下方法得到OF运行时间：

.. code-block:: C

    scalar t  = this->db().time().value();


添加下面的语句来解决 :code:`error: ‘mesh’ was not declared in this scope` 的问题：

.. code-block:: C

    codeOptions
    #{
    -I$(LIB_SRC)/meshTools/lnInclude
    #};







壁面函数
===========

壁面函数的推导
----------------

首先要了解近壁区域的性质才能了解什么时候能够使用壁面函数。引入两个无量纲数：

.. math::
    \begin{align}
    y^{+} = \frac{yu_{\tau}}{\nu}, \quad  u_{\tau} = \sqrt{\frac{\tau_{w}}{\rho}} , \quad u^{+} = \frac{u}{u_{\tau}}
    \end{align}

其中 :math:`u_{\tau}` 为摩擦速度，它可以后续用来定义无量纲速度； :math:`\tau_{w}` 为壁面切应力， :math:`y` 为距离壁面的距离， :math:`y^{+}` 是一个无量纲数， :math:`u^{+}` 为无量纲速度。第一层网格的 :math:`y^{+}` 值非常重要，因为它将决定其所在的近壁区域类型。

近壁区域可以分为三个类型，它们可以通过 :math:`y^{+}` 和 :math:`u^{+}` 的关系来进行区分：

1. **粘性底层** （ :math:`y^{+} < 5` ）：在粘性底层中，流体主要受粘性的影响，所以在这个区域可以假设剪切力等于壁面剪切应力 :math:`\tau_{w}` 。在粘性底层中粘性力决定了流动方式并且速度分布式线性的，满足
   
.. math::
    \begin{align}
    u ^{+} = y^{+}
    \end{align}

2. **对数分布区** （ :math:`30 < y^{+} < 200` ）：在对数分布区湍流应力起主导作用，速度分布变化按照关于壁面距离 :math:`y` 的对数方式进行分布，满足
   
.. math::
    \begin{align}
    u^{+} = \frac{1}{\kappa}\ln(E y^{+})
    \end{align}

其中 :math:`\kappa` 为卡门常数，取 :math:`\kappa=0.41` ，对于光滑壁面取 :math:`E = 9.8` 。

3. **缓冲区** ：粘性和湍流应力的作用尺度相似，因此在这部分区域速度分布非常复杂而无法良好定义，因此原始壁面函数需要壁面第一层网格中心位于这个区域。但是，一些改良的壁面函数能够允许第一层网格中心位于缓冲区。在OpenFOAM中，缓冲层被分为两部分，一部分认为是粘性底层满足线性关系，另一部分认为满足对数分布规律。

壁面函数的推导过程将会涉及到 :math:`\varepsilon, f, k, \nu, \overline{v^{2}}` 和 :math:`\omega` ，不过具体应用时都会取它们的无量纲形式，即

.. math::
    \begin{align}
    u^{+} = \frac{u}{u_{\tau}} ,\quad 
    k^{+}=\frac{k}{u_{\tau}^{2}} ,\quad
    \varepsilon^{+} = \frac{\varepsilon \nu}{u_{\tau}^{4}} ,\quad 
    \overline{v^{2}}^{+} = \frac{\overline{v^{2}}}{u_{\tau}^{2}} ,\quad
    f^{+} = \frac{f \nu}{u_{\tau}^{2}} ,\quad 
    \omega^{+} = \frac{\nu \omega}{u_{\tau}^{2}}  
    \end{align}

下面将讨论两类湍流模型，第一个是 :math:`v^{2}-f` 湍流模型，需要 :math:`k, \varepsilon, v^{2}, f` 壁面函数；第二个是 :math:`k-\omega` 湍流模型，需要 :math:`\omega` 壁面函数。

在粘性底层， :math:`v^{2}-f` 湍流模型方程组可以简化为

.. math::
    \begin{align}
    - \varepsilon^{+} 
    + \frac{\mathrm{d}^{2}k^{+}}{\mathrm{d}(y^{+})^{2}}
    = 0 
    \end{align}

.. math::
    \begin{align}
    - \frac{C_{\varepsilon 2}}{6}(\varepsilon^{+})^{1.5} 
    + \frac{\mathrm{d}^{2}\varepsilon^{+}}{\mathrm{d}(y^{+})^{2}} 
    = 0 
    \end{align}

.. math::
    \begin{align}
    - N \frac{\varepsilon^{+} (\overline{v^{2}})^{+}}{k^{+}} 
    + k^{+}f^{+} 
    + \frac{\mathrm{d}^{2}(\overline{v^{2}})^{+}}{\mathrm{d}(y^{+})^{2}} 
    = 0  
    \end{align}

.. math::
    \begin{align}
    \frac{2}{3}(C_{f1} - 1) 
    - (N - C_{f1})\frac{(\overline{v^{2}})^{+}}{k^{+}}
    - \frac{6}{(\varepsilon^{+})^{0.5}}f^{+}
    + \frac{C_{\eta}^{2} C_{L}^{2} 6}{\varepsilon^{+}}\frac{\mathrm{d}^{2}f^{+}}{\mathrm{d}(y^{+})^{2}} 
    = 0 
    \end{align}

根据上面的方程组可以得到 :math:`\varepsilon^{+}` 的表达式为

.. math::
    \begin{align}
    \varepsilon^{+} = \frac{14400}{C_{\varepsilon2}^{2}}\frac{1}{(y^{+} + C)^{4}}  
    \end{align}

根据边界条件 :math:`k^{+}(0)=0` ， :math:`\frac{\mathrm{d}k^{+}}{\mathrm{d}y^{+}}(0) = 0` ，可以使用 :math:`\varepsilon^{+}` 的结果进行积分得到 :math:`k^{+}` 的表达式为

.. math::
    \begin{align}
    k^{+} = \frac{2400}{C_{\varepsilon2}^{2}} \times \Big( \frac{1}{(y^{+} + C)^{4}} + \frac{2y^{+}}{C^{3}} - \frac{1}{C^{2}} \Big)
    \end{align}

假定 :math:`k^{+}` 满足一个二次函数关系 :math:`k^{+} = C_{k}(y^{+})^{2}` ，将其代入到湍流方程组中可以得到一个关于 :math:`\varepsilon^{+}` 的特别条件：

.. math::
    \begin{align}
    \varepsilon^{+} = 2 \frac{k^{+}}{(y^{+})^{2}} 
    \end{align}

:math:`f^{+}` 的边界条件的推导可以通过假设 :math:`(\overline{v^{2}})^{+} = C_{V^{2}}(y^{+})^{4}` ，将其代入到 :math:`v^{2}-f` 模型方程组就可以得到

.. math::
    \begin{align}
    f^{+} = \frac{-4(6-N)(\overline{v^{2}})^{+}}{\varepsilon^{+}(y^{+})^{4}} 
    \end{align}

在对数分布区，可以假设扩散项非常小，得到

.. math::
    \begin{align}
    \kappa y^{+} \frac{\mathrm{d}k^{+}}{\mathrm{d}y^{+}} = C_{k}
    \end{align}

用相同的方式可以推导出 :math:`\overline{v^{2}}^{+}` ， :math:`\varepsilon^{+}` 和 :math:`f^{+}` ：

.. math::
    \begin{align}
    \overline{v^{2}}^{+} = \frac{C_{V^{2}}}{\kappa}\log (y^{+}) + B_{V^{2}} 
    \end{align}

.. math::
    \begin{align}
    \varepsilon^{+} = \frac{1}{\kappa y^{+}} 
    \end{align}

.. math::
    \begin{align}
    f^{+} = N \frac{\overline{v^{2}}^{+}}{(k^{+})^{2}}\varepsilon^{+} 
    \end{align}

在上述推导过程中涉及到一些常数，这些常数的赋值在OpenFOAM中一般为

.. math::
    \begin{align}
    C_{k} = -0.416 ,\quad 
    B_{k} = 8.366 ,\quad 
    C_{V^{2}} = 0.193 ,\quad 
    B_{V^{2}} = -0.940
    \end{align}

与 :math:`v^{2}-f` 模型类似， :math:`k-\omega` 模型方程组也可以简化来得到 :math:`\omega` 在粘性底层和对数分布区的行为。在粘性底层，标准 :math:`k-\omega` 方程组可以简化为

.. math::
    \begin{align}
    C_{\mu} \omega^{+}k^{+} + \frac{\mathrm{d}^{2}k^{+}}{\mathrm{d}(y^{+})^{2}} = 0 
    \end{align}

.. math::
    \begin{align}
    - \beta_{1} (\omega^{+})^{2} + \frac{\mathrm{d}^{2}\omega^{+}}{\mathrm{d}(y^{+})^{2}} = 0 
    \end{align}

根据上面两个方程， :math:`\omega^{+}` 的奇异解为

.. math::
    \begin{align}
    \omega ^{+} = \frac{6}{\beta_{1}(y^{+})^{2}} 
    \end{align}

在对数分布区， :math:`\omega^{+}` 的表达式则为

.. math::
    \begin{align}
    \omega ^{+} = \frac{1}{\kappa\sqrt{C_{\mu}} y^{+}} 
    \end{align}

在过渡区 :math:`\omega^{+}` 通常根据粘性底层和对数分布律的组合来得到，即

.. math::
    \begin{align}
    \omega^{+} = \sqrt{[\omega^{+}_{\text{vis}}]^{2} + [\omega^{+}_{\text{log}}]^{2}} 
    \end{align}


壁面函数代码解读
------------------

壁面函数作为一种边界条件继承于FvPatchField类，它们提供Dirichlet和Neumann边界条件，继承于fixedValue和zeroGradient边界条件。它们的实现将会涉及到upateCoeffs()和evaluate()功能。另外，OpenFOAM还使用了yPlusLam这个量来表示粘性底层与对数分布区的交界位置，对于一些提供了两种计算模式的壁面函数，则会在类的最开始计算yPlusLam。同时，壁面函数的计算过程也可以分为两类，一类是计算第一层网格面上的值，另一类则是计算临近壁面的网格中心的值。

OpenFOAM的壁面函数定义在src/MomentumTransportModels/momentumTransportModels/derivedFvPatchFields/wallFunctions当中，总共有6大类壁面函数，而各类细分后总共有12种壁面函数：

+--------------------------+------------------------------------------------------+
| 壁面函数                 | 用途                                                 |
+==========================+======================================================+
| kqRWallFunction          | 用于高雷诺数，属于zeroGradient条件                   |
+--------------------------+------------------------------------------------------+
| kLowReWallFunction       | 用于高和低雷诺数，条件根据 :math:`y^{+}` 的情况      |
+--------------------------+------------------------------------------------------+
| epsilonWallFunction      | 用于高雷诺数                                         |
+--------------------------+------------------------------------------------------+
| epsilonLowReWallFunction | 用于高和低雷诺数，条件根据 :math:`y^{+}` 的情况      |
+--------------------------+------------------------------------------------------+
| V2WallFunction           | 用于高和低雷诺数，条件根据 :math:`y^{+}` 的情况      |
+--------------------------+------------------------------------------------------+
| fWallFunction            | 用于高和低雷诺数，条件根据 :math:`y^{+}` 的情况      |
+--------------------------+------------------------------------------------------+
| omegaWallFunction        | 用于高和低雷诺数，条件基于粘性底层和对数分布律的混合 |
+--------------------------+------------------------------------------------------+
| nutWallFunction          | 抽象类，不提供特定的 :math:`\nu_{t}`                 |
+--------------------------+------------------------------------------------------+
| nutLowReWallFunction     | 用于低雷诺数，条件是zero                             |
+--------------------------+------------------------------------------------------+
| nutUWallFunction         | 条件基于速度                                         |
+--------------------------+------------------------------------------------------+
| nutkWallFunction         | 条件基于kinematic                                    |
+--------------------------+------------------------------------------------------+
| nutUSpaldingWallFunction | 用于整个区域                                         |
+--------------------------+------------------------------------------------------+

在壁面函数的构建过程中，会使用到src/MomentumTransportModels/momentumTransportModels/momentumTransportModel.H中定义的调用函数来获取所需物理量。



nutWallFunction
^^^^^^^^^^^^^^^^^^

该边界条件是一个抽象类，提供了基于湍流动能湍流运动粘度条件。不少其他壁面函数会继承这里面定义的一些调用函数。

在nutWallFunctionFvPatchScalarField.H文件中可以看到声明的变量的含义及相关的调用函数：

.. code-block:: C

    protected:

        // Protected data

            //- Cmu coefficient
            scalar Cmu_;    // 系数Cmu

            //- Von Karman constant
            scalar kappa_;    // 卡门常数kappa

            //- E coefficient
            scalar E_;    // 粗糙系数E

            //- Y+ at the edge of the laminar sublayer
            scalar yPlusLam_;    // 粘性底层极限位置的y+值


        // Protected Member Functions

            //- Check the type of the patch
            virtual void checkType();

            //- Calculate the turbulence viscosity
            virtual tmp<scalarField> nut() const = 0;    // 计算湍流粘度

            //- Write local wall function variables
            virtual void writeLocalEntries(Ostream&) const;


.. code-block:: C

    //- Return the nut patchField for the given wall patch
    static const nutWallFunctionFvPatchScalarField& nutw    // 返回所选壁面的nut
    (
        const momentumTransportModel& turbModel,
        const label patchi
    );

    //- Calculate the Y+ at the edge of the laminar sublayer
    static scalar yPlusLam(const scalar kappa, const scalar E);    // 计算粘性底层极限位置的y+值yPlusLam

    //- Return the Y+ at the edge of the laminar sublayer
    scalar yPlusLam() const;    // 返回yPlusLam的值

    //- Calculate and return the yPlus at the boundary
    virtual tmp<scalarField> yPlus() const = 0;    // 计算壁面的y+


在直接使用该壁面函数时，将会读取设置中的Cmu、kappa和E关键词的赋值。

.. code-block:: C

    void Foam::nutWallFunctionFvPatchScalarField::writeLocalEntries
    (
        Ostream& os
    ) const
    {
        writeEntry(os, "Cmu", Cmu_);
        writeEntry(os, "kappa", kappa_);
        writeEntry(os, "E", E_);
    }

nutWallFunction继承于fixedValue边界条件，默认情况下会初始化 :math:`C_{\mu}=0.09` ， :math:`\kappa = 0.41` ， :math:`E=9.8` 。

.. code-block:: C

    Foam::nutWallFunctionFvPatchScalarField::nutWallFunctionFvPatchScalarField
    (
        const fvPatch& p,
        const DimensionedField<scalar, volMesh>& iF,
        const dictionary& dict
    )
    :
        fixedValueFvPatchScalarField(p, iF, dict),
        Cmu_(dict.lookupOrDefault<scalar>("Cmu", 0.09)),
        kappa_(dict.lookupOrDefault<scalar>("kappa", 0.41)),
        E_(dict.lookupOrDefault<scalar>("E", 9.8)),
        yPlusLam_(yPlusLam(kappa_, E_))
    {
        checkType();
    }


下面的代码定义了yPlusLam是如何通过kappa和E的值进行计算的：

.. code-block:: C

    Foam::scalar Foam::nutWallFunctionFvPatchScalarField::yPlusLam
    (
        const scalar kappa,
        const scalar E
    )
    {
        scalar ypl = 11.0;

        for (int i=0; i<10; i++)
        {
            ypl = log(max(E*ypl, 1))/kappa;
        }

        return ypl;
    }

可以看到，计算过程为

.. math::
    \begin{align}
    \text{ypl} = \frac{\log (\max(E\times \text{ypl}^{*} , 1))}{\kappa}  
    \end{align}



kqRWallFunction
^^^^^^^^^^^^^^^^^^

该边界条件为高雷诺数流动情况下的湍流k、q和R场提供了合适的条件。它本质上是对zeroGradient条件的简单包装。

.. code-block:: C

    template<class Type>
    void Foam::kqRWallFunctionFvPatchField<Type>::evaluate
    (
        const Pstream::commsTypes commsType
    )
    {
        zeroGradientFvPatchField<Type>::evaluate(commsType);
    }


    template<class Type>
    void Foam::kqRWallFunctionFvPatchField<Type>::write(Ostream& os) const
    {
        zeroGradientFvPatchField<Type>::write(os);
        writeEntry(os, "value", *this);
    }



kLowReWallFunction
^^^^^^^^^^^^^^^^^^^^^

该边界条件为低雷诺数和高雷诺数湍流流动情况提供了湍流动能壁函数条件。该模型在两种模式下运行，基于计算得到的层流-湍流转换y+值，该值由对应的nutWallFunction中指定的kappa和E导出。

.. code-block:: C

    void kLowReWallFunctionFvPatchScalarField::write(Ostream& os) const
    {
        writeEntry(os, "Ceps2", Ceps2_);
        fixedValueFvPatchField<scalar>::write(os);
    }

上面的代码表明kLowReWallFunction需要读取设置中Ceps2关键词的赋值。

.. code-block:: C

    kLowReWallFunctionFvPatchScalarField::kLowReWallFunctionFvPatchScalarField
    (
        const fvPatch& p,
        const DimensionedField<scalar, volMesh>& iF,
        const dictionary& dict
    )
    :
        fixedValueFvPatchField<scalar>(p, iF, dict),
        Ceps2_(dict.lookupOrDefault<scalar>("Ceps2", 1.9))
    {}

上面的代码表明kLowReWallFunction边界条件其实继承于fixedValue边界条件，并初始化Ceps2的值为1.9。


.. code-block:: C

    void kLowReWallFunctionFvPatchScalarField::updateCoeffs()
    {
        if (updated())
        {
            return;
        }

        const label patchi = patch().index();

        const momentumTransportModel& turbModel =
            db().lookupObject<momentumTransportModel>
            (
                IOobject::groupName
                (
                    momentumTransportModel::typeName,
                    internalField().group()
                )
            );

        const nutWallFunctionFvPatchScalarField& nutw =
            nutWallFunctionFvPatchScalarField::nutw(turbModel, patchi);

        const scalarField& y = turbModel.y()[patchi];    // 定义第一层网格中心到壁面的距离y

        const tmp<volScalarField> tk = turbModel.k();    // 定义第一层网格中心的湍动能k
        const volScalarField& k = tk();

        const tmp<scalarField> tnuw = turbModel.nu(patchi);    // 定义层流粘性nuw
        const scalarField& nuw = tnuw();

        const scalar Cmu25 = pow025(nutw.Cmu());    // 计算了Cmu系数的0.25次幂，记作Cmu25

        scalarField& kw = *this;

        // Set k wall values
        forAll(kw, facei)
        {
            label celli = patch().faceCells()[facei];

            scalar uTau = Cmu25*sqrt(k[celli]);    // 计算摩擦速度

            scalar yPlus = uTau*y[facei]/nuw[facei];    // 计算y+

            if (yPlus > nutw.yPlusLam())
            {
                scalar Ck = -0.416;
                scalar Bk = 8.366;
                kw[facei] = Ck/nutw.kappa()*log(yPlus) + Bk;
            }
            else
            {
                scalar C = 11.0;
                scalar Cf = (1.0/sqr(yPlus + C) + 2.0*yPlus/pow3(C) - 1.0/sqr(C));
                kw[facei] = 2400.0/sqr(Ceps2_)*Cf;
            }

            kw[facei] *= sqr(uTau);    // 更新壁面的湍流动能
        }

        // Limit kw to avoid failure of the turbulence model due to division by kw
        kw = max(kw, small);    // 避免后续除以kw的时候出现数值错误，即防止除以零

        fixedValueFvPatchField<scalar>::updateCoeffs();

        // TODO: perform averaging for cells sharing more than one boundary face
    }


从上面的代码可以看到摩擦速度 :math:`u_{\tau}` 和 :math:`y^{+}` 的计算方式为

.. math::
    \begin{align}
    u_{\tau} = C_{\mu}^{0.25}\sqrt{k} ,\quad
    y^{+} = \frac{u_{\tau}y}{\nu}
    \end{align}

壁面处的 :math:`k^{+}` 计算方式为

.. math::
    \begin{align}
    k^{+} = 
    \left \{\begin{array}{l}
    \frac{C_{k}}{\kappa}\log(y^{+}) + B_{k} ,\qquad\qquad\qquad\quad y^{+} > \text{yPlusLam} \\
    \frac{2400}{C_{eps}^{2}}\times \Big(\frac{1}{(y^{+} + C)^{2}} + \frac{2y^{+}}{C^{3}} - \frac{1}{C^{2}} \Big) ,\quad y^{+} \le \text{yPlusLam}
    \end{array}\right .
    \end{align}

其中 :math:`C_{k}=-0.416` ， :math:`B_{k} = 8.366` ; :math:`C = 11` ， :math:`C_{eps2}` 通过读取设置赋值得到。

最后将无量纲数 :math:`k^{+}` 计算为壁面边界处的 :math:`k` 的方式为：

.. math::
    \begin{align}
    k = k^{+} u_{\tau}^{2}
    \end{align}


v2WallFunction
^^^^^^^^^^^^^^^^

该边界条件为低雷诺数和高雷诺数湍流流动情况提供了一个垂直于流线壁函数的湍流应力条件。该模型在两种模式下运行，基于计算得到的层流-湍流转换y+值，该值由对应的nutWallFunction中指定的kappa和E导出。

.. code-block:: C

    void v2WallFunctionFvPatchScalarField::updateCoeffs()
    {
        if (updated())
        {
            return;
        }

        const label patchi = patch().index();

        const momentumTransportModel& turbModel =
            db().lookupObject<momentumTransportModel>
            (
                IOobject::groupName
                (
                    momentumTransportModel::typeName,
                    internalField().group()
                )
            );

        const nutWallFunctionFvPatchScalarField& nutw =
            nutWallFunctionFvPatchScalarField::nutw(turbModel, patchi);

        const scalarField& y = turbModel.y()[patchi];    // 定义到壁面的距离y

        const tmp<volScalarField> tk = turbModel.k();    // 定义湍流动能k
        const volScalarField& k = tk();

        const tmp<scalarField> tnuw = turbModel.nu(patchi);    // 定义层流粘性nuw
        const scalarField& nuw = tnuw();

        const scalar Cmu25 = pow025(nutw.Cmu());    // 计算了Cmu系数的0.25次幂，记作Cmu25

        scalarField& v2 = *this;

        // Set v2 wall values
        forAll(v2, facei)
        {
            label celli = patch().faceCells()[facei];

            scalar uTau = Cmu25*sqrt(k[celli]);    // 计算摩擦速度

            scalar yPlus = uTau*y[facei]/nuw[facei];    // 计算y+

            if (yPlus > nutw.yPlusLam())
            {
                scalar Cv2 = 0.193;
                scalar Bv2 = -0.94;
                v2[facei] = Cv2/nutw.kappa()*log(yPlus) + Bv2;
            }
            else
            {
                scalar Cv2 = 0.193;
                v2[facei] = Cv2*pow4(yPlus);
            }

            v2[facei] *= sqr(uTau);    // 更新壁面的v2
        }

        fixedValueFvPatchField<scalar>::updateCoeffs();

        // TODO: perform averaging for cells sharing more than one boundary face
    }

从上面的代码可以看到 :math:`(v^{2})^{+}` 的计算方式为

.. math::
    \begin{align}
    (v^{2})^{+} = 
    \left \{\begin{array}{l}
    \frac{C_{V^{2}}}{\kappa}\log(y^{+}) + B_{V^{2}} ,\quad y^{+} > \text{yPlusLam} \\
    C_{V^{2}}(y^{+})^{4} ,\qquad\qquad\quad y^{+} \le \text{yPlusLam}
    \end{array}\right .
    \end{align}

其中 :math:`C_{V^{2}} = 0.193` ， :math:`B_{V^{2}} = -0.94` 。

最后将无量纲数 :math:`(v^{2})^{+}` 计算为壁面处的 :math:`v^{2}` 的方式为

.. math::
    \begin{align}
    v^{2} = (v^{2})^{+}u_{\tau}^{2}
    \end{align}




fWallFunction
^^^^^^^^^^^^^^^

该边界条件提供了湍流阻尼函数f，低雷诺数和高雷诺数的壁面函数条件，湍流流动情况下的模型在两种模式下运行，基于计算得到的层流到湍流的转换y+值，由对应的nutWallFunction中指定的kappa和E导出。

.. code-block:: C

    void fWallFunctionFvPatchScalarField::updateCoeffs()
    {
        if (updated())
        {
            return;
        }

        const label patchi = patch().index();

        const momentumTransportModel& turbModel =
            db().lookupObject<momentumTransportModel>
            (
                IOobject::groupName
                (
                    momentumTransportModel::typeName,
                    internalField().group()
                )
            );
        const v2fBase& v2fModel = refCast<const v2fBase>(turbModel);

        const nutWallFunctionFvPatchScalarField& nutw =
            nutWallFunctionFvPatchScalarField::nutw(turbModel, patchi);

        const scalarField& y = turbModel.y()[patchi];    // 定义到壁面的距离y

        const tmp<volScalarField> tk = turbModel.k();    // 定义湍流动能k
        const volScalarField& k = tk();

        const tmp<volScalarField> tepsilon = turbModel.epsilon();    // 定义湍流动能耗散率epsilon
        const volScalarField& epsilon = tepsilon();

        const tmp<volScalarField> tv2 = v2fModel.v2();    // 定义垂直于流线的湍流应力v2
        const volScalarField& v2 = tv2();

        const tmp<scalarField> tnuw = turbModel.nu(patchi);    // 定义层流粘度nuw
        const scalarField& nuw = tnuw();

        const scalar Cmu25 = pow025(nutw.Cmu());    // 计算了Cmu系数的0.25次幂，记作Cmu25

        scalarField& f = *this;

        // Set f wall values
        forAll(f, facei)
        {
            label celli = patch().faceCells()[facei];

            scalar uTau = Cmu25*sqrt(k[celli]);    // 计算摩擦速度

            scalar yPlus = uTau*y[facei]/nuw[facei];    // 计算y+

            if (yPlus > nutw.yPlusLam())
            {
                scalar N = 6.0;
                scalar v2c = v2[celli];
                scalar epsc = epsilon[celli];
                scalar kc = k[celli];

                f[facei] = N*v2c*epsc/(sqr(kc) + rootVSmall);
                f[facei] /= sqr(uTau) + rootVSmall;
            }
            else
            {
                f[facei] = 0.0;
            }
        }

        fixedValueFvPatchField<scalar>::updateCoeffs();

        // TODO: perform averaging for cells sharing more than one boundary face
    }


:math:`f` 的计算方式为

.. math::
    \begin{align}
    f = 
    \left \{\begin{array}{l}
    \frac{Nv^{2}\varepsilon}{k^{2}u_{\tau}^{2}}  ,\quad y^{+} > \text{yPlusLam} \\
    0 ,\qquad y^{+} \le \text{yPlusLam}
    \end{array}\right .
    \end{align}

其中系数 :math:`N = 6` 。

.. attention:: 该壁面函数的实现方式与理论存在较大差异，在使用该壁面函数时需要注意是否满足自身需求。



epsilonWallFunction
^^^^^^^^^^^^^^^^^^^^^

该边界条件为低雷诺数和高雷诺数湍流模型提供了湍流耗散壁约束。该条件可应用于壁面边界，计算出湍流耗散场和湍流产生场，并指定近壁面 :math:`\epsilon` 值。



湍流模型
=============

所有包含湍流的求解器都需要读取momentumTransport文件内设置的湍流模型信息。在该文件内，由 :code:`simulationType` 关键词决定所使用的湍流模型，其可能的赋值有：

- :code:`laminar` ，表示不使用湍流模型；
- :code:`RAS` ，表示使用雷诺平均模型；
- :code:`LES` ，表示使用大涡模拟。
  


RAS模型
---------

速度的雷诺分解为其平均贡献和波动贡献的形式为

.. math::
    \begin{align}
    \mathbf{U}(\mathbf{x},t) = \overline{\mathbf{U}}(\mathbf{x},t) + \mathbf{U}'(\mathbf{x},t)
    \end{align}

其中，波动分量的均值定义为零，即

.. math::
    \begin{align}
    \overline{\mathbf{U}'} = 0 
    \end{align}

应用于Navier Stokes方程，可以得到平均速度和平均压力的方程：

.. math::
    \begin{align}
    \frac{\partial \rho}{\partial t} + \nabla \cdot (\rho\overline{\mathbf{U}}) = 0 
    \end{align}

.. math::
    \begin{align}
    \frac{\partial (\rho\overline{\mathbf{U}})}{\partial t} + \nabla \cdot (\rho \overline{\mathbf{U}} \otimes \overline{\mathbf{U}}) = \mathbf{g} + \nabla \cdot \overline{\tau} - \nabla \cdot (\rho \mathbf{R})
    \end{align}

其中时均切应力 :math:`\overline{\tau}` ，对于牛顿流体则表示为

.. math::
    \begin{align}
    \overline{\tau} = 
    - \Big( p + \frac{2}{3}\mu \nabla \cdot \overline{\mathbf{U}} \Big) \mathbf{I}
    + \mu \Big( \nabla \overline{\mathbf{U}} + (\nabla \overline{\mathbf{U}})^{T} \Big)
    \end{align}

根据数学关系：

.. math::
    \begin{align}
    \nabla \cdot \overline{\mathbf{U}}
    = \operatorname{tr}(\nabla \overline{\mathbf{U}})
    = \operatorname{tr}\Big( (\nabla \overline{\mathbf{U}})^{T} \Big) 
    \end{align}

时均切应力可以改写为

.. math::
    \begin{align}
    \overline{\tau} = - p\mathbf{I} + \mu \Big[ \nabla\overline{\mathbf{U}} + (\nabla\overline{\mathbf{U}})^{T} - \frac{2}{3}\operatorname{tr}\Big( (\nabla\overline{\mathbf{U}})^{T} \Big) \Big]
    \end{align}

:math:`\mathbf{R}` 为雷诺应力张量，可以进一步分解为各向同性贡献和偏向各向异性贡献：

.. math::
    \begin{align}
    \mathbf{R} = \overline{\mathbf{U}' \otimes \mathbf{U}'} 
    = \frac{2}{3}k\mathbf{I} + \overline{\mathbf{U}' \otimes \mathbf{U}'} - \frac{2}{3}k\mathbf{I}
    \end{align}

其中 :math:`k` 是湍流动能，定义为

.. math::
    \begin{align}
    k = \frac{1}{2} \overline{\mathbf{U}' \cdot \mathbf{U}'} = \frac{1}{2}\operatorname{tr}(\mathbf{R})
    \end{align}

只有雷诺应力张量的各向异性贡献才能传递动量，因此各向同性贡献可以加到平均压力上，从而得到完整的形式：

.. math::
    \begin{align}
    \frac{\partial (\rho\overline{\mathbf{U}})}{\partial t}
    + \nabla \cdot (\rho \overline{\mathbf{U}}\otimes \overline{\mathbf{U}})
    = \mathbf{g}
    - \nabla \overline{p}'
    + \nabla\cdot (\mu \nabla \overline{\mathbf{U}})
    + \nabla \cdot \Big[ \mu \Big( (\nabla\overline{\mathbf{U}})^{T} - \frac{2}{3}\operatorname{tr}\big( (\nabla\overline{\mathbf{U}})^{T} \big)\mathbf{I} \Big) \Big]
    - \nabla \cdot (\rho \mathbf{R}_{dev})
    \end{align}

其中

.. math::
    \begin{align}
    & \mathbf{R}_{dev} = \overline{\mathbf{U}' \otimes \mathbf{U}'} - \frac{2}{3}k\mathbf{I} \\
    & \overline{p}' = \overline{p} + \frac{2}{3}\rho k 
    \end{align}

湍流模型RAS家族提供了近似由 :math:`\mathbf{R}_{dev}` 引起的偏差各向异性应力贡献的方法。



如果选用了RAS模型，就需要在momentumTransport文件内进一步创建RAS子字典，该子字典需要包含下列内容：

- :code:`model` ：具体采用的RAS湍流模型的名称；
- :code:`turbulence` ：开启或关闭湍流模型，可能的赋值有 :code:`on` 或 :code:`off` ；
- :code:`printCoeffs` ：输出或不输出湍流模型系数，可能的赋值有 :code:`on` 或 :code:`off` ；
- :code:`<model>Coeffs` ：可选参数，指定后可以覆盖默认的湍流模型参数。
  

以 :code:`kEpsilon` 模型为例，上述RAS子字典应该写为

.. code-block:: C

    RAS
    {
        model           kEpsilon;

        turbulence      on;

        printCoeffs     on;
    }

在运行算例后可以看到默认设置如下：

.. code-block:: C

    RAS
    {
        model           kEpsilon;
        turbulence      on;
        printCoeffs     on;
        Cmu             0.09;
        C1              1.44;
        C2              1.92;
        C3              0;
        sigmak          1;
        sigmaEps        1.3;
    }









fvShemes离散格式设置
=======================

参考 `OpenFOAM中fvSchemes字典文件解析 <https://www.zybuluo.com/daidezhi/note/389113>`_ 

system/fvSchemes文件用来设置离散格式，凡是求解器里面出现的方程，都需要在这里进行离散格式设置。需要指定的信息主要以下子字典：

+----------------------+------------------+
| 子字典关键词         | 含义             |
+======================+==================+
| interpolationSchemes | 插值格式         |
+----------------------+------------------+
| snGradSchemes        | 面法向梯度格式   |
+----------------------+------------------+
| ddtSchemes           | 时间一阶导项格式 |
+----------------------+------------------+
| d2dt2Schemes         | 时间二阶导项格式 |
+----------------------+------------------+
| divSchemes           | 散度项格式       |
+----------------------+------------------+
| gradSchemes          | 梯度项格式       |
+----------------------+------------------+
| laplacianSchemes     | 拉普拉斯项格式   |
+----------------------+------------------+
| fluxRequired         | 需要计算通量的场 |
+----------------------+------------------+


插值格式interpolationSchemes
-------------------------------

插值格式在子字典interpolationSchemes下设置，通常用来指定从相邻两个体单元计算公共面单元处变量值的计算方法：

+----------+----------------------+------------------------------+------------------+
| 插值格式 | 具体方法             | 含义                         | 用途             |
+==========+======================+==============================+==================+
| 中心格式 | linear               | 线性插值(中心差分)格式       | 应用于普通场插值 |
+          +----------------------+------------------------------+                  +
|          | cubicCorrection      | 立方正交格式                 |                  |
+          +----------------------+------------------------------+                  +
|          | midPoint             | 对称加权线性插值格式         |                  |
+----------+----------------------+------------------------------+------------------+
| 迎风格式 | upwind               | 一阶迎风格式                 | 主要应用于对流项 |
+          +----------------------+------------------------------+                  +
|          | linearUpwind         | 线性迎风格式                 |                  |
+          +----------------------+------------------------------+                  +
|          | skewLinear           | 带畸变修正线性迎风格式       |                  |
+          +----------------------+------------------------------+                  +
|          | filteredLinear2      | 高频波过滤线性迎风格式       |                  |
+----------+----------------------+------------------------------+------------------+
| TVD家族  | limitedLinear        | 有界线性格式                 | 主要应用于对流项 |
+          +----------------------+------------------------------+                  +
|          | limitedLimitedLinear | 有界线性格式(带限制器)       |                  |
+          +----------------------+------------------------------+                  +
|          | limitedLinearV       | 有界线性格式(矢量场专用)     |                  |
+          +----------------------+------------------------------+                  +
|          | vanLeer              | van Leer有界格式             |                  |
+          +----------------------+------------------------------+                  +
|          | limitedVanLeer       | van Leer有界格式(带限制器)   |                  |
+          +----------------------+------------------------------+                  +
|          | vanLeerV             | van Leer有界格式(矢量场专用) |                  |
+          +----------------------+------------------------------+                  +
|          | MUSCL                | MUSCL有界格式                |                  |
+          +----------------------+------------------------------+                  +
|          | limitedMUSCL         | MUSCL有界格式(带限制器)      |                  |
+          +----------------------+------------------------------+                  +
|          | limitedCubic         | 立方正交有界格式             |                  |
+          +----------------------+------------------------------+                  +
|          | limitedLimitedCubic  | 立方正交有界格式(带限制器)   |                  |
+          +----------------------+------------------------------+                  +
|          | limitedCubicV        | 立方正交有界格式(矢量场专用) |                  |
+----------+----------------------+------------------------------+------------------+
| NVD家族  | SFCD                 | 自过滤中心格式               | 主要应用于对流项 |
+          +----------------------+------------------------------+                  +
|          | SFCDV                | 自过滤中心格式(矢量场专用)   |                  |
+          +----------------------+------------------------------+                  +
|          | Gamma                | Gamma差分格式                |                  |
+          +----------------------+------------------------------+                  +
|          | limitedGamma         | Gamma差分格式(带限制器)      |                  |
+          +----------------------+------------------------------+                  +
|          | GammaV               | Gamma差分格式(矢量场专用)    |                  |
+----------+----------------------+------------------------------+------------------+



针对对流项的插值格式需要在通量的基础上计算插值，因此这些格式的指定需要提供通量场的名称。在OpenFOAM标准求解器中，体积通量名称一般为phi，类型为surfaceScalarField（面心标量场），因此针对对流项的插值格式指定方式为：

.. code-block:: C

    default upwind phi;


一些基于TVD或者NVD的格式需要系数 :math:`\psi` ，该系数的值介于0和1之间。当 :math:`\psi=1` 时对应标准TVD格式，能够达到最快的收敛速度；当 :math:`\psi=0` 时对应最高精度，例如：

.. code-block:: C

    default limitedLinear phi 1.0;



某些标量场是严格有界的，例如VOF模型中的流体体积分数场 :math:`F` 的值严格介于0和1之间，因此才会出现一些带有限制器的增强版格式。如果想要指定有界场的上下限，需要在格式名称前加上limited前缀。例如将vanLeer格式的上下限设置为 :math:`[-2,3]` ：

.. code-block:: C

    default limitedVanLeer -2.0 3.0;

特别地，对于类似于流体体积分数场上下限严格为 :math:`[0,1]` 的情况，可以添加后缀01，例如：

.. code-block:: C

    default vanLeer01;


针对矢量场的有向性，一些带有限制器的格式具有矢量场的专用版本，使用方法为添加后缀V，如：

.. code-block:: C

    default limitedLinearV;


下面是一些具体的设置案例：

.. code-block:: C

    default            linear;
    reconstruct(rho)   vanLeer;
    reconstruct(U)     vanLeerV;




面法向梯度格式snGradSchemes
-------------------------------

面法向梯度指的是变量场梯度在面 :math:`f` 处的法向分量，一般需要在单独计算面法向梯度 :math:`\nabla_{f}\cdot \mathbf{A}_{f}` 或者指定拉普拉斯项 :math:`\nabla^{2}\cdot` 离散格式时指定面法向梯度格式。支持的标准格式有：

+----------------+--------------------------+
| 面法向梯度格式 | 含义                     |
+================+==========================+
| corrected      | 显示非正交修正格式       |
+----------------+--------------------------+
| uncorrected    | 无非正交修正格式         |
+----------------+--------------------------+
| limited        | 非完全正交修正格式       |
+----------------+--------------------------+
| bounded        | 对正值标量的有界修正格式 |
+----------------+--------------------------+
| fourth         | 四阶格式                 |
+----------------+--------------------------+


特别地，非完全正交修正格式limited需要指定系数 :math:`\psi` ，其值介于0和1之间：

- 取值为0时，无非正交修正；
- 取值为0.333时，限制非正交修正部分不超过正交部分的一半；
- 取值为0.5时，限制非正交修正部分不超过正交部分；
- 取值为1时，不限制非正交修正部分，等同于corrected格式。


下面是一些具体的设置案例：

.. code-block:: C

    default         corrected;








时间一阶导项格式ddtSchemes
----------------------------

时间一阶导项 :math:`\frac{\partial}{\partial t}` 格式支持的标准格式有：



+------------------+----------------------------------+
| 时间一阶导项格式 | 含义                             |
+==================+==================================+
| backward         | 二阶向后差分格式(BDS2)，隐式     |
+------------------+----------------------------------+
| bounded          |                                  |
+------------------+----------------------------------+
| CoEuler          | 一阶，可控制局部库朗数           |
+------------------+----------------------------------+
| CrankNicolson    | 二阶精度，有界，隐式             |
+------------------+----------------------------------+
| Euler            | 一阶精度，有界，隐式             |
+------------------+----------------------------------+
| localEuler       | 局部时间步，一阶精度，有界，隐式 |
+------------------+----------------------------------+
| SLTS             |                                  |
+------------------+----------------------------------+
| steadyState      | 定常，忽略时间导数项             |
+------------------+----------------------------------+







其中CrankNicolson格式需要设置系数 :math:`\psi` ，其值介于0和1之间。当 :math:`\psi=1` 时为纯Crank-Nicolson格式；当 :math:`\psi=0` 时为纯Euler格式。

下面是一些具体使用的案例：

.. code-block:: C

    default         Euler;
    default         localEuler;






时间二阶导项格式d2dt2Schemes
-------------------------------

时间二阶导项 :math:`\frac{\partial^{2}}{\partial t^{2}}` 格式只支持Euler格式。



梯度项格式gradSchemes
------------------------

梯度项 :math:`\nabla` 格式支持的标准格式有：


+-----------------------------+-------------------------------------------------------+
| 梯度项格式                  | 含义                                                  |
+=============================+=======================================================+
| Gauss <interpolationScheme> | 高斯积分，<interpolationScheme>设置插值格式，二阶精度 |
+-----------------------------+-------------------------------------------------------+
| leastSquares                | 最小二乘法，二阶精度                                  |
+-----------------------------+-------------------------------------------------------+
| fourth                      | 最小二乘法，四阶精度                                  |
+-----------------------------+-------------------------------------------------------+
| cellLimited <gradScheme>    | 上述格式的体单元有界版本                              |
+-----------------------------+-------------------------------------------------------+
| faceLimited <gradScheme>    | 上述格式的面单元有界版本                              |
+-----------------------------+-------------------------------------------------------+


下面是一些具体的设置案例：

.. code-block:: C

    default         Gauss linear;





散度项格式divSchemes
-----------------------

参考 `Divergence schemes <https://www.openfoam.com/documentation/guides/latest/doc/guide-schemes-divergence.html>`_ 

此项一般只出现在涉及流体流动的数值模拟中，例如标量形式的 :math:`\nabla\cdot(\rho \mathbf{U}T)` 和矢量形式的 :math:`\nabla\cdot(\rho \mathbf{U}\mathbf{U})` 。以动量方程中的对流项 :math:`\nabla\cdot(\rho \mathbf{U}\mathbf{U})` 为例，基于有限体积积分有

.. math::
    \begin{align}
    \int_{V}\nabla\cdot(\rho\mathbf{U}\mathbf{U})~\mathrm{d}V=\int_{\mathbf{A}_{f}}\rho\mathbf{U}\mathbf{U}\cdot \mathrm{d}\mathbf{A}_{f}=\sum \rho_{f}\mathbf{U}_{f}\mathbf{U}_{f}\cdot \mathbf{A}_{f}=\sum \phi_{f}\mathbf{U}_{f} 
    \end{align}

其中 :math:`\phi_{f}` 表示面 :math:`f` 处的质量通量，即 :math:`\rho_{f}\mathbf{U}_{f}\cdot\mathbf{A}_{f}` ，也因此在OpenFOAM中表示为 :code:`div(phi, U)` 。

散度项格式一般为下面的格式：

.. code-block:: 

    Gauss <interpolationScheme>


为线性化此非线性项，在对对流项进行离散的过程中， :math:`\phi_{f}` 是作为已知量参与计算的，一般使用上一时间步的速度场 :math:`\mathbf{U}^{n}` 计算得到，即

.. math::
    \begin{align}
    \sum\rho_{f}\mathbf{U}_{f}\mathbf{U}_{f}\cdot\mathbf{A}_{f}=\sum\rho_{f}^{n}\mathbf{U}_{f}^{n+1}\mathbf{U}_{f}^{n}\cdot\mathbf{A}_{f}=\sum\phi_{f}^{n}\mathbf{U}_{f}^{n+1}
    \end{align}

其中 :math:`\phi_{f}^{n}` 的数值通过Rhie-Chow动量插值计算得到。因此，这里的插值格式<interpolationScheme>只针对上式中的 :math:`\mathbf{U}_{f}^{n+1}` ，其数学特性如下：



+-------------------------------+----------------------------+
| 所选用的<interpolationScheme> | 数学特性                   |
+===============================+============================+
| linear                        | 二阶，无界                 |
+-------------------------------+----------------------------+
| skewLinear                    | 二阶，带skewness修正，无界 |
+-------------------------------+----------------------------+
| cubicCorrected                | 四阶，无界                 |
+-------------------------------+----------------------------+
| upwind                        | 一阶，有界                 |
+-------------------------------+----------------------------+
| linearUpwind                  | 一/二阶，有界              |
+-------------------------------+----------------------------+
| QUICK                         | 一/二阶，有界              |
+-------------------------------+----------------------------+
| TVD家族                       | 一/二阶，有界              |
+-------------------------------+----------------------------+
| SFCD                          | 二阶，有界                 |
+-------------------------------+----------------------------+
| NVD家族                       | 一/二阶，有界              |
+-------------------------------+----------------------------+



+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| 散度项格式                                      | 数学特性                                                                                                                                                                                                                                                         |
+=================================================+==================================================================================================================================================================================================================================================================+
| Gauss limitedLinear <coeff>                     | 一阶或二阶，无界                                                                                                                                                                                                                                                 |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss linear                                    | 二阶，无界，低耗散(适合于LES)，用于各项同性网格                                                                                                                                                                                                                  |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss linearUpwind grad(U)                      | 二阶，无界，采用迎风插值权重并基于局部单元梯度进行显式修正                                                                                                                                                                                                       |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss midPoint                                  | 一阶或二阶，无界，应用于各向同性网格时等价于linear，使用表面通量计算                                                                                                                                                                                             |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss Minmod                                    | 一阶，无界，最小模量                                                                                                                                                                                                                                             |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss MUSCL                                     | 二阶，无界，守恒定律的单调上游中心格式                                                                                                                                                                                                                           |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss QUICK                                     | 二阶，无界，对流运动学的二次上游插值                                                                                                                                                                                                                             |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss UMIST                                     | 二阶，无界，标量传输的上游单调插值                                                                                                                                                                                                                               |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss upwind                                    | 一阶，有界，根据上游值设置面值，相当于假设单元值是各向同性的且其值代表平均值                                                                                                                                                                                     |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss vanLeer                                   | 二阶，无界                                                                                                                                                                                                                                                       |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss CoBlended <co1> <scheme1> <co2> <scheme2> | 基于表面库朗数混合两种格式：当Co小于<co1>时采用<scheme1>，当Co大于<co2>时采用<scheme2>，当<co1>小于Co小于<co2>时线性混合<scheme1>和<scheme2>                                                                                                                     |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss DEShybrid <many coeff>                    | 基于局部属性混合两种格式                                                                                                                                                                                                                                         |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss filteredLinear2 <k> <l>                   | 二阶，无界，试图限制linear格式的无界性。<k>是缩放校正应用的比率，取0时为线性，取1时为完全限制；<l>是相对于difference across the face的最大允许overshoot/undershoot，取0时为没有overshoot/undershoot，取1时为overshoot/undershoot与difference across the face相等 |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Gauss LUST <grad-scheme>                        | 无界，线性迎风稳定输送，固定使用linearUpwind权重0.25，linear权重0.75                                                                                                                                                                                             |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+





对于某些流动情况，有几种对流方案可供选择：稳态，有界标量传输和有限方案。对于稳态情况，可以应用有界形式：

.. code-block:: C

    bounded Gauss <interpolation scheme>

这增加了一个线性化，隐式源贡献的传输方程的形式。也就是说，它去掉了一个与连续性误差成比例的分量。随着计算的进行，这作为收敛辅助，趋向于有界解。在收敛时，这一项变为零，对最终解没有贡献。




下面是一些具体的设置案例：

.. code-block:: C

    div(tauMC)          Gauss linear;
    div(phi,U)          Gauss limitedLinear 1;
    div(phi,U)          bounded Gauss upwind;
    div(phi,k)          bounded Gauss linearUpwind limited;








拉普拉斯项格式laplacianSchemes
----------------------------------

在流体流动的动量方程中，拉普拉斯项一般为 :math:`\nabla\cdot(\nu\nabla\mathbf{U})` ，在OpenFOAM中表示为 :code:`laplacian(nu, U)` ，基于有限体积积分有：

.. math::
    \begin{align}
    \int_{V}\nabla\cdot(\nu\nabla\mathbf{U})~\mathrm{d}V=\int_{\mathbf{A}_{f}}\nu_{f}\nabla\mathbf{U}_{f}\cdot\mathrm{d}\mathbf{A}_{f}=\sum\nu_{f}\nabla\mathbf{U}_{f}\cdot\mathbf{A}_{f}    
    \end{align}

因此，需要指定 :math:`\nu_{f}` 的插值格式，同时也要指定面法向梯度 :math:`\nabla\mathbf{U}_{f}` 的离散格式。拉普拉斯格式laplacianSchemes只支持下面的格式：

.. code-block:: 

    Gauss <interpolationScheme> <snGradScheme>

其中 :code:`<interpolationScheme>` 用于指定 :math:`\nu_{f}` 的插值格式； :code:`<snGradScheme>` 用于指定面法向梯度 :math:`\nabla\mathbf{U}_{f}\cdot\mathbf{A}_{f}` 的离散格式：

+----------------------+----------------------------------+
| 所选的<snGradScheme> | 数学特性                         |
+======================+==================================+
| corrected            | 无界，二阶，守恒                 |
+----------------------+----------------------------------+
| uncorrected          | 有界，一阶，非守恒               |
+----------------------+----------------------------------+
| limited              | corrected和uncorrected的混合格式 |
+----------------------+----------------------------------+
| bounded              | 有界，一阶                       |
+----------------------+----------------------------------+
| fourth               | 无界，四阶，守恒                 |
+----------------------+----------------------------------+


下面是一些具体的设置案例：

.. code-block:: C

    default         Gauss linear corrected;





需要计算通量的场fluxRequired
------------------------------

fluxRequired子字典列举了数值模拟过程中需要计算通量的场。例如流体流动模拟中，在求解压力p的方程后需要计算通量，这可以通过在fluxRequired子字典中简单地指定：

.. code-block:: C

    fluxRequired 
    { 
        p; 
    }





fvSolution代数方程组求解设置
==============================

该文件由solvers、所采用耦合算法(PISO、SIMPLE、PIMPLE)以及relaxationFactors等子字典组成。

solvers设置
---------------

+----------------+--------------------------------------------------------------------------------------------------------------------+
| solvers关键词  | 含义                                                                                                               |
+================+====================================================================================================================+
| solver         | 代数方程组求解器                                                                                                   |
+----------------+--------------------------------------------------------------------------------------------------------------------+
| preconditioner | 预处理器。本质上为一个改变原先系数矩阵条件数的左乘矩阵。当solver采用了PCG/PBiCG求解器时进行设置。                  |
+----------------+--------------------------------------------------------------------------------------------------------------------+
| smoother       | 光滑器。当solver采用了smoothSolver时进行设置。                                                                     |
+----------------+--------------------------------------------------------------------------------------------------------------------+
| tolerance      | 绝对残差(前后两次迭代结果的差值)。决定了求解器退出的标准。对于稳态问题应该取得很小，而对于瞬态问题则不能取得太小。 |
+----------------+--------------------------------------------------------------------------------------------------------------------+
| relTol         | 相对残差(前后两次迭代残差的比值)。当设置为非零数时将忽略tolerance的设置。                                          |
+----------------+--------------------------------------------------------------------------------------------------------------------+
| maxIter        | 最大迭代次数。                                                                                                     |
+----------------+--------------------------------------------------------------------------------------------------------------------+


关键词solver可以选择的代数方程组求解器包括：

+--------------+------------------------------------+
| solver       | 含义                               |
+==============+====================================+
| PCG          | 预处理共轭梯度(对称)求解器         |
+--------------+------------------------------------+
| PBiCG        | 预处理稳定双共轭梯度(非对称)求解器 |
+--------------+------------------------------------+
| smoothSolver | 光滑求解器                         |
+--------------+------------------------------------+
| GAMG         | 几何-代数多重网格求解器            |
+--------------+------------------------------------+
| diagonal     | 对角求解器(显式离散)               |
+--------------+------------------------------------+

关键词preconditioner可以选择的预处理器包括：

+----------------+-----------------------------------------------------+
| preconditioner | 含义                                                |
+================+=====================================================+
| DIC            | 不完全的对角Cholesky预处理器(对称矩阵)              |
+----------------+-----------------------------------------------------+
| FDIC           | 不完全的快速对角Cholesky预处理器(相当于带缓存的DIC) |
+----------------+-----------------------------------------------------+
| DILU           | 对角不完全LU预处理器(非对称)                        |
+----------------+-----------------------------------------------------+
| diagonal       | 对角预处理器                                        |
+----------------+-----------------------------------------------------+
| GAMG           | 几何-代数多重网格预处理器                           |
+----------------+-----------------------------------------------------+
| none           | 不进行预处理                                        |
+----------------+-----------------------------------------------------+


关键词smoother可以选择的光滑器包括：

+----------------+----------------------------------------------------------------------------+
| smoother       | 含义                                                                       |
+================+============================================================================+
| GaussSeidel    | 高斯塞德尔光顺器。一般情况下最可靠。                                       |
+----------------+----------------------------------------------------------------------------+
| DIC            | 不完全的对角Cholesky光顺器(对称矩阵)。对于有些条件数不好的矩阵收敛性更好。 |
+----------------+----------------------------------------------------------------------------+
| DICGaussSeidel | 不完全的对角Cholesky-高斯塞德尔光顺器(对称矩阵)                            |
+----------------+----------------------------------------------------------------------------+


耦合算法设置
---------------

.. code-block:: C

    //PISO算法设置
    PISO
    {
        nCorrectors     2;                  //PISO修正次数
        nNonOrthogonalCorrectors 0;         //非正交修正次数
        pRefCell        0;                  //压力参考单元
        pRefValue       0;                  //压力参考值
    }


欠松弛处理设置
----------------

欠松弛处理主要有两种不同的使用方式：

- 在迭代之前提高系数矩阵主对角元素数值，并且降低源项来保证系数矩阵对角占优，比如速度场U；
- 限制变量在迭代后改变的大小，比如压力场p。
  
欠松弛因子 :math:`\alpha` 介于0和1之间，越接近0求解越稳定，但同时也会降低求解效率；提高 :math:`\alpha` 的数值会提高求解效率，但同时也会降低稳定性。

欠松弛因子在子字典relaxationFactors下指定，通过子字典名equations和fields来设置不同的欠松弛方式，例如：

.. code-block:: C

    relaxationFactors
    {
        fields
        {
            p 0.3;
        }
        equations
        {
            U 0.7;
        }
    }



controlDict设置
====================

位于system文件夹内的controlDict文件用于设置时间和输入输出控制，包括时间控制、计算结果输出控制、时间步长自适应控制、字典读取控制和运行时加载库或者函数五个部分。

常规设置
----------

时间控制部分startFrom关键词决定了开始计算的时间，可选的取值包括：

+------------+---------------------------------------------------------------+
| startFrom  | 含义                                                          |
+============+===============================================================+
| firstTime  | 所有时间目录中最早的时间步                                    |
+------------+---------------------------------------------------------------+
| latestTime | 所有时间目录中最近的时间步                                    |
+------------+---------------------------------------------------------------+
| startTime  | 从指定开始的时间步开始计算，需要在下面指定startTime关键词的值 |
+------------+---------------------------------------------------------------+


时间控制部分stopAt关键词决定了停止计算的时间，可选的取值包括：

+------------+-----------------------------------------------------------+
| stopAt     | 含义                                                      |
+============+===========================================================+
| endTime    | 在指定的结束时间停止计算，需要在下面指定endTime关键词的值 |
+------------+-----------------------------------------------------------+
| writeNow   | 当前时间步完成时结束计算并且输出计算结果                  |
+------------+-----------------------------------------------------------+
| noWriteNow | 当前时间步完成时结束计算但是不输出计算结果                |
+------------+-----------------------------------------------------------+
| nextWrite  | 下一个时间步完成时结束计算并且输出计算结果                |
+------------+-----------------------------------------------------------+


计算结果输出控制部分writeControl关键词决定计算结果输出间隔方式，可选的取值包括：

+-------------------+------------------------------------------------------------------------+
| writeControl      | 含义                                                                   |
+===================+========================================================================+
| timeStep          | 按照时间步输出，间隔由关键字writeInterval指定，单位为[步]              |
+-------------------+------------------------------------------------------------------------+
| runTime           | 按照计算时间输出，间隔由关键字writeInterval指定，单位为[s]             |
+-------------------+------------------------------------------------------------------------+
| adjustableRunTime | 时间自适应下按照计算时间输出，间隔由关键字writeInterval指定，单位为[s] |
+-------------------+------------------------------------------------------------------------+
| cpuTime           | 按照CPU时间输出，间隔由关键字writeInterval指定，单位为[s]              |
+-------------------+------------------------------------------------------------------------+
| clockTime         | 按照真实时间输出，间隔由关键字writeInterval指定，单位为[s]             |
+-------------------+------------------------------------------------------------------------+


计算结果输出控制部分writeFormat关键词决定了计算结果输出的格式，可选的取值包括：

+-------------+------------------------------------------------------------------------+
| writeFormat | 含义                                                                   |
+=============+========================================================================+
| ascii       | 文本格式，由writePrecision关键词控制有效数字位数                       |
+-------------+------------------------------------------------------------------------+
| binary      | 二进制格式，直接将内存内容写入文件，能够减少文件存储空间，提高读写效率 |
+-------------+------------------------------------------------------------------------+


计算结果输出控制部分writeCompression关键词决定了输出文件是否压缩，可选的取值包括：

+------------------+--------------+
| writeCompression | 含义         |
+==================+==============+
| uncompressed     | 不压缩       |
+------------------+--------------+
| compressed       | gzip压缩格式 |
+------------------+--------------+


计算结果输出控制部分timeFormat关键词决定了时间的格式，可选的取值包括：

+------------+----------------------------------------------------------------------------+
| timeFormat | 含义                                                                       |
+============+============================================================================+
| fixed      | :math:`\pm\text{m.dddddd}` ，其中d由timePrecision来控制                    |
+------------+----------------------------------------------------------------------------+
| scientific | :math:`\pm\text{m.dddddd}\pm\text{xx}` ，其中d由timePrecision来控制        |
+------------+----------------------------------------------------------------------------+
| general    | 使用scientific格式，默认小数点后有4位有效位数，也可通过timePrecision来调节 |
+------------+----------------------------------------------------------------------------+

自适应时间步长需要指定自适应开关adjustTimeStep，最大库朗数maxCo时间步长最大值maxDeltaT的数值，例如：

.. code-block:: C

    //时间步长自适应控制
    adjustTimeStep  yes;                //是否开启时间步长自适应
    maxCo           0.5;                //最大库郎数
    maxDeltaT       1.0;                //最大时间步长


在计算过程当中，一些字典文件可能会被修改，这时需要打开读取开关runTimeModifiable，以让求解器更新一些参数。


运行时加载库或者函数控制
----------------------------

设置运行时需要加载的库或函数如下所示：

.. code-block:: C

    libs        libUser1.so;    //库列表，库文件位于$LD_LIBRARY_PATH
    functions   probes;         //函数列表



后处理
========

postProcess
-------------

可以在终端通过下面的命令查看可用的后处理方法：

.. code-block:: 

    postProcess -list

场计算
^^^^^^^^^

+-----------------------+------------------------------------------------------------------+
| functionObject        | 作用                                                             |
+=======================+==================================================================+
| CourantNo             | 输出库郎数                                                       |
+-----------------------+------------------------------------------------------------------+
| Lambda2               | 输出Lambda2                                                      |
+-----------------------+------------------------------------------------------------------+
| MachNo                | 计算马赫数                                                       |
+-----------------------+------------------------------------------------------------------+
| Peclect               | 输出Peclet数                                                     |
+-----------------------+------------------------------------------------------------------+
| Q                     | 计算速度梯度第二不变量                                           |
+-----------------------+------------------------------------------------------------------+
| R                     | 计算雷诺应力张量场                                               |
+-----------------------+------------------------------------------------------------------+
| XiReactionRate        | 写入湍流火焰速度以及反应速率体标量场                             |
+-----------------------+------------------------------------------------------------------+
| add                   | 添加场                                                           |
+-----------------------+------------------------------------------------------------------+
| components            | 写入矢量场的分量                                                 |
+-----------------------+------------------------------------------------------------------+
| ddt                   | 计算场的时间导数                                                 |
+-----------------------+------------------------------------------------------------------+
| div                   | 计算场的散度                                                     |
+-----------------------+------------------------------------------------------------------+
| enstrophy             | 计算场的涡度拟能                                                 |
+-----------------------+------------------------------------------------------------------+
| flowType              | 输出速度场类型，-1 表示有旋流；0 表示剪切流；+1 表示其他类型流动 |
+-----------------------+------------------------------------------------------------------+
| grad                  | 计算场的梯度                                                     |
+-----------------------+------------------------------------------------------------------+
| mag                   | 计算场的模                                                       |
+-----------------------+------------------------------------------------------------------+
| magSqr                | 计算场的模的平方                                                 |
+-----------------------+------------------------------------------------------------------+
| randomize             | 对场添加随机分量，扰动量可以指定                                 |
+-----------------------+------------------------------------------------------------------+
| scale                 | 对场进行缩放                                                     |
+-----------------------+------------------------------------------------------------------+
| streamFunction        | 计算网格点的流函数；计算面通量                                   |
+-----------------------+------------------------------------------------------------------+
| substract             | 从某个场中减去某个场的值                                         |
+-----------------------+------------------------------------------------------------------+
| turbulenceFields      | 计算给定的湍流场                                                 |
+-----------------------+------------------------------------------------------------------+
| turbulenceIntensity   | 计算湍流强度场                                                   |
+-----------------------+------------------------------------------------------------------+
| vorticity             | 计算涡量场，例如速度的旋度                                       |
+-----------------------+------------------------------------------------------------------+
| wallShearStress       | 计算壁面剪切力，输出体矢量场                                     |
+-----------------------+------------------------------------------------------------------+
| wallHeatFlux          | 计算壁面热通量，输出体矢量场                                     |
+-----------------------+------------------------------------------------------------------+
| wallHeatTransferCoeff | 计算边界场的壁面换热系数                                         |
+-----------------------+------------------------------------------------------------------+
| writeCellCenters      | 通过体矢量场的方式输出网格体心矢量                               |
+-----------------------+------------------------------------------------------------------+
| writeCellVolumes      | 通过体标量场的方式输出网格单元体积                               |
+-----------------------+------------------------------------------------------------------+
| writeObjects          | 输出某些特定场                                                   |
+-----------------------+------------------------------------------------------------------+
| yPlus                 | 计算湍流的 y+                                                    |
+-----------------------+------------------------------------------------------------------+


流率计算
^^^^^^^^^

+--------------------+----------------------------------------------------------------------------------+
| functionObject     | 作用                                                                             |
+====================+==================================================================================+
| flowRateFaceZone   | 计算patch特定面区域的流量。有可能是体积通量，也有可能是质量通量                  |
+--------------------+----------------------------------------------------------------------------------+
| flowRatePatch      | 计算patch的流量。有可能是体积通量，也有可能是质量通量                            |
+--------------------+----------------------------------------------------------------------------------+
| volFlowRateSurface | 计算三角面的体积通量，速度的计算采用对面表面进行插值并积分。建议三角的面积足够小 |
+--------------------+----------------------------------------------------------------------------------+


力以及力系数
^^^^^^^^^^^^^^^

+---------------------------+---------------------------------------------------------------------------+
| functionObject            | 作用                                                                      |
+===========================+===========================================================================+
| forceCoeffsCompressible   | 对于可压缩求解器，通过对某patch上的力进行加和汇总计算升力、压力、矩系数   |
+---------------------------+---------------------------------------------------------------------------+
| forceCoeffsIncompressible | 对于不可压缩求解器，通过对某patch上的力进行加和汇总计算升力、压力、矩系数 |
+---------------------------+---------------------------------------------------------------------------+
| forceCompressible         | 对于可压缩求解器，计算某patch上的压力以及粘性力                           |
+---------------------------+---------------------------------------------------------------------------+
| forceIncompressible       | 对于不可压缩求解器，计算某patch上的压力以及粘性力                         |
+---------------------------+---------------------------------------------------------------------------+

提取制图
^^^^^^^^^^

+----------------+----------------------+
| functionObject | 作用                 |
+================+======================+
| singleGraph    | 提取某一条线上的数据 |
+----------------+----------------------+

拉格朗日数据
^^^^^^^^^^^^^^^^

+----------------+------------------------------------------------------------------+
| functionObject | 作用                                                             |
+================+==================================================================+
| dsmcFields     | 从DSMC计算结果中提取UMean、translationalT、internalT以及overallT |
+----------------+------------------------------------------------------------------+


监控极值
^^^^^^^^^

+------------------+----------------------------------------------+
| functionObject   | 作用                                         |
+==================+==============================================+
| cellMax          | 对于一个或多个场，输出最大的值               |
+------------------+----------------------------------------------+
| cellMin          | 对于一个或多个场，输出最小的值               |
+------------------+----------------------------------------------+
| faceMax          | 对于一个或多个场，输出面上最大的值           |
+------------------+----------------------------------------------+
| faceMin          | 对于一个或多个场，输出面上最小的值           |
+------------------+----------------------------------------------+
| minMaxComponents | 通过非标量的形式，输出最大最小值以及位置     |
+------------------+----------------------------------------------+
| MinMaxMagnitude  | 通过非标量的形式，输出最大最小值的模以及位置 |
+------------------+----------------------------------------------+


数据格式
^^^^^^^^^^^^

+----------------+----------------------------------------------------------------------+
| functionObject | 作用                                                                 |
+================+======================================================================+
| residuals      | 对于指定场，输出每个时间步迭代的初始残差。对于矢量场，输出最大的分量 |
+----------------+----------------------------------------------------------------------+
| Time           | 写入运行时间、CPU时间、钟表时间                                      |
+----------------+----------------------------------------------------------------------+


压力工具
^^^^^^^^^^

+-----------------------------+------------------------------------+
| functionObject              | 作用                               |
+=============================+====================================+
| pressureDifferencePatch     | 计算两个patch的平均压力差          |
+-----------------------------+------------------------------------+
| pressureDifferenceSurface   | 将压力插值在三角面并计算平均压力差 |
+-----------------------------+------------------------------------+
| staticPressure              | 通过指定的密度计算动压             |
+-----------------------------+------------------------------------+
| totalPressureCompressible   | 计算可压缩求解器的总压             |
+-----------------------------+------------------------------------+
| totalPressureIncompressible | 计算不可压缩求解器的动力总压       |
+-----------------------------+------------------------------------+

探针
^^^^^^

+-----------------+----------------------------------------------------------------------------+
| functionObject  | 作用                                                                       |
+=================+============================================================================+
| boundaryCloud   | 输出场在某 patch 上指定位置的值                                            |
+-----------------+----------------------------------------------------------------------------+
| interfaceHeight | 对于一系列的点，输出界面的高度。这个高度是在这个点上，界面和壁面的垂直距离 |
+-----------------+----------------------------------------------------------------------------+
| internalCloud   | 输出场在指定位置的值                                                       |
+-----------------+----------------------------------------------------------------------------+
| Probes          | 输出场在指定位置距离最近的网格单元的值                                     |
+-----------------+----------------------------------------------------------------------------+

外挂求解器
^^^^^^^^^^^^^^^

+----------------------------+--------------------+
| functionObject             | 作用               |
+============================+====================+
| scalarTransport            | 求解标量场传输方程 |
+----------------------------+--------------------+
| icoUncoupledKinematicCloud | 求解拉格朗日粒子云 |
+----------------------------+--------------------+

可视化工具
^^^^^^^^^^^^^^

+----------------+---------------------------------+
| functionObject | 作用                            |
+================+=================================+
| streamlines    | 通过VTK格式输出流线数据         |
+----------------+---------------------------------+
| surfaces       | 通过VTK格式输出切割面、等值面等 |
+----------------+---------------------------------+




ParaView
-------------

画截面上的流线
^^^^^^^^^^^^^^^^

paraview的Stream Tracer无法直接作一个截面上的流线。比如，对于OpenFOAM的算例，即使是二维算例，截取一个面后，用 Stream tracer 无法得到流线。解决办法是存在的，本篇介绍如果通过一系列filter的组合来得到截面上的流线。

1. 作出需要查看流线的截面Slice；
2. 对上述截面添加Filters/Alphabetical/Surface Vector，让速度矢量投影到平面上；
3. 对得到的Surface Vector使用Filters/Alphabetical/Mask Points，生成一系列参考点用于绘制流线。
   
在MaskPoints中需要调节On Ratio参数以及Maximum number of points参数。其中，On Ratio控制取点的疏密，表示每多少个点中取一个；Maximum number of points控制总点数的数目；一般会勾选Random Sampling以及Generate Vertices。

4. 开启Filters/Alphabetical/Stream Tracer with Custom Source，分别选择上述的SurfaceVector作为Input，选择上述的MaskPoints作为Seed Source。
   

.. note:: 流线的疏密可以通过MaskPoints的点数量来控制，但是点数的空间分布不容易控制。










求解器代码解读
==================

createTime.H
--------------

.. code-block:: C

    Foam::Info<< "Create time\n" << Foam::endl;              // 打印信息，提示开始创建时间对象

    Foam::Time runTime(Foam::Time::controlDictName, args);   // 在Time这个类下面创建一个runTime对象


createMesh.H
----------------

.. code-block:: C

    Foam::Info
        << "Create mesh for time = "
        << runTime.timeName() << Foam::nl << Foam::endl;   // 打印信息，提示开始创建网格对象

    Foam::fvMesh mesh      // 在fvMesh这个类下面创建一个mesh对象
    (
        Foam::IOobject
        (
            Foam::fvMesh::defaultRegion,
            runTime.timeName(),
            runTime,
            Foam::IOobject::MUST_READ
        )
    );




createPhi.H
---------------

这里给出的是位于src/finiteVolume/lnInclude下的createPhi.H文件内容，部分求解器可能会使用其他文件，可以通过求解器对应的Make/options文件来确认读取的哪个createPhi.H文件。

里面核心的计算步骤为 :code:`fvc::flux(U)` ，相当于 :code:`fvc::interpolate(U) & mesh.Sf()` ，即

.. math::
    \begin{align}
    \phi = \mathbf{U}_{f}\cdot \mathbf{S}_{f}
    \end{align}

.. code-block:: C

    Info<< "Reading/calculating face flux field phi\n" << endl;

    surfaceScalarField phi    // 创建定义在网格面中心的标量场-流量场phi
    (
        IOobject    // 通过IOobject读取phi文件
        (
            "phi",
            runTime.timeName(),           // 存在于时间文件夹下
            mesh,
            IOobject::READ_IF_PRESENT,    // 如果已经存在则进行读取，否则需要计算
            IOobject::AUTO_WRITE          // 会自动进行输出
        ),
        fvc::flux(U)    // 速度矢量与面矢量点乘，速度矢量插值到面上的过程与fvSchemes设置相关
    );





laplacianFoam求解器
---------------------

laplacianFoam的createFields.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    Info<< "Reading field T\n" << endl;

    volScalarField T    // 定义在网格体中心的标量场T
    (
        IOobject
        (
            "T",                      // 场的名称(T),用于确定初始文件名称(T)以及变量名称(T)
            runTime.timeName(),       // 存储位置为运行时间(文件夹)
            mesh,                     // 注册于网格对象mesh中
            IOobject::MUST_READ,      // 该对象通过读取文件创建,必须进行读取
            IOobject::AUTO_WRITE      // 根据controlDict中的设置自动写入结果文件
        ),
        mesh    // 新建体心标量场(T)所用的网格对象,在createMesh.H创建
    );


    Info<< "Reading physicalProperties\n" << endl;

    // IOdictionary用于新建字典文件
    IOdictionary physicalProperties    // 参数控制文件声明通过文件physicalProperties读取
    (
        IOobject
        (
            "physicalProperties",                // 文件名
            runTime.constant(),                  // 文件位置，位于$case/constant
            mesh,                                // 网格对象，主要从事对象注册，以便由runTime.write()控制输出
            IOobject::MUST_READ_IF_MODIFIED,     // 在字典文件被更改的时候进行读取
            IOobject::NO_WRITE                   // 不输出，字典文件不需要输出
        )
    );


    Info<< "Reading diffusivity DT\n" << endl;

    // dimensionedScalar用于新建带单位标量，新建扩散率DT。因为各向同性，DT为常数
    dimensionedScalar DT
    (
        // 通过查询参数控制文件$case/constant/physicalProperties，初始化带单位标量
        // 查询关键字DT并读取
        physicalProperties.lookup("DT")
    );

    #include "createFvModels.H"
    #include "createFvConstraints.H"


laplacianFoam.C
^^^^^^^^^^^^^^^^^


laplacianFoam求解器用于求解热传递温度控制方程：

.. math::
    \begin{align}
    \frac{\partial T}{\partial t} - \nabla^{2}(D_{T}T) = 0 
    \end{align}

其中 :math:`T` 表示温度， :math:`t` 表示时间， :math:`D_{T}` 为热扩散系数，具体表达式为

.. math::
    \begin{align}
    D_{T} = \frac{k}{\rho C_{p}} 
    \end{align}

其中 :math:`k` 表示热传导系数， :math:`\rho` 为密度， :math:`C_{p}` 为比热容。

.. code-block:: C

    #include "fvCFD.H"            // 必备头文件。涉及到时间构建、矩阵组建、有限体积离散、网格组建、量纲设置等
    #include "fvModels.H"
    #include "fvConstraints.H"
    #include "simpleControl.H"    // 定义SIMPLE循环，使用SIMPLE循环必备头文件

    int main(int argc, char *argv[])
    {
        #include "setRootCaseLists.H"    // 必备头文件。根据输入参数argc和argv设置算例根目录rootcase

        #include "createTime.H"          // 创建时间对象，涉及到runTime控制。非定常求解器必备头文件
        #include "createMesh.H"          // 必备头文件。创建网格对象，根据$case/constant/polyMesh文件夹中的网格数据创建对象mesh

        simpleControl simple(mesh);      // 从网格mesh对象构造类simpleControl(基类:solutionControl)的对象simple

        #include "createFields.H"        // 创建场对象，位于求解器根目录

        Info<< "\nCalculating temperature distribution\n" << endl;

        while (simple.loop(runTime))    // 开始时间循环，采用SIMPLE算法必备语句
        {
            Info<< "Time = " << runTime.userTimeName() << nl << endl;

            fvModels.correct();
            
            // 是否进行非正交修正
            // 如果在fvSolution字典文件中设置为0就只求解控制方程一次，如果设置为n则求解控制方程n-1次
            while (simple.correctNonOrthogonal())
            {
                
                fvScalarMatrix TEqn    // 定义热传递温度控制方程
                (
                    fvm::ddt(T) - fvm::laplacian(DT, T)    // fvm表示隐式离散,返回有限体积稀疏矩阵类fvMatrix对象
                 ==                                        // fvMatrix的==操作符执行优先级最低。先将==左右的各项相加，最后执行==。而==操作符被重载了，实际上是-
                    fvModels.source(T)    // 源项
                );

                fvConstraints.constrain(TEqn);
                TEqn.solve();    // 求解方程。solve是FOAM名称空间的全局函数,参数为矩阵fvMatrix
                fvConstraints.constrain(T);
            }

            #include "write.H"    // 额外计算grad(T)并进行输出

            Info<< "ExecutionTime = " << runTime.elapsedCpuTime() << " s"
                << "  ClockTime = " << runTime.elapsedClockTime() << " s"
                << nl << endl;
        }

        Info<< "End\n" << endl;

        return 0;
    }


laplacianFoam的write.H
^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    if (runTime.writeTime())    // 当运行时间步到达输出时间的时候执行下面的内容
    {
        volVectorField gradT(fvc::grad(T));    // 计算T的梯度，结果是定义在网格体中心的向量场。fvc::grad显示离散计算能够直接得到结果

        volScalarField gradTx    // 定义在网格体中心的标量场gradTx
        (
            IOobject
            (
                "gradTx",
                runTime.timeName(),     // 位于时间文件夹
                mesh,
                IOobject::NO_READ,      // 不进行读取
                IOobject::AUTO_WRITE    // 到达输出时间步时自动进行输出
            ),
            gradT.component(vector::X)    // 取计算得到的gradT的x分量赋值给gradTx
        );

        volScalarField gradTy    // 定义在网格体中心的标量场gradTy
        (
            IOobject
            (
                "gradTy",
                runTime.timeName(),     // 位于时间文件夹
                mesh,
                IOobject::NO_READ,      // 不进行读取
                IOobject::AUTO_WRITE    // 到达输出时间步时自动进行输出
            ),
            gradT.component(vector::Y)    // 取计算得到的gradT的y分量赋值给gradTy
        );

        volScalarField gradTz    // 定义在网格体中心的标量场gradTz
        (
            IOobject
            (
                "gradTz",
                runTime.timeName(),     // 位于时间文件夹
                mesh,
                IOobject::NO_READ,      // 不进行读取
                IOobject::AUTO_WRITE    // 到达输出时间步时自动进行输出
            ),
            gradT.component(vector::Z)    // 取计算得到的gradT的z分量赋值给gradTz
        );


        runTime.write();    // 输出计算结果
    }



scalarTransportFoam求解器
---------------------------


scalarTransportFoam的createFields.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    Info<< "Reading field T\n" << endl;

    volScalarField T    // 定义在网格体中心的标量场T
    (
        IOobject
        (
            "T",
            runTime.timeName(),     // 位于时间文件夹
            mesh,
            IOobject::MUST_READ,    // 必须读取
            IOobject::AUTO_WRITE    // 根据controlDict设置自动输出
        ),
        mesh
    );


    Info<< "Reading field U\n" << endl;

    volVectorField U
    (
        IOobject
        (
            "U",
            runTime.timeName(),     // 位于时间文件夹
            mesh,
            IOobject::MUST_READ,    // 必须读取
            IOobject::AUTO_WRITE    // 根据controlDict设置自动输出
        ),
        mesh
    );


    Info<< "Reading physicalProperties\n" << endl;

    IOdictionary physicalProperties    // 创建physicalProperties
    (
        IOobject
        (
            "physicalProperties",               // 读取physicalProperties文件
            runTime.constant(),                 // 位于constant文件夹
            mesh,
            IOobject::MUST_READ_IF_MODIFIED,    // 修改后必须读取
            IOobject::NO_WRITE                  // 不进行输出
        )
    );


    Info<< "Reading diffusivity DT\n" << endl;

    dimensionedScalar DT    // 创建标量DT
    (
        physicalProperties.lookup("DT")    // 从physicalProperties文件中读取DT关键词的值
    );

    #include "createPhi.H"    // 创建通量场

    #include "createFvModels.H"
    #include "createFvConstraints.H"




scalarTransportFoam.C
^^^^^^^^^^^^^^^^^^^^^^^^^^

最基本的控制方程为

.. math::
    \begin{align}
        \frac{\partial (\rho T)}{\partial t} 
      + \nabla \cdot (\rho \mathbf{U}T) 
    =   \nabla \cdot (\Gamma \nabla T)
      + Q
    \end{align}

scalarTransportFoam处理的是 :math:`\rho` 和 :math:`\Gamma` 为常量的情况，因此上述方程可以简化为

.. math::
    \begin{align}
    \frac{\partial T}{\partial T} + \nabla \cdot (\mathbf{U}T) = \nabla \cdot (D_{T}\nabla T) + q
    \end{align}

其中 :math:`D_{T}=\frac{\Gamma}{\rho}` ， :math:`q = \frac{Q}{\rho}` 。


.. code-block:: C

    #include "fvCFD.H"
    #include "fvModels.H"
    #include "fvConstraints.H"
    #include "simpleControl.H"    // 使用SIMPLE算法必备头文件

    int main(int argc, char *argv[])
    {
        #include "setRootCaseLists.H"
        #include "createTime.H"
        #include "createMesh.H"

        simpleControl simple(mesh);

        #include "createFields.H"    // 创建场信息

        Info<< "\nCalculating scalar transport\n" << endl;

        #include "CourantNo.H"

        while (simple.loop(runTime))    // 开始SIMPLE算法循环
        {
            Info<< "Time = " << runTime.userTimeName() << nl << endl;

            fvModels.correct();

            while (simple.correctNonOrthogonal())
            {
                fvScalarMatrix TEqn    // 标量传输方程
                (
                    fvm::ddt(T)              // 非稳态项
                  + fvm::div(phi, T)         // 对流项
                  - fvm::laplacian(DT, T)    // 扩散项
                 ==
                    fvModels.source(T)       // 源项
                );

                TEqn.relax();
                fvConstraints.constrain(TEqn);
                TEqn.solve();    // 求解标量传输方程
                fvConstraints.constrain(T);
            }

            runTime.write();
        }

        Info<< "End\n" << endl;

        return 0;
    }




potentialFoam求解器
---------------------


potentialFoam的createFields.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    Info<< "Reading velocity field U\n" << endl;
    volVectorField U    // 定义在网格体中心的矢量场U
    (
        IOobject
        (
            "U",
            runTime.timeName(),     // 位于时间文件夹
            mesh,
            IOobject::MUST_READ,    // 必须读取
            IOobject::AUTO_WRITE    // 根据controlDict设置自动输出
        ),
        mesh
    );

    U = Zero;

    surfaceScalarField phi    // 定义在网格面中心的标量场phi
    (
        IOobject
        (
            "phi",
            runTime.timeName(),     // 位于时间文件夹
            mesh,
            IOobject::NO_READ,      // 不进行读取
            IOobject::AUTO_WRITE    // 根据controlDict设置自动输出
        ),
        fvc::flux(U)    // 速度场插值到网格面上后点乘面矢量得到通量
    );

    if (args.optionFound("initialiseUBCs"))
    {
        U.correctBoundaryConditions();
        phi = fvc::flux(U);
    }


    // Default name for the pressure field
    word pName("p");    // 使用pName关键字来表示p，只起到替换作用

    // Update name of the pressure field from the command-line option
    args.optionReadIfPresent("pName", pName);

    // Infer the pressure BCs from the velocity
    wordList pBCTypes
    (
        U.boundaryField().size(),
        fixedValueFvPatchScalarField::typeName
    );

    forAll(U.boundaryField(), patchi)
    {
        if (U.boundaryField()[patchi].fixesValue())
        {
            pBCTypes[patchi] = zeroGradientFvPatchScalarField::typeName;
        }
    }

    Info<< "Constructing pressure field " << pName << nl << endl;
    volScalarField p    // 定义在体中心的标量场p
    (
        IOobject
        (
            pName,
            runTime.timeName(),           // 处于时间文件夹
            mesh,
            IOobject::READ_IF_PRESENT,    // 如果存在则进行读取
            IOobject::NO_WRITE            // 不进行输出
        ),
        mesh,
        dimensionedScalar(pName, sqr(dimVelocity), 0),
        pBCTypes
    );

    // Infer the velocity potential BCs from the pressure
    wordList PhiBCTypes
    (
        p.boundaryField().size(),
        zeroGradientFvPatchScalarField::typeName
    );

    forAll(p.boundaryField(), patchi)
    {
        if (p.boundaryField()[patchi].fixesValue())
        {
            PhiBCTypes[patchi] = fixedValueFvPatchScalarField::typeName;
        }
    }

    Info<< "Constructing velocity potential field Phi\n" << endl;
    volScalarField Phi    // 定义在网格体中心的标量场，速度势场Phi
    (
        IOobject
        (
            "Phi",
            runTime.timeName(),           // 处于时间文件夹
            mesh,
            IOobject::READ_IF_PRESENT,    // 如果存在则读取
            IOobject::NO_WRITE            // 不进行读取
        ),
        mesh,
        dimensionedScalar(dimLength*dimVelocity, 0),
        PhiBCTypes
    );

    label PhiRefCell = 0;      // 初始化速度势流参考网格标签
    scalar PhiRefValue = 0;    // 初始化速度势流参考值
    setRefCell
    (
        Phi,
        potentialFlow.dict(),    // 读取potentialFlow子字典
        PhiRefCell,              // 设置速度势流参考网格标签
        PhiRefValue              // 设置速度势流参考值
    );
    mesh.schemes().setFluxRequired(Phi.name());

    #include "createMRF.H"




potentialFoam.C
^^^^^^^^^^^^^^^^^^^

首先有稳态不可压缩流体连续性方程：

.. math::
    \begin{align}
    \nabla \cdot \mathbf{U} = 0
    \end{align}

对于无粘无旋流，则必定存在一个势函数 :math:`\Phi` 使得(速度势与压力同向)

.. math::
    \begin{align}
    -\nabla \cdot \Phi = \mathbf{U}
    \end{align}

将上式代入连续性方程得到

.. math::
    \begin{align}
    -\nabla \cdot (\nabla \Phi) = \nabla \cdot \mathbf{U}
    \end{align}

该方程的离散形式为：

.. math::
    \begin{align}
    -\sum(\nabla \Phi)_{f}\cdot \mathbf{S}_{f} = \sum\mathbf{U}_{f}\cdot \mathbf{S}_{f} = \sum\phi_{f}
    \end{align}


.. attention:: 

    之所以没有直接考虑 :math:`-\nabla \cdot (\nabla \Phi)=0` 是因为这个方程离散后得到 :math:`-\sum(\nabla \Phi)_{f}\cdot \mathbf{S}_{f}=0` ，无法考虑速度边界条件的影响。而由于速度边界条件很可能不等于零，所以不能采用这个方程。

求解流程可以分为以下几步：

- 首先针对计算域，将初始化的 :math:`\mathbf{U}` 内部场设置为0，保证 :math:`\sum\phi_{f}` 在内部场为零。 :math:`\mathbf{U}` 的边界场需要自己给定，且不为零。
- 求解一次所离散的方程，获得 :math:`\Phi` 场。
- 对于内部场，由于 :math:`\sum\phi_{f}=0` ，因此在内部场有 :math:`\phi_{f} = -(\nabla \Phi)_{f}\cdot \mathbf{S}_{f}` 。
- 对于边界场，如果是固定值边界条件，那么 :math:`\sum\phi_{f}` 通过速度计算而来，为一个固定值；如果是零法向梯度边界，边界处有 :math:`\phi_{f} = -(\nabla \Phi)_{f}\cdot \mathbf{S}_{f}` 。
- 获得 :math:`\phi_{f}` 场后可以重组得到速度场 :math:`\mathbf{U}` 。
  
.. note:: 

    同时，在求解所离散的方程的时候，需要边界条件。速度的边界条件通常自行给定。 :math:`\Phi` 的边界条件在进口，因为已经给定速度，因此要给定零法向梯度边界条件。

.. code-block:: C

    #include "fvCFD.H"
    #include "nonOrthogonalSolutionControl.H"

    int main(int argc, char *argv[])
    {
        argList::addOption
        (
            "pName",
            "pName",
            "Name of the pressure field"
        );

        argList::addBoolOption
        (
            "initialiseUBCs",
            "Initialise U boundary conditions"
        );

        argList::addBoolOption
        (
            "writePhi",
            "Write the velocity potential field"
        );

        argList::addBoolOption
        (
            "writep",
            "Calculate and write the pressure field"
        );

        argList::addBoolOption
        (
            "withFunctionObjects",
            "execute functionObjects"
        );

        #include "setRootCaseLists.H"
        #include "createTime.H"
        #include "createMesh.H"

        nonOrthogonalSolutionControl potentialFlow(mesh, "potentialFlow");

        #include "createFields.H"    // 创建场信息

        Info<< nl << "Calculating potential flow" << endl;

        // Since solver contains no time loop it would never execute
        // function objects so do it ourselves
        runTime.functionObjects().start();    // 启动求解

        MRF.makeRelative(phi);
        adjustPhi(phi, U, p);

        // Non-orthogonal velocity potential corrector loop
        while (potentialFlow.correctNonOrthogonal())
        {
            fvScalarMatrix PhiEqn    // 势流方程
            (
                fvm::laplacian(dimensionedScalar(dimless, 1), Phi)    // 势流拉普拉斯项
             ==
                fvc::div(phi)    // 速度梯度项
            );

            PhiEqn.setReference(PhiRefCell, PhiRefValue);    // 设置势流参考网格和参考值
            PhiEqn.solve();    // 求解势流方程得到Phi

            if (potentialFlow.finalNonOrthogonalIter())
            {
                phi -= PhiEqn.flux();    // 通过速度势流得到通量
            }
        }

        Info<< "Continuity error = "
            << mag(fvc::div(phi))().weightedAverage(mesh.V()).value()
            << endl;

        U = fvc::reconstruct(MRF.absolute(phi));    // 通过通量重组出速度场
        U.correctBoundaryConditions();

        Info<< "Interpolated velocity error = "
            << (
                    sqrt(sum(sqr(fvc::flux(U) - MRF.absolute(phi))))
                   /sum(mesh.magSf())
               ).value()
            << endl;

        // Write U and phi
        U.write();      // 输出速度场
        phi.write();    // 输出通量场

        // Optionally write Phi
        if (args.optionFound("writePhi"))    // 如果设置了writePhi
        {
            Phi.write();    // 输出速度势流场
        }

        // Calculate the pressure field
        if (args.optionFound("writep"))    // 如果设置了writep则要计算压力场
        {
            Info<< nl << "Calculating approximate pressure field" << endl;

            label pRefCell = 0;        // 初始化压力参考网格标签
            scalar pRefValue = 0.0;    // 初始化压力参考值
            setRefCell
            (
                p,
                potentialFlow.dict(),    // 读取potentialFlow子字典
                pRefCell,                // 设置压力参考网格标签
                pRefValue                // 设置压力参考值
            );

            // Calculate the flow-direction filter tensor
            /* 计算速度场模长的平方值 |U|^{2} ，是定义在网格体中心的标量场 */
            volScalarField magSqrU(magSqr(U));

            /* 定义在网格体中心的对称张量场
               F为流向滤波张量，表示为 U^{2} / |U|^{2}
               small是一个极小数1.0e-6，用来避免除数为零 */
            volSymmTensorField F(sqr(U)/(magSqrU + small*average(magSqrU)));

            // Calculate the divergence of the flow-direction filtered div(U*U)
            // Filtering with the flow-direction generates a more reasonable
            // pressure distribution in regions of high velocity gradient in the
            // direction of the flow
            /*
               在流动方向的高速度梯度区域，按流动方向进行过滤，可使压力分布更加合理
            */
            volScalarField divDivUU    // 滤波后流向的散度，是定义在网格体中心的标量场
            (
                /*
                   \nabla \cdot (\frac{U^{2}}{|U|^{2}} \cdot \nabla \cdot (UU))
                */
                fvc::div
                (
                    F & fvc::div(phi, U),
                    "div(div(phi,U))"
                )
            );

            // Solve a Poisson equation for the approximate pressure
            while (potentialFlow.correctNonOrthogonal())
            {
                fvScalarMatrix pEqn    // 压力泊松方程，属于标量方程
                (
                    /*
                       \nabla^{2} p + \nabla \cdot (\frac{U^{2}}{|U|^{2}} \cdot \nabla \cdot (UU))
                    */
                    fvm::laplacian(p) + divDivUU
                );

                pEqn.setReference(pRefCell, pRefValue);    // 设置压力参考网格和参考值
                pEqn.solve();    // 求解压力泊松方程得到估计压力场
            }

            p.write();    // 输出压力场
        }

        runTime.functionObjects().end();    // 结束求解

        Info<< "ExecutionTime = " << runTime.elapsedCpuTime() << " s"
            << "  ClockTime = " << runTime.elapsedClockTime() << " s"
            << nl << endl;

        Info<< "End\n" << endl;

        return 0;
    }



potentialFoam的createControls.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

在求解器目录中还存在这个头文件，但是在potentialFoam.C中并没有调用。

.. code-block:: C

    const dictionary& potentialFlow
    (
        mesh.solution().dict().subDict("potentialFlow")
    );

    const int nNonOrthCorr
    (
        potentialFlow.lookupOrDefault<int>("nNonOrthogonalCorrectors", 0)
    );





icoFoam求解器
----------------


icoFoam的createFields.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    // 在此之前已经创建了runTime和mesh对象，可以直接使用runTime和mesh进行操作
    Info<< "Reading physicalProperties\n" << endl;      // 打印信息，提示要读取physicalProperties这个文件

    IOdictionary physicalProperties    // 创建physicalProperties对象
    (
        IOobject     // 通过IOobject读取physicalProperties文件内的信息
        (
            "physicalProperties",
            runTime.constant(),                   // 存在于constant文件夹下
            mesh,
            IOobject::MUST_READ_IF_MODIFIED,
            IOobject::NO_WRITE                    // 位于constant文件夹内的属性不进行输出
        )
    );

    dimensionedScalar nu    // 创建有量纲标量场-动力粘度场nu
    (
        "nu",                                           
        dimViscosity,
        physicalProperties.lookup("nu")    // 通过读取关键词nu的值进行创建
    );

    Info<< "Reading field p\n" << endl;
    volScalarField p    // 创建定义在网格体中心的标量场-压力场p
    (
        IOobject    // 通过IOobject读取p文件内的信息
        (
            "p",
            runTime.timeName(),     // 存在于时间文件夹下
            mesh,
            IOobject::MUST_READ,    // 必须进行读取
            IOobject::AUTO_WRITE    // 会自动进行输出
        ),
        mesh
    );


    Info<< "Reading field U\n" << endl;
    volVectorField U    // 创建定义在网格体中心的矢量场-速度场U
    (
        IOobject    // 通过IOobject读取U文件内的信息
        (
            "U",
            runTime.timeName(),     // 存在于时间文件夹下
            mesh,
            IOobject::MUST_READ,    // 必须进行读取
            IOobject::AUTO_WRITE    // 会自动进行输出
        ),
        mesh
    );


    #include "createPhi.H"    // 创建面通量场phi


    label pRefCell = 0;         // 标定网格参考的编号，首先初始化为了0
    scalar pRefValue = 0.0;     // 标定网格的参考值，首先初始化为了0。不可压缩流有意义的是参考压力值
    // 进入fvSolution文件查找PISP子字典，读取其中的pRefCell与pRefValue的值并进行更新
    setRefCell(p, mesh.solution().dict().subDict("PISO"), pRefCell, pRefValue);
    mesh.schemes().setFluxRequired(p.name());






icoFoam.C
^^^^^^^^^^^^^^^

icoFoam求解不可压缩流体，控制方程有两个：

.. math::
    \begin{align}
    \nabla \cdot \mathbf{U} = 0
    \end{align}

.. math::
    \begin{align}
    \frac{\partial \mathbf{U}}{\partial t}
    + \nabla\cdot(\mathbf{U}\mathbf{U}) 
    = 
    -\nabla \frac{p}{\rho} 
    + \nabla \cdot (\nu \nabla \mathbf{U}) 
    \end{align}

使用有限体积法处理动量方程得到

.. math::
    \begin{align}
    \frac{1}{\Delta t}\iint \bigg( 
    \frac{\partial \mathbf{U}}{\partial t}
    + \nabla\cdot(\mathbf{U}\mathbf{U}) 
    \bigg) \mathrm{d}V\mathrm{d}t
    = 
    \frac{1}{\Delta t}\iint \bigg(
    -\nabla \frac{p}{\rho} 
    + \nabla \cdot (\nu \nabla \mathbf{U}) 
    \bigg) \mathrm{d}V\mathrm{d}t
    \end{align}

接下来对各项进行离散处理。首先是时间项欧拉全隐式离散：

.. math::
    \begin{align}
    \frac{1}{\Delta t}\iint \frac{\partial \mathbf{U}}{\partial t} \mathrm{d}V\mathrm{d}t = \frac{(\mathbf{U}_{P}^{*} - \mathbf{U}_{P}^{t})}{\Delta t}V_{P}
    \end{align}

其中下标P表示当前网格，上标t表示当前时间步(已知)，上标*表示预测步。

对流项隐式离散利用了高斯定理：

.. math::
    \begin{align}
    \frac{1}{\Delta t}\iint \nabla \cdot (\mathbf{U}\mathbf{U}) \mathrm{d}V\mathrm{d}t 
    = \frac{1}{\Delta t}\iint (\mathbf{U}\mathbf{U}) \cdot \mathrm{d}\mathbf{S}\mathrm{d}t
    = \frac{1}{\Delta t}\sum (\mathbf{U}^{*}\mathbf{U}^{t})_{f} \cdot \mathbf{S}_{f} \Delta t
    = \sum \phi_{f}^{t} \mathbf{U}_{f}^{*}
    \end{align}

其中下标f表示插值到网格面上， :math:`\mathbf{S}_{f}` 为网格面矢量， :math:`\phi_{f}^{t}` 为网格面上当前时间步的通量。

扩散项隐式离散：

.. math::
    \begin{align}
    \frac{1}{\Delta t}\iint \nabla \cdot (\nu \nabla \mathbf{U}) \mathrm{d}V\mathrm{d}t
    = \frac{1}{\Delta t}\iint \nu \nabla \mathbf{U} \cdot \mathrm{d}\mathbf{S}\mathrm{d}t  
    = \sum (\nu \nabla \mathbf{U}^{*})_{f} \cdot \mathbf{S}_{f} 
    \end{align}

其中 :math:`\nabla \mathbf{U}^{*}` 定义在网格体中心， :math:`(\nabla \mathbf{U}^{*})_{f}` 定义在网格面中心。

为了方便，重新定义 :math:`p = \frac{p}{\rho}` 去掉密度，于是压力项显式离散为

.. math::
    \begin{align}
    \frac{1}{\Delta t} \iint - \nabla p~\mathrm{d}V\mathrm{d}t
    = \frac{1}{\Delta t}\iint - p ~\mathrm{d}\mathbf{S}\mathrm{d}t
    = -\sum (p_{f}^{t}\mathbf{S}_{f}) 
    \end{align}

将上面的离散结果全部应用到动量方程并将所有速度相关的项移到左边则得到

.. math::
    \begin{align}
    \frac{(\mathbf{U}_{P}^{*} - \mathbf{U}_{P}^{t})}{\Delta t}V_{P}
    + \sum \phi_{f}^{t} \mathbf{U}_{f}^{*}
    - \sum (\nu \nabla \mathbf{U}^{*})_{f} \cdot \mathbf{S}_{f}
    =
    - \sum (p_{f}^{t}\mathbf{S}_{f})
    \end{align}

左侧与速度相关的方程在icoFoam中通过如下方式组建：

.. code-block:: C

    fvVectorMatrix UEqn
    (
        fvm::ddt(U)
        + fvm::div(phi, U)
        - fvm::laplacian(nu, U)
    );  

右侧显式离散的压力梯度项则如下进行组建：

.. code-block:: C

    -fvc::grad(p)

上述方程中 :math:`\mathbf{U}_{P}^{*}` 作为未知数保留下来， :math:`\phi_{f}^{t}` 通过 :math:`\mathbf{U}_{P}^{t}` 插值计算得到。插值到面的过程需要自行选择格式，以均一网格上的中心线性格式为例则有

.. math::
    \begin{align}
    \mathbf{U}_{f}^{*} = \frac{\mathbf{U}_{P}^{*} + \mathbf{U}_{N}^{*}}{2}, \qquad p_{f}^{t} = \frac{p_{P}^{t} + p_{N}^{t}}{2}  
    \end{align}

其中下标P表示定义在当前网格的体中心，下标N表示定义在相邻网格的体中心。

为了使用紧致基架点防止数值振荡， :math:`(\nabla \mathbf{U}^{*})_{f} \cdot \mathbf{S}_{f}` 需要重新表示为面法向梯度乘以面矢量的模，即

.. math::
    \begin{array}{c}
    (\nabla \mathbf{U}^{*})_{f} \cdot \mathbf{S}_{f}
    = \bigg( (\nabla \mathbf{U}^{*})_{f} \cdot \frac{\mathbf{S}_{f}}{|\mathbf{S}_{f}|} \bigg) \cdot |\mathbf{S}_{f}|
    \end{array}

上面的面法向梯度可以离散为

.. math::
    \begin{align}
    (\nabla \mathbf{U}^{*})_{f} \cdot \frac{\mathbf{S}_{f}}{|\mathbf{S}_{f}|}
    = \frac{\mathbf{U}_{N}^{*} - \mathbf{U}_{P}^{*}}{|\mathbf{d}|} 
    \end{align}

其中 :math:`\mathbf{d}` 表示相邻网格体中心之间的距离矢量。

将这些进一步的离散形式应用于动量方程则得到

.. math::
    \begin{align}
    \frac{\mathbf{U}_{P}^{*} - \mathbf{U}_{P}^{t}}{\Delta t}V_{P}
    + \sum \phi_{f}^{t} \frac{\mathbf{U}_{P}^{*} + \mathbf{U}_{N}^{*}}{2}
    - \sum \nu \frac{\mathbf{U}_{N}^{*} - \mathbf{U}_{P}^{*}}{|\mathbf{d}|} |\mathbf{S}_{f}|
    =
    - \sum \frac{p_{P}^{t} + p_{N}^{t}}{2} \mathbf{S}_{f}    
    \end{align}

按各速度项提取系数进行整理得到

.. math::
    \begin{align}
    \bigg( \frac{V_{P}}{\Delta t} + \sum\frac{\phi_{f}^{t}}{2} + \sum \nu\frac{|\mathbf{S}_{f}|}{|\mathbf{d}|} \bigg) \mathbf{U}_{P}^{*}
    + \sum \bigg( \frac{\phi_{f}^{t}}{2} - \nu \frac{|\mathbf{S}_{f}|}{|\mathbf{d}|} \bigg) \mathbf{U}_{N}^{*}
    - \frac{V_{P}}{\Delta t} \mathbf{U}_{P}^{t}
    =
    - \sum \frac{p_{P}^{t} + p_{N}^{t}}{2}\mathbf{S}_{f}  
    \end{align}

各系数记为

.. math::
    \begin{align}
    A_{P} &= \frac{V_{P}}{\Delta t} + \sum\frac{\phi_{f}^{t}}{2} + \sum \nu\frac{|\mathbf{S}_{f}|}{|\mathbf{d}|}  \\
    A_{N} &= \frac{\phi_{f}^{t}}{2} - \nu \frac{|\mathbf{S}_{f}|}{|\mathbf{d}|}  \\
    \end{align}

其中 :math:`A_{P}` 通过 :code:`UEqn.A()` 来得到，实际操作则是提取了关于U的线性方程组的系数矩阵的对角元素， :code:`A()` 操作定义于src/finiteVolume/fvMatrices/fvMatrix/fvMatrix.C文件当中的809行。在后续常以 :math:`1/A_{P}` 的形式出现，因此icoFoam如下进行定义：

.. code-block:: C

    volScalarField rAU(1.0/UEqn.A());

于是上式简写为

.. math::
    \begin{align}
    A_{P}\mathbf{U}_{P}^{*} + \sum A_{N}\mathbf{U}_{N}^{*} - \frac{V_{P}}{\Delta t} \mathbf{U}_{P}^{t} = - \sum \frac{p_{P}^{t} + p_{N}^{t}}{2}\mathbf{S}_{f}
    \end{align}

该方程称为 **动量预测方程** ，求解它就能够获得预测速度 :math:`\mathbf{U}_{P}^{*}` ：

.. code-block:: C

    if (piso.momentumPredictor())
    {
        solve(UEqn == -fvc::grad(p));
    }

.. note:: 不过动量预测步骤并不是必须的，如果不调用动量预测，则 :math:`\mathbf{U}_{P}^{*}=\mathbf{U}_{P}^{t}` 。


对连续性方程进行离散得到

.. math::
    \begin{align}
    \sum (\mathbf{U}_{P,f}^{t+\Delta t} \cdot \mathbf{S}_{f}) = 0
    \end{align}

其中上标 :math:`t+\Delta t` 表示下一时间步达到收敛状态的情况。下面要尝试使用压力来表示 :math:`\mathbf{U}_{P,f}^{t+\Delta t}` 。

重新来看动量预测方程，考虑 **达到收敛情况的动量预测方程** 则有

.. math::
    \begin{align}
    A_{P}\mathbf{U}_{P}^{t+\Delta t} + \sum A_{N}\mathbf{U}_{N}^{t+\Delta t} - \frac{V_{P}}{\Delta t} \mathbf{U}_{P}^{t} = - \sum p_{f}^{t+\Delta t}\mathbf{S}_{f}
    \end{align}

收敛情况下的动量预测方程和原始动量预测方程做减法则得到

.. math::
    \begin{align}
    A_{P}(\mathbf{U}_{P}^{t+\Delta t} - \mathbf{U}_{P}^{*})
    + \sum A_{N}(\mathbf{U}_{N}^{t+\Delta t} - \mathbf{U}_{N}^{*})
    = - \sum (p_{f}^{t+\Delta t} - p_{f}^{t}) \mathbf{S}_{f} 
    \end{align}


对收敛情况下的动量预测方程做移项得到 :math:`\mathbf{U}_{P}^{t+\Delta t}` 的表达式：

.. math::
    \begin{align}
    \mathbf{U}_{P}^{t+\Delta t}
    = 
    \mathbf{HbyA}_{P}^{t+\Delta t}
    - \frac{1}{A_{P}} \sum p_{f}^{t+\Delta t}\mathbf{S}_{f} 
    \end{align}

其中

.. math::
    \begin{align}
    \mathbf{HbyA}_{P}^{t+\Delta t} = \frac{1}{A_{P}} \Big( -\sum A_{N}\mathbf{U}_{N}^{t+\Delta t} + \frac{V_{P}}{\Delta t} \mathbf{U}_{P}^{t} \Big)  
    \end{align}

类似的，面上的速度则可以表示为

.. math::
    \begin{align}
    \mathbf{U}_{P,f}^{t+\Delta t}
    =
    \mathbf{HbyA}_{f}^{t+\Delta t}
    -\Big(\frac{1}{A_{P}}\Big)_{f} \Big( \sum p_{f}^{t+\Delta t}\mathbf{S}_{f} \Big)_{f}
    \end{align}

上式就成功将 :math:`\mathbf{U}_{P,f}^{t+\Delta t}` 表示为与压力有关的式子，代入到离散的连续性方程则得到

.. math::
    \begin{align}
    \sum \bigg( \mathbf{HbyA}_{f}^{t+\Delta t} -\Big(\frac{1}{A_{P}}\Big)_{f} \Big( \sum p_{f}^{t+\Delta t}\mathbf{S}_{f} \Big)_{f} \bigg) \cdot \mathbf{S}_{f} = 0
    \end{align}

将面矢量点乘乘进去并移项就得到了压力泊松方程的离散形式：

.. math::
    \begin{align}
    \sum \mathbf{HbyA}_{f}^{t+\Delta t} \cdot \mathbf{S}_{f} = \sum \Big(\frac{1}{A_{P}}\Big)_{f}\Big( \sum p_{f}^{t+\Delta t}\mathbf{S}_{f} \Big)_{f} \cdot \mathbf{S}_{f}
    \end{align}

其所表达的原始压力泊松方程的形式为

.. math::
    \begin{align}
    \nabla \cdot \mathbf{HbyA}^{t+\Delta t} = \nabla \cdot \Big( \frac{1}{A_{P}}\nabla p^{t+\Delta t} \Big) 
    \end{align}


.. attention:: 

    上述压力泊松方程的离散形式对 :math:`\nabla \cdot \Big( \frac{1}{A}\nabla p^{t+\Delta t} \Big)` 的处理是先求梯度再求散度，但是这样会引起数值振荡。为了调用紧致格式防止数值振荡，应当从原始压力泊松方程形式考虑，通过拉普拉斯并进行高斯积分进行离散。

目前我们只有通过动量预测方程求解出来的 :math:`\mathbf{U}_{P}^{*}` ，而 :math:`\mathbf{HbyA}_{P}^{t+\Delta t}` 和 :math:`p^{t+\Delta t}` 均未知，因此压力泊松方程尚不能求解。为了解决这个问题，Issa提出了PISO算法。依据PISO算法，重新考虑收敛情况下的动量预测方程和原始动量预测方程作差后的方程，引入忽略相邻点影响的假定，则有

.. math::
    \begin{align}
    A_{P}(\mathbf{U}_{P}^{t+\Delta t} - \mathbf{U}_{P}^{*}) = -\sum (p_{f}^{t+\Delta t} - p_{f}^{t}) \mathbf{S}_{f}
    \end{align}

将上式与原始动量方程相加得到

.. math::
    \begin{align}
    A_{P}\mathbf{U}_{P}^{**} + \sum A_{N}\mathbf{U}_{N}^{*} - \frac{V_{P}}{\Delta t} \mathbf{U}_{P}^{t} = - \sum p_{f}^{*}\mathbf{S}_{f}
    \end{align}

.. note:: 因为忽略了相邻点的影响，方程求解的结果将不会是准确的，也即两个方程相加将不会产生 :math:`\mathbf{U}_{P}^{t+\Delta t}` 和 :math:`p_{f}^{t+\Delta t}` ，而是预测值 :math:`\mathbf{U}_{P}^{**}` 和 :math:`p_{f}^{*}` 。

对上式进行移项得到 :math:`\mathbf{U}_{P}^{**}` 的表达式：

.. math::
    \begin{align}
    \mathbf{U}_{P}^{**} = \mathbf{HbyA}_{P}^{*} - \frac{1}{A_{P}}\sum p_{f}^{*}\mathbf{S}_{f}   
    \end{align}

其中

.. math::
    \begin{align}
    \mathbf{HbyA}_{P}^{*} = \frac{1}{A_{P}} \Big( -\sum A_{N}\mathbf{U}_{N}^{*} + \frac{V_{P}}{\Delta t} \mathbf{U}_{P}^{t} \Big)  
    \end{align}

使用 :code:`UEqn.H()` 来得到 :math:`-\sum A_{N}\mathbf{U}_{N}^{*} + \frac{V_{P}}{\Delta t} \mathbf{U}_{P}^{t}` ，实际操作内容的讨论见 `what's the meaning of UEqn().A() <https://www.cfd-online.com/Forums/openfoam/75661-whats-meaning-ueqn.html>`_  ， :code:`H()` 操作定义于src/finiteVolume/fvMatrices/fvMatrix/fvMatrix.C文件当中的831行。在icoFoam通过如下方式进行定义：

.. code-block:: C

    volVectorField HbyA(constrainHbyA(rAU*UEqn.H(), U, p));

类似的可以得到插值在面上的形式：

.. math::
    \begin{align}
    \mathbf{U}_{P,f}^{**} = \mathbf{HbyA}_{f}^{*} - \Big(\frac{1}{A_{P}}\Big)_{f} \Big(\sum p_{f}^{*}\mathbf{S}_{f}\Big)_{f}
    \end{align}

上式代入到离散的连续性方程则得到

.. math::
    \begin{align}
    \sum \bigg( \mathbf{HbyA}_{f}^{*} - \Big(\frac{1}{A_{P}}\Big)_{f} \Big(\sum p_{f}^{*}\mathbf{S}_{f}\Big)_{f} \bigg) \cdot \mathbf{S}_{f} = 0
    \end{align}

将面矢量点乘乘进去并移项则得到

.. math::
    \begin{align}
    \sum \mathbf{HbyA}_{f}^{*} \cdot \mathbf{S}_{f} =  \sum \Big(\frac{1}{A_{P}}\Big)_{f} \Big( \sum p_{f}^{*}\mathbf{S}_{f} \Big)_{f} \cdot \mathbf{S}_{f}
    \end{align}

其中 :math:`\mathbf{HbyA}_{f}^{*} \cdot \mathbf{S}_{f}` 用了一个定义在网格面中心的标量场来表示：

.. code-block:: C

    surfaceScalarField phiHbyA
    (
        "phiHbyA",
        fvc::flux(HbyA)
        + fvc::interpolate(rAU)*fvc::ddtCorr(U, phi)    // 保证速度通量的全局守恒，以确保压力方程有解
    );


如此也就成功组建得到了压力泊松方程：

.. math::
    \begin{align}
    \nabla \cdot \Big( \frac{1}{A_{P}}\nabla p^{*} \Big) = \nabla \cdot \mathbf{HbyA}^{*} 
    \end{align}

该压力泊松方程在icoFoam当中通过如下方式进行组建：

.. code-block:: C

    fvScalarMatrix pEqn
    (
        fvm::laplacian(rAU, p) == fvc::div(phiHbyA)
    );

.. attention:: :code:`fvc::div` 操作实际上进行的是加和操作。因此在进行这个操作之前总是要自行先计算出所需的通量。


求解该压力泊松方程后可以得到 :math:`p^{*}` ，回代到 :math:`\mathbf{U}_{P}^{**}` 的表达式就可以得到满足连续性方程的 :math:`\mathbf{U}_{P}^{**}` ：

.. code-block:: C

    U = HbyA - rAU*fvc::grad(p);

但是，由于忽略了相邻点的影响，此时求解得到的 :math:`p^{*}` 和 :math:`\mathbf{U}_{P}^{**}` 并不严格满足动量方程，因此还需要继续使用这两个量进行时间步内的循环迭代，即 :code:`while (piso.correct())` 循环。PISO算法在时间步内的迭代一般只需要3步即可。

除此之外，在每次求解出预测压力与预测速度之后，还会使用最新压力校正速度通量，以保证速度通量场严格守恒：

.. code-block:: C

    if (piso.finalNonOrthogonalIter())
    {
        phi = phiHbyA - pEqn.flux();
    }

其中 :code:`pEqn.flux()` 返回的内容是

.. code-block:: C

    fvc::interpolate(rUA)*fvc::snGrad(p)*mag(mesh.Sf())


.. note:: 

    在OpenFOAM中的通量计算有一点不同，主要差别在于 :math:`\phi^{*}` 被定义为了 :math:`\left ( \frac{A_{H}}{A_{D}} \right )_{f} \cdot \mathbf{S}_{f} + \phi_{e}` ，其中添加的 :math:`\phi_{e}` 为

    .. math::
        \begin{align}
        \phi_{e} = \frac{\gamma \rho}{A_{D}\Delta t}(\phi_{0}-\mathbf{S}_{f}\cdot\mathbf{U}_{f,0})
        \end{align}

    而 :math:`\gamma` 参数具体含义为

    .. math::
        \begin{align}
        \gamma = 1- \min\left ( \frac{|\phi_{0}-\mathbf{U}_{f,0}|\cdot\mathbf{S}_{f}}{|\phi_{0}|+\varepsilon},1  \right ) 
        \end{align}

icoFoam使用PISO算法求解NS方程，基本的步骤如下：

1. 根据初始条件(压力场、速度场等)求解预测速度场；
2. 根据预测速度求无压力梯度项的速度场；
3. 根据无压力梯度项的速度场求解压力(泊松)方程，得到压力场；
4. 根据压力场修正预测速度场以满足连续性方程；
5. 返回第二步，循环直到满足收敛要求。




.. code-block:: C

    #include "fvCFD.H"    // 有限体积库头文件的集合
    #include "pisoControl.H"    //定义PISO循环,使用PISO循环必备头文件

    int main(int argc, char *argv[])
    {
        #include "setRootCaseLists.H"     // 用于检查算例文件的结构是否正确
        #include "createTime.H"           // 创建runTime时间对象
        #include "createMesh.H"           // 创建mesh网格对象

        pisoControl piso(mesh);    // 从网格mesh对象构造类pisoControl(基类:solutionControl)的对象piso

        #include "createFields.H"          // 对场量进行初始化
        #include "initContinuityErrs.H"    // 初始化连续误差


        Info<< "\nStarting time loop\n" << endl;

        while (runTime.loop())
        {
            Info<< "Time = " << runTime.userTimeName() << nl << endl;

            #include "CourantNo.H"    // 计算库朗数并输出至屏幕

            // Momentum predictor

            fvVectorMatrix UEqn    // 创建了一个关于U的式子(U方程)，即动量方程等号左边的部分
            (
                fvm::ddt(U)              // 隐式离散时间导数项
              + fvm::div(phi, U)         // 隐式离散对流项
              - fvm::laplacian(nu, U)    // 隐式离散扩散项
            );
            
            // 动量预测求解开关，对于多相流以及低雷诺数一般设置为off
            // 通过fvSolution中momentumPredictor进行赋值
            if (piso.momentumPredictor())
            {
                // 求解动量方程，使用上一步的压力场，得到预测速度场
                solve(UEqn == -fvc::grad(p));    // 显式离散压强梯度项
            }

            // --- PISO loop
            while (piso.correct())    // 通过system/fvSolution中PISO字典中的nCorrectors关键词来指定循环次数
            {
                volScalarField rAU(1.0/UEqn.A());    // 创建一个定义在体中心的标量场rAU

                volVectorField HbyA(constrainHbyA(rAU*UEqn.H(), U, p));    // 创建一个定义在体中心的向量场HbyA

                surfaceScalarField phiHbyA    // 创建一个定义在面中心的标量场
                (
                    "phiHbyA",
                    fvc::flux(HbyA)                               // 将HbyA差分到面上，并点乘面矢量
                  + fvc::interpolate(rAU)*fvc::ddtCorr(U, phi)    // 这一项是OpenFOAM自己添加的项，保证速度通量的全局守恒以确保压力方程有解
                );

                /* 确保整个区域的净通量为0，即流入等于流出，
                   函数先统计流入和流出的量，如果两者不相等，那么调整速度assignable边界，
                   通过改动边界上的值使得整个体系通量守恒。
                   也就是要修正压力边界（梯度为0）上的phi，使其满足连续性方程。 */
                adjustPhi(phiHbyA, U, p);

                // Update the pressure BCs to ensure flux consistency
                constrainPressure(p, U, phiHbyA, rAU);    // //更正压力边界条件，保证通量守恒，用于修正fixedFluxPressure类压力边界条件

                // Non-orthogonal pressure corrector loop
                while (piso.correctNonOrthogonal())    // 网格非正交压力修正循环，需要指定nNonOrthogonalCorrectors的值来确定循环次数
                {
                    // Pressure corrector
                    // 构造泊松压力方程进行求解
                    fvScalarMatrix pEqn
                    (
                        fvm::laplacian(rAU, p) == fvc::div(phiHbyA)
                    );
                    
                    // 在不可压缩流动中，只有相对压力才起作用。除非存在边界压力
                    // 一个网格的压力可以任意设定，以产生独特的压力解决方案
                    pEqn.setReference(pRefCell, pRefValue);    // 设置压力参考值

                    pEqn.solve();    // 求解上述p方程，可以得到p的值

                    if (piso.finalNonOrthogonalIter())    // 使用求解的压力场修正通量场，即在最后一次修正的时候使通量守恒
                    {
                        phi = phiHbyA - pEqn.flux();
                    }
                }

                #include "continuityErrs.H"    // 计算连续性方程误差

                // 校正速度，满足边界条件(主要针对第二类边界条件）
                U = HbyA - rAU*fvc::grad(p);

                /* 上述隐式求解过程中U的边界条件不会参与，调用该函数之后才得到边界值，
                   该函数的主要作用是将GeometricField中的变量及时更新，
                   通常会在每一时间步的结束时刻调用一次，多次调用也不会出错。 */
                U.correctBoundaryConditions();
            }

            runTime.write();    // 输出时间

            Info<< "ExecutionTime = " << runTime.elapsedCpuTime() << " s"
                << "  ClockTime = " << runTime.elapsedClockTime() << " s"
                << nl << endl;
        }

        Info<< "End\n" << endl;

        return 0;
    }


.. note:: 

    更新通量phi采用 :code:`phi = phiHbyA - pEqn.flux()` 的方法，而不是在求解出正确速度场之后通过 :code:`phi = fvc::flux(U)` 来更新，这样可以保证通量phi是严格守恒的。由于U不存在守恒的概念，即使是通过正确的U插值求解通量也不能保证一定守恒。






pisoFoam求解器
------------------

pisoFoam的createFields.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    Info<< "Reading field p\n" << endl;
    volScalarField p    // 创建定义在网格体中心的标量场-压力场p
    (
        IOobject    // 通过IOobject读取p文件内的信息
        (
            "p",
            runTime.timeName(),     // 存在于时间文件夹下
            mesh,
            IOobject::MUST_READ,    // 必须进行读取
            IOobject::AUTO_WRITE    // 会自动进行输出
        ),
        mesh
    );

    Info<< "Reading field U\n" << endl;
    volVectorField U    // 创建定义在网格体中心的矢量场-速度场U
    (
        IOobject    // 通过IOobject读取U文件内的信息
        (
            "U",
            runTime.timeName(),     // 存在于时间文件夹下
            mesh,
            IOobject::MUST_READ,    // 必须读取
            IOobject::AUTO_WRITE    // 会自动进行输出
        ),
        mesh
    );

    #include "createPhi.H"    // 创建面通量场phi


    pressureReference pressureReference(p, piso.dict());

    mesh.schemes().setFluxRequired(p.name());

    // autoPtr是一个智能指针，不需要用户考虑内存释放等问题
    autoPtr<viscosityModel> viscosity(viscosityModel::New(mesh));    // 创建一个viscosity指针

    autoPtr<incompressible::momentumTransportModel> turbulence    // 创建一个turbulence指针
    (
        incompressible::momentumTransportModel::New(U, phi, viscosity)
    );

    #include "createMRF.H"
    #include "createFvModels.H"
    #include "createFvConstraints.H"


pisoFoam.C
^^^^^^^^^^^^^^

.. code-block:: C

    #include "fvCFD.H"
    #include "viscosityModel.H"
    #include "incompressibleMomentumTransportModels.H"   // 引入湍流模型
    #include "pisoControl.H"
    #include "pressureReference.H"
    #include "fvModels.H"
    #include "fvConstraints.H"

    int main(int argc, char *argv[])
    {
        #include "postProcess.H"

        #include "setRootCaseLists.H"
        #include "createTime.H"
        #include "createMesh.H"
        #include "createControl.H"
        #include "createFields.H"          // 创建场信息与粘度湍流指针
        #include "initContinuityErrs.H"    //定义标量的连续性误差为0

        turbulence->validate();

        Info<< "\nStarting time loop\n" << endl;

        while (runTime.loop())
        {
            Info<< "Time = " << runTime.userTimeName() << nl << endl;

            #include "CourantNo.H"

            // Pressure-velocity PISO corrector
            {
                fvModels.correct();

                #include "UEqn.H"    // 求解速度场

                // --- PISO loop
                while (piso.correct())
                {
                    #include "pEqn.H"    // 求解压力场
                }
            }

            viscosity->correct();     // 更新与粘度有关的量，涉及非牛顿流体系数
            turbulence->correct();    // 更新与所选湍流模型有关的量

            runTime.write();    // 输出时间

            Info<< "ExecutionTime = " << runTime.elapsedCpuTime() << " s"
                << "  ClockTime = " << runTime.elapsedClockTime() << " s"
                << nl << endl;
        }

        Info<< "End\n" << endl;

        return 0;
    }


pisoFoam的UEqn.H
^^^^^^^^^^^^^^^^^^

.. code-block:: C

    MRF.correctBoundaryVelocity(U);

    fvVectorMatrix UEqn
    (
        fvm::ddt(U) + fvm::div(phi, U)    // 隐式离散时间导数项和隐式离散对流项
      + MRF.DDt(U)                        // MRF方法旋转坐标系的额外项，用于动网格系统，
                                          // 这里表示\mathbf{\Omega } \times \mathbf{U}_{I} 。
      + turbulence->divDevSigma(U)        // 考虑湍流扩散效应的拉普拉斯项，
                                          // 不仅有基于分子间的粘性mu还有基于湍流的粘性mu_t 。
     ==
        fvModels.source(U)    // 动量方程的源项
    );

    UEqn.relax();    // 松弛技术，
                     // 对方程进行隐形松弛，用来提高矩阵的对角占优有利解；
                     // 对场进行显性松弛。

    fvConstraints.constrain(UEqn);

    if (piso.momentumPredictor())
    {
        // 求解动量方程
        // p是上一个时间步的压强，求解将会更新U，下面所有的U都将是这一步求解出来的U
        solve(UEqn == -fvc::grad(p));    // 显式离散压强梯度项

        fvConstraints.constrain(U);
    }

    //到了这里就得到了预测速度


pisoFoam的pEqn.H
^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    /* 创建一个定义在体中心的标量场rAU，
       UEqn.A()进行了A运算，返回的是A_{D}，
       因此rAU实际上是1/A_{D}。 */
    volScalarField rAU(1.0/UEqn.A());
    
    /* 创建一个定义在体中心的向量场HbyA，UEqn.H()进行了H运算返回的是A_{H}，
       因此HbyA实际上是A_{H}/A_{D}，constrainHbyA函数将U固定值边界条件赋给HbyA。 */
    volVectorField HbyA(constrainHbyA(rAU*UEqn.H(), U, p));
    
    surfaceScalarField phiHbyA    // 创建一个定义在面中心的标量场，这是一个中间通量\phi^{*}
    (          
        "phiHbyA",
        fvc::flux(HbyA)    // 将HbyA差分到面上，并点乘面矢量
      + MRF.zeroFilter(fvc::interpolate(rAU)*fvc::ddtCorr(U, phi))
    );
    
    MRF.makeRelative(phiHbyA);

    adjustPhi(phiHbyA, U, p);

    // Update the pressure BCs to ensure flux consistency
    constrainPressure(p, U, phiHbyA, rAU, MRF);    // 用于修正fixedFluxPressure类压力边界条件
    
    // Non-orthogonal pressure corrector loop
    while (piso.correctNonOrthogonal())    // 默认非正交修正为0
    {
        // Pressure corrector

        fvScalarMatrix pEqn
        (
            // 方程等号左边使用隐式离散，方程等号右边使用显式离散
            fvm::laplacian(rAU, p) == fvc::div(phiHbyA)
        );

        pEqn.setReference    // 设置压力参考值
        (
            pressureReference.refCell(),
            pressureReference.refValue()
        );

        pEqn.solve();     // 求解上述p方程，可以得到p的值

        if (piso.finalNonOrthogonalIter())    // 非正交修正的总迭代残差
        {
            /* 即 \phi = \phi^{*} - \phi^{**}，其中pEqn.flux()返回的\phi^{**}
               最终得到统一的、能够满足连续性方程的通量 */
            phi = phiHbyA - pEqn.flux();
        }
    }
    
    #include "continuityErrs.H"
    
    /* 使用修正后的压力场求解出正确的速度场，即
       \mathbf{U} = \frac{A_{H}}{A_{D}} - \frac{\nabla p}{A_{D}}
    */
    U = HbyA - rAU*fvc::grad(p);
    U.correctBoundaryConditions();
    fvConstraints.constrain(U);




rhoSimpleFoam求解器
----------------------

rhoSimpleFoam的createFields.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    Info<< "Reading thermophysical properties\n" << endl;

    autoPtr<fluidThermo> pThermo
    (
        fluidThermo::New(mesh)
    );
    fluidThermo& thermo = pThermo();
    thermo.validate(args.executable(), "h", "e");

    volScalarField& p = thermo.p();

    volScalarField rho    // 定义在网格体中心的标量场，密度场rho
    (
        IOobject
        (
            "rho",
            runTime.timeName(),           // 位于时间文件夹
            mesh,
            IOobject::READ_IF_PRESENT,    // 如果存在则读取
            IOobject::AUTO_WRITE          // 自动输出
        ),
        thermo.rho()
    );

    Info<< "Reading field U\n" << endl;
    volVectorField U    // 定义在网格体中心的矢量场，速度场U
    (
        IOobject
        (
            "U",
            runTime.timeName(),     // 位于时间文件夹
            mesh,
            IOobject::MUST_READ,    // 必须读取
            IOobject::AUTO_WRITE    // 自动输出
        ),
        mesh
    );

    #include "compressibleCreatePhi.H"

    pressureReference pressureReference
    (
        p,
        simple.dict(),
        thermo.incompressible()
    );

    mesh.schemes().setFluxRequired(p.name());

    Info<< "Creating turbulence model\n" << endl;
    autoPtr<compressible::momentumTransportModel> turbulence    // 创建湍流指针
    (
        compressible::momentumTransportModel::New
        (
            rho,
            U,
            phi,
            thermo
        )
    );

    Info<< "Creating thermophysical transport model\n" << endl;
    autoPtr<fluidThermophysicalTransportModel> thermophysicalTransport
    (
        fluidThermophysicalTransportModel::New(turbulence(), thermo)
    );

    dimensionedScalar initialMass = fvc::domainIntegrate(rho);

    #include "createMRF.H"
    #include "createFvModels.H"
    #include "createFvConstraints.H"


rhoSimpleFoam的createFieldRefs.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    const volScalarField& psi = thermo.psi();


rhoSimpleFoam.C
^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    #include "fvCFD.H"
    #include "fluidThermo.H"    // 引入热物理物料模型
    #include "compressibleMomentumTransportModels.H"    // 引入可压缩流体湍流模型
    #include "fluidThermophysicalTransportModel.H"      // 引入热物理能量模型
    #include "simpleControl.H"    // SIMPLE算法必要头文件
    #include "pressureReference.H"
    #include "fvModels.H"
    #include "fvConstraints.H"

    int main(int argc, char *argv[])
    {
        #include "postProcess.H"

        #include "setRootCaseLists.H"
        #include "createTime.H"
        #include "createMesh.H"
        #include "createControl.H"
        #include "createFields.H"         // 创建场信息与热物理模型
        #include "createFieldRefs.H"
        #include "initContinuityErrs.H"

        turbulence->validate();

        Info<< "\nStarting time loop\n" << endl;

        while (simple.loop(runTime))
        {
            Info<< "Time = " << runTime.userTimeName() << nl << endl;

            fvModels.correct();

            // Pressure-velocity SIMPLE corrector
            #include "UEqn.H"    // 求解U方程，得到速度场
            #include "EEqn.H"    // 求解能量方程
            #include "pEqn.H"    // 求解压力方程，得到压力场

            turbulence->correct();    // 更新湍流模型相关参数
            thermophysicalTransport->correct();    // 更新热物理模型相关参数

            runTime.write();

            Info<< "ExecutionTime = " << runTime.elapsedCpuTime() << " s"
                << "  ClockTime = " << runTime.elapsedClockTime() << " s"
                << nl << endl;
        }

        Info<< "End\n" << endl;

        return 0;
    }


rhoSimpleFoam的UEqn.H
^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    // Solve the Momentum equation

    MRF.correctBoundaryVelocity(U);

    tmp<fvVectorMatrix> tUEqn
    (
        fvm::div(phi, U)
      + MRF.DDt(rho, U)
      + turbulence->divDevTau(U)
     ==
        fvModels.source(rho, U)
    );
    fvVectorMatrix& UEqn = tUEqn.ref();

    UEqn.relax();

    fvConstraints.constrain(UEqn);

    solve(UEqn == -fvc::grad(p));

    fvConstraints.constrain(U);


rhoSimpleFoam的EEqn.H
^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    {
        volScalarField& he = thermo.he();

        fvScalarMatrix EEqn
        (
            fvm::div(phi, he)
          + (
                he.name() == "e"
              ? fvc::div(phi, volScalarField("Ekp", 0.5*magSqr(U) + p/rho))
              : fvc::div(phi, volScalarField("K", 0.5*magSqr(U)))
            )
          + thermophysicalTransport->divq(he)
         ==
            fvModels.source(rho, he)
        );

        EEqn.relax();

        fvConstraints.constrain(EEqn);

        EEqn.solve();

        fvConstraints.constrain(he);

        thermo.correct();
    }


rhoSimpleFoam的pEqn.H
^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    rho = thermo.rho();
    rho.relax();

    const volScalarField rAU("rAU", 1.0/UEqn.A());
    const surfaceScalarField rhorAUf("rhorAUf", fvc::interpolate(rho*rAU));

    tmp<volScalarField> rAtU
    (
        simple.consistent()
      ? volScalarField::New("rAtU", 1.0/(1.0/rAU - UEqn.H1()))
      : tmp<volScalarField>(nullptr)
    );
    tmp<surfaceScalarField> rhorAtUf
    (
        simple.consistent()
      ? surfaceScalarField::New("rhoRAtUf", fvc::interpolate(rho*rAtU()))
      : tmp<surfaceScalarField>(nullptr)
    );

    const volScalarField& rAAtU = simple.consistent() ? rAtU() : rAU;
    const surfaceScalarField& rhorAAtUf =
        simple.consistent() ? rhorAtUf() : rhorAUf;

    volVectorField HbyA(constrainHbyA(rAU*UEqn.H(), U, p));

    tUEqn.clear();

    surfaceScalarField phiHbyA
    (
        "phiHbyA",
        fvc::interpolate(rho)*fvc::flux(HbyA)
    );

    MRF.makeRelative(fvc::interpolate(rho), phiHbyA);

    bool closedVolume = false;

    // Update the pressure BCs to ensure flux consistency
    constrainPressure(p, rho, U, phiHbyA, rhorAAtUf, MRF);

    if (simple.transonic())
    {
        const surfaceScalarField phid
        (
            "phid",
            fvc::interpolate(psi)*phiHbyA/fvc::interpolate(rho)
        );

        const fvScalarMatrix divPhidp(fvm::div(phid, p));
        phiHbyA -= divPhidp.flux();

        if (simple.consistent())
        {
            phiHbyA += (rhorAAtUf - rhorAUf)*fvc::snGrad(p)*mesh.magSf();
            HbyA += (rAAtU - rAU)*fvc::grad(p);
        }

        while (simple.correctNonOrthogonal())
        {
            fvScalarMatrix pEqn
            (
                fvc::div(phiHbyA) + divPhidp
              - fvm::laplacian(rhorAAtUf, p)
              ==
                fvModels.source(psi, p, rho.name())
            );

            // Relax the pressure equation to ensure diagonal-dominance
            pEqn.relax();

            pEqn.setReference
            (
                pressureReference.refCell(),
                pressureReference.refValue()
            );

            pEqn.solve();

            if (simple.finalNonOrthogonalIter())
            {
                phi = phiHbyA + pEqn.flux();
            }
        }
    }
    else
    {
        closedVolume = adjustPhi(phiHbyA, U, p);

        if (simple.consistent())
        {
            phiHbyA += (rhorAAtUf - rhorAUf)*fvc::snGrad(p)*mesh.magSf();
            HbyA += (rAAtU - rAU)*fvc::grad(p);
        }

        while (simple.correctNonOrthogonal())
        {
            fvScalarMatrix pEqn
            (
                fvc::div(phiHbyA)
              - fvm::laplacian(rhorAAtUf, p)
              ==
                fvModels.source(psi, p, rho.name())
            );

            pEqn.setReference
            (
                pressureReference.refCell(),
                pressureReference.refValue()
            );

            pEqn.solve();

            if (simple.finalNonOrthogonalIter())
            {
                phi = phiHbyA + pEqn.flux();
            }
        }
    }

    #include "incompressible/continuityErrs.H"

    // Explicitly relax pressure for momentum corrector
    p.relax();

    U = HbyA - rAAtU*fvc::grad(p);
    U.correctBoundaryConditions();
    fvConstraints.constrain(U);

    fvConstraints.constrain(p);

    // For closed-volume cases adjust the pressure and density levels
    // to obey overall mass continuity
    if (closedVolume && !thermo.incompressible())
    {
        p += (initialMass - fvc::domainIntegrate(psi*p))
            /fvc::domainIntegrate(psi);
        p.correctBoundaryConditions();
    }

    rho = thermo.rho();
    rho.relax();



rhoCentralFoam求解器
----------------------

rhoCentralFoam的directionInterpolate.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    namespace Foam
    {

    //- Interpolate field vf according to direction dir 根据方向dir来对场vf进行插值
    template<class Type>
    tmp<GeometricField<Type, fvsPatchField, surfaceMesh>> interpolate
    (
        const GeometricField<Type, fvPatchField, volMesh>& vf,
        const surfaceScalarField& dir,
        const word& reconFieldName = word::null
    )
    {
        tmp<GeometricField<Type, fvsPatchField, surfaceMesh>> tsf
        (
            fvc::interpolate    // 将插值场的变量和方向作为自变量
            (
                vf,
                dir,
                "reconstruct("
              + (reconFieldName != word::null ? reconFieldName : vf.name())
              + ')'
            )
        );

        GeometricField<Type, fvsPatchField, surfaceMesh>& sf = tsf.ref();

        sf.rename(vf.name() + '_' + dir.name());

        return tsf;
    }

    }



rhoCentralFoam的createFields.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


.. code-block:: C

    #include "createRDeltaT.H"

    Info<< "Reading thermophysical properties\n" << endl;

    autoPtr<psiThermo> pThermo
    (
        psiThermo::New(mesh)
    );
    psiThermo& thermo = pThermo();

    volScalarField& e = thermo.he();      // 创建能量场，这里是内能场

    Info<< "Reading field U\n" << endl;
    volVectorField U    // 创建定义在网格体中心的速度场U
    (
        IOobject
        (
            "U",
            runTime.timeName(),
            mesh,
            IOobject::MUST_READ,
            IOobject::AUTO_WRITE
        ),
        mesh
    );

    volScalarField rho    // 创建定义在网格体中心的密度场rho
    (
        IOobject
        (
            "rho",
            runTime.timeName(),
            mesh,
            IOobject::NO_READ,
            IOobject::AUTO_WRITE
        ),
        thermo.rho()    // 通过热物理模型定义方式求解rho
    );

    volVectorField rhoU    // 创建定义在网格体中心的rhoU场
    (
        IOobject
        (
            "rhoU",
            runTime.timeName(),
            mesh,
            IOobject::NO_READ,
            IOobject::NO_WRITE
        ),
        rho*U    // 通过密度场与速度场直接相乘得到
    );

    volScalarField rhoE    // 创建定义在网格体中心的rhoE场，由于加上了动能这里的E表示总能量
    (
        IOobject
        (
            "rhoE",
            runTime.timeName(),
            mesh,
            IOobject::NO_READ,
            IOobject::NO_WRITE
        ),
        rho*(e + 0.5*magSqr(U))    // 计算方法为 \rho \cdot (e + \frac{1}{2}|U|^{2})
    );

    surfaceScalarField pos    // 定义在网格面中心的场pos
    (
        IOobject
        (
            "pos",
            runTime.timeName(),
            mesh
        ),
        mesh,
        dimensionedScalar(dimless, 1.0)    // 该场是一个无量纲的1.0
    );

    surfaceScalarField neg    // 定义在网格面中心的场neg
    (
        IOobject
        (
            "neg",
            runTime.timeName(),
            mesh
        ),
        mesh,
        dimensionedScalar(dimless, -1.0)    // 该场是无量纲的-1.0
    );

    surfaceScalarField phi("phi", fvc::flux(rhoU));    // 定义在网格面中心的质量通量场phi，通过 (\rho U)_{f} \cdot S_{f} 得到

    Info<< "Creating turbulence model\n" << endl;
    autoPtr<compressible::momentumTransportModel> turbulence
    (
        compressible::momentumTransportModel::New
        (
            rho,
            U,
            phi,
            thermo
        )
    );

    Info<< "Creating thermophysical transport model\n" << endl;
    autoPtr<fluidThermophysicalTransportModel> thermophysicalTransport
    (
        fluidThermophysicalTransportModel::New(turbulence(), thermo)
    );


rhoCentralFoam的createFieldRefs.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    volScalarField& p = thermo.p();             // 根据热物理模型定义的方式获取定义在网格体中心的压力场p
    const volScalarField& T = thermo.T();       // 根据热物理模型定义的方式获取定义在网格体中心的温度场T
    const volScalarField& psi = thermo.psi();   // 根据热物理模型定义的方式获取定义在网格体中心的可压缩性场psi
    const volScalarField& mu = thermo.mu();     // 根据热物理模型定义的方式获取定义在网格体中心的动力粘度场mu

    bool inviscid(true);    // 初始化inviscid为true
    if (max(mu.primitiveField()) > 0.0)    // 如果场中动力粘度最大值大于零则设置inviscid为false
    {
        inviscid = false;
    }


rhoCentralFoam的readFluxScheme.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

    word fluxScheme("Kurganov");    // 初始化fluxScheme为Kurganov
    if (mesh.schemes().dict().readIfPresent("fluxScheme", fluxScheme))    // 读取fvScheme文件中的fluxScheme字典设置
    {
        if ((fluxScheme == "Tadmor") || (fluxScheme == "Kurganov"))    // 有两种设置，分别为Tadmor和Kurganov
        {
            Info<< "fluxScheme: " << fluxScheme << endl;
        }
        else    // 其他设置都是不合法的，将报错
        {
            FatalErrorInFunction
                << "fluxScheme: " << fluxScheme
                << " is not a valid choice. "
                << "Options are: Tadmor, Kurganov"
                << abort(FatalError);
        }
    }


rhoCentralFoam的resetDeltaT.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

该文件在controlDict文件中设置为了adjustTimeStep模式时会使用到。首先定义了参数deltaT的初始化计算方式为

.. math::
    \begin{align}
    \text{deltaT} = \frac{\text{maxCo} \times \Delta t}{\text{CoNum} + \text{small}}
    \end{align}

之后根据库朗数更新deltaT的办法为

.. math::
    \begin{align}
    \text{deltaT} = \min\Big(\min(\text{deltaT}, \Delta t + 0.1\times \text{deltaT}),1.2\Delta t\Big) 
    \end{align}

.. code-block:: C

    if (adjustTimeStep)    // 如果在controlDict文件中设置为了adjustTimeStep模式
    {
        scalar deltaT = maxCo*runTime.deltaTValue()/(CoNum + small);    // 定义并初始化参数deltaT 
        deltaT = min  // 更新deltaT的值
        (
            min(deltaT, runTime.deltaTValue() + 0.1*deltaT),
            1.2*runTime.deltaTValue()
        );
        runTime.setDeltaT(min(deltaT, maxDeltaT));    // 重新设置时间步进长度为deltaT和maxDeltaT中的最小值

        Info<< "deltaT = " <<  runTime.deltaTValue() << endl;
    }


rhoCentralFoam的CentralCourantNo.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

该文件基于库朗数计算平均波速和最大波速。计算方法为

.. math::
    \begin{align}
    & \text{CoNum} = 0.5 \times \max_{\text{global}}\Big(\frac{\sum_{f}\text{amaxSf}}{V}\cdot \Delta t\Big)  \\
    & \text{meanCoNum} = 0.5 \times \Big(\frac{\sum_{\text{global}}(\sum_{f}\text{amaxSf})}{\sum_{\text{global}}V} \Big) \cdot \Delta t
    \end{align}

其中 :math:`\sum_{f}\text{amaxSf}` 表示在每个网格单元中对其各面上的amaxSf值进行求和，得到的是与网格单元数同维的标量场。

.. code-block:: C

    if (mesh.nInternalFaces())
    {
        scalarField sumAmaxSf(fvc::surfaceSum(amaxSf)().primitiveField());    // 将amaxSf按面求和得到sumAmaxSf

        CoNum = 0.5*gMax(sumAmaxSf/mesh.V().field())*runTime.deltaTValue();    // gMax表示全局最大值，涉及到并行

        meanCoNum =
            0.5*(gSum(sumAmaxSf)/gSum(mesh.V().field()))*runTime.deltaTValue();    // gSum表示全局求和，涉及到并行
    }

    Info<< "Mean and max Courant Numbers = "
        << meanCoNum << " " << CoNum << endl;



rhoCentralFoam的setRDeltaT.H
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

当使用当地局部时间步方法时会使用这个文件。

.. code-block:: C

    {
        volScalarField& rDeltaT = trDeltaT.ref();

        scalar rDeltaTSmoothingCoeff
        (
            runTime.controlDict().lookupOrDefault<scalar>
            (
                "rDeltaTSmoothingCoeff",
                0.02
            )
        );

        // Set the reciprocal time-step from the local Courant number
        rDeltaT.ref() = max
        (
            1/dimensionedScalar(dimTime, maxDeltaT),
            fvc::surfaceSum(amaxSf)()()
           /((2*maxCo)*mesh.V())
        );

        // Update the boundary values of the reciprocal time-step
        rDeltaT.correctBoundaryConditions();

        fvc::smooth(rDeltaT, rDeltaTSmoothingCoeff);

        Info<< "Flow time scale min/max = "
            << gMin(1/rDeltaT.primitiveField())
            << ", " << gMax(1/rDeltaT.primitiveField()) << endl;
    }



rhoCentralFoam.C
^^^^^^^^^^^^^^^^^^^

rhoCentralFoam求解的连续性方程为

.. math::
    \begin{align}
    \frac{\partial \rho}{\partial t} + \nabla \cdot (\rho\mathbf{U}) = 0
    \end{align}

rhoCentralFoam求解的动量方程为

.. math::
    \begin{align}
    \frac{\partial \rho\mathbf{U}}{\partial t} 
    + \nabla \cdot (\rho\mathbf{UU}) 
    + \nabla p 
    - \nabla \cdot (\mu_{\text{Eff}} \nabla \mathbf{U})
    - \nabla \cdot \Big[ \mu_{\text{Eff}} \Big( (\nabla \mathbf{U})^{T} - \frac{2}{3}(\nabla \cdot \mathbf{U})\mathbf{I} \Big) \Big]
    = 0
    \end{align}

rhoCentralFoam求解的能量方程为

.. math::
    \begin{align}
    \frac{\partial \rho(e+\frac{1}{2}|\mathbf{U}|^{2})}{\partial t} 
    + \nabla \cdot \big(\rho\mathbf{U}(e+\frac{1}{2}|\mathbf{U}|^{2})\big)
    + \nabla \cdot (p \mathbf{U})
    - \nabla \cdot (\alpha_{\text{Eff}}\nabla e) 
    - \nabla \cdot (\boldsymbol{\tau} \cdot \mathbf{U}) 
    = 0
    \end{align}


在该求解器中所采用的中心差分算法引入了许多系数，包括

.. math::
    \begin{align}
    & c = \sqrt{\frac{c_{p}}{c_{v}}\frac{1}{\psi}} \\
    & a_{p} = \max\Big( \max(\mathbf{U}_{+}\cdot \mathbf{S}_{f}  + c_{+}|\mathbf{S}_{f}|, \mathbf{U}_{-}\cdot \mathbf{S}_{f}  + c_{-}|\mathbf{S}_{f}|) , 0.0\Big)  \\
    & a_{m} = \min\Big( \min(\mathbf{U}_{+}\cdot \mathbf{S}_{f}  - c_{+}|\mathbf{S}_{f}|, \mathbf{U}_{-}\cdot \mathbf{S}_{f}  - c_{-}|\mathbf{S}_{f}|) , 0.0\Big)  \\
    & a_{+} = \frac{a_{p}}{a_{p} - a_{m}}  \\
    & a_{-} = 1.0 - a_{+}
    \end{align}

其中下标 :math:`+,-` 表示定向插值到网格面。

质量通量项的计算方法为 :code:`phi = aphiv_pos*rho_pos + aphiv_neg*rho_neg;` ，即

.. math::
    \begin{align}
    \int_{V} \nabla \cdot (\rho \mathbf{U}) ~\mathrm{d}V
    = \sum_{f}(\rho \mathbf{U})_{f}\cdot\mathbf{S}_{f} 
    = \sum_{f}\Big( \rho_{+}(\mathbf{U}_{+}\cdot \mathbf{S}_{f})a_{+} + \rho_{-}(\mathbf{U}_{-}\cdot\mathbf{S}_{f})a_{-} \Big)
    \end{align}


动量方程的中间项如下进行计算：

.. math::
    \begin{align}
    &\int_{V} \Big( \nabla \cdot (\rho\mathbf{UU}) + \nabla p \Big)~\mathrm{d}V
    = \sum_{f}(\rho\mathbf{UU})_{f} \cdot \mathbf{S}_{f} + \sum_{f}p_{f}\mathbf{S}_{f}  \\
    &= \sum_{f}\Big( 
      (\mathbf{U}_{+}\cdot\mathbf{S}_{f}a_{+} - a_{m}a_{+})(\rho\mathbf{U})_{+} 
      + (\mathbf{U}_{-}\cdot\mathbf{S}_{f}a_{-} + a_{m}a_{+})(\rho\mathbf{U})_{-}
      + (a_{+}p_{+} + a_{-}p_{-})\mathbf{S}_{f}
      \Big)
    \end{align}

.. code-block:: C

    surfaceVectorField phiUp
    (
        (aphiv_pos*rhoU_pos + aphiv_neg*rhoU_neg)
      + (a_pos*p_pos + a_neg*p_neg)*mesh.Sf()
    );


能量方程的中间项如下进行计算：

.. math::
    \begin{align}
    &\int_{V}\Big( \nabla \cdot (\rho\mathbf{U}E) + \nabla \cdot (p\mathbf{U}) \Big)~\mathrm{d}V
    = \sum_{f}(\rho\mathbf{U}E)_{f}\cdot\mathbf{S}_{f} + \sum_{f}(p\mathbf{U})_{f}\cdot\mathbf{S}_{f}  \\
    &= \sum_{f}\Big(
      (\mathbf{U}_{+}\cdot\mathbf{S}_{f}a_{+} - a_{m}a_{+})(\rho_{+}E_{+} + p_{+})
      + (\mathbf{U}_{-}\cdot\mathbf{S}_{f}a_{-} + a_{m}a_{+})(\rho_{e}E_{-} + p_{-})
      + a_{m}a_{+}p_{+} - a_{m}a_{+}p_{-}
      \Big)
    \end{align}

其中 :math:`E_{+} = e_{+} + \frac{1}{2}|\mathbf{U}_{+}|^{2}` ， :math:`E_{-} = e_{-} + \frac{1}{2}|\mathbf{U}_{-}|^{2}` 。

.. code-block:: C

    surfaceScalarField phiEp
    (
        "phiEp",
        aphiv_pos*(rho_pos*(e_pos + 0.5*magSqr(U_pos)) + p_pos)
      + aphiv_neg*(rho_neg*(e_neg + 0.5*magSqr(U_neg)) + p_neg)
      + aSf*p_pos - aSf*p_neg
    );


有效动力粘度系数利用湍流模型的有效运动粘度系数来计算，为 :code:`volScalarField muEff("muEff", rho*turbulence->nuEff());` ，即 :math:`\mu_{\text{Eff}} = \rho \nu_{\text{Eff}}` 。动量方程粘性项的一部分如此进行计算 :code:`volTensorField tauMC("tauMC", muEff*dev2(Foam::T(fvc::grad(U))));` ，即

.. math::
    \begin{align}
    \int_{V}\nabla \cdot \Big[ \mu_{\text{Eff}} \Big( (\nabla \mathbf{U})^{T} - \frac{2}{3}(\nabla \cdot \mathbf{U})\mathbf{I} \Big) \Big]~\mathrm{d}V
    = \sum_{f} \Big[ \mu_{\text{Eff}} \Big( (\nabla \mathbf{U})_{\text{fvc}}^{T} - \frac{2}{3}\operatorname{tr}\big((\nabla\mathbf{U})_{\text{fvc}}^{T}\big) \mathbf{I} \Big) \Big]_{f}
    \end{align}


现在可以求解连续性方程得到密度场：

.. math::
    \begin{align}
    \Big(\frac{\partial \rho}{\partial t}\Big)_{\text{fvm}} + \sum_{f,\text{fvc}}(\rho \mathbf{U})_{f}\cdot\mathbf{S}_{f} = 0
    \quad \Rightarrow \quad 
    \Big(\frac{\partial \rho}{\partial t}\Big)_{\text{fvm}} + \sum_{f,\text{fvc}}\Big(\rho_{+}(\mathbf{U}_{+}\cdot \mathbf{S}_{f})a_{+} + \rho_{-}(\mathbf{U}_{-}\cdot\mathbf{S}_{f})a_{-}\Big) = 0
    \end{align}

.. code-block:: C

    solve(fvm::ddt(rho) + fvc::div(phi));

在rhoCentralFoam中首先求解了一次不考虑粘性的动量方程，即

.. math::
    \begin{align}
    \Big(\frac{\partial \rho\mathbf{U}}{\partial t} \Big)_{\text{fvm}} 
    + \sum_{f,\text{fvc}}\Big( (\rho\mathbf{UU})_{f}\cdot\mathbf{S}_{f} + p_{f}\mathbf{S}_{f} \Big)
    = 0
    \quad \Rightarrow \quad 
    \end{align}

.. math::
    \begin{align}
    \Big(\frac{\partial \rho\mathbf{U}}{\partial t} \Big)_{\text{fvm}}
    + \sum_{f,\text{fvc}}\Big(
          (\mathbf{U}_{+}\cdot\mathbf{S}_{f}a_{+} - a_{m}a_{+})(\rho_{+}E_{+} + p_{+})
          + (\mathbf{U}_{-}\cdot\mathbf{S}_{f}a_{-} + a_{m}a_{+})(\rho_{e}E_{-} + p_{-})
          + a_{m}a_{+}p_{+} - a_{m}a_{+}p_{-}
          \Big)
    = 0
    \end{align}

.. code-block:: C

    solve(fvm::ddt(rhoU) + fvc::div(phiUp));

通过求解上式可以得到更新后的动量密度场 :math:`\rho\mathbf{U}` ，然后通过 :math:`\rho\mathbf{U}/\rho` 的方式得到参考速度场。接下来考虑上粘性项的影响再求解一次动量方程：

.. math::
    \begin{align}
    \Big( \frac{\partial \rho\mathbf{U}}{\partial t} \Big)_{\text{fvm}} 
    - \Big( \frac{\partial \rho\mathbf{U}}{\partial t} \Big)_{\text{fvc}}
    - \sum_{f,\text{fvm}}\Big( \mu_{\text{Eff}} \nabla\mathbf{U} \Big)_{f}
    - \sum_{f,\text{fvc}}\Big[ \mu_{\text{Eff}} \Big( (\nabla \mathbf{U})_{\text{fvc}}^{T} - \frac{2}{3}\operatorname{tr}\big((\nabla\mathbf{U})_{\text{fvc}}^{T}\big) \mathbf{I} \Big) \Big]_{f}
    = 0
    \end{align}

.. code-block:: C

    if (!inviscid)
    {
        solve
        (
            fvm::ddt(rho, U) - fvc::ddt(rho, U)
          - fvm::laplacian(muEff, U)
          - fvc::div(tauMC)
        );
        rhoU = rho*U;
    }

如此就能得到求解出的速度场 :math:`\mathbf{U}` ，利用它更新一次动量密度场 :math:`\rho\mathbf{U}` 。


能量场中的应力张量做功项如下进行计算：

.. math::
    \begin{align}
    \int_{V} \nabla \cdot (\boldsymbol{\tau} \cdot \mathbf{U}) ~\mathrm{d}V
    = \sum_{f}\Big( (\mu_{\text{Eff}})_{f,\text{fvc}}|\mathbf{S}_{f}| (\nabla\mathbf{U})_{\text{fvc}} + \Big[ \mu_{\text{Eff}} \Big( (\nabla \mathbf{U})_{\text{fvc}}^{T} - \frac{2}{3}\operatorname{tr}\big((\nabla\mathbf{U})_{\text{fvc}}^{T}\big) \mathbf{I} \Big) \Big]_{f} \cdot \mathbf{S}_{f} \Big)
      \cdot (a_{+}\mathbf{U}_{+} + a_{-}\mathbf{U}_{-})
    \end{align}

.. code-block:: C

    surfaceScalarField sigmaDotU
    (
        "sigmaDotU",
        (
            fvc::interpolate(muEff)*mesh.magSf()*fvc::snGrad(U)
          + fvc::dotInterpolate(mesh.Sf(), tauMC)
        )
        & (a_pos*U_pos + a_neg*U_neg)
    );

于是能量方程可以进行求解：

.. math::
    \begin{align}
    \Big(\frac{\partial \rho E}{\partial t} \Big)_{\text{fvm}}
    + \sum_{f,\text{fvc}}\Big( (\rho\mathbf{U}E)_{f}\cdot\mathbf{S}_{f} + (p\mathbf{U})_{f}\cdot\mathbf{S}_{f} \Big)
    - \sum_{f,\text{fvc}}\Big( \boldsymbol{\tau} \cdot \mathbf{U} \Big)_{f}
    = 0
    \quad \Rightarrow \quad 
    \end{align}

.. math::
    \begin{align}
    \Big(\frac{\partial \rho E}{\partial t} \Big)_{\text{fvm}}
    &+ \sum_{f,\text{fvc}}\Big(
          (\mathbf{U}_{+}\cdot\mathbf{S}_{f}a_{+} - a_{m}a_{+})(\rho_{+}E_{+} + p_{+})
          + (\mathbf{U}_{-}\cdot\mathbf{S}_{f}a_{-} + a_{m}a_{+})(\rho_{e}E_{-} + p_{-})
          + a_{m}a_{+}p_{+} - a_{m}a_{+}p_{-}
          \Big)  \\
    &- \sum_{f,\text{fvc}}\Big( (\mu_{\text{Eff}})_{f,\text{fvc}}|\mathbf{S}_{f}| (\nabla\mathbf{U})_{\text{fvc}} + \Big[ \mu_{\text{Eff}} \Big( (\nabla \mathbf{U})_{\text{fvc}}^{T} - \frac{2}{3}\operatorname{tr}\big((\nabla\mathbf{U})_{\text{fvc}}^{T}\big) \mathbf{I} \Big) \Big]_{f} \cdot \mathbf{S}_{f} \Big)
          \cdot (a_{+}\mathbf{U}_{+} + a_{-}\mathbf{U}_{-})
    = 0
    \end{align}

.. code-block:: C

    solve    // 求解能量方程，得到rhoE
    (
        fvm::ddt(rhoE)
      + fvc::div(phiEp)
      - fvc::div(sigmaDotU)
    );

由此计算得到 :math:`\rho E` 后据此更新内能场 :math:`e = \rho E / \rho - \frac{1}{2}|\mathbf{U}|^{2}` 。

但是上式没有考虑热通量项，对于有粘场则还会再求解一次考虑了热通量贡献的能量方程：

.. math::
    \begin{align}
    \Big(\frac{\partial \rho e}{\partial t} \Big)_{\text{fvm}} 
    - \Big( \frac{\partial \rho e}{\partial t} \Big)_{\text{fvc}}
    - \sum_{f,\text{fvc}} \Big( \alpha_{\text{Eff}} \nabla e \Big)_{f}
    = 0
    \end{align}

.. code-block:: C

    if (!inviscid)
    {
        solve
        (
            fvm::ddt(rho, e) - fvc::ddt(rho, e)
          + thermophysicalTransport->divq(e)
        );
        thermo.correct();
        rhoE = rho*(e + 0.5*magSqr(U));
    }

由此求解出新的内能场 :math:`e` ，据此更新 :math:`\rho E = \rho (e + \frac{1}{2}|\mathbf{U}|^{2})` 的值。

最后通过密度场和可压缩性场求解出压力场 :code:`p.ref() = rho()/psi();` ，即 :math:`p = \frac{\rho}{\psi}` 就完成了本次时间步的内容，开始下一个时间步的循环。



.. code-block:: C

    #include "fvCFD.H"
    #include "psiThermo.H"
    #include "compressibleMomentumTransportModels.H"
    #include "fluidThermophysicalTransportModel.H"
    #include "fixedRhoFvPatchScalarField.H"
    #include "directionInterpolate.H"
    #include "localEulerDdtScheme.H"
    #include "fvcSmooth.H"

    int main(int argc, char *argv[])
    {
        #define NO_CONTROL
        #include "postProcess.H"

        #include "setRootCaseLists.H"
        #include "createTime.H"
        #include "createMesh.H"
        #include "createFields.H"
        #include "createFieldRefs.H"
        #include "createTimeControls.H"

        turbulence->validate();

        #include "readFluxScheme.H"

        dimensionedScalar v_zero("v_zero", dimVolume/dimTime, 0.0);    // 定义一个有量纲标量场v_zero，值为0.0，量纲为 m^{3}/t

        // Courant numbers used to adjust the time-step
        scalar CoNum = 0.0;        // 初始化参数CoNum为0.0
        scalar meanCoNum = 0.0;    // 初始化参数meanCoNum为0.0

        Info<< "\nStarting time loop\n" << endl;

        while (runTime.run())    // 开始时间步迭代步进
        {
            #include "readTimeControls.H"

            if (!LTS)    // 如果不采用当地时间步方法
            {
                #include "setDeltaT.H"    // 关于adjustTimeStep模式

                // Update the mesh for topology change, mesh to mesh mapping
                mesh.update();

                runTime++;

                // Move the mesh
                mesh.move();
            }

            // --- Directed interpolation of primitive fields onto faces 将原始场定向插值到面上

            surfaceScalarField rho_pos(interpolate(rho, pos));    // 密度场正向插值得到rho_pos
            surfaceScalarField rho_neg(interpolate(rho, neg));    // 密度场反向插值得到rho_neg

            surfaceVectorField rhoU_pos(interpolate(rhoU, pos, U.name()));    // rhoU场正向插值得到rhoU_pos
            surfaceVectorField rhoU_neg(interpolate(rhoU, neg, U.name()));    // rhoU场反向插值得到rhoU_neg

            volScalarField rPsi("rPsi", 1.0/psi);    // 创建一个定义在网格体中心的标量场rPsi，它是可压缩性场的倒数
            surfaceScalarField rPsi_pos(interpolate(rPsi, pos, T.name()));    // rPsi场正向插值得到rPsi_pos
            surfaceScalarField rPsi_neg(interpolate(rPsi, neg, T.name()));    // rPsi场反向插值得到rPsi_neg

            surfaceScalarField e_pos(interpolate(e, pos, T.name()));    // 能量场正向插值得到e_pos
            surfaceScalarField e_neg(interpolate(e, neg, T.name()));    // 能量场反向插值得到e_neg

            surfaceVectorField U_pos("U_pos", rhoU_pos/rho_pos);    // 速度场正向插值通过计算得到，即 U_{+} = \frac{(\rho U)_{+}}{\rho_{+}}
            surfaceVectorField U_neg("U_neg", rhoU_neg/rho_neg);    // 速度场反向插值通过计算得到，即 U_{-} = \frac{(\rho U)_{-}}{\rho_{-}}

            surfaceScalarField p_pos("p_pos", rho_pos*rPsi_pos);    // 压力场正向插值通过计算得到，即 p_{+} = \rho_{+} \cdot (\frac{1}{\psi})_{+}
            surfaceScalarField p_neg("p_neg", rho_neg*rPsi_neg);    // 压力场反向插值通过计算得到，即 p_{-} = \rho_{-} \cdot (\frac{1}{\psi})_{-}

            surfaceScalarField phiv_pos("phiv_pos", U_pos & mesh.Sf());    // 定义正向插值速度通量为 phiv_{+} = U_{+} \cdot S_{f}
            surfaceScalarField phiv_neg("phiv_neg", U_neg & mesh.Sf());    // 定义反向插值速度通量为 phiv_{-} = U_{-} \cdot S_{f}

            // Make fluxes relative to mesh-motion
            if (mesh.moving())    // 如果是动网格系统
            {
                phiv_pos -= mesh.phi();
                phiv_neg -= mesh.phi();
            }

            volScalarField c("c", sqrt(thermo.Cp()/thermo.Cv()*rPsi));    // 定义在网格体中心的标量场c，为 \sqrt{\frac{c_{p}}{c_{v}} \cdot \frac{1}{\psi}}
            surfaceScalarField cSf_pos    // 定义cSf的正向插值
            (
                "cSf_pos",
                interpolate(c, pos, T.name())*mesh.magSf()    // 通过 c_{+} \cdot |S_{f}| 计算
            );
            surfaceScalarField cSf_neg    // 定义cSf的反向插值
            (
                "cSf_neg",
                interpolate(c, neg, T.name())*mesh.magSf()    // 通过 c_{-} \cdot |S_{f}| 计算
            );

            surfaceScalarField ap
            (
                "ap",
                max(max(phiv_pos + cSf_pos, phiv_neg + cSf_neg), v_zero)
            );
            surfaceScalarField am
            (
                "am",
                min(min(phiv_pos - cSf_pos, phiv_neg - cSf_neg), v_zero)
            );

            surfaceScalarField a_pos("a_pos", ap/(ap - am));

            surfaceScalarField amaxSf("amaxSf", max(mag(am), mag(ap)));

            surfaceScalarField aSf("aSf", am*a_pos);

            if (fluxScheme == "Tadmor")    // 如果通量计算方法选择为Tadmor，则aSf和a_pos的值将有所不同
            {
                aSf = -0.5*amaxSf;
                a_pos = 0.5;
            }

            surfaceScalarField a_neg("a_neg", 1.0 - a_pos);

            phiv_pos *= a_pos;
            phiv_neg *= a_neg;

            surfaceScalarField aphiv_pos("aphiv_pos", phiv_pos - aSf);
            surfaceScalarField aphiv_neg("aphiv_neg", phiv_neg + aSf);

            // Reuse amaxSf for the maximum positive and negative fluxes
            // estimated by the central scheme
            amaxSf = max(mag(aphiv_pos), mag(aphiv_neg));

            #include "centralCourantNo.H"    // 计算库朗数

            if (LTS)    // 如果使用当地局部时间步方法
            {
                #include "setRDeltaT.H"
                runTime++;
            }

            Info<< "Time = " << runTime.userTimeName() << nl << endl;

            phi = aphiv_pos*rho_pos + aphiv_neg*rho_neg;    // 计算质量通量

            surfaceVectorField phiUp    // 定义在网格面中心的矢量场phiUp
            (
                (aphiv_pos*rhoU_pos + aphiv_neg*rhoU_neg)
              + (a_pos*p_pos + a_neg*p_neg)*mesh.Sf()
            );

            surfaceScalarField phiEp    // 定义在网格面中心的标量场phiEp
            (
                "phiEp",
                aphiv_pos*(rho_pos*(e_pos + 0.5*magSqr(U_pos)) + p_pos)
              + aphiv_neg*(rho_neg*(e_neg + 0.5*magSqr(U_neg)) + p_neg)
              + aSf*p_pos - aSf*p_neg
            );

            // Make flux for pressure-work absolute
            if (mesh.moving())    // 如果是动网格系统还需要对phiEp进行修正
            {
                phiEp += mesh.phi()*(a_pos*p_pos + a_neg*p_neg);
            }

            volScalarField muEff("muEff", rho*turbulence->nuEff());    // 定义在网格体中心的标量场muEff有效动力粘度场，通过密度乘以有效运动粘度场得到
            volTensorField tauMC("tauMC", muEff*dev2(Foam::T(fvc::grad(U))));    // 定义在网格体中心的张量场tauMC

            // --- Solve density
            solve(fvm::ddt(rho) + fvc::div(phi));    // 通过连续性方程求解密度场

            // --- Solve momentum
            solve(fvm::ddt(rhoU) + fvc::div(phiUp));    // 通过动量方程求解rhoU，此时还没有考虑粘性

            U.ref() = rhoU()/rho();    // 通过求解得到的rhoU和rho相除得到速度场参考值
            U.correctBoundaryConditions();
            rhoU.boundaryFieldRef() == rho.boundaryField()*U.boundaryField();

            if (!inviscid)    // 如果是有粘场，即具有动力粘度
            {
                solve    // 求解含有粘性项的动量方程
                (
                    fvm::ddt(rho, U) - fvc::ddt(rho, U)
                  - fvm::laplacian(muEff, U)
                  - fvc::div(tauMC)
                );
                rhoU = rho*U;    // 更新rhoU场的值
            }

            // --- Solve energy
            surfaceScalarField sigmaDotU    // 应力张量做功项
            (
                "sigmaDotU",
                (
                    fvc::interpolate(muEff)*mesh.magSf()*fvc::snGrad(U)
                  + fvc::dotInterpolate(mesh.Sf(), tauMC)
                )
              & (a_pos*U_pos + a_neg*U_neg)
            );

            solve    // 求解能量方程，得到rhoE
            (
                fvm::ddt(rhoE)
              + fvc::div(phiEp)
              - fvc::div(sigmaDotU)
            );

            e = rhoE/rho - 0.5*magSqr(U);    // 通过上面得到的rhoE更新内能场e的值，采用总能量减去动能的方式计算
            e.correctBoundaryConditions();
            thermo.correct();    // 更新热物理模型中相关的参数
            rhoE.boundaryFieldRef() ==
                rho.boundaryField()*
                (
                    e.boundaryField() + 0.5*magSqr(U.boundaryField())
                );

            if (!inviscid)    // 如果是有粘场，即具有动力粘度
            {
                solve    // 求解带有湍流粘度项的能量方程，得到能量场e
                (
                    fvm::ddt(rho, e) - fvc::ddt(rho, e)
                  + thermophysicalTransport->divq(e)    // 表示的是热通量项
                );
                thermo.correct();    // 更新热物理模型中相关的参数
                rhoE = rho*(e + 0.5*magSqr(U));    // 通过新计算得到的e更新rhoE的值
            }

            p.ref() = rho()/psi();    // 通过求解得到的密度场rho和可压缩性场psi相除得到压力场p
            p.correctBoundaryConditions();
            rho.boundaryFieldRef() == psi.boundaryField()*p.boundaryField();

            turbulence->correct();    // 更新湍流模型相关参数
            thermophysicalTransport->correct();    // 更新热物理模型相关参数

            runTime.write();

            Info<< "ExecutionTime = " << runTime.elapsedCpuTime() << " s"
                << "  ClockTime = " << runTime.elapsedClockTime() << " s"
                << nl << endl;
        }

        Info<< "End\n" << endl;

        return 0;
    }





interFoam求解器
-----------------

interFoam涉及的控制方程有：

.. math::
    \begin{align}
    \nabla \cdot \mathbf{U} = 0
    \end{align}

.. math::
    \begin{align}
      \frac{\partial \rho\mathbf{U}}{\partial t}
      + \nabla \cdot (\rho\mathbf{U})\mathbf{U}
      - \nabla \cdot [ \mu (\nabla\mathbf{U}) ]
    = - \nabla p
      -  (\mathbf{g} \cdot \mathbf{x})\nabla\rho
      + \sigma_{T}\kappa_{\alpha}\nabla\alpha 
    \end{align}

.. math::
    \begin{align}
      \frac{\partial \alpha }{\partial t}
      + \nabla \cdot \mathbf{U}\alpha 
    = 0 
    \end{align}

.. math::
    \begin{align}
    & \rho = \alpha \rho_{1} + (1 - \alpha )\rho_{2}  \\
    & \mu = \alpha \mu_{1} + (1 - \alpha )\mu_{2}
    \end{align}

两相流系统被当成一个混合系统，它的密度场和粘度系数场都不再是常数，两相交界面也必须足够尖锐与足够大才能通过网格捕捉到，同时假设了两相交界面处速度场是连续的。可以看到，方程中考虑了重力场和表面张力的作用。

实际上，上面给出的第二个方程与平常看到的有所不同。一般看到的形式为

.. math::
    \begin{align}
      \frac{\partial \rho\mathbf{U}}{\partial t}
      + \nabla \cdot (\rho\mathbf{U})\mathbf{U}
      - \nabla \cdot [ \mu (\nabla\mathbf{U}) ]
    = - \nabla P
      + \rho\mathbf{g}
      + \sigma_{T}\kappa_{\alpha}\nabla\alpha 
    \end{align}

其中 :math:`P` 是总压(total pressure)，而在OpenFOAM中采用的压强 :math:`p` 表示为总压减去液体静压：

.. math::
    \begin{align}
    p = P - \rho \mathbf{g}\cdot\mathbf{x}
    \end{align}

使用动压 :math:`p` 的表达形式改写上面的方程：

.. math::
    \begin{align}
    - \nabla P = - \nabla p - \nabla [\rho(\mathbf{g}\cdot\mathbf{x})]
               = - \nabla p - (\mathbf{g}\cdot\mathbf{x})\nabla \rho - \rho \nabla (\mathbf{g}\cdot\mathbf{x})
    \end{align}

.. math::
    \begin{align}
    \nabla (\mathbf{g}\cdot\mathbf{x}) 
    = \mathbf{g} \times (\nabla \times \mathbf{x})
      + \mathbf{x} \times (\nabla \times \mathbf{g})
      + (\mathbf{g} \cdot \nabla )\mathbf{x}
      + (\mathbf{x} \cdot \nabla )\mathbf{g}  
    \end{align}

根据 :math:`\mathbf{g} \times (\nabla \times \mathbf{x})=0` ， :math:`\mathbf{x} \times (\nabla \times \mathbf{g})=0` ， :math:`(\mathbf{g} \cdot \nabla )\mathbf{x}=\mathbf{g}` ， :math:`(\mathbf{x} \cdot \nabla )\mathbf{g}=0` 可知 :math:`\nabla (\mathbf{g}\cdot\mathbf{x}) = \mathbf{g}` ，从而

.. math::
    \begin{align}
    -\nabla P = -\nabla p - \nabla [\rho(\mathbf{g}\cdot \mathbf{x})]
              = -\nabla p - (\mathbf{g}\cdot \mathbf{x}) \nabla \rho - \rho\mathbf{g}
    \end{align}

最终就得到了OpenFOAM中所采用的方程形式。

.. note:: 正因为使用了 :math:`\nabla \rho` 的形式来描述重力项，在遇到水气界面等密度剧烈变化的情况时，会产生非常明显的数值耗散和误差。除此之外，在表面张力项，由于曲率 :math:`\kappa_{\alpha}` 的评估有时会有较大的误差，从而导致有时会在周边产生额外的速度场来平衡表面曲率误差。


interFoam求解器求解的步骤可以概括为：

1. 求解输运方程得到体积相分数 :math:`\alpha` ，不过在实现的时候方程额外添加了一项，修改成了
   
.. math::
    \begin{align}
      \frac{\partial \alpha }{\partial t}
    + \nabla \cdot \mathbf{U}\alpha 
    + \nabla \cdot (\mathbf{U}_{r}\alpha (1-\alpha ) )
    = 0  
    \end{align}

2. 修正流体和界面的参数，即计算 :math:`\rho` 和 :math:`\mu` 。
3. 使用PISO算法求解速度场和压力场，但与icoFoam不同的是添加了体积力。
   





interFoam.C
^^^^^^^^^^^^^^^^

.. code-block:: C

    #include "fvCFD.H"
    #include "interfaceCompression.H"
    #include "CMULES.H"                    // MULS算法
    #include "EulerDdtScheme.H"            // 欧拉离散格式
    #include "localEulerDdtScheme.H"       // 局部欧拉离散格式
    #include "CrankNicolsonDdtScheme.H"    // CrankNicolson离散格式
    #include "subCycle.H"                  // 亚循环。由于alpha是显式离散的，为了减少计算时间而引入
    #include "immiscibleIncompressibleTwoPhaseMixture.H"    // 物理模型
    #include "noPhaseChange.H"
    #include "incompressibleInterPhaseTransportModel.H"     // 湍流头文件
    #include "pimpleControl.H"
    #include "pressureReference.H"
    #include "fvModels.H"
    #include "fvConstraints.H"
    #include "CorrectPhi.H"          // 动量修正
    #include "fvcSmooth.H"


    int main(int argc, char *argv[])
    {
        #include "postProcess.H"

        #include "setRootCaseLists.H"
        #include "createTime.H"
        #include "createMesh.H"
        #include "initContinuityErrs.H"
        #include "createDyMControls.H"
        #include "createFields.H"
        #include "createFieldRefs.H"
        #include "initCorrectPhi.H"
        #include "createUfIfPresent.H"

        if (!LTS)    // 如果不采用局部欧拉格式
        {
            #include "CourantNo.H"           // 读取库朗数
            #include "setInitialDeltaT.H"    // 设置初始的DeltaT
        }

        Info<< "\nStarting time loop\n" << endl;

        while (pimple.run(runTime))
        {
            #include "readDyMControls.H"

            if (LTS)    // 如果使用局部欧拉格式
            {
                #include "setRDeltaT.H"
            }
            else        // 如果不使用局部欧拉格式
            {
                #include "CourantNo.H"
                #include "alphaCourantNo.H"
                #include "setDeltaT.H"
            }

            fvModels.preUpdateMesh();

            // Store divU from the previous mesh so that it can be mapped
            // and used in correctPhi to ensure the corrected phi has the
            // same divergence
            tmp<volScalarField> divU;

            if
            (
                correctPhi
             && !isType<twoPhaseChangeModels::noPhaseChange>(phaseChange)
             && mesh.topoChanged()
            )
            {
                // Construct and register divU for correctPhi
                divU = new volScalarField
                (
                    "divU0",
                    fvc::div(fvc::absolute(phi, U))
                );
            }

            // Update the mesh for topology change, mesh to mesh mapping
            bool topoChanged = mesh.update();

            // Do not apply previous time-step mesh compression flux
            // if the mesh topology changed
            if (topoChanged)
            {
                talphaPhi1Corr0.clear();
            }

            runTime++;

            Info<< "Time = " << runTime.userTimeName() << nl << endl;

            // --- Pressure-velocity PIMPLE corrector loop
            while (pimple.loop())
            {
                if (pimple.firstPimpleIter() || moveMeshOuterCorrectors)
                {
                    if
                    (
                        correctPhi
                     && !isType<twoPhaseChangeModels::noPhaseChange>(phaseChange)
                     && !divU.valid()
                    )
                    {
                        // Construct and register divU for correctPhi
                        divU = new volScalarField
                        (
                            "divU0",
                            fvc::div(fvc::absolute(phi, U))
                        );
                    }

                    // Move the mesh
                    mesh.move();

                    if (mesh.changing())
                    {
                        gh = (g & mesh.C()) - ghRef;
                        ghf = (g & mesh.Cf()) - ghRef;

                        MRF.update();

                        if (correctPhi)
                        {
                            #include "correctPhi.H"
                        }

                        mixture.correct();

                        if (checkMeshCourantNo)
                        {
                            #include "meshCourantNo.H"
                        }
                    }

                    divU.clear();
                }

                fvModels.correct();

                surfaceScalarField rhoPhi
                (
                    IOobject
                    (
                        "rhoPhi",
                        runTime.timeName(),
                        mesh
                    ),
                    mesh,
                    dimensionedScalar(dimMass/dimTime, 0)
                );

                #include "alphaControls.H"
                #include "alphaEqnSubCycle.H"    // 求解alpha

                turbulence.correctPhasePhi();

                mixture.correct();

                #include "UEqn.H"    // 求解U

                // --- Pressure corrector loop
                while (pimple.correct())
                {
                    #include "pEqn.H"    // 求解p
                }

                if (pimple.turbCorr())
                {
                    turbulence.correct();
                }
            }

            runTime.write();

            Info<< "ExecutionTime = " << runTime.elapsedCpuTime() << " s"
                << "  ClockTime = " << runTime.elapsedClockTime() << " s"
                << nl << endl;
        }

        Info<< "End\n" << endl;

        return 0;
    }


interFoam的UEqn.H
^^^^^^^^^^^^^^^^^^^

动量预测步中，考虑线性方程组：

.. math::
    \begin{align}
    A := \frac{\partial \rho[\mathbf{U}]}{\partial t} 
         + \nabla \cdot (\phi [\mathbf{U}]_{f})
         - \nabla \cdot (\mu \nabla [\mathbf{U}])
    \end{align}

于是动量方程可以离散成

.. math::
    \begin{align}
    A_{D}\mathbf{U} = A_{H} + \text{reconstruct}\bigg [ |\mathbf{S}_{f}| \Big( (\sigma_{T}\kappa_{\alpha })_{f}\nabla _{f}^{\perp}\alpha -(\mathbf{g}\cdot\mathbf{x})_{f}\nabla _{f}^{\perp}\rho -\nabla _{f}^{\perp}\rho  \Big) \bigg ]   
    \end{align}

可以看到，为了避免两相密度差距大造成速度场的奇怪振荡，使用了reconstruct操作。这个操作显式地通过面通量 :math:`a_{f}` 建立了网格面中心的场 :math:`\mathbf{a}` ，具体计算方法为

.. math::
    \begin{align}
    \mathbf{a} = \left ( \sum_{f}\mathbf{n}_{f} \otimes \mathbf{S}_{f} \right )^{-1}\cdot \left ( \sum_{f}\mathbf{n}_{f}(\mathbf{S}_{f}\cdot \mathbf{a}_{f} ) \right ) 
    \end{align}

其中 :math:`\mathbf{n}_{f}` 是网格面的单位矢量， :math:`\otimes` 表示外积。

上面的式子是基于这样的假设：

.. math::
    \begin{align}
    \sum_{f}\mathbf{n}_{f}(\mathbf{S}_{f}\cdot\mathbf{a})
    =  \sum_{f}\mathbf{n}_{f}(\mathbf{S}_{f}\cdot\mathbf{a}_{f})
    \end{align}

结合关系 :math:`\mathbf{n}_{f}(\mathbf{S}_{f}\cdot\mathbf{a}) = (\mathbf{n}_{f}\otimes\mathbf{S}_{f})\cdot\mathbf{a}` ，从而上面这个方程可以写成

.. math::
    \begin{align}
    \sum_{f}(\mathbf{n}_{f}\otimes\mathbf{S}_{f})\cdot\mathbf{a}
    =  \sum_{f}\mathbf{n}_{f}(\mathbf{S}_{f}\cdot\mathbf{a}_{f})
    \end{align}

根据外积与内积的性质，可以将求和符号放到括号内部：

.. math::
    \begin{align}
    \sum_{f}\big( (\mathbf{n}_{f} \otimes \mathbf{S}_{f})\cdot \mathbf{a} \big)
    = \left ( \sum_{f}(\mathbf{n}_{f} \otimes \mathbf{S}_{f}) \right ) \cdot \mathbf{a} 
    \end{align}

求逆矩阵移项就得到了 :math:`\mathbf{a}` 的表达式。


.. code-block:: C

    MRF.correctBoundaryVelocity(U);

    fvVectorMatrix UEqn
    (
        fvm::ddt(rho, U) + fvm::div(rhoPhi, U)
      + MRF.DDt(rho, U)
      + turbulence.divDevTau(rho, U)
     ==
       phaseChange.SU(rho, rhoPhi, U)
     + fvModels.source(rho, U)
    );

    UEqn.relax();

    fvConstraints.constrain(UEqn);

    if (pimple.momentumPredictor())
    {
        solve
        (
            UEqn
         ==
            fvc::reconstruct
            (
                (
                    mixture.surfaceTensionForce()    // 表面张力项
                  - ghf*fvc::snGrad(rho)             // 重力项
                  - fvc::snGrad(p_rgh)               // 压强梯度项
                ) * mesh.magSf()                     // 面矢量绝对值
            )
        );

        fvConstraints.constrain(U);
    }



interFoam的pEqn.H
^^^^^^^^^^^^^^^^^^^^

压力方程离散成了

.. math::
    \begin{align}
    \nabla \cdot \left ( \frac{1}{A_{D}} \big(\nabla p + (\mathbf{g}\cdot\mathbf{x})\nabla \rho - \sigma_{T}\kappa_{\alpha}\nabla \alpha \big)\right ) 
    = \nabla \cdot \left ( \frac{A_{H}}{A_{D}} \right )
    \end{align}

在求解动量方程时先不考虑压强的贡献得到通量：

.. math::
    \begin{align}
    \phi^{*} = \left ( \frac{A_{H}}{A_{D}}\right )_{f}\cdot \mathbf{S}_{f}
    + \phi_{g}
    + \phi_{e}
    \end{align}

.. math::
    \begin{align}
    \phi_{g}=\left ( \frac{1}{A_{D}}\right )_{f}|\mathbf{S}_{f}| \bigg( (\sigma _{T}\kappa_{\alpha})_{f} \nabla _{f}^{\perp}\alpha - (\mathbf{g}\cdot\mathbf{x})_{f}\nabla_{f}^{\perp}\rho \bigg)
    \end{align}

.. math::
    \begin{align}
    \phi_{e} = \frac{\gamma \rho}{A_{D}\Delta t}(\phi_{o}-\mathbf{S}_{f}\cdot\mathbf{U}_{f,o} ) 
    \end{align}

.. math::
    \begin{align}
    \gamma = 1 - \min\left ( \frac{|\phi_{o}-\mathbf{U}_{f,o}\cdot\mathbf{S}_{f}|}{|\phi_{o}|+\varepsilon } ,1 \right ) 
    \end{align}

此时的 :math:`\phi^{*}` 还不满足连续性方程，接下来需要进行压力修正，也就需要求解压力方程：

.. math::
    \begin{align}
    \nabla \cdot \left ( \frac{\nabla [p]}{A_{D}}\right ) 
    = \nabla \cdot \left ( \frac{A_{H}}{A_{D}} - (\mathbf{g} \cdot \mathbf{x})\nabla \rho +\sigma_{T}\kappa_{\alpha}\nabla \alpha  \right ) 
    \end{align}

于是可以修正通量为 :math:`\phi=\phi^{*}+\phi^{**}` ，其中

.. math::
    \begin{align}
    \phi^{**}=-|\mathbf{S}_{f}|\cdot \bigg( \big( \frac{1}{A_{D}}\big)_{f}\nabla _{f}^{\perp}p \bigg)
    \end{align}



.. note:: 

    - 使用 :code:`rAU` 表示 :math:`\frac{1}{A_{D}}` ；
    - 使用 :code:`rAUf` 表示 :math:`\left ( \frac{1}{A_{D}}\right )_{f}` ；
    - 使用 :code:`HbyA` 表示 :math:`\frac{A_{H}}{A_{D}}` ；
    - 使用 :code:`phiHbyA` 表示 :math:`\left ( \frac{A_{H}}{A_{D}}\right )_{f}\cdot \mathbf{S}_{f} + \phi_{e}` ；
    - 使用 :code:`phig` 表示 :math:`\phi_{g}` ；
    - 使用 :code:`p_rghEqn` 表示 :math:`\nabla \cdot \left ( \frac{A_{H}}{A_{D}} - (\mathbf{g} \cdot \mathbf{x})\nabla \rho +\sigma_{T}\kappa_{\alpha}\nabla \alpha  \right ) - \nabla \cdot \left ( \frac{\nabla [p]}{A_{D}}\right ) = S_{p}` ，注意这里添加了额外项 :code:`Sp_rgh` ；
    - 使用 :code:`p_rghEqn.flux()` 表示 :math:`\phi^{**}` ；




.. code-block:: C

    {
        if (rAU.valid())
        {
            rAU.ref() = 1.0/UEqn.A();
        }
        else
        {
            rAU = 1.0/UEqn.A();
        }

        surfaceScalarField rAUf("rAUf", fvc::interpolate(rAU()));
        volVectorField HbyA(constrainHbyA(rAU()*UEqn.H(), U, p_rgh));
        surfaceScalarField phiHbyA
        (
            "phiHbyA",
            fvc::flux(HbyA)    // phi^{*}的第一项
          + MRF.zeroFilter(fvc::interpolate(rho*rAU())*fvc::ddtCorr(U, phi, Uf))    // 表示的是\phi_{e}
        );
        MRF.makeRelative(phiHbyA);

        if (p_rgh.needReference())
        {
            fvc::makeRelative(phiHbyA, U);
            adjustPhi(phiHbyA, U, p_rgh);
            fvc::makeAbsolute(phiHbyA, U);
        }

        surfaceScalarField phig
        (
            (
                mixture.surfaceTensionForce()
              - ghf*fvc::snGrad(rho)
            )*rAUf*mesh.magSf()
        );

        phiHbyA += phig;    // 此时phiHbyA就表示成了完整的phi^{*}

        // Update the pressure BCs to ensure flux consistency
        constrainPressure(p_rgh, U, phiHbyA, rAUf, MRF);

        // Cache the phase change pressure source
        fvScalarMatrix Sp_rgh(phaseChange.Sp_rgh(rho, gh, p_rgh));

        while (pimple.correctNonOrthogonal())
        {
            fvScalarMatrix p_rghEqn    // 构建压力方程
            (
                fvc::div(phiHbyA) - fvm::laplacian(rAUf, p_rgh)
             == Sp_rgh
            );

            p_rghEqn.setReference
            (
                pressureReference.refCell(),
                getRefCellValue(p_rgh, pressureReference.refCell())
            );

            p_rghEqn.solve();    // 求解出压力p_rgh

            if (pimple.finalNonOrthogonalIter())
            {
                phi = phiHbyA + p_rghEqn.flux();    // 得到最终修正后的满足连续性方程的通量

                p_rgh.relax();

                U = HbyA + rAU()*fvc::reconstruct((phig + p_rghEqn.flux())/rAUf);    // 求解最终的速度场
                U.correctBoundaryConditions();
                fvConstraints.constrain(U);
            }
        }

        #include "continuityErrs.H"

        // Correct Uf if the mesh is moving
        fvc::correctUf(Uf, U, phi, MRF);

        // Make the fluxes relative to the mesh motion
        fvc::makeRelative(phi, U);

        p == p_rgh + rho*gh;

        if (p_rgh.needReference())
        {
            p += dimensionedScalar
            (
                "p",
                p.dimensions(),
                pressureReference.refValue()
              - getRefCellValue(p, pressureReference.refCell())
            );
            p_rgh = p - rho*gh;
        }

        if (!correctPhi)
        {
            rAU.clear();
        }
    }





自定义求解器
=================


passiveScalarFoam
-------------------

该求解器基于icoFoam进行修改。icoFoam求解器涉及的控制方程如下：

.. math::
    \begin{align}
    \nabla \cdot \mathbf{U} = 0
    \end{align}

.. math::
    \begin{align}
    \frac{\partial \mathbf{U}}{\partial t}
    + \nabla \mathbf{U}\mathbf{U}
    - \nabla \cdot [ \nu (\nabla\mathbf{U}) ] 
    = - \nabla p
    \end{align}

现在额外添加一个基于求解出的速度场的无源标量传输方程：

.. math::
    \begin{align}
    \frac{\partial s}{\partial t} + \nabla \cdot (\mathbf{U}s) = 0
    \end{align}


为了不污染OpenFOAM源程序，需要在自己的run文件夹内建立与OpenFOAM相同的求解器文件结构。在run文件夹内，建立applications/solvers/incompressible文件结构，然后将icoFoam文件夹复制到自己建立的该结构当中。

接下来修改各文件名字：修改该文件夹的名字为passiveScalarFoam，修改icoFoam.C为passiveScalarFoam.C，然后进入Make/files进行修改，其中第一句指定所需编译文件，第二句指定求解器存放位置：

.. code-block:: 

    passiveScalarFoam.C

    EXE = $(FOAM_USER_APPBIN)/passiveScalarFoam

此时进入终端运行wclean和wmake验证更改名字没有导致编译错误。

接下来进入createFields.H添加定义在体中心的标量场 :math:`s` 。由于定义在体中心的标量场与压力场p是类似的，所以可以直接复制p的内容并修改名字为s作为标量场s的信息(直接放到原文件所有内容的最后即可)：


.. code-block:: C

    Info<< "Reading field s\n" << endl;
    volScalarField s
    (
        IOobject
        (
            "s",
            runTime.timeName(),
            mesh,
            IOobject::MUST_READ,
            IOobject::AUTO_WRITE
        ),
        mesh
    );

保险起见可以再次运行wmake进行编译验证没有任何错误发生。

接下来进入passiveScalarFoam.C进行求解方程的修改。在原PISO算法求解完U和p之后，进行runTime.write()之前，添加下面所需求解的方程：

.. code-block:: C

    solve(fvm::ddt(s)+fvm::div(phi,s));

然后运行wmake进行编译，如此就完成了求解器的修改。接下来可以使用cavity算例来验证一下求解情况。

修改cavity的名字为passiveCavity以区分原本用于icoFoam的算例。进入0文件建立s文件，因为s和p相似，可以直接复制p文件并修改其相应的名字，而量纲可以修改为无量纲，初始条件与边界条件保持相同：

.. code-block:: C

    FoamFile
    {
        format      ascii;
        class       volScalarField;
        object      s;
    }

    dimensions      [0 0 0 0 0 0 0];

    internalField   uniform 0;

    boundaryField
    {
        movingWall
        {
            type            zeroGradient;
        }

        fixedWalls
        {
            type            zeroGradient;
        }

        frontAndBack
        {
            type            empty;
        }
    }


接下来进入fvSchemes设置额外添加方程的离散格式：

.. code-block:: C

    divSchemes
    {
        default         none;
        div(phi,U)      Gauss linear;
        div(phi,s)      Gauss linearUpwind grad(s);
    }

然后进入fvSolution设置所添加方程离散后线性方程组的求解方法：

.. code-block:: C

    s
    {
        solver          smoothSolver;
        smoother        symGaussSeidel;
        tolerance       1e-05;
        relTol          0;
    }


同时修改controlDict的相关内容，然后运行blockMesh和passiveScalarFoam即可。

.. note:: 在后处理过程中可以发现，虽然所添加方程只有对流项，但是结果却呈现出扩散项的现象。这其实是数值耗散的问题。针对这一问题可以参考interFoam求解器是如何应对数值耗散问题的。



temInterFoam
--------------

该求解基于interFoam进行修改。interFoam涉及的控制方程有：

.. math::
    \begin{align}
    \nabla \cdot \mathbf{U} = 0
    \end{align}

.. math::
    \begin{align}
      \frac{\partial \rho\mathbf{U}}{\partial t}
      + \nabla \cdot (\rho\mathbf{U})\mathbf{U}
      - \nabla \cdot [ \mu (\nabla\mathbf{U}) ]
    = - \nabla p
      -  (\mathbf{g} \cdot \mathbf{x})\nabla\rho
      + \sigma_{T}\kappa_{\alpha}\nabla\alpha 
    \end{align}

.. math::
    \begin{align}
      \frac{\partial \alpha }{\partial t}
      + \nabla \cdot \mathbf{U}\alpha 
    = 0 
    \end{align}

.. math::
    \begin{align}
    & \rho = \alpha \rho_{1} + (1 - \alpha )\rho_{2}  \\
    & \mu = \alpha \mu_{1} + (1 - \alpha )\mu_{2}
    \end{align}

将要添加的控制方程需要求解温度的输运过程：

.. math::
    \begin{align}
      \frac{\partial \rho T}{\partial t}
      + \nabla \cdot (\rho \mathbf{U} T)
      - \nabla \cdot (D_{\text{eff}} \nabla T)
    = 0 
    \end{align}

有效扩散系数 :math:`D_{\text{eff}}` 表示为

.. math::
    \begin{align}
      D_{\text{eff}}
    = \frac{\alpha k_{1}}{C_{\text{v1}}}
      + \frac{(1 - \alpha )k_{2}}{C_{\text{v2}}}  
    \end{align}

其中 :math:`k_{1},k_{2},C_{v1},C_{v2}` 代表传导系数和两种流相的热容量。


新建文件结构applications/solvers/multiphase，将OpenFOAM的interFoam文件夹复制到该处，并修改名字为temInterFoam。进入该文件夹，修改interFoam.C名字为temInterFoam.C，并修改Make/files文件的内容为：

.. code-block:: 

    temInterFoam.C

    EXE = $(FOAM_USER_APPBIN)/temInterFoam

然后运行wclean和wmake验证更改名字没有造成编译错误。

进入createFields.H文件，在最后添加传导系数的内容：

.. code-block:: C

    dimensionedScalar k1
    (
        "k",
        dimensionSet(1,1,-3,-1,0),
        mixture.subDict
        (
            mixture.phase1Name()
        ).lookup("k")
    );

    dimensionedScalar k2
    (
        "k",
        dimensionSet(1,1,-3,-1,0),
        mixture.subDict
        (
            mixture.phase2Name()
        ).lookup("k")
    );

    dimensionedScalar Cv1
    (
        "Cv",
        dimensionSet(0,2,-2,-1,0),
        mixture.subDict
        (
            mixture.phase1Name()
        ).lookup("Cv")
    );

    dimensionedScalar Cv2
    (
        "Cv",
        dimensionSet(0,2,-2,-1,0),
        mixture.subDict
        (
            mixture.phase2Name()
        ).lookup("Cv")
    );

.. note:: 这里可以运行wmake验证没有编译错误。如果只书写了phase1的信息就编译则会提示与phase2相关的错误。



同时复制p_rgh的内容修改得到T的信息：

.. code-block:: C

    Info<< "Reading field T\n" << endl;
    volScalarField T
    (
        IOobject
        (
            "T",
            runTime.timeName(),
            mesh,
            IOobject::MUST_READ,
            IOobject::AUTO_WRITE
        ),
        mesh
    );

运行wmake验证没有编译错误。

为了更好地组织代码，我们将与T相关的方程求解提取到TEqn.H当中。复制UEqn.H并清除其内容改名为TEqn.H，书写其内容：

.. code-block:: C

    volScalarField Deff
    (
        "Deff",
        (alpha1*k1/Cv1 + (scalar(1) - alpha1)*k2/Cv2)
    );

    solve
    (
          fvm::ddt(rho, T)
        + fvm::div(rhoPhi, T)
        - fvm::laplacian(Deff, T)
    );

然后需要将TEqn.H添加到temInterFoam.C里面。需要注意的是，添加位置在pimple loop内部但是在piso loop后面：

.. code-block:: C

    #include "TEqn.H"

进行wmake编译成功后就完成了temInterFoam求解器的编写，后续可以设置算例进行验证。



运行错误报告
============


一般运行过程中出错可能是网格问题或边界设置问题造成的。可以查看运行过程中库朗数的变化情况，如果maxCourant超过1很多则很有可能出错，这也许是部分网格太小或者雷诺数较高的问题。


.. code-block:: C

    SigFpe : Enabling floating point exception trapping (FOAM_SIGFPE).

上面这句报错说明存在浮点数溢出问题。



.. code-block:: C

    #1  Foam::sigFpe::sigHandler(int) at ??:?

上面这句报错说明在数学运算过程中出现了类似除以无穷或除以零之类的运算错误。
