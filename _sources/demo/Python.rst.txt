******
Python
******

fitz
====

图片转PDF
---------

下面的代码能够实现将目标文件夹内的同类型图片按顺序合并为一个PDF文件。需要导入 :code:`import fitz` ， :code:`import os` ， :code:`import re` 。该函数代码需要传入图片所在目录、图片类型、合并PDF的名称。下面是一个示例：

.. code-block:: python

	img_path = r'C:\Users\25281\Desktop\工作文件\学校相关资料\课程相关\大二上\电路原理\作业\第6周'
	imgType = '.jpg'
	combined_pdf_name = '06电路原理.pdf'

具体实现的函数代码如下：

.. code-block:: python

	def img_to_pdf(img_path, imgType, combined_pdf_name):
	    doc = fitz.open()  # 打开一个用于存放pdf信息的空doc

	    for fileName_in_img_path in os.listdir(img_path):  # 从目录中依次获取每一个文件名
	        obj = re.compile(r"(?P<imgName>.*?){}".format(imgType), re.S)  # 正则表达式寻找.png后缀的文件
	        result = obj.finditer(fileName_in_img_path)  # 将目录名放入匹配器，并将匹配结果的迭代器存储到result变量中
	        for it in result:  # 从迭代器里面获取img文件名进行操作
	            imgName = it.group('imgName')  # 获取png文件名
	            img_file = img_path + '\\' + imgName + imgType  # 获取完整的img文件路径
	            imgdoc = fitz.open(img_file)  # 打开img文件获取图片数据
	            pdfbytes = imgdoc.convert_to_pdf()  # 将图片数据转换为pdf格式数据
	            subPDF_name = imgName + '.pdf'  # 获取子pdf文件名，以原img文件名字命名
	            imgpdf = fitz.open(subPDF_name, pdfbytes)  # 将子pdf文件名与pdf格式数据打开为pdf文件
	            doc.insert_pdf(imgpdf)  # 将上述pdf文件插入到doc当中

	    doc_position = img_path + '\\' + combined_pdf_name
	    doc.save(doc_position)  # 将doc保存到目标路径
	    doc.close()
	    return



matplotlib
==========

最常用的模块是matplotlib.pyplot，一般的导入方式都是 :code:`import matplotlib.pyplot as plt` 。

显示方式
---------

图片大小
^^^^^^^^^

通过 :code:`plt.figure(figsize=(10, 10))` 的方式来控制图片大小，其含义为“设置的画布大小为10英寸×10英寸”。可以在保存图片的时候设置dpi，例如 :code:`plt.savefig('test.jpg', dpi=100)` 表示保存图片为100像素/英寸，那么实际保存的图片大小就是1000像素×1000像素。

只是像上面那样设定的话，输出的图片会有明显的边缘留白。如果需要完全去除周边空白，可以通过设置 :code:`bbox_inches` 参数来实现，例如 :code:`plt.savefig('test.jpg', bbox_inches='tight')` 。当设置为 :code:`bbox_inches='tight'` 时，可以进一步设置 :code:`pad_inches` 的值来自定义边框宽度（默认是0.1英寸），例如 :code:`plt.savefig('test.jpg', bbox_inches='tight', pad_inches=1)` 。

但是需要注意，通过 :code:`bbox_inches='tight'` 设置得到的图片会让之前的图片大小设置失效。如果完全不想留白，并且想保留对输出图片大小的设置，那么可以改用

.. code-block:: python

    plt.subplots_adjust(top=1, bottom=0, right=1, left=0, hspace=0, wspace=0)
    plt.margins(0, 0)
    plt.savefig('test.jpg', dpi=100)



文字显示
^^^^^^^^

要想让matplotlib.pyplot生成的图表支持中文，需要加入以下代码：

.. code-block:: python

    plt.rcParams['font.sans-serif'] = ['SimHei']  # 中文


要想让matplotlib生成的图表正常显示负号，需要加入以下代码：

.. code-block:: python

    plt.rcParams['axes.unicode_minus'] = False    # 显示负号



线条样式
^^^^^^^^

:code:`plt.plot()` 函数包含下面的可调控参数：

* :code:`linestyle` ：指定折线的类型，默认是实线。
* :code:`linewidth` ：指定折线的宽度。
* :code:`marker` ：可以为折线图添加点，该参数设置点的形状。
* :code:`markersize` ：设置点的大小。
* :code:`markeredgecolor` ：设置点的边框色。
* :code:`markerfacecolor` ：设置点的填充色。
* :code:`markeredgewidth` ：设置点的边框宽度。
* :code:`label` ：添加折线图的标签，类似于图例的作用。
* :code:`alpha` ：设置图形的透明度。


使用 :code:`plt.style.available` 输出matplotlib.pyplot提供的所有风格名称，共计26种。要使用某种预设的样式时，只需要像如下方式调用即可：

.. code-block:: python

	plt.style.use('ggplot')


如果需要调整 **线条的颜色** ，可以修改 :code:`plt.plot()` 函数的 :code:`color` 参数。有下面几种方式来进行赋值：

.. code-block:: python

	plt.plot(x, np.sin(x - 0), color='blue') # 标准颜色名称
	plt.plot(x, np.sin(x - 1), color='g') # 缩写颜色代码（rgbcmyk）
	plt.plot(x, np.sin(x - 2), color='0.75') # 范围在0~1的灰度值
	plt.plot(x, np.sin(x - 3), color='#FFDD44') # 十六进制（RRGGBB，00~FF）
	plt.plot(x, np.sin(x - 4), color=(1.0,0.2,0.3)) # RGB元组，范围在0~1 
	plt.plot(x, np.sin(x - 5), color='chartreuse'); # HTML颜色名称

也有一些常用颜色的缩写可以直接赋值使用：

+------+------+----------+
| 字符 | 颜色 | 英文全称 |
+======+======+==========+
| 'b'  | 蓝色 | blue     |
+------+------+----------+
| 'g'  | 绿色 | green    |
+------+------+----------+
| 'r'  | 红色 | red      |
+------+------+----------+
| 'c'  | 青色 | cyan     |
+------+------+----------+
| 'm'  | 品红 | magenta  |
+------+------+----------+
| 'y'  | 黄色 | yellow   |
+------+------+----------+
| 'k'  | 黑色 | black    |
+------+------+----------+
| 'w'  | 白色 | white    |
+------+------+----------+


如果需要调整 **线条样式** ，可以修改 :code:`linestyle` 参数。下面是一些常见的线条样式。

+------+--------+
| 字符 | 类型   |
+======+========+
| '-'  | 实线   |
+------+--------+
| '--' | 虚线   |
+------+--------+
| '-.' | 点划线 |
+------+--------+
| ':'  | 点线   |
+------+--------+

如果需要标出数据点， **数据点的形状** 可以通过 :code:`marker` 参数来设置，一些常见的数据点形状如下

+--------+--------------------------------+
| 字符   | 类型                           |
+========+================================+
| '.'    | 点                             |
+--------+--------------------------------+
| 'o'    | 圆圈                           |
+--------+--------------------------------+
| '*'    | 星形                           |
+--------+--------------------------------+
| 'x'    | 十字架                         |
+--------+--------------------------------+
| 's'    | 正方形                         |
+--------+--------------------------------+
| 'p'    | 五角星                         |
+--------+--------------------------------+
| 'D/d'  | 钻石/小钻石                    |
+--------+--------------------------------+
| 'h'    | 六角形                         |
+--------+--------------------------------+
| '+'    | 加号                           |
+--------+--------------------------------+
| '      | '   竖直线                     |
+--------+--------------------------------+
| 'v^<>' | 下三角、上三角、左三角、右三角 |
+--------+--------------------------------+
| '1234' | Tripod向下、向上、向左、向右   |
+--------+--------------------------------+


如果需要修改 **线条宽度** ，可以使用 :code:`linewidth` 参数来修改线条的粗细。默认情况下， :code:`linewidth` 设置为1个单位。利用线条的粗细可以在视觉上强调某条特定的曲线。


坐标轴
^^^^^^


如果希望自定义 **坐标轴上下限** ，最基础的方法是 :code:`plt.xlim()` 和 :code:`plt.ylim()` ，例如

.. code-block:: python

	plt.xlim(-1, 11) 
	plt.ylim(-1.5, 1.5)

如果你想要让 **坐标轴逆序显示** ，那么也可以逆序设置坐标轴刻度值，例如

.. code-block:: python

	plt.xlim(10, 0) 
	plt.ylim(1.2, -1.2)


还有一个方法是 :code:`plt.axis()` 。通过传入 :code:`[xmin, xmax, ymin, ymax]` 对应的值，可以只用一行代码就设置好x和y的限值：

.. code-block:: python

    plt.axis([-1, 11, -1.5, 1.5])

还可以用 :code:`plt.axis('tight')` 按照图形的内容 **自动收紧坐标轴** ，不留空白区域；使用 :code:`plt.axis('equal')` 让屏幕上显示的图形分辨率为1:1， **x轴单位长度与y轴单位长度相等** 。


如果希望将原本的浮点数显示转变为 **百分数显示** 在坐标轴刻度，可以使用FuncFormatter函数。需要导入 :code:`from matplotlib.ticker import FuncFormatter` 。首先自定义转换浮点数为百分数刻度显示的函数：

.. code-block:: python

	def to_percent(temp, position):
	    """
	    用来将坐标轴的浮点数转换为百分比显示
	    :param temp: 坐标轴数据，一般由plt.gca().yaxis.set_major_formatter自动提供
	    :param position: 显示位置，一般由plt.gca().yaxis.set_major_formatter自动提供
	    :return: 百分比显示的str文字
	    """
	    return '%1.0f' % (100 * temp) + '%'

之后只需要在绘图代码中利用 :code:`plt.gca()` 修改对应坐标轴的显示格式即可。例如

.. code-block:: python

	plt.gca().yaxis.set_major_formatter(FuncFormatter(to_percent))  # 将y轴原本的浮点数转换为百分比显示




图形标签
^^^^^^^^

图形标题与坐标轴标题是最简单的标签，快速设置方法如下所示

.. code-block:: python

	plt.title("A Sine Curve") 
	plt.xlabel("x") 
	plt.ylabel("sin(x)")

在单个坐标轴上显示多条线时，创建图例显示每条线是很有效的方法。Matplotlib 内置了 :code:`plt.legend()` 用来创建图例，例如

.. code-block:: python

	plt.plot(x, np.sin(x), '-g', label='sin(x)') 
	plt.plot(x, np.cos(x), ':b', label='cos(x)') 
	plt.axis('equal')

	plt.legend()




折线图(曲线图)
---------------

下面是进行折线图（曲线图）绘制的基本模板，根据需要修改 :code:`x` 、 :code:`y` 、图片大小、绘图风格、线条样式、标签、绘图范围、像素大小与图片名称。

.. code-block:: python

    plt.rcParams['font.sans-serif'] = ['SimHei']
    plt.rcParams['axes.unicode_minus'] = False

    x = np.linspace(0, 50, 50)
    y = np.sin(x)

    plt.figure(figsize=(10, 10))
    plt.style.use('ggplot')
    plt.plot(x, y,
        linestyle='-',
        linewidth=1,
        marker='.',
        markersize=1,
        color='red',
        label='line label',
        alpha=1
    )
    plt.xlim(0, 50)
    plt.ylim(-1.5, 1.5)
    plt.legend(loc='best')
    plt.savefig('test.jpg', dpi=100, bbox_inches='tight', pad_inches=0.1)


多列柱状图
----------

下面给出一个通用的创建多列柱状图的函数代码。它要求分别传入x轴标签、柱状形标签和二维数据数组。这些内容都通过列表来记录，如果不希望产生柱状形标签，那么就传入一个空列表。例如下面是一个5组4列柱状图的数据集

.. code-block:: python
	
	xlabels = ['G1', 'G2', 'G3', 'G4', 'G5']
	bar_labels = ['1', '2', '3', '4']
	first = [20, 34, 30, 35, 27]
	second = [25, 32, 34, 20, 25]
	third = [21, 31, 37, 21, 28]
	fourth = [26, 31, 35, 27, 21]
	data = [first, second, third, fourth]

具体的绘图函数代码如下（已经导入 :code:`import matplotlib.pyplot as plt` 和 :code:`import numpy as np` ）。可以根据需要调整每组柱子之间的空隙、y轴标签、生成图片的文件名。如果希望生成图表标题，可以加入 :code:`plt.title('my title')` 。

.. code-block:: python

	def create_multi_bars(xlabels, bar_labels, datas, tick_step=1, group_gap=0.2, bar_gap=0):
	    """
	    xlabels : x轴坐标标签序列
	    bar_labels : 一组中各柱子的图例
	    datas ：数据集，二维列表，要求列表每个元素的长度必须与labels的长度一致
	    tick_step ：默认x轴刻度步长为1，通过tick_step可调整x轴刻度步长。
	    group_gap : 柱子组与组之间的间隙，最好为正值，否则组与组之间重叠
	    bar_gap ：每组柱子之间的空隙，默认为0，每组柱子紧挨，正值每组柱子之间有间隙，负值每组柱子之间重叠
	    """
	    ticks = np.arange(len(xlabels)) * tick_step  # ticks为x轴刻度
	    group_num = len(datas)  # group_num为数据的组数，即每组柱子的柱子个数
	    group_width = tick_step - group_gap  # group_width为每组柱子的总宽度，group_gap 为柱子组与组之间的间隙。
	    bar_span = group_width / group_num  # bar_span为每组柱子之间在x轴上的距离，即柱子宽度和间隙的总和
	    bar_width = bar_span - bar_gap  # bar_width为每个柱子的实际宽度

	    # baseline_x为每组柱子第一个柱子的基准x轴位置，随后的柱子依次递增bar_span即可
	    baseline_x = ticks - (group_width - bar_span) / 2
	    for index, y in enumerate(datas):
	        plt.bar(baseline_x + index * bar_span, y, bar_width)

	    plt.legend(bar_labels, loc='best')  # 设置各柱形图例
	    plt.ylabel('Scores')  # 设置y轴标签
	    plt.xticks(ticks, xlabels)  # x轴刻度标签位置与x轴刻度一致

	    plt.savefig('test.png')
	    return 


三维绘图
--------

可以通过 :code:`plt.axes()` 函数的关键字 :code:`projection='3d'` 来实现三维坐标轴。例如

.. code-block:: python

    fig = plt.figure()
    ax = plt.axes(projection='3d')

使用 :code:`ax = fig.add_subplot(111, projection='3d')` 的形式可以画多个子图。

使用 :code:`ax.view_init()` 函数来修改三维视图的摄像机视角，需要设置 :code:`elev` 参数和 :code:`azim` 参数，其中elev沿着y轴旋转，azim沿着z轴旋转。当 :code:`elev=0, azim=0` 时，视角是沿x轴向y-z平面正视着看去；当 :code:`elev=45, azim=45` 时，视角是经典的正轴测视角。

在上面的坐标轴基础上，下面的案例演示了如何绘制 **三维曲线** 和 **散点图** ：

.. code-block:: python

    z = np.linspace(0,13,1000)
    x = 5*np.sin(z)
    y = 5*np.cos(z)

    zd = 13*np.random.random(100)
    xd = 5*np.sin(zd)
    yd = 5*np.cos(zd)

    ax.scatter3D(xd, yd, zd, cmap='Blues')  # 绘制散点图
    ax.plot3D(x, y, z, 'gray')    # 绘制空间曲线
    plt.savefig('test.png')

在上面坐标轴的基础上，下面的案例演示了如何绘制 **三维曲面** ：

.. code-block:: python

    xx = np.arange(-5,5,0.5)
    yy = np.arange(-5,5,0.5)
    X, Y = np.meshgrid(xx, yy)  # 形成网格二维数组
    Z = np.sin(X) + np.cos(Y)

    ax.plot_surface(X, Y, Z, cmap='rainbow')  # 也可以调整alpha参数改变曲面透明度
    plt.savefig('test.png')

使用 :code:`ax.contour()` 函数来绘制 **等高线** ，要设置 :code:`offset` 参数，为所需投影位置在投影轴的坐标。同时可以修改 :code:`zdir` 参数来生成不同方向的等高线投影。例如

.. code-block:: python

    ax.contour(X, Y, Z, zdir='z', offset=-3, cmap="rainbow")  #生成z方向投影，投到x-y平面
    ax.contour(X, Y, Z, zdir='x', offset=-6, cmap="rainbow")  #生成x方向投影，投到y-z平面
    ax.contour(X, Y, Z, zdir='y', offset=6, cmap="rainbow")   #生成y方向投影，投到x-z平面

如果使用 :code:`ax.contourf()` 函数，则得到的是“contour with fill”，即有填充颜色的等高线，例如 :code:`ax.contourf(X, Y, Z, zdir='y', offset=6, cmap="rainbow")` 。

如果加入渲染时的步长，会得到更加清晰细腻的图像，例如 :code:`ax.plot_surface(X, Y, Z, rstride = 1, cstride = 1,cmap='rainbow')` ，其中的 :code:`rstride` 和 :code:`cstride` 分别表示横竖方向的绘图采样步长，其参数越小绘图越精细。





numpy
=====

numpy模块一般的导入方式都是 :code:`import numpy as np` 。

基本数学运算
------------

numpy提供了各种三角函数。例如 :code:`np.sin()` ， :code:`np.cos()` ， :code:`np.tan()` ， :code:`np.arcsin()` ， :code:`np.arccos()` ， :code:`np.arctan()` 。需要注意的是，这些三角函数的计算内容应该是弧度制，所以对于以角度为单位的数 :code:`degree` ，需要通过 :code:`degree*np.pi/180` 来将角度转换为弧度。而弧度可以利用 :code:`np.degrees()` 函数来将其转换为角度。

在指数运算方面，numpy提供了自然常数e为底的指数函数 :code:`np.exp()` ，一般的指数计算可以使用 :code:`np.power(a, b)` 来计算 :math:`a^{b}` 。

在对数运算方面，nump提供了自然常数e为底的对数函数 :code:`np.log()` 和以10为底的对数函数 :code:`np.log10()` 。



数据类型转换
------------

numpy数据类型转换需要调用方法 :code:`astype()` ，例如 :code:`np.array(x).astype(int)` 。调用astype返回进行了数据类型修改后的数据，但是源数据的类型不会变，需要进一步对源数据的使用dtype进行操作才能改变，例如 :code:`a.astype(np.int16)` 。但是，没有使用astype而直接修改dtype数据会强制用新数据类型表示，将会导致输出错误数据。



生成序列
---------

生成一维序列可以使用 :code:`linspace` 函数，能够通过指定区间开始和结尾及点个数来生成序列。其调用方式为

.. code-block:: python

    numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None, axis=0)

各参数的含义如下：

- :code:`start` ：序列开始的值。
- :code:`stop` ：序列结束的值。
- :code:`num` ：生成序列点的数量。默认为50个。
- :code:`endpoint` ：用来控制序列末尾是开区间还是闭区间。默认是闭区间。

函数将返回一个数组对象。

另外一个用来生成一维序列的函数为 :code:`arange` ，能够通过指定区间开始和结尾及步长来生成序列。其调用方式为

.. code-block:: python

    numpy.arange(start=0, stop, step=1, dtype=None, like=None)

一般有三种使用方式：

- :code:`arange(stop)` ：只传入结尾点，函数将返回左开右闭序列 :code:`[0, stop)` ，且步长为1。
- :code:`arange(start, stop)` ：传入开始和结尾，函数将返回左开右闭序列 :code:`[start, stop)` ，且步长为1。
- :code:`arange(start, stop, step)` ：传入开始、结尾和步长，函数将返回左开右闭序列 :code:`[start, stop)` ，且步长为指定的step。


interp线性插值
----------------

:code:`np.interp()` 能够进行一维线性插值，返回离散数据的一维分段线性插值结果。其参数与返回值情况如下：

- x: 数组。待插入数据的横坐标。
- xp：一维浮点数序列。原始数据点的横坐标，如果period参数没有指定那么就必须是递增的。否则，在使用 :code:`xp = xp % period` 正则化之后，xp在内部进行排序。
- fp：一维浮点数或复数序列。原始数据点的纵坐标，和xp序列等长。
- left：可选参数，类型为浮点数或复数（与fp值对应）。作为 :code:`x < xp[0]` 时的返回值，默认为 :code:`fp[0]` 。
- right：可选参数，类型为浮点数或复数（与fp值对应）。作为 :code:`x > xp[-1]` 时的返回值，默认为 :code:`fp[-1]` 。
- period：None或者浮点数，可选参数。横坐标的周期.。此参数使得可以正确插入angular x-coordinates。如果该参数被设定，那么会忽略left参数和right参数。
- 返回值：浮点数或复数（对应于fp值）或ndarray。插入数据的纵坐标，和x形状相同。
  
需要注意的是，在没有设定 :code:`period` 参数时，默认要求xp参数必须是递增的。

一种使用案例是根据标定好的二维数据组进行直线内插值。例如，通过实验标定得知电子管阴极电流 :math:`I_{f}` 与温度的对应关系分别为列表 :code:`xp` 和 :code:`fp` ，通过实验测量得到的 :math:`I_{f}` 序列为 :code:`x` ，那么通过调用 :code:`np.interp()` 函数即可得到对应的直线内插值序列：

.. code-block:: python

	xp = [0.500, 0.550, 0.600, 0.650, 0.700]
	fp = [1726, 1809, 1901, 1975, 2059]

	x = [0.51, 0.54, 0.57, 0.60, 0.64, 0.68]
	y = np.interp(x, xp, fp)
	


计算标准差
----------

:code:`np.std()` 能够计算给定数组沿指定轴线的标准差。其参数和返回值情况如下：

- arr：数组。输入数组来计算标准差。
- axis： :code:`None`, :code:`int` 或元素为 :code:`int` 的元组。计算标准差的轴。 :code:`axis=0` 表示沿列计算标准差， :code:`axis=1` 表示沿行计算标准差。如果给定该参数，那么就会把多维数组视为一个扁平化的列表。
- dtype： :code:`dtype` 或 :code:`None` 。在计算标准差时使用的数据类型，默认为 :code:`float64` 。


scipy
=====


数值导数
----------

使用 :code:`scipy.misc` 模块下的 :code:`derivative` 函数来计算函数在某点处的导数值。其调用方式为 :code:`scipy.misc.derivative(func, x0, dx=1.0, n=1, args=(), order=3)` ，其中各参数的含义如下：

- :code:`func` ：需要计算导数值的函数表达式。
- :code:`x0` ：计算导数值对应的横坐标，类型为 :code:`float` 。
- :code:`dx` ：步长间隔。将步长减小过小会导致舍入误差。
- :code:`n` ：求导阶数。默认为一阶导。
- :code:`order` ：用于计算的点数，必须是奇数整型。
  
一般的导入方式是 :code:`from scipy.misc import derivative` ，下面是一个简单的示例，计算了 :math:`\frac{\mathrm{d}(x^{3}+x^{2})}{\mathrm{d}x}\bigg|_{x=1}` ：

.. code-block:: python

    f = lambda x : x**3 + x**2
    result = derivative(f, 1.0, dx=1e-6)



数值积分
--------

一重积分
^^^^^^^^

使用 :code:`scipy.integrate` 库中的 :code:`quad` 函数进行一重积分。其调用方式为 :code:`scipy.integrate.quad(f，a，b)` ，各参数的含义如下：

- :code:`f` ：被积函数。
- :code:`a` ：积分下限的值。
- :code:`b` ：积分上限的值。
  
其返回的结果是一个元组，第一个元素是积分结果，第二个元素是积分值绝对误差的估计值。一般的导入方式是 :code:`from scipy.integrate import quad` 。下面是一个简单的示例，计算了 :math:`\int_{0}^{1}e^{-x^{2}}~\mathrm{d}x` ：

.. code-block:: python

    f = lambda x : np.exp(-x**2)
    result = quad(f, 0, 1)


二重积分
^^^^^^^^

使用 :code:`scipy.integrate` 库中的 :code:`dblquad` 函数进行二重积分。在进行计算前需要将二重积分写成累次积分的形式。其调用方式为

.. code-block::

    scipy.integrate.dblquad(func，a，b，gfun，hfun)


各参数的含义如下：

- :code:`func` ：被积函数的表达式。
- :code:`a` ：自由变量的下限。
- :code:`b` ：自由变量的上限。
- :code:`gfun` ：束缚变量的下限表达式。
- :code:`hfun` ：束缚变量的上限表达式。

需要注意，即使束缚变量的上下限是常数，也应该设为函数表达式来传入。其返回的结果是一个元组，第一个元素是积分结果，第二个元素是积分值绝对误差的估计值。一般的导入方式是 :code:`from scipy.integrate import dblquad` 。下面是一个简单的示例，计算了 :code:`\int_{0}^{1/2}\mathrm{d}y\int_{0}^{\sqrt{1-4y^{2}}}16xy~\mathrm{d}x` ：

.. code-block:: python

    f = lambda x, y : 16*x*y
    g = lambda x : 0
    h = lambda y : np.sqrt(1 - 4 * y**2)
    result = dblquad(f, 0, 0.5, g, h)


多重积分
^^^^^^^^

如果需要进行多重积分的数值计算，可以使用 :code:`scipy.integrate` 库中的 :code:`nquad` 函数。其调用方式为

.. code-block:: python

    scipy.integrate.nquad(func, ranges, args=None, opts=None, full_output=False)

各参数的含义如下：

- :code:`func` ：被积函数的表达式。要求以 :code:`func(x0, x1, ..., xn, t0, t1, ..., tm)` 的形式书写，其中 :code:`x0, x1, ..., xn` 为函数变量， :code:`t0, t1, ..., tm` 为函数参数，并且按次序使得 :code:`x0` 是最内层的积分变量， :code:`xn` 是最外层的积分变量。
- :code:`ranges` ：积分变量上下限。需要是一个可迭代对象，一般是二维列表，依次书写最内层积分变量的[下限，上限]列表直到最外层作为其元素。
- :code:`args` ：被积函数参数 :code:`t0, t1, ..., tm` 的值。
- :code:`opts` ：用来传递给具体积分运算的可选要求。需要是包含字典的可迭代对象或能够返回字典的函数。先后依次对应最内层积分直到最外层的运算。可以调整的opts参数有：
  
    * :code:`epsabs=1.49e-08` ，绝对误差宽容。
    * :code:`epsrel=1.49e-0.8` ，相对误差宽容。
    * :code:`limit=50` ，自适应算法中使用的子区间数的上限。
    * :code:`points=None` ，在有界积分区间内的断点序列，在这里被积函数可能出现奇点、不连续等问题。序列不需要排序。该选项不能与 :code:`weight` 一起使用。
    * :code:`weight=None` ，字符串指示权重函数。
    * :code:`wvar=None` ，用于权重函数的变量。
    * :code:`wopts=None` ，可选输入重用切比雪夫矩。
      
- :code:`full_output` ：如果设置为 :code:`full_output=True` ，那么就会返回一个 :code:`neval` 字典记录被积函数求值的次数。

该函数将返回计算结果、估计误差。一般的导入方式是 :code:`from scipy.integrate import nquad` 。下面是一个案例，计算了

.. math::
	\begin{align}
	\int_{t_{0}+t_{1}-1}^{t_{0}+t_{1}+1}\int_{x_{2}+t_{0}^{2}t_{1}^{3}-1}^{x_{2}+t_{0}^{2}t_{1}^{3}+1}\int_{t_{0}x_{1}+t_{1}x_{2}-1}^{t_{0}x_{1}+t_{1}x_{2}+1}f(x_{0},x_{1},x_{2},t_{0},t_{1})~\mathrm{d}x_{0}\mathrm{d}x_{1}\mathrm{d}x_{2}
	\end{align}

其中被积函数的表达式为

.. math::
	\begin{align}
	f(x_{0},x_{1},x_{2},t_{0},t_{1})=\left\{\begin{array}{ll}
	x_{0}x_{2}^{2}+\sin x_{1}+2 & (x_{0}+t_{1}x_{1}-t_{0}>0) \\
	x_{0}x_{2}^{2}+\sin x_{1}+1 & (x_{0}+t_{1}x_{1}-t_{0} \leqslant 0)
	\end{array}\right.
	\end{align}

且参数为 :math:`(t_{0}, t_{1})=(0,1)` ，计算代码如下：

.. code-block:: python

    def func(x0, x1, x2, t0, t1):
    	return x0*x2**2 + np.sin(x1) + 1 + (1 if x0+t1*x1-t0>0 else 0)
    def lim0(x1, x2, t0, t1):
    	return [t0*x1 + t1*x2 - 1, t0*x1 + t1*x2 + 1]
    def lim1(x2, t0, t1):
    	return [x2 + t0**2*t1**3 - 1, x2 + t0**2*t1**3 + 1]
    def lim2(t0, t1):
    	return [t0 + t1 - 1, t0 + t1 + 1]
    def opts0(x1, x2, t0, t1):
    	return {'points' : [t0 - t1*x1]}  # 由于被积函数分段，在x0=t0-t1*x1处不连续
    def opts1(x2, t0, t1):
    	return {}
    def opts2(t0, t1):
    	return {}
    result = nquad(func, [lim0, lim1, lim2], args=(0,1), opts=[opts0, opts1, opts2])



寻找函数极小值
--------------

:code:`scipy.optimize` 库的 :code:`fmin` 函数提供了使用下坡单纯形算法来求函数极小值的方法，可以寻找给定横坐标最近的极小值点。这个算法只使用函数的值，而没有使用函数的导数等信息。其调用方式为

.. code-block:: python

    scipy.optimize.fmin(func, x0, args=(), xtol=0.0001, ftol=0.0001, maxiter=None, maxfun=None, full_output=0, disp=1, retall=0, callback=None, initial_simplex=None)

各参数的含义如下：

- :code:`func` ：需要求极小值的函数表达式。
- :code:`x0` ：初始猜测点。
- :code:`args` ：传入函数表达式的额外参数。
- :code:`xtol` ：对于自变量收敛来说可接受的自变量迭代之间的绝对误差。
- :code:`ftol` ：对于函数值收敛来说可接受的函数值迭代之间的绝对误差。
- :code:`maxiter` ：迭代次数上限。
  
函数直接返回的是包含选取到的极小值点横坐标的列表，需要通过索引得到该极小值点的值，并回代到函数当中得到对应的极小值。一般的导入方式是 :code:`from scipy.integrate import fmin` 。下面是一个简单的案例：

.. code-block:: python

    def f(x):
    	return x**2 + 1
    result = fmin(f, 1)  # 寻找离1最近的极小值点
    print(result[0])
    print(f(result[0]))


:code:`scipy.optimize` 库的 :code:`fminbound` 函数则可以寻找给定区间的极小值点。其调用方式为

.. code-block:: python

    scipy.optimize.fminbound(func, x1, x2, args=(), xtol=1e-05, maxfun=500, full_output=0, disp=1)

其中 :code:`func` 为需要求极小值的函数表达式， :code:`x1` 为区间左端点， :code:`x2` 为区间右端点。一般的导入方式是 :code:`from scipy.integrate import fminbound` 。下面是一个简单的案例：

.. code-block:: python

    def f(x):
    	return x**2 + 1
    result = fminbound(f, -1, 2)
    print(result)
    print(f(result))




最小二乘法拟合
--------------

最小二乘法的数学原理就是使下面公式中的 :math:`S` 最小。其中的 :math:`p` 表示拟合函数 :math:`f` 的所有参数集合。

.. math::
	\begin{align}
	S(p)=\sum_{i=1}^{m}[y_{i}-f(x_{i},p)]^{2}
	\end{align}

scipy中的子函数库optimize已经提供了实现最小二乘拟合算法的函数leastsq。需要导入 :code:`import numpy as np` 和 :code:`from scipy.optimize import leastsq` 。

首先要获取用于拟合的数据。作为测试，下面使用真实函数数据与噪声组合的方式来获取用于拟合的数据，数据集要以列表或数组的形式存在。

.. code-block:: python

	x = np.linspace(0, -2*np.pi, 100)
	A, k, theta = 10, 0.34, np.pi/6 # 真实数据的函数参数
	y0 = func(x, [A, k, theta]) # 真实数据
	y1 = y0 + 2 * np.random.randn(len(x)) # 加入噪声之后的实验数据

接下来要自定义拟合函数和残差计算函数。例如下面的拟合函数为 :math:`A\sin(2\pi kx+\theta)` ，拟合参数 :math:`p` 包括 :math:`A,k,\theta` 。

.. code-block:: python

	def func(x, p):
	    """
	    数据拟合所用的函数: A*sin(2*pi*k*x + theta)
	    """
	    A, k, theta = p
	    return A*np.sin(2*np.pi*k*x+theta)

.. code-block:: python

	def residuals(p, y, x):
	    """
	    实验数据x, y和拟合函数之间的差，p为拟合需要找到的系数
	    """
	    return y - func(x, p)

接下来开始进行最小二乘法拟合。首先需要自行猜测一组参数，在这个例子里就可以如下猜测：

.. code-block:: python
	
	p0 = [7, 0.2, 0] # 第一次猜测的函数拟合参数


之后就开始调用leastsq进行数据拟合，分别传入计算误差的函数、猜测的拟合参数和需要拟合的实验数据：

.. code-block:: python
	
	plsq = leastsq(residuals, p0, args=(y1, x))

调用成功后，通过 :code:`plsq[0]` 就可以获得拟合参数的列表。如果需要进行拟合曲线绘制，只需要plot即可。

.. code-block:: python
	
	plt.plot(x, func(x, plsq[0]), label='拟合曲线')



如果需要求 **决定系数** ，可以使用下面的函数代码。需要依次传入实际y数据、拟合y数据。

.. code-block:: python

	def get_R2(y, y_fit):
	    y = np.array(y)
	    y_fit = np.array(y_fit)
	    
	    SSE = ((y - y_fit)**2).sum()
	    SST = ((y - y.mean())**2).sum()

	    R2 = 1 - SSE / SST
	    return R2




非线性方程组求解
----------------

optimize库中的fsolve函数可以用来对非线性方程组进行求解，需要导入 :code:`from scipy.optimize import fsolve` 。它进行的数学计算逻辑如下，其中 :math:`f` 是方程组函数， :math:`X` 是未知数矢量。求未知数即是需要找到能令方程组计算误差趋于零的参数。

.. math::
	\begin{align}
	f(X) & = 0
	\end{align}

首先要自定义函数来表示方程组及方程组计算的误差。下面以如下的含有三个未知数的非线性方程组为例（已经导入了 :code:`from math import sin,cos` ）：

.. math::
	\begin{align}
	5x_{1}+3 & = 0 \\
	4x_{0}^{2}-2\sin(x_{1}\cdot x_{2}) &=0 \\
	x_{1}\cdot x_{2} - 1.5 &= 0
	\end{align}

.. code-block:: python

	def func(x):
	    x0 = float(x[0])
	    x1 = float(x[1])
	    x2 = float(x[2])
	    return [
	        5*x1+3,
	        4*x0*x0 - 2*sin(x1*x2),
	        x1*x2 - 1.5
	    ]


之后只需要直接调用fsolve函数即可。需要传入一组试验未知数参数，这里用的试验参数是 :code:`[1,1,1]` 。返回的result就是以列表形式储存的参数向量。可以用 :code:`func(result)` 来检查误差情况。

.. code-block:: python

	result = fsolve(func, [1,1,1])

在对方程组进行求解时，fsolve会自动计算方程组的雅可比矩阵，如果方程组中的未知数很多，而与每个方程有关的未知数较少时，即雅可比矩阵比较稀疏时，传递一个计算雅可比矩阵的函数将能大幅度提高运算速度。对于上面的非线性方程组，使用雅可比矩阵的fsolve方法如下。计算雅可比矩阵的函数j通过fprime参数传递给fsolve，即 :code:`result = fsolve(f, [1,1,1], fprime=j)` 。

.. code-block:: python

	def j(x):
	    x0 = float(x[0])
	    x1 = float(x[1])
	    x2 = float(x[2])
	    return [
	        [0, 5, 0],
	        [8*x0, -2*x2*cos(x1*x2), -2*x1*cos(x1*x2)],
	        [0, x2, x1]
	        ]



微分方程的数值解
-----------------

使用 :code:`scipy.integrate` 模块的odeint模块的odeint函数来求常微分方程的数值解。一般通过 :code:`from scipy.integrate import odeint` 来导入。需要注意的是，该函数只能处理一阶方程组，如果是高阶微分方程组，需要通过龙格-库塔方法化为一阶微分方程组。

该函数的基本调用格式是 :code:`result = odeint(func, y0, t)` ，其中 :code:`func` 是定义微分方程的函数或匿名函数； :code:`y0` 是初始条件的序列； :code:`t` 是一个自变量取值的序列（其一个元素一定必须是初始时刻）；返回值是对应于序列 :code:`t` 中元素的数值解，如果微分方程组中有 :code:`n` 个函数，返回值会是 :math:`n` 列的矩阵，其第 :math:`i(i=1,2,\cdots,n)` 列对应于第 :math:`i` 个函数的数值解。

接下来处理下面给的一阶微分方程，求解其在 :math:`1<x<10` （步长间隔为0.5）的点上的数值解。

.. math::
	\begin{align}
	\left\{\begin{array}{l}
	y'=-2y+x^{2}+2x \\
	y(1)=2
	\end{array}\right.
	\end{align}

.. code-block:: python

    dy = lambda y,x: -2*y + x**2 + 2*x  # 定义微分方程
    x = np.arange(1, 10.5, 0.5)  # 给定求解范围与步长
    result = odeint(dy, 2, x)  # 初始条件的值与求解范围的第一个元素对应


接下来求解下面给的二阶微分方程的数值解。首先引入 :math:`y_{0}=y` ， :math:`y_{1}=y'` ，将原来的二阶微分方程转换为一阶微分方程组。

.. math::
	\begin{align}
	\left\{\begin{array}{l}
	\frac{\mathrm{d}^{2}y}{\mathrm{d}x^{2}}+2\frac{\mathrm{d}y}{\mathrm{d}x}+2y=0 \\
	y(0)=0 \\
	y'(0)=1  
	\end{array}\right .
	\quad \Rightarrow \quad 
	\left\{\begin{array}{l}
	y_{0}'=y_{1} \\
	y_{1}'=-2y_{0}-2y_{1} \\
	y_{0}(0)=0 \\
	y_{1}(0)=1
	\end{array}\right .
	\end{align}


.. code-block:: python

    def pfun(f_list, x):
    	y0, y1 = f_list
    	func1 = y1
    	func2 = -2*y0 - 2*y1
    	return np.array([func1, func2])  # 返回的是等式右边的值，要求先低阶再高阶

    x = np.arange(0, 10, 0.1)  # 创建自变量序列
    result = odeint(pfun, [0.0, 1.0], x)










Sphinx
======

Sphinx是一个静态网页发布工具，可将rST和md文件，发布为各类常见的用户帮助如联机帮助，用户手册等。

快速新建项目
------------

详细内容可以参考 `sphinx快速入门`_ 

.. _sphinx快速入门: https://doclikecode.readthedocs.io/zh_CN/latest/1_sphinx/sphinx101.html#:~:text=%E5%BF%AB%E9%80%9F%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%BB%A5Mac%E7%B3%BB%E7%BB%9F%E4%B8%BA%E4%BE%8B%EF%BC%8CWindow%E7%B3%BB%E7%BB%9F%E7%B1%BB%E4%BC%BC%EF%BC%89%20%C2%B6%201%20%E5%9C%A8%E6%A1%8C%E9%9D%A2%E4%B8%8A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%8C%E5%B9%B6%E5%91%BD%E5%90%8D%E4%B8%BA%20sphinx-demo%202%20%E5%9C%A8Terminal%E4%B8%AD%E6%B5%8F%E8%A7%88%E8%87%B3%E4%B8%8A%E8%BF%B0%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%8C%E5%B9%B6%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4%EF%BC%9A,sphinx-quickstart%203%20%E5%9C%A8%E5%AF%B9%E8%AF%9D%E6%A1%86%E5%BC%8F%E7%9A%84%E9%80%89%E6%8B%A9%E4%B8%AD%EF%BC%8CY%2FN%E7%9A%84%E9%80%89%E9%A1%B9%EF%BC%8C%E9%80%89Y%EF%BC%9B%E5%A6%82%E6%9E%9C%E8%AF%A2%E9%97%AE%E9%85%8D%E7%BD%AE%EF%BC%8C%E7%9B%B4%E6%8E%A5%E5%A4%8D%E5%88%B6%20%5B%5D%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E5%A6%82%20%5B.rst%5D%EF%BC%8C%E5%88%99%E5%A1%AB%E5%86%99.rst%204%20%E6%96%B0%E5%BB%BA%E6%88%90%E5%8A%9F%E5%90%8E%EF%BC%8C%E5%88%99%E4%BC%9A%E5%BE%97%E5%88%B0%E5%A6%82%E5%9B%BE%E6%89%80%E7%A4%BA%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E7%BB%93%E6%9E%84

首先新建希望存放项目文件的文件夹，然后在Terminal中浏览至上述文件夹，并运行命令： :code:`sphinx-quickstart` 。在对话框式的选择中，Y/N的选项，根据需要选Y；语言设置时，填入 :code:`zh-CN` 以支持中文简体。

新建完成后，浏览至 source 文件夹，并在其根目录下创建新文件夹demo，在demo文件夹中放置用于生成页面的rst文件。放置完成后，打开source文件中的 index.rst，将demo内的文件添加至目录中。例如

.. code-block:: rst

    .. toctree::
       :maxdepth: 2
       :caption: Contents:

       demo/电路原理.rst
       demo/数字电路.rst

完成后在Terminal中运行编译命令： :code:`sphinx-build -b html source build` ，编译成功后在 build 文件夹中则有刚才发布的网站。

修改网页主题
------------

如果需要修改网页主题，打开 source 文件夹中的conf.py，并找到主题配置行 html_theme = ‘alabaster’ ，修改该参数即可。如果要使用ReadtheDoc主题，则修改为 html_theme = ‘sphinx_rtd_theme’ 。


加宽网页宽度
------------

在使用ReadtheDoc主题时，注意到其内容页面集中在中间，右边存在空间冗余。如果需要将网页宽度加大，可以在 :code:`source/_static` 中新建css文件，命名为 :code:`style.css` ，内容为

.. code-block:: css

    .wy-nav-content {
    	max-width: 1200px !important;
    }


再在 :code:`source/_templates` 文件夹中新建一个 :code:`layout.html` 文件，内容为

.. code-block:: 

	{% extends "!layout.html" %}
	{% block extrahead %}
	    <link href="{{ pathto("_static/style.css", True) }}" rel="stylesheet" type="text/css">
	{% endblock %}

确保 :code:`source/conf.py` 引用了 :code:`source/_static` 目录，即包含语句 :code:`html_static_path = ['_static']` ，就可以实现将原本ReadtheDoc主题页面宽度加大的效果。




sympy
=====

sympy是重要的数学符号运算库，可以完成数学公式的符号推导。为了调用方便，一般通过 :code:`import sympy as sp` 导入该库。并且，其计算的函数结果可以通过 :code:`latex` 函数直接输出 :math:`\LaTeX` 公式，例如 :code:`print(latex(integrate(sqrt(x), x)))` 。

需要注意的是，由sympy创建的符号函数对象不能混用numpy的函数运算。

变量赋值与精度转换
------------------

采用符号变量的 :code:`subs()` 方法来进行替换操作，例如下面的代码实现了令表达式 :math:`\frac{R_{3} \left(R_{1} U_{s2} + R_{2} U_{s1}\right)}{R_{1} R_{2} + R_{1} R_{3} + R_{2} R_{3}}` 中的 :math:`R_{1}=3.6,~R_{2}=3.6,~R_{3}=3.3,~U_{s1}=4,~U_{s2}=8` ，函数返回了其计算结果。如果只需要给一个变量赋值，那么可以像 :code:`expr.subs(x,1)` 这样传值。

.. code-block:: python

	v, R1, R2, R3, Us1, Us2 = sp.symbols('v R1 R2 R3 Us1 Us2')
	expr = R3 * (R1 * Us2 + R2 * Us1) / (R1 * R2 + R1 * R3 + R2 * R3)
	result = expr.subs({'R1': 3.6, 'R2': 3.6, 'R3': 3.3, 'Us1': 4, 'Us2': 8})
    

使用 :code:`sympify()` 函数可以将字符串表达式转换为Sympy表达式。例如：

.. code-block:: python

	str_expr = 'x**2 + 2*x + 1'
	expr = sympify(str_expr)

使用符号变量的 :code:`evalf()` 方法可以将数值转换为指定精度的数值解，保留指定的有效数字。例如：

.. code-block:: python

	pi.evalf(3)  # pi保留3位有效数字



函数表达式化简
---------------

simplify函数化简
^^^^^^^^^^^^^^^^^

在符号计算中，最常用的操作就是利用 :code:`simplify` 函数对表达式进行化简。默认情况下， :code:`simplify` 函数将自行寻找它认为的最简单的表达形式。下面就是分别利用该函数将 :math:`\sin^{2}x+\cos^{2}x` 化简为 :math:`1` 和将 :math:`2\sin\alpha\cos\alpha` 化简为 :math:`\sin(2\alpha)` 。

.. code-block:: python

    expr = simplify(sin(x)**2 + cos(x)**2)

.. code-block:: python

	alpha = symbols('alpha')
	expr = simplify(2*sin(alpha)*cos(alpha))


多项式展开
^^^^^^^^^^

使用 :code:`expand` 函数来实现将多项式展开。例如下面就使用了该函数来展开 :math:`(x_{1}+1)^{2}` ，成功得到 :math:`x_{1}^{2}+2x_{1}+1` 。

.. code-block:: python

	x_1 = symbols('x_1')
	result = expand((x_1 + 1)**2)


多项式因式分解
^^^^^^^^^^^^^^

使用 :code:`factor` 函数来对多项式进行因式分解。例如下面就使用了该函数来对 :math:`x^{3}-x^{2}+x-1` 进行因式分解，成功得到 :math:`(x-1)(x^{2}+1)` 。

.. code-block:: python

	x = symbols('x')
	result = factor(x**3 - x**2 + x - 1)


合并同类项
^^^^^^^^^^

使用 :code:`collect` 函数来实现合并同类项的操作。例如下面就使用了该函数来对 :math:`xy+x-3+2x^{2}-zx^{2}` 根据 :math:`x` 合并同类项，成功得到 :math:`x^{3}+x^{2}(2-z)+x(y+1)-3` 。

.. code-block:: python

    x, y = symbols('x y')
    expr = x*y + x - 3 + 2*x**2 - z*x**2 + x**3
    new_expr = collect(expr, x)


有理分式化简
^^^^^^^^^^^^

使用 :code:`cancel` 函数来消去分子分母的公因式。例如下面就使用了该函数来将 :code:`\frac{x^{2}+2x+1}{x^{2}+x}` 化简为 :math:`\frac{x+1}{x}` 。

.. code-block:: python

    x = symbols('x')
    expr = cancel((x**2 + 2*x + 1) / (x**2 + x))


分式展开
^^^^^^^^

使用 :code:`apart` 函数来将分式展开。例如下面就使用了该函数来将 :math:`\frac{4x^{3}+21x^{2}+10x+12}{x^{4}+5x^{3}+5x^{2}+4x}` 展开为 :math:`\frac{2x-1}{x^{2}+x+1}-\frac{1}{x+4}+\frac{3}{x}` 。

.. code-block:: python

    x = symbols('x')
    expr = (4*x**3 + 21*x**2 + 10*x + 12) / (x**4 + 5*x**3 + 5*x**2 + 4*x)
    new_expr = apart(expr)


符号函数求导
-------------

求导函数使用的是 :code:`diff` 函数。对一个一元函数求一阶导可以简单地像这样完成： :code:`diff(cos(x), x)` 。如果需要求高阶导可以像这样来完成： :code:`diff(x**4, x, 3)` 。其中的表达式也不一定要放在括号内，可以作为符号变量放在外面。

下面以计算 :math:`\frac{\partial y}{\partial x_{2}}=\frac{\partial }{\partial x_{2}}\left ( x_{1}^{2}+x_{2}^{2} \right )` 为例来说明偏导数的计算。首先要定义表达式的变量名称：

.. code-block:: python
 
     x1, x2 = symbols('x1 x2')

然后定义表达式内容：

.. code-block:: python
 
     y = x1**2 + x2**2

那么计算对 :math:`x_{2}` 偏导数的结果为

.. code-block:: python

    dy_dx2 = diff(y, x2)

可以 :code:`print(dy_dx2)` 来查看计算结果的表达式。如果需要给该表达式的自变量赋值进行计算，可以使用 :code:`evalf(subs={})` 函数。其中 :code:`subs={}` 里面填入对应变量及其取值的字典。例如上述偏导结果代入 :math:`x_{2}=6` 的方式如下：

.. code-block:: python

    result = dy_dx2.evalf(subs={'x2': 6})


符号函数积分
-------------

使用 :code:`integrate` 函数来求积分。例如 :code:`integrate(cos(x), x)` 。

如果要求定积分，则在变量处传入元组，依次说明变量、积分下限和积分上限。同时注意，在sympy中，使用 :code:`oo` 来表示 :math:`\infty` 。例如 :code:`integrate(exp(-x), (x, 0, oo))` 就计算了 :math:`\int_{0}^{\infty}e^{-x}~\mathrm{d}x`

如果要计算二重积分，则只需多传入一个变量元组即可。例如 :code:`integrate(exp(-x**2 - y**2), (x, -oo, oo), (y, -oo, oo))` 就计算了 :math:`\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}e^{-x^{2}-y^{2}}~\mathrm{d}x\mathrm{d}y` 。


符号函数极限
--------------

使用 :code:`limit` 函数来计算函数极限。例如 :code:`limit(sp.sin(x)/x, x, 0)` 计算了 :math:`\lim\limits_{x\to 0}\frac{\sin x}{x}` 。

如果要计算单侧积分，则只需额外用 :code:`'+'` 或 :code:`'-'` 指定即可。例如 :code:`limit(1/x, x, 0, '+')` 计算了 :math:`\lim\limits _{x\to 0^{+}}\frac{1}{x}` 。


符号函数的级数展开
-------------------

使用符号变量的 :code:`series` 方法可以对函数 :math:`f(x)` 在 :math:`x=x_{0}` 处进行 :math:`n` 阶展开。例如下面进行对 :math:`f(x)=\sin x` 在 :math:`x=0` 处进行4阶展开：

.. code-block:: python

    x = sp.symbols('x')
    expr = sp.sin(x)
    new_expr = expr.series(x, 0, 4)


求解符号方程组
---------------

使用 :code:`solve` 函数来求解符号方程组，依次传入方程组列表和需要求解的变量列表，常数符号不需要写入参数当中。例如

.. code-block:: python

    u1, u2, R1, R2, R3 = sp.symbols('u1 u2 R1 R2 R3')

    eq1 = (R1 + R3)/R3 - 2
    eq2 = (R1*R2 + R1*R3 + R2*R3)/R3 - 8
    eq3 = 1/R3 - 0.5
    eq4 = (R2 + R3)/R3 - 2.5

    result = sp.solve([eq1, eq2, eq3, eq4], [R1, R2, R3])

如果没有解析解则会报错。这时可以改用 :code:`nsolve` 函数来求数值解。


求解微分符号方程
-----------------

使用 :code:`dsolve` 函数求解微分方程。首先需要建立符号函数变量：

.. code-block:: python

    f = sp.symbols('f', cls = Function)

接下来使用 :code:`Eq` 函数（逗号左右两边表达式相等）构建微分方程 :math:`f''(x)-2f'(x)+f(x)=\sin x` 并调用 :code:`dsolve` 函数进行求解得到 :math:`f(x)=(C_{1}+C_{2}x)e^{x}+\frac{\cos x}{2}` ：

.. code-block:: python

    diffeq = Eq(f(x).diff(x, 2) - 2*f(x).diff(x) + f(x), sin(x))
    result = dsolve(diffeq, f(x))


矩阵运算
--------

构建矩阵
^^^^^^^^

使用 :code:`Matrix` 函数构造矩阵。例如 :code:`Matrix([[1, -1], [3, 4], [0, 2]])` 构造矩阵 :math:`\begin{pmatrix} 1 & -1\\ 3 & 4\\ 0 & 2\end{pmatrix}` ， :code:`Matrix([1, 2, 3])` 构造列向量 :math:`\begin{pmatrix}1 \\2 \\3\end{pmatrix}` ，配合转置操作 :code:`T` 可以像 :code:`Matrix([[1], [2], [3]]).T` 构造行向量 :math:`\begin{pmatrix} 1 & 2 & 3\end{pmatrix}` 。

特别地，可以用 :code:`eye(4)` 构建4阶单位矩阵；用 :code:`zeros(4)` 构建4阶全零矩阵；用 :code:`ones(4)` 构建4阶全一矩阵；用 :code:`diag(1, 2, 3, 4)` 构建对角矩阵。


求矩阵的幂与求逆
^^^^^^^^^^^^^^^^

直接对矩阵变量像数值那样进行幂操作即可，例如

.. code-block:: python

    M = Matrix([[1, 3], [-2, 3]])
    result = M**2

特别地，矩阵的 :math:`-1` 次幂就是矩阵的逆。


求矩阵的行列式
^^^^^^^^^^^^^^^

用矩阵变量的 :code:`det` 函数来求其行列式：

.. code-block:: python

    M = Matrix([[1, 0, 1], [2, -1, 3], [4, 3, 2]])
    result = M.det()


求矩阵的特征值和特征多项式
^^^^^^^^^^^^^^^^^^^^^^^^^^^

用矩阵变量的 :code:`eigenvals` 函数来求其特征值。该函数返回的是字典，字典的key是特征值，value是对应的重数。

.. code-block:: python

    M = Matrix([[3, -2,  4, -2], [5,  3, -3, -2], [5, -2,  2, -2], [5, -2, -3,  3]])
    eigenvalue = M.eigenvals()

用矩阵变量的 :code:`charpoly` 方法来求其特征多项式。

.. code-block:: python

    M = Matrix([[3, -2,  4, -2], [5,  3, -3, -2], [5, -2,  2, -2], [5, -2, -3,  3]])
    p = M.charpoly(lamda)
    eigenpolynomial = factor(p)  # 调用了factor来将表达式因式分解


Laplace变换
------------

使用 :code:`laplace_transform` 进行Laplace变换，例如

.. code-block:: python

    t, s = symbols('t s')
    expr = sin(t)
    result = laplace_transform(expr, t, s)

使用 :code:`inverse_laplace_transform` 进行逆Laplace变换，例如

.. code-block:: python

    s, t = symbols('s t')
    expr = 1/(s - 1)
    result = inverse_laplace_transform(expr, s, t)




