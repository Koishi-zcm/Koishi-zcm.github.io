***
C++
***

变量和基本类型
==============


基本内置类型
------------


算术类型
^^^^^^^^

算术类型分为两类：整型(包括字符和布尔类型)和浮点型。


+-------------+----------------+--------------+
| 类型        | 含义           | 最小尺寸     |
+=============+================+==============+
| bool        | 布尔类型       | 未定义       |
+-------------+----------------+--------------+
| char        | 字符           | 8位          |
+-------------+----------------+--------------+
| wchar_t     | 宽字符         | 16位         |
+-------------+----------------+--------------+
| char16_t    | Unicode字符    | 16位         |
+-------------+----------------+--------------+
| char32_t    | Unicode字符    | 32位         |
+-------------+----------------+--------------+
| short       | 短整型         | 16位         |
+-------------+----------------+--------------+
| int         | 整型           | 16位         |
+-------------+----------------+--------------+
| long        | 长整型         | 32位         |
+-------------+----------------+--------------+
| long long   | 长整型         | 64位         |
+-------------+----------------+--------------+
| float       | 单精度浮点数   | 6位有效数字  |
+-------------+----------------+--------------+
| double      | 双精度浮点数   | 10位有效数字 |
+-------------+----------------+--------------+
| long double | 扩展精度浮点数 | 10位有效数字 |
+-------------+----------------+--------------+


除了布尔型和拓展的字符型之外，其他整型可以划分为带符号的(signed)和无符号的(unsigned)两种。类型int、short、long和long long都是带符号的，通过在这些类型名前添加unsigned就可以得到无符号类型。与其他整型不同，字符型被分为了三种：char、signed char和unsigned char。不过，字符表现形式却只有两种：带符号的和无符号的。类型char实际上会表现为上述两种形式中的一种，具体是哪种由编译器决定。

无符号类型中所有比特都用来存储值，例如8比特的unsigned char可以表示0至255区间内的值；8比特的signed char的表示范围为-128至127。


.. attention:: 

	- 当明确知道数值不可能是负的情况时，选用无符号类型。
	- 使用int执行整数运算。在实际应用中，short常常位数太小，而long一般和int有一样的尺寸。如果数值超过了int的表示范围，就需要选用long long类型。
	- 在算术表达式中不要使用char或bool，只有在存放字符或布尔值时才使用它们。如果需要使用一个不大的整数，那么明确指定它的类型是signed char或者unsigned char。
	- 执行浮点数运算选用double，因为float常常精度不够，而long double精度一般没必要且运行消耗不容忽视。


类型转换
^^^^^^^^

类型所能表示的值的范围决定了转换的过程：

- 当把一个非布尔类型的算术值赋给布尔类型时，初始值为0则结果为false，否则结果为true。
- 当把一个布尔值赋给非布尔类型时，初始值为false则结果为0，初始值为true则结果为1。
- 当把一个浮点数赋给整数类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分。
- 当把整数值赋给浮点类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。
- 当赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。
- 当赋给带符号类型一个超出它表示范围的值时，结果是未定义的。
  


字面值常量
^^^^^^^^^^

可以将整型字面值写作十进制数、八进制数或十六进制数的形式。以0开头的整数表示八进制，以0x或0X开头的表示十六进制数。例如数值20可以分别表示为：十进制20；八进制024；十六进制0x14。


一些特殊字符不能直接使用进行打印，这时需要用到转义序列。C++规定的转义序列包括：

+------------+--------------+------------+-------------+--------------+-------------+
| 含义       | 符号         | 含义       | 符号        | 含义         | 符号        |
+============+==============+============+=============+==============+=============+
| 换行符     | :code:`\\n`  | 横向制表符 | :code:`\\t` | 报警(响铃)符 | :code:`\\a` |
+------------+--------------+------------+-------------+--------------+-------------+
| 纵向制表符 | :code:`\\v`  | 退格符     | :code:`\\b` | 双引号       | :code:`\\"` |
+------------+--------------+------------+-------------+--------------+-------------+
| 反斜线     | :code:`\\\\` | 问号       | :code:`\\?` | 单引号       | :code:`\\'` |
+------------+--------------+------------+-------------+--------------+-------------+
| 回车符     | :code:`\\r`  | 进纸符     | :code:`\\f` |              |             |
+------------+--------------+------------+-------------+--------------+-------------+




字符和字符串字面值可以通过前缀符号指定类型：

+------+-----------------------------+----------+
| 前缀 | 含义                        | 类型     |
+======+=============================+==========+
| u    | Unicode16字符               | char16_t |
+------+-----------------------------+----------+
| U    | Unicode32字符               | char32_t |
+------+-----------------------------+----------+
| L    | 宽字符                      | wchar_t  |
+------+-----------------------------+----------+
| u8   | UTF-8(仅用于字符串字面常量) | char     |
+------+-----------------------------+----------+


整型字面值和浮点型字面值通过后缀符号来指定类型：

+--------+-------------+
| 后缀   | 类型        |
+========+=============+
| u或U   | unsigned    |
+--------+-------------+
| l或L   | long        |
+--------+-------------+
| ll或LL | long long   |
+--------+-------------+
| f或F   | float       |
+--------+-------------+
| l或L   | long double |
+--------+-------------+






复合类型
--------

引用
^^^^^^

引用是为对象起了另外一个名字，声明符号将写成 :code:`&d` 的形式，其中 :code:`d` 是声明的变量名：

.. code-block:: C

    int ival = 1024;
    int &refVal = ival;

.. attention:: 使用引用时必须初始化。




指针
^^^^^

定义指针类型的方法是将声明符写成 :code:`*d` 的形式，其中 :code:`d` 是变量名。如果在一条语句中定义了多个指针变量，那么每个变量前面都必须有符号 :code:`*` ：

.. code-block:: C

    int *ipl, *ip2;        // ip1和ip2都是指向int型对象的指针
    double dp, *dp2;       // dp2是指向double型对象的指针，dp是double型对象


指针存放某个对象的地址，而获取地址需要使用取地址符 :code:`&` ：

.. code-block:: C

    int ival = 42;
    int *p = &ival;      // p存放变量ival的地址，或者说p是指向变量ival的指针


.. attention:: 因为在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。


如果指针指向了一个对象，则允许使用解引用符 :code:`*` 来访问该对象，之后就可以进行打印输出或赋值等操作：

.. code-block:: C

    int ival = 42;
    int *p = &ival;      // p存放着变量ival的地址，或者说p是指向变量ival的指针
    cout << *p;          // 由符号*得到指针p所指的对象，输出42
    *p = 0;              // 由符号*得到指针p所指的对象，即可经由p为变量ival赋值
    cout << *p;          // 输出0




.. note:: 像 :code:`&` 和 :code:`*` 这样的符号，既能用作表达式里的运算符，也能作为声明的一部分出现，符号的上下文决定了符号的意义。


.. code-block:: C

    int i = 42;
    int &r = i;         // &紧随类型名出现，因此是声明的一部分，r是一个引用
    int *p;             // *紧随类型名出现，因此是声明的一部分，p是一个指针
    p = &i;             // &出现在表达式中，是一个取地址符
    *p = i;             // *出现在表达式中，是一个解引用符
    int &r2 = *p;       // &是声明的一部分，*是一个解引用符




const限定符
-------------

有时候需要定义一种不被调整的变量，那么就可以用关键词 :code:`const` 对变量的类型加以限定，之后任何试图给其进行赋值的行为都会引发错误。因为const对象一旦创建之后其值就不能再改变，所以const对象必须初始化：

.. code-block:: C

    const int i = get_size();           // 运行时初始化
    const int j = 42;                   // 编译时初始化


可以把引用绑定到const对象上，称为对常量的引用。不过，对常量的引用不能被用作修改它所绑定的对象：

.. code-block:: C

    const int ci = 1024;
    const int &rl = ci;      // 正确：引用及其对应的对象都是常量
    rl = 42;                 // 错误：rl是对常量的引用
    int &r2 = ci;            // 错误：试图让一个非常量引用指向一个常量对象












