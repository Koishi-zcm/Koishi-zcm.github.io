******
Python
******


Basemap
=======

该模块的导入方式一般为 :code:`from mpl_toolkits.basemap import Basemap` 。

地图投影类型与经纬度范围
------------------------

创建一个地图的方式如下：

.. code-block:: python

    map = Basemap(
        projection='merc',
        llcrnrlon=70,  # 最左侧经度
        llcrnrlat=3,  # 最下方纬度
        urcrnrlon=140,  # 最右侧经度
        urcrnrlat=55  # 最上方纬度
    )

其中 :code:`projection` 参数设置的是投影方式，可以选择的投影方式有 :code:`'cea'` 圆柱等面积投影、 :code:`mbtfpq` 麦克布赖德-托马斯平极四次投影、 :code:`aeqd` 等距方位离投影、 :code:`sinu` 正弦曲线投影、 :code:`poly` 多圆锥投影、 :code:`moll` 默尔威得投影、 :code:`merc` 墨卡托投影……

另外四个参数是用来设置显示经纬度范围的，四个参数的含义为

- :code:`llcrnrlon` ：longitude of lower left hand corner，地图左下角的经度界限，也即最左侧经度。
- :code:`llcrnrlat` ：latitude of lower left hand corner，地图左下角的纬度界限，也即最下方纬度。
- :code:`urcrnrlon` ：longitude of upper right hand corner，地图右上角的经度界限，也即最右侧经度。
- :code:`urcrnrlat` ：latitude of upper right hand corner，地图右上角的纬度界限，也即最上方纬度。

上面四个参数是通过框定界线来确定地图范围的。如果需要将某个地区放置到地图中心，可以改用下面四个参数来确定地图范围：

- :code:`width` ：在投影坐标下的地图宽度，单位为米。
- :code:`height` ：在投影坐标下的地图高度，单位为米。
- :code:`lon_0` ：地图中心位置的经度。
- :code:`lat_0` ：地图中心位置的纬度。


更多详细信息可以参看 `官方文档 <https://matplotlib.org/basemap/api/basemap_api.html#module-mpl_toolkits.basemap>`_ 


绘制地图经纬度刻度线
---------------------

使用 :code:`drawparallels()` 函数来绘制地图维度刻度线，其基本调用方式为：

.. code-block:: python

    drawparallels(circles, color='k', textcolor='k', linewidth=1.0, zorder=None, dashes=[1, 1], labels=[0, 0, 0, 0], labelstyle=None, fmt='%g', xoffset=None, yoffset=None, ax=None, latmax=None, **text_kwargs)

其中各参数的含义如下：

- :code:`circles` ：刻度序列，最方便的方式是使用 :code:`np.linspace()` 来传入，例如 :code:`np.linspace(-90, 90, 7)` 。
- :code:`color` ：刻度线的颜色，默认是黑色，另外常用的颜色是 :code:`grey` 。
- :code:`labels` ：显示刻度线的方位，四个数代表bool值，分别对应「left」、「right」、「top」、「bottom」。

一个完整的使用示例为 :code:`map.drawparallels(circles=np.linspace(-90, 90, 7), labels=[1, 0, 0, 0], color='grey')` 。

使用 :code:`drawmeridians()` 函数来绘制地图经度刻度线，其基本调用方式为

.. code-block:: python

    drawmeridians(meridians, color='k', textcolor='k', linewidth=1.0, zorder=None, dashes=[1, 1], labels=[0, 0, 0, 0], labelstyle=None, fmt='%g', xoffset=None, yoffset=None, ax=None, latmax=None, **text_kwargs)

其中各参数的含义如下：

- :code:`meridians` ：刻度序列，最方便的方式是使用 :code:`np.linspace()` 来传入，例如 :code:`np.linspace(-180, 180, 13)` 。
- :code:`color` ：刻度线的颜色，默认是黑色，另外常用的颜色是 :code:`grey` 。
- :code:`labels` ：显示刻度线的方位，四个数代表bool值，分别对应「left」、「right」、「top」、「bottom」。

一个完整的使用示例为 :code:`map.drawmeridians(meridians=np.linspace(-180, 180, 13), labels=[0, 0, 0, 1], color='grey')` 。




绘制地图元素
------------

下面是一些常见的绘图元素：

.. code-block:: python

    map.drawcoastlines()  # 绘制大陆海岸线
    map.drawcountries()  # 绘制国界线
    map.drawcounties()  # 绘制州界线
    map.drawrivers()  # 绘制河流线

上述的函数都可以添加 :code:`color` 、 :code:`linewidth` 参数来进行调整。



在地图上绘制额外数据内容
-------------------------

可以参考 `basemap之地图上画额外数据 <https://zhuanlan.zhihu.com/p/158921398>`_ 

在地图上绘制散点
^^^^^^^^^^^^^^^^^

下面的示例实现了在指定经纬度上绘制不同大小的圆点标记。

.. code-block:: python

    lon = df['lon']
    lat = df['lat']
    size = df['高等院校总数']
    x, y = map(lon, lat)
    map.scatter(x, y, marker='.', color='blue', s=size)




fitz
====

图片转PDF
---------

下面的代码能够实现将目标文件夹内的同类型图片按顺序合并为一个PDF文件。需要导入 :code:`import fitz` ， :code:`import os` ， :code:`import re` 。该函数代码需要传入图片所在目录、图片类型、合并PDF的名称。下面是一个示例：

.. code-block:: python

	img_path = r'C:\Users\25281\Desktop\工作文件\学校相关资料\课程相关\大二上\电路原理\作业\第6周'
	imgType = '.jpg'
	combined_pdf_name = '06电路原理.pdf'

具体实现的函数代码如下：

.. code-block:: python

	def img_to_pdf(img_path, imgType, combined_pdf_name):
	    doc = fitz.open()  # 打开一个用于存放pdf信息的空doc

	    for fileName_in_img_path in os.listdir(img_path):  # 从目录中依次获取每一个文件名
	        obj = re.compile(r"(?P<imgName>.*?){}".format(imgType), re.S)  # 正则表达式寻找.png后缀的文件
	        result = obj.finditer(fileName_in_img_path)  # 将目录名放入匹配器，并将匹配结果的迭代器存储到result变量中
	        for it in result:  # 从迭代器里面获取img文件名进行操作
	            imgName = it.group('imgName')  # 获取png文件名
	            img_file = img_path + '\\' + imgName + imgType  # 获取完整的img文件路径
	            imgdoc = fitz.open(img_file)  # 打开img文件获取图片数据
	            pdfbytes = imgdoc.convert_to_pdf()  # 将图片数据转换为pdf格式数据
	            subPDF_name = imgName + '.pdf'  # 获取子pdf文件名，以原img文件名字命名
	            imgpdf = fitz.open(subPDF_name, pdfbytes)  # 将子pdf文件名与pdf格式数据打开为pdf文件
	            doc.insert_pdf(imgpdf)  # 将上述pdf文件插入到doc当中

	    doc_position = img_path + '\\' + combined_pdf_name
	    doc.save(doc_position)  # 将doc保存到目标路径
	    doc.close()
	    return



matplotlib
==========

最常用的模块是matplotlib.pyplot，一般的导入方式都是 :code:`import matplotlib.pyplot as plt` 。

显示方式
---------

图片大小
^^^^^^^^^

通过 :code:`plt.figure(figsize=(10, 10))` 的方式来控制图片大小，其含义为“设置的画布大小为10英寸×10英寸”。可以在保存图片的时候设置dpi，例如 :code:`plt.savefig('test.jpg', dpi=100)` 表示保存图片为100像素/英寸，那么实际保存的图片大小就是1000像素×1000像素。

只是像上面那样设定的话，输出的图片会有明显的边缘留白。如果需要完全去除周边空白，可以通过设置 :code:`bbox_inches` 参数来实现，例如 :code:`plt.savefig('test.jpg', bbox_inches='tight')` 。当设置为 :code:`bbox_inches='tight'` 时，可以进一步设置 :code:`pad_inches` 的值来自定义边框宽度（默认是0.1英寸），例如 :code:`plt.savefig('test.jpg', bbox_inches='tight', pad_inches=1)` 。


.. attention:: 但是需要注意，通过 :code:`bbox_inches='tight'` 设置得到的图片会让之前的图片大小设置失效。


如果完全不想留白，并且想保留对输出图片大小的设置，那么可以改用

.. code-block:: python

    plt.subplots_adjust(top=1, bottom=0, right=1, left=0, hspace=0, wspace=0)
    plt.margins(0, 0)
    plt.savefig('test.jpg', dpi=100)



文字显示与字体
^^^^^^^^^^^^^^

要想让matplotlib生成的图表正常显示负号，需要加入以下代码：

.. code-block:: python

    plt.rcParams['axes.unicode_minus'] = False    # 显示负号


要想让matplotlib.pyplot生成的图表支持中文，需要加入以下代码：

.. code-block:: python

    plt.rcParams['font.sans-serif'] = ['SimHei']  # 中文

但是这样会让图表所有部分的字体都设置为黑体，所以如果有更细致的需求，可以在每个需要文字显示的函数中添加 :code:`family` 参数设置，例如

.. code-block:: python

    plt.title("Study3\nFalse Headline", family="Times New Roman")
    plt.xlabel("Sharing Likelyhood", family="Times New Roman")
    plt.ylabel("Frequency", family="Times New Roman")
    plt.xticks(x, xLabel, family="Times New Roman")
    plt.yticks(np.arange(0, 0.7, 0.1), family="Times New Roman")

文字大小都可以通过各个函数的 :code:`size` 参数来设置。

上面设置的方法对于全英文或全中文的情况较为有效，但是对于中英文和公式混合的情况，则可以考虑用下面的方案，参考 `Matplotlib 中英文及公式字体设置 <https://zhuanlan.zhihu.com/p/118601703>`_ 

.. code-block:: python

	import matplotlib.pyplot as plt
	from matplotlib import rcParams

	config = {
	    "font.family":'serif',
	    "font.size": 12,
	    "mathtext.fontset":'stix',
	    "font.serif": ['SimSun'],
	    "axes.unicode_minus": False
	}
	rcParams.update(config)

之后中文则正常书写，英文则写在Latex公式内部使用mathrm环境，即可实现中文用宋体、英文和公式用Times New Roman的效果。



线条样式
^^^^^^^^

:code:`plt.plot()` 函数包含下面的可调控参数：

* :code:`linestyle` ：指定折线的类型，默认是实线。
* :code:`linewidth` ：指定折线的宽度。
* :code:`marker` ：可以为折线图添加点，该参数设置点的形状。
* :code:`markersize` ：设置点的大小。
* :code:`markeredgecolor` ：设置点的边框色。
* :code:`markerfacecolor` ：设置点的填充色。
* :code:`markeredgewidth` ：设置点的边框宽度。
* :code:`label` ：添加折线图的标签，类似于图例的作用。
* :code:`color` ：线条的颜色。
* :code:`alpha` ：设置图形的透明度。


使用 :code:`plt.style.available` 输出matplotlib.pyplot提供的所有风格名称，共计26种，各种样式的效果可以参考 `matplotlib04-绘图风格 <https://zhuanlan.zhihu.com/p/158237088>`_  。要使用某种预设的样式时，只需要像如下方式调用即可：

.. code-block:: python

	plt.style.use('ggplot')


如果需要调整 **线条的颜色** ，可以修改 :code:`plt.plot()` 函数的 :code:`color` 参数。有下面几种方式来进行赋值：

.. code-block:: python

	plt.plot(x, np.sin(x - 0), color='blue') # 标准颜色名称
	plt.plot(x, np.sin(x - 1), color='g') # 缩写颜色代码（rgbcmyk）
	plt.plot(x, np.sin(x - 2), color='0.75') # 范围在0~1的灰度值
	plt.plot(x, np.sin(x - 3), color='#FFDD44') # 十六进制（RRGGBB，00~FF）
	plt.plot(x, np.sin(x - 4), color=(1.0,0.2,0.3)) # RGB元组，范围在0~1 
	plt.plot(x, np.sin(x - 5), color='chartreuse'); # HTML颜色名称

也有一些常用颜色的缩写可以直接赋值使用：

+------+------+----------+
| 字符 | 颜色 | 英文全称 |
+======+======+==========+
| 'b'  | 蓝色 | blue     |
+------+------+----------+
| 'g'  | 绿色 | green    |
+------+------+----------+
| 'r'  | 红色 | red      |
+------+------+----------+
| 'c'  | 青色 | cyan     |
+------+------+----------+
| 'm'  | 品红 | magenta  |
+------+------+----------+
| 'y'  | 黄色 | yellow   |
+------+------+----------+
| 'k'  | 黑色 | black    |
+------+------+----------+
| 'w'  | 白色 | white    |
+------+------+----------+


如果需要调整 **线条样式** ，可以修改 :code:`linestyle` 参数。下面是一些常见的线条样式。

+------+--------+
| 字符 | 类型   |
+======+========+
| '-'  | 实线   |
+------+--------+
| '--' | 虚线   |
+------+--------+
| '-.' | 点划线 |
+------+--------+
| ':'  | 点线   |
+------+--------+

如果需要标出数据点， **数据点的形状** 可以通过 :code:`marker` 参数来设置，一些常见的数据点形状如下

+--------+--------------------------------+
| 字符   | 类型                           |
+========+================================+
| '.'    | 点                             |
+--------+--------------------------------+
| 'o'    | 圆圈                           |
+--------+--------------------------------+
| '*'    | 星形                           |
+--------+--------------------------------+
| 'x'    | 十字架                         |
+--------+--------------------------------+
| 's'    | 正方形                         |
+--------+--------------------------------+
| 'p'    | 五角星                         |
+--------+--------------------------------+
| 'D/d'  | 钻石/小钻石                    |
+--------+--------------------------------+
| 'h'    | 六角形                         |
+--------+--------------------------------+
| '+'    | 加号                           |
+--------+--------------------------------+
| '      | '   竖直线                     |
+--------+--------------------------------+
| 'v^<>' | 下三角、上三角、左三角、右三角 |
+--------+--------------------------------+
| '1234' | Tripod向下、向上、向左、向右   |
+--------+--------------------------------+


如果需要修改 **线条宽度** ，可以使用 :code:`linewidth` 参数来修改线条的粗细。默认情况下， :code:`linewidth` 设置为1个单位。利用线条的粗细可以在视觉上强调某条特定的曲线。


坐标轴与轴标签
^^^^^^^^^^^^^^

刻度范围设置
""""""""""""

如果希望自定义 **坐标轴上下限** ，最基础的方法是 :code:`plt.xlim()` 和 :code:`plt.ylim()` ，例如

.. code-block:: python

	plt.xlim(-1, 11) 
	plt.ylim(-1.5, 1.5)

如果你想要让 **坐标轴逆序显示** ，那么也可以逆序设置坐标轴刻度值，例如

.. code-block:: python

	plt.xlim(10, 0) 
	plt.ylim(1.2, -1.2)


还有一个方法是 :code:`plt.axis()` 。通过传入 :code:`[xmin, xmax, ymin, ymax]` 对应的值，可以只用一行代码就设置好x和y的限值：

.. code-block:: python

    plt.axis([-1, 11, -1.5, 1.5])

还可以用 :code:`plt.axis('tight')` 按照图形的内容 **自动收紧坐标轴** ，不留空白区域；使用 :code:`plt.axis('equal')` 让屏幕上显示的图形分辨率为1:1， **x轴单位长度与y轴单位长度相等** 。


刻度显示设置
""""""""""""

如果希望将原本的浮点数显示转变为 **百分数显示** 在坐标轴刻度，可以使用FuncFormatter函数。需要导入 :code:`from matplotlib.ticker import FuncFormatter` 。首先自定义转换浮点数为百分数刻度显示的函数：

.. code-block:: python

	def to_percent(temp, position):
	    """
	    用来将坐标轴的浮点数转换为百分比显示
	    :param temp: 坐标轴数据，一般由plt.gca().yaxis.set_major_formatter自动提供
	    :param position: 显示位置，一般由plt.gca().yaxis.set_major_formatter自动提供
	    :return: 百分比显示的str文字
	    """
	    return '%1.0f' % (100 * temp) + '%'

之后只需要在绘图代码中利用 :code:`plt.gca()` 修改对应坐标轴的显示格式即可。例如

.. code-block:: python

	plt.gca().yaxis.set_major_formatter(FuncFormatter(to_percent))  # 将y轴原本的浮点数转换为百分比显示


如果希望 **x轴的刻度改为使用中文名词** 来显示，可以使用 :code:`plt.xticks()` 函数来实现。首先需要有原本的数字刻度 :code:`x` ，以及将进行对应替换的名词列表 :code:`ticks_x` ，然后通过下面的方式进行调用：

.. code-block:: python

    plt.xticks(x, ticks_x, rotation=90)

其中 :code:`rotation` 参数设置的是文字的旋转程度。


框线显示设置
""""""""""""

如果要把上框线和右框线去掉，可以使用下面的函数实现：

.. code-block:: python

    plt.gca().spines['right'].set_color('none')
    plt.gca().spines['top'].set_color('none')


图形标签
^^^^^^^^

图形标题与坐标轴标题是最简单的标签，快速设置方法如下所示

.. code-block:: python

	plt.title("A Sine Curve") 
	plt.xlabel("x") 
	plt.ylabel("sin(x)")

在单个坐标轴上显示多条线时，创建图例显示每条线是很有效的方法。Matplotlib 内置了 :code:`plt.legend()` 用来创建图例，例如

.. code-block:: python

	plt.plot(x, np.sin(x), '-g', label='sin(x)') 
	plt.plot(x, np.cos(x), ':b', label='cos(x)') 
	plt.axis('equal')

	plt.legend()

定义图例的字体可以按照如下方式进行：

.. code-block:: python

    font = {
        'family': 'Times New Roman',
        'weight': 'normal',
        'size': 15
    }
    plt.legend(prop=font, frameon=False)



折线图(曲线图)
---------------

下面是进行折线图（曲线图）绘制的基本模板，根据需要修改 :code:`x` 、 :code:`y` 、图片大小、绘图风格、线条样式、标签、绘图范围、像素大小与图片名称。

首先需要先写入下面的代码以使得中文和负号正常显示：

.. code-block:: python

	import matplotlib.pyplot as plt
	from matplotlib import rcParams

	config = {
	    "font.family":'serif',
	    "font.size": 12,
	    "mathtext.fontset":'stix',
	    "font.serif": ['SimSun'],
	    "axes.unicode_minus": False
	}
	rcParams.update(config)

.. code-block:: python

	def draw_line_chart(x, y):
	    plt.figure(figsize=(10, 10))
	    plt.plot(x, y, linestyle='-', marker='.', color='red', label='line label', alpha=1)
	    plt.legend(loc='best')

	    plt.xlabel('x label')
	    plt.ylabel('y label')

	    plt.savefig('test.jpg', dpi=100, bbox_inches='tight', pad_inches=0.1)
	    return


对于分段函数，需要自行定义函数来描述每个自变量产生的值，通过 :code:`if` 语句分别返回不同的函数值，结合循环语句来生成数组。特别地，对于周期函数，最重要的是确定周期 :math:`T` ，然后使用取模运算 :code:`%` 来区分同一周期内的不同分段函数表达式。例如下面的函数就描述了一个具有周期的三角波。

.. code-block:: python

	def y_value(t_array):
	    t1 = 0.00037156
	    t2 = 6.13581111e-05
	    T = t1 + t2
	    result = []
	    for i in range(0, len(t_array)):
	        t = t_array[i] % T
	        if t < t1:
	            value = 900 - 870 * np.exp(-1000 * t)
	            result.append(value)
	        elif t1 <= t < T:
	            value = 17.647 + 282.353 * np.exp(-51000 * (t-t1))
	            result.append(value)
	    return result




多列柱状图
----------

下面给出一个通用的创建多列柱状图的函数代码。它要求分别传入x轴标签、柱状形标签和二维数据数组。这些内容都通过列表来记录，如果不希望产生柱状形标签，那么就传入一个空列表。例如下面是一个5组4列柱状图的数据集

.. code-block:: python
	
	xlabels = ['G1', 'G2', 'G3', 'G4', 'G5']
	bar_labels = ['1', '2', '3', '4']
	data1 = [20, 34, 30, 35, 27]
	data2 = [25, 32, 34, 20, 25]
	data3 = [21, 31, 37, 21, 28]
	data4 = [26, 31, 35, 27, 21]
	dataset = [data1, data2, data3, data4]

具体的绘图函数代码如下（已经导入 :code:`import matplotlib.pyplot as plt` 和 :code:`import numpy as np` ）。可以根据需要调整每组柱子之间的空隙、y轴标签、生成图片的文件名。如果希望生成图表标题，可以加入 :code:`plt.title('my title')` 。

.. code-block:: python

	def create_multi_bars(xlabels, bar_labels, dataset, tick_step=1, group_gap=0.2, bar_gap=0):
	    """
	    xlabels : x轴坐标标签序列
	    bar_labels : 一组中各柱子的图例
	    dataset ：数据集，二维列表，要求列表每个元素的长度必须与labels的长度一致
	    tick_step ：默认x轴刻度步长为1，通过tick_step可调整x轴刻度步长。
	    group_gap : 柱子组与组之间的间隙，最好为正值，否则组与组之间重叠
	    bar_gap ：每组柱子之间的空隙，默认为0，每组柱子紧挨，正值每组柱子之间有间隙，负值每组柱子之间重叠
	    """
	    ticks = np.arange(len(xlabels)) * tick_step  # ticks为x轴刻度
	    group_num = len(dataset)  # group_num为数据的组数，即每组柱子的柱子个数
	    group_width = tick_step - group_gap  # group_width为每组柱子的总宽度，group_gap 为柱子组与组之间的间隙。
	    bar_span = group_width / group_num  # bar_span为每组柱子之间在x轴上的距离，即柱子宽度和间隙的总和
	    bar_width = bar_span - bar_gap  # bar_width为每个柱子的实际宽度

	    # baseline_x为每组柱子第一个柱子的基准x轴位置，随后的柱子依次递增bar_span即可
	    baseline_x = ticks - (group_width - bar_span) / 2
	    for index, y in enumerate(dataset):
	        plt.bar(baseline_x + index * bar_span, y, bar_width)

	    plt.legend(bar_labels, loc='best')  # 设置各柱形图例
	    plt.ylabel('Scores')  # 设置y轴标签
	    plt.xticks(ticks, xlabels)  # x轴刻度标签位置与x轴刻度一致

	    plt.savefig('test.png')
	    return 



向量图
------

使用 :code:`quiver` 方法来绘制向量箭头，官方文档见 `matplotlib.pyplot.quiver <https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.quiver.html>`_ ，其调用方式为

.. code-block:: python

    matplotlib.pyplot.quiver(X, Y, U, V, C, **kw)

各参数的含义如下：

- :code:`X,Y` ：箭头起点的坐标位置。
- :code:`U,V` ：箭头矢量的x,y分量。
- :code:`C` ：映射箭头和颜色的颜色数组。
- :code:`units` ：箭头单位，可以选择 :code:`width` 或 :code:`height` 表示axes的宽高； :code:`dots` 或 :code:`inches` 表示像素或英寸，依赖设置的图片dpi； :code:`'x','y','xy'` 表示 :math:`x` , :math:`y` 或 :math:`\sqrt(x^{2}+y^{2})` 数据单位。

其他关于箭头形状设置的参数可以参考 `matplotlib 绘图命令：quiver <https://cloud.tencent.com/developer/article/1616767>`_  和 `matplotlib中矢量场quiver详解 <http://nightship.cn/index.php/archives/128/>`_ 。下面是一个绘制向量场的示例：

.. code-block:: python

	import matplotlib.pyplot as plt
	import numpy as np

	X, Y = np.meshgrid(np.arange(0, 2 * np.pi, .2), np.arange(0, 2 * np.pi, .2))
	U = np.cos(X)
	V = np.sin(Y)

	plt.figure()
	plt.title('Arrows scale with plot xy')
	Q = plt.quiver(X, Y, U, V, units='xy')

	plt.show()






三维绘图
--------

可以通过 :code:`plt.axes()` 函数的关键字 :code:`projection='3d'` 来实现三维坐标轴。例如

.. code-block:: python

    fig = plt.figure()
    ax = plt.axes(projection='3d')

使用 :code:`ax = fig.add_subplot(111, projection='3d')` 的形式可以画多个子图。

使用 :code:`ax.view_init()` 函数来修改三维视图的摄像机视角，需要设置 :code:`elev` 参数和 :code:`azim` 参数，其中elev沿着y轴旋转，azim沿着z轴旋转。当 :code:`elev=0, azim=0` 时，视角是沿x轴向y-z平面正视着看去；当 :code:`elev=45, azim=45` 时，视角是经典的正轴测视角。

在上面的坐标轴基础上，下面的案例演示了如何绘制 **三维曲线** 和 **散点图** ：

.. code-block:: python

    z = np.linspace(0,13,1000)
    x = 5*np.sin(z)
    y = 5*np.cos(z)

    zd = 13*np.random.random(100)
    xd = 5*np.sin(zd)
    yd = 5*np.cos(zd)

    ax.scatter3D(xd, yd, zd, cmap='Blues')  # 绘制散点图
    ax.plot3D(x, y, z, 'gray')    # 绘制空间曲线
    plt.savefig('test.png')

在上面坐标轴的基础上，下面的案例演示了如何绘制 **三维曲面** ：

.. code-block:: python

    xx = np.arange(-5,5,0.5)
    yy = np.arange(-5,5,0.5)
    X, Y = np.meshgrid(xx, yy)  # 形成网格二维数组
    Z = np.sin(X) + np.cos(Y)

    ax.plot_surface(X, Y, Z, cmap='rainbow')  # 也可以调整alpha参数改变曲面透明度
    plt.savefig('test.png')

使用 :code:`ax.contour()` 函数来绘制 **等高线** ，要设置 :code:`offset` 参数，为所需投影位置在投影轴的坐标。同时可以修改 :code:`zdir` 参数来生成不同方向的等高线投影。例如

.. code-block:: python

    ax.contour(X, Y, Z, zdir='z', offset=-3, cmap="rainbow")  #生成z方向投影，投到x-y平面
    ax.contour(X, Y, Z, zdir='x', offset=-6, cmap="rainbow")  #生成x方向投影，投到y-z平面
    ax.contour(X, Y, Z, zdir='y', offset=6, cmap="rainbow")   #生成y方向投影，投到x-z平面

如果使用 :code:`ax.contourf()` 函数，则得到的是“contour with fill”，即有填充颜色的等高线，例如 :code:`ax.contourf(X, Y, Z, zdir='y', offset=6, cmap="rainbow")` 。

如果加入渲染时的步长，会得到更加清晰细腻的图像，例如 :code:`ax.plot_surface(X, Y, Z, rstride = 1, cstride = 1,cmap='rainbow')` ，其中的 :code:`rstride` 和 :code:`cstride` 分别表示横竖方向的绘图采样步长，其参数越小绘图越精细。




numba
=====

官方文档见 `Numba documentation <https://numba.readthedocs.io/en/stable/index.html>`_ 

导入下面的函数来加速Python代码的运行速度：

.. code-block:: python

    from numba import jit, njit, vectorize

之后只需要在需要进行加速的函数前添加声明 :code:`@jit(nopython=True)` 或 :code:`@njit()` ，例如

.. code-block:: python

    @njit
    def original_function(input_array):
        output_array = np.zeros_like(input_array)
        for ii, item in enumerate(input_array):
            if item % 2 == 0:
                output_array[ii] = (2)
            else:
                output_array[ii] = (1)

        return output_array


.. note:: 

	上面的例子背后隐含了许多技巧：

	- 在使用numba加速的过程中，不要使用Python的原生列表list，而改用numpy的数组array。
	- 不要使用循环填入空列表的方式，而应该提前确定好输出列表的大小，也即应当预分配内存。


对于上面的例子，因为是对传入的数组中每个元素逐个处理，所以可以使用 :code:`@vectorize` 来加速，该模块可以将处理单个元素的函数等效应用到输入数组的每个元素上。上面的例子的等效处理如下：

.. code-block:: python

    @vectorize
    def scalar_computation(num):
        if num % 2 == 0:
            return 2
        else:
            return 1

    output_array = scalar_computation(input_array)



下面是一个实际应用案例，其描述了一个弹簧质点阻尼振荡系统，由二阶常系数微分方程表示：

.. math::
	\begin{align}
	&\dot{x} = Ax+Bu \\
	&y = Cx + Du 
	\end{align}

其中 :math:`A=\begin{bmatrix} 0 & 1 \\ -\frac{k}{m} & -\frac{\beta}{m}  \end{bmatrix}` ， :math:`B=\begin{bmatrix} 0 \\ 1\end{bmatrix}` ， :math:`C = \begin{bmatrix}1 & 0\end{bmatrix}` ， :math:`D = \begin{bmatrix} 0\end{bmatrix}` 。

下面是进行该系统模拟的代码：

.. code-block:: python

    @njit
    def friction_fn(v, vt):
        if v > vt:
            return - v * 3
        else:
            return - vt * 3 * np.sign(v)

    @njit
    def simulate_spring_mass_funky_damper(x0, T=10, dt=0.0001, vt=1.0):
        times = np.arange(0, T, dt)
        positions = np.zeros_like(times)

        v = 0
        a = 0
        x = x0
        positions[0] = x0/x0

        for ii in range(len(times)):
            if ii == 0:
                continue
            t = times[ii]
            a = friction_fn(v, vt) - 100 * x
            v = v + a * dt
            x = x + v * dt
            positions[ii] = x/x0
        return times, positions


后续可以用 :code:`plot(*simulate_spring_mass_funky_damper(0.1))` 来查看图像情况。


直接运行上面的代码已经可以很好地处理传入一个初始条件x0的情况了，而更进一步地，如果需要对一系列不同的初始条件进行处理（例如从x0从0.1到1000），则还可以采用并行的方式来加速。首先需要将之前函数的声明修改为 :code:`@njit(nogil=True)` 以释放全局锁，使用Python原生的并行操作的方法如下：

.. code-block:: python

    from concurrent.futures import ThreadPoolExecutor

    with ThreadPoolExecutor(4) as ex:
        ex.map(simulate_spring_mass_funky_damper, np.arange(0.1, 1000, 0.1))


或者使用numba提供的并行方式：

.. code-block:: python

    from numba import prange

    @njit(parallel=True)
    def run_sims(end=1000):
        for ii in prange(int(end/0.1)):
            if ii == 0:
                continue
            simulate_spring_mass_funky_damper(ii*0.1)




.. note:: 

	- 固定输入输出数据类型可以加速编译过程，例如输入一个int16和int16一维数组，输出由两个int16数字组成的元组可以声明为 :code:`@njit("UniTuple(int16,2)(int16,int16[:])")` 。同时尽量减少内存开销，能用int16就不要使用int32.
	- 使用了njit后就不要拘泥于Pythonic的编程思路，可以采用for和While循环。
	- 多考虑循环的必要性。用移动下标的方法会比两重循环高效。


numba支持的函数输入输出类型声明包括：

- :code:`void` ：无返回值。
- :code:`intp` , :code:`uintp` ：指针大小的整数(分别为有符号和无符号)。
- :code:`intc` , :code:`uintc` ：等价于C语言中的 :code:`int` 和 :code:`unsigned int` 整数类型。
- :code:`int8` , :code:`uint8` , :code:`int16` , :code:`uint16` , :code:`int32` , :code:`uint32` , :code:`int64` , :code:`uint64` ：对应位宽的固定宽度整数(有符号和无符号)。
- :code:`float32` , :code:`float64` ：分别是单精度浮点数和双精度浮点数。
- :code:`complex64` , :code:`complex128` ：分别是单精度复数和双精度复数。
- 通过索引来表示数组类型，例如 :code:`float64[:]` 表示一维双精度数数组， :code:`int8[:,:]` 表示二维8-bit整数数组。


另一个实际案例则通过明确函数的输入输出类型来加快编译速度：

.. code-block:: python

    @njit("float64(float64)")
    def func1(uc):
        return -1000 * uc + 900000


    @njit("float64(float64)")
    def func2(uc):
        return -51000 * uc + 900000

    @njit("float64[:](float64, float64[:], float64)")
    def ode_func(uc0, T_array, dt):
        flag = True
        uc = np.zeros(shape=(len(T_array),))
        uc[0] = uc0
        for i in range(len(uc) - 1):
            if flag:
                k1 = func1(uc[i])
                k2 = func1(uc[i] + dt/2 * k1)
                k3 = func1(uc[i] + dt/2 * k2)
                k4 = func1(uc[i] + dt * k3)
            else:
                k1 = func2(uc[i])
                k2 = func2(uc[i] + dt / 2 * k1)
                k3 = func2(uc[i] + dt / 2 * k2)
                k4 = func2(uc[i] + dt * k3)

            duc = dt / 6 * (k1 + 2 * k2 + 2 * k3 + k4)
            uc[i + 1] = uc[i] + duc

            if uc[i + 1] > 300 and duc > 0:
	            flag = False
            elif uc[i + 1] < 30 and duc < 0:
                flag = True
        return uc		

    dt = 1e-9
    T_array = np.arange(0, 0.01, dt)
    uc = generate_triangular_wave(0, T_array, dt)







numpy
=====

numpy模块一般的导入方式都是 :code:`import numpy as np` 。

基本数学运算
------------

numpy提供了各种三角函数。例如 :code:`np.sin()` ， :code:`np.cos()` ， :code:`np.tan()` ， :code:`np.arcsin()` ， :code:`np.arccos()` ， :code:`np.arctan()` 。需要注意的是，这些三角函数的计算内容应该是弧度制，所以对于以角度为单位的数 :code:`degree` ，需要通过 :code:`degree*np.pi/180` 来将角度转换为弧度。而弧度可以利用 :code:`np.degrees()` 函数来将其转换为角度。

在指数运算方面，numpy提供了自然常数e为底的指数函数 :code:`np.exp()` ，一般的指数计算可以使用 :code:`np.power(a, b)` 来计算 :math:`a^{b}` 。

在对数运算方面，nump提供了自然常数e为底的对数函数 :code:`np.log()` 和以10为底的对数函数 :code:`np.log10()` 。



数据类型转换
------------

numpy数据类型转换需要调用方法 :code:`astype()` ，例如 :code:`np.array(x).astype(int)` 。调用astype返回进行了数据类型修改后的数据，但是源数据的类型不会变，需要进一步对源数据的使用dtype进行操作才能改变，例如 :code:`a.astype(np.int16)` 。但是，没有使用astype而直接修改dtype数据会强制用新数据类型表示，将会导致输出错误数据。



生成序列
---------

生成一维序列可以使用 :code:`linspace` 函数，能够通过指定区间开始和结尾及点个数来生成序列。其调用方式为

.. code-block:: python

    numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None, axis=0)

各参数的含义如下：

- :code:`start` ：序列开始的值。
- :code:`stop` ：序列结束的值。
- :code:`num` ：生成序列点的数量。默认为50个。
- :code:`endpoint` ：用来控制序列末尾是开区间还是闭区间。默认是闭区间。

函数将返回一个数组对象。

另外一个用来生成一维序列的函数为 :code:`arange` ，能够通过指定区间开始和结尾及步长来生成序列。其调用方式为

.. code-block:: python

    numpy.arange(start=0, stop, step=1, dtype=None, like=None)

一般有三种使用方式：

- :code:`arange(stop)` ：只传入结尾点，函数将返回左开右闭序列 :code:`[0, stop)` ，且步长为1。
- :code:`arange(start, stop)` ：传入开始和结尾，函数将返回左开右闭序列 :code:`[start, stop)` ，且步长为1。
- :code:`arange(start, stop, step)` ：传入开始、结尾和步长，函数将返回左开右闭序列 :code:`[start, stop)` ，且步长为指定的step。


interp线性插值
----------------

:code:`np.interp()` 能够进行一维线性插值，返回离散数据的一维分段线性插值结果。其参数与返回值情况如下：

- x: 数组。待插入数据的横坐标。
- xp：一维浮点数序列。原始数据点的横坐标，如果period参数没有指定那么就必须是递增的。否则，在使用 :code:`xp = xp % period` 正则化之后，xp在内部进行排序。
- fp：一维浮点数或复数序列。原始数据点的纵坐标，和xp序列等长。
- left：可选参数，类型为浮点数或复数（与fp值对应）。作为 :code:`x < xp[0]` 时的返回值，默认为 :code:`fp[0]` 。
- right：可选参数，类型为浮点数或复数（与fp值对应）。作为 :code:`x > xp[-1]` 时的返回值，默认为 :code:`fp[-1]` 。
- period：None或者浮点数，可选参数。横坐标的周期.。此参数使得可以正确插入angular x-coordinates。如果该参数被设定，那么会忽略left参数和right参数。
- 返回值：浮点数或复数（对应于fp值）或ndarray。插入数据的纵坐标，和x形状相同。
  
需要注意的是，在没有设定 :code:`period` 参数时，默认要求xp参数必须是递增的。

一种使用案例是根据标定好的二维数据组进行直线内插值。例如，通过实验标定得知电子管阴极电流 :math:`I_{f}` 与温度的对应关系分别为列表 :code:`xp` 和 :code:`fp` ，通过实验测量得到的 :math:`I_{f}` 序列为 :code:`x` ，那么通过调用 :code:`np.interp()` 函数即可得到对应的直线内插值序列：

.. code-block:: python

	xp = [0.500, 0.550, 0.600, 0.650, 0.700]
	fp = [1726, 1809, 1901, 1975, 2059]

	x = [0.51, 0.54, 0.57, 0.60, 0.64, 0.68]
	y = np.interp(x, xp, fp)
	


计算标准差
----------

:code:`np.std()` 能够计算给定数组沿指定轴线的标准差。其参数和返回值情况如下：

- arr：数组。输入数组来计算标准差。
- axis： :code:`None`, :code:`int` 或元素为 :code:`int` 的元组。计算标准差的轴。 :code:`axis=0` 表示沿列计算标准差， :code:`axis=1` 表示沿行计算标准差。如果给定该参数，那么就会把多维数组视为一个扁平化的列表。
- dtype： :code:`dtype` 或 :code:`None` 。在计算标准差时使用的数据类型，默认为 :code:`float64` 。



pandas
======

该模块的一般导入方式为 :code:`import pandas as pd` 。



文件的读取与保存
----------------

pandas打开文件的函数有三种，分别对应三类文件，如下所示

+-------------+-----------------------------+-----------------+
| 数据类型    | 说明                        | pandas读取方式  |
+=============+=============================+=================+
| csv,tsv,txt | 用逗号、tab分隔的纯文本文件 | pd.read_csv()   |
+-------------+-----------------------------+-----------------+
| excel       | xls或xlsx文件               | pd.read_excel() |
+-------------+-----------------------------+-----------------+
| mysql       | 关系型数据库表              | pd.read_sql()   |
+-------------+-----------------------------+-----------------+

详细可见 :code:`read_excel()` 的 `read_excel官方文档 <https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_excel.html>`_ 和 :code:`read_csv()` 的 `read_csv官方文档 <https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html>`_ 






表格的行列显示
--------------

通过下面的代码来解决DataFrame行列显示不全的问题：

.. code-block:: python

	pd.set_option('display.max_rows', 1000)
	pd.set_option('display.max_columns', 1000)
	pd.set_option('display.width', 5000)


表格的合并
----------

如果需要将表格直接合并，可以使用 :code:`concat()` 函数来实现。其基本调用方式如下：

.. code-block:: python

    pandas.concat(objs, axis=0, join='outer', ignore_index=False, keys=None, levels=None, names=None, verify_integrity=False, sort=False, copy=True)

其中各参数的含义如下：

- :code:`objs` ：需要进行合并的表格序列，一般通过list来传入。
- :code:`axis` ：表格进行合并的方向。 :code:`axis=0` 表示各个表格上下进行合并； :code:`axis=1` 表示各个表格左右进行合并。
- :code:`join` ：合并方式。可选的方式有 :code:`inner, outer` ，默认是 :code:`outer` ，因为列名不匹配而空出的部分会用 :code:`NaN` 填充。
- :code:`ignore_index` ：如果采用默认的False，那么列表合并之后的index还是原来的；如果设置为True，那么会在合并后重新按顺序设置index，效果相当于 :code:`reset_index(drop=True)` 。
- :code:`sort` ：连接方式为 :code:`outer` 时，如果连接时存在不匹配的部分，设置为True后可以将这些存在NaN填充的列排到最后。当连接方式为 :code:`inner` 时此参数不起作用。


如果需要根据其中某列的共同数据来将两个表格进行合并，可以使用 :code:`merge()` 函数来实现。其基本的调用方式如下：

.. code-block:: python

    pandas.merge(left, right, how='inner', on=None, left_on=None, right_on=None, left_index=False, right_index=False, sort=False, suffixes=('_x', '_y'), copy=True, indicator=False, validate=None)

其中各参数的含义如下：

- :code:`left` ：用于合并的表格，必须是DataFrame。
- :code:`right` ：用以与上面的表格进行合并的表格，可以是DataFrame或Series。
- :code:`how` ：合并表格的依据。可以选择的有 :code:`'left', 'right', 'outer', 'inner', 'cross'` ，默认是 :code:`inner` 。各种依据的实现效果可以参考 `DataFrame的合并merge() <https://zhuanlan.zhihu.com/p/344353519>`_ 
- :code:`on` ：连接的列名依据，必须两个表格共有。
- :code:`left_on` 和 :code:`right_on` ：如果合并列表的依据列的列名并不相同，可以改为使用这两个参数来分别指定，效果同 :code:`on` 。
- :code:`indicator` ：如果设置为 :code:`True` ，则会自动添加一列「_merge」，其中包含了各行的合并情况，	分为「left_only」、「right_only」和「both」。可以配合 :code:`query('_merge == "left_only"')` 函数来实现快速查找。




剔除表格重复行
--------------

通过 :code:`drop_duplicates()` 函数来将Series中重复的元素替换为 :code:`NaN` ，之后配合 :code:`dropna()` 函数来将其剔除掉。下面是一个完整的操作示例：

.. code-block:: python

    df['tte_time'] = df['tte_time'].drop_duplicates()
    df = df.dropna(axis=0)
    df = df.reset_index(drop=True)


按列对数据进行函数处理
----------------------

对于Series对象，使用的是 :code:`map()` 函数；对于DataFrame对象，使用的是 :code:`apply()` 函数。对Series操作时，不需要指定方向；对DataFrame操作时，需要指定 :code:`axis=1` 来按列操作。下面是使用示例：

.. code-block:: python

	df['posatt_time'] = df['posatt_time'].map(lambda x: int(x) + 1514736000 + 8 * 3600)
	df['voltage'] = df.apply(lambda x: calculate_voltage(x['current'], x['resistance']), axis=1)




筛选符合条件的数据
-------------------

直接对DataFrame的列使用逻辑判断运算会得到对应的包含bool判断结果的Series，例如

.. code-block:: python

    df['valid_value_judge'] = ((df.E0 > 40) & (df.E0 < 3000))
    df['invalid_value_judge'] = ((df.E0 <= 40) | (df.E0 >= 3000))

再配合 :code:`sum()` 函数可以实现对符合判断结果的数据进行统计。


re
====

正则表达式
----------

可以在 `正则表达式在线测试 <https://c.runoob.com/front-end/854/>`_ 测试自己的正则表达式效果。


下面是常用的具有固定含义的特殊符号（元符号）：

+--------+----------------------------------+
| 元符号 | 功能                             |
+========+==================================+
| .      | 匹配除了换行符以外的任意字符     |
+--------+----------------------------------+
| \\w    | 匹配字母或数字或下划线           |
+--------+----------------------------------+
| \\s    | 匹配任意的空白符                 |
+--------+----------------------------------+
| \\d    | 匹配数字                         |
+--------+----------------------------------+
| \\n    | 匹配一个换行符                   |
+--------+----------------------------------+
| \\t    | 匹配一个制表符                   |
+--------+----------------------------------+
| ^      | 匹配字符串的开始                 |
+--------+----------------------------------+
| $      | 匹配字符串的结尾                 |
+--------+----------------------------------+
| \\W    | 匹配字母或数字或下划线以外的内容 |
+--------+----------------------------------+
| \\D    | 匹配非数字                       |
+--------+----------------------------------+
| \\S    | 匹配非空白符                     |
+--------+----------------------------------+
| a|b    | 匹配字符a或字符b                 |
+--------+----------------------------------+
| ()     | 匹配括号内的表达式，也表示一个组 |
+--------+----------------------------------+
| [...]  | 匹配字符组中的字符，用-表示范围  |
+--------+----------------------------------+
| [^...] | 匹配除了字符组中字符的所有字符   |
+--------+----------------------------------+

可以使用量词来控制前面元符号出现的次数

+----------+------------------+
| 量词符号 | 功能             |
+==========+==================+
| \*       | 重复零次或更多次 |
+----------+------------------+
| \+       | 重复一次或更多次 |
+----------+------------------+
| ?        | 重复零次或一次   |
+----------+------------------+
| {n}      | 重复n次          |
+----------+------------------+
| {n,}     | 重复n次或更多次  |
+----------+------------------+
| {n,m}    | 重复n到m次       |
+----------+------------------+


在爬虫里面常用的两种匹配有 **贪婪匹配** 和 **惰性匹配** ，分别通过 :code:`.*` 和 :code:`.*?` 来实现。贪婪匹配的意思是在符合其他限制的前提下，尽可能多地匹配内容；惰性匹配的意思是在符合其他限制的前提下，尽可能少地匹配内容。惰性匹配的实现是在贪婪匹配的基础之上的，先遍历所有字符查找到最远的匹配字符，得到最长的符合匹配要求的字符串，然后反过来回溯寻找最先遇到的匹配字符，得到最短的符合匹配要求的字符。



re模块匹配分析
--------------

使用 :code:`findall()` 函数可以匹配字符串中所有符合正则的内容，返回一个列表。例如

.. code-block:: python

	mypattern = r"\d+"
	content = "Koishi的电话号码是：10086，Satori的电话号码是：10010"
	lst = re.findall(mypattern, content)
	print(lst)


使用 :code:`finditer()` 函数来匹配内容则会返回迭代器，可以通过循环来得到匹配内容。迭代器里面的是match对象，需要用 :code:`group()` 函数来获取数据。例如

.. code-block:: python

	mypattern = r"\d+"
	content = "Koishi的电话号码是：10086，Satori的电话号码是：10010"
	it = re.finditer(mypattern, content)
	for item in it:
	    print(item.group()) 


上面的匹配函数是来寻找所有匹配内容的。使用 :code:`search()` 函数则只会匹配第一个符合的内容，返回的是match对象，同样需要用 :code:`group()` 函数来获取数据。例如

.. code-block:: python

	mypattern = r"\d+"
	content = "Koishi的电话号码是：10086，Satori的电话号码是：10010"
	s = re.search(mypattern, content)
	print(s.group())

:code:`match()` 函数是从头开始匹配，可以理解为是在 :code:`search()` 函数的基础上，自动在正则表达式前面加上了 :code:`^` 。


有时候正则表达式非常复杂，并且在爬虫时经常使用到，就可以用 :code:`compile()` 函数来将正则表达式预加载来提高效率。例如

.. code-block:: python

	mypattern = r"\d+"
	content = "Koishi的电话号码是：10086，Satori的电话号码是：10010"

	obj = re.compile(mypattern)
	result = obj.finditer(content)
	for item in result:
	    print(item.group())


接下来就从正则表达式匹配到的内容分别获取所需数据。核心就是在原本的匹配符号添加小括号，并添加标签，例如 :code:`(?P<id>\d+)` ，其中的 :code:`<>` 内包含的字符为标签名称，可以赋值给 :code:`group()` 函数来获取对应数据。下面是一个简单的示例：

.. code-block:: python

	content = """
	<div class='koishi'><span id='1'>古明地恋</span></div>
	<div class='Satori'><span id='2'>古明地觉</span></div>
	"""

	mypattern = r"<div class='.*?'><span id='(?P<id>\d)'>(?P<name>.*?)</span></div>"

	obj = re.compile(mypattern, re.S)  # re.S能让.匹配换行符
	result = obj.finditer(content)
	for item in result:
	    print(item.group('id'))
	    print(item.group('name'))




requests
=========

获取网址响应
------------

下面是一个获取搜索页面响应源代码内容的爬虫代码。

.. code-block:: python

	import requests

	url = 'https://www.sogou.com/web?query=古明地恋'
	resp = requests.get(url)
	print(resp.text)
	resp.close()

.. note:: 从直接从网页url得到的响应都是 :code:`get` 类型的。



事实上，上面的代码没有成功获取页面源代码，因为没有通过用户检测。要想处理这个反爬手段，可以添加请求头来使请求更像正常请求。在浏览器页面中右键选择「检查」，选择「网络」标签，查看对应请求的标头，找到「user-agent」，将对应的内容复制添加到代码响应头当中，即可成功爬取网页源代码。

.. code-block:: python

	import requests

	url = 'https://www.sogou.com/web?query=古明地恋'
	myheaders = {
	    "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36 Edg/107.0.1418.42"
	}
	resp = requests.get(url, headers=myheaders)
	print(resp.text)
	resp.close()


如果不是网页url的响应，就需要通过浏览器F12在「网络」处检查自己所需的内容是在哪个地方请求出来的。下面以爬取百度翻译翻译结果为例进行说明。首先进入百度翻译网页 :code:`https://fanyi.baidu.com/` ，按下F12进入浏览器开发者界面，观察「网络」情况，然后以英文输入法在搜索框输入「dog」，在事件中查看「预览」，可以发现所需的翻译结果在「sug」事件里面。通过查看其标头可知请求URL为 :code:`https://fanyi.baidu.com/sug` ，请求方法为 :code:`POST` ，而自己传入的数据「dog」是在「负载」当中以「kw: dog」的形式传入的。于是爬取的代入如下：

.. code-block:: python

	import requests

	url = "https://fanyi.baidu.com/sug"

	mydata = {
	    "kw": "dog"
	}

	resp = requests.post(url, data=mydata)
	print(resp.json())
	resp.close()

.. note:: 发送post请求时，发送的数据必须放在字典中，通过 :code:`data` 参数进行传递。



有的响应内容会更加复杂，请求URL也更加复杂。下面以爬取豆瓣电影分类排行榜-喜剧片为例进行说明。首先进入对应的网页界面，按下F12进入开发者工具观察「网络」情况，刷新页面以获取响应。直接查看「全部」响应过于繁杂，常见的二级反馈内容可以在「Fetch/XHR」中看到，在这个案例中就是在其中的第三个事件的「预览」当中可以找到所需数据。可以看到请求URL为 :code:`https://movie.douban.com/j/chart/top_list?type=24&interval_id=100%3A90&action=&start=0&limit=20` ，请求方法为 :code:`GET` 。

但是直接使用该URL过于冗杂，而其实际上是通过自动传入的数据形成的，可以在「负载」里面看到传入的对应数据，将其复制下来作为将要传入的字典，这时请求URL就简化为了原本 :code:`?` 之前的url，可以通过 :code:`print(resp.request.url)` 来验证。

.. note:: 因为是GET方法，所以就不再是通过POST方法的 :code:`data` 参数传入，而是通过GET方法的 :code:`params` 参数传入。

.. code-block:: python

	import requests

	url = "https://movie.douban.com/j/chart/top_list"

	myparams = {
	    "type": "24",
	    "interval_id": "100:90",
	    "action": "",
	    "start": 0,
	    "limit": 20
	}

	resp = requests.get(url=url, params=myparams)
	print(resp.text)
	resp.close()

实际上，上面的代码没有返回任何数据，说明程序被反爬了，接下来要尝试各种破解手段。首先考虑的应该是添加user-agent。

.. code-block:: python

	import requests

	url = "https://movie.douban.com/j/chart/top_list"

	myparams = {
	    "type": "24",
	    "interval_id": "100:90",
	    "action": "",
	    "start": 0,
	    "limit": 20
	}

	myheaders = {
	    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36 Edg/107.0.1418.42"
	}

	resp = requests.get(url=url, params=myparams, headers=myheaders)
	print(resp.json())
	resp.close()


上述代码就成功爬取到了所需内容。进一步观察可以发现，网页下拉可以加载更多数据，而对应到事件标头可以发现，只是将「负载」中的参数 :code:`start` 对应的数字进行递增而已，其他没有任何变化，于是就可以通过循环爬取更多内容。


爬虫案例
----------

使用re模块进行数据提取的案例
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

下面来爬取豆瓣电影top250的信息数据，需要爬取电影名、年份、评分、评分人数四类数据。其网址为 :code:`https://movie.douban.com/top250` ，可以发现所需数据直接放在了网页页面源代码上，所以是通过 :code:`GET` 方法来获取响应。

.. code-block:: python

	import requests
	import re

	url = "https://movie.douban.com/top250"

	myheaders = {
	    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36 Edg/107.0.1418.42"
	}

	resp = requests.get(url, headers=myheaders)
	page_content = resp.text
	resp.close()

通过观察页面源代码，满足需求的正则表达式如下：

.. code-block:: python

	pattern1 = r'<li>.*?<span class="title">(?P<name>.*?)</span>'
	pattern2 = r'<br>(?P<year>.*?)&nbsp'
	pattern3 = r'<span class="rating_num" property="v:average">(?P<score>.*?)</span>'
	pattern4 = r'<span>(?P<num>.*?)人评价</span>'
	mypattern = pattern1 + '.*?' + pattern2 + '.*?' + pattern3 + '.*?' + pattern4

	obj = re.compile(mypattern, re.S)  # 注意要re.S让.匹配换行符
	result = obj.finditer(page_content)
	for item in result:
	    print(item.group('name'))
	    print(item.group('year').strip())  # 去掉空白与换行
	    print(item.group('score'))
	    print(item.group('num'))

上面的代码说明已经能够提取出所需数据了，接下来配合csv模块将爬取的数据写入到csv文件当中，需要导入 :code:`import csv` 。


.. code-block:: python

	obj = re.compile(mypattern, re.S)  # 注意要re.S让.匹配换行符
	result = obj.finditer(page_content)

	with open('test.csv', mode='w', newline='') as f:
	    csvwriter = csv.writer(f)
	    for item in result:
	        dic = item.groupdict()
	        dic['year'] = dic['year'].strip()
	        csvwriter.writerow(dic.values())


.. attention:: 如果在 :code:`open()` 函数里面没有添加 :code:`newline=''` 参数设置，会导致最后的csv文件存在空行。


仔细观察原网页，可以发现点击第2页的时候url变成了 :code:`https://movie.douban.com/top250?start=25&filter=` ，可以观察到 :code:`start=25` 控制了页面显示的内容。通过循环赋值修改url，可以逐步爬取到排行榜所有的信息。




scipy
=====

插值
------

Lagrange插值
^^^^^^^^^^^^^

使用 :code:`scipy.interpolate` 模块的 :code:`lagrange` 方法来实现拉格朗日插值，其返回的是一个拉格朗日插值多项式函数，可以传入参数来得到插值结果。官方文档见 `scipy.interpolate.lagrange <https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.lagrange.html>`_ 

.. code-block:: python

    from scipy.interpolate import lagrange

    def interp_lagrange(x, y, x_fit):
        fit_func = lagrange(x, y)
        y_fit = fit_func(x_fit)
        return y_fit


Hermite插值
^^^^^^^^^^^

使用 :code:`scipy.interpolate` 模块的 :code:`KroghInterpolator` 方法来实现埃尔米特插值，其返回的是一个埃尔米特插值多项式函数，可以传入参数来得到插值结果。官方文档见 `scipy.interpolate.KroghInterpolator <https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.KroghInterpolator.html#scipy.interpolate.KroghInterpolator>`_ 

下面是解决埃尔米特插值问题的代码，需要传入节点横坐标、节点纵坐标、节点一阶导值和待插值横坐标。

.. code-block:: python

    from scipy.interpolate import KroghInterpolator

	def interp_hermite(x, y, yprime, x_fit):
	    x_array = np.repeat(x, 2)
	    y_array = np.dstack((y, yprime)).reshape((len(y)+len(yprime),))
	    fit_func = KroghInterpolator(x_array, y_array)
	    y_fit = fit_func(x_fit)
	    return y_fit

.. attention:: 该方法要求自变量x是递增的。


实际上，  :code:`KroghInterpolator` 能够解决任意的额外要求节点导数条件的插值问题，只需要在重复的横坐标 :code:`x` 对应的 :code:`y` 依次填入一阶导、二阶导等即可。



样条插值
^^^^^^^^

前面提到的埃尔米特插值由于需要用到导数值，所以在实际应用中并不常见。样条插值则能只根据节点值来得到连续光滑的曲线。可以使用 :code:`scipy.interpolate` 模块的 :code:`splev, splrep` 方法来实现样条插值，官方文档见 `scipy.interpolate.splrep <https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.splrep.html#scipy.interpolate.splrep>`_ 

.. code-block:: python

    from scipy.interpolate import splev, splrep

    def bspine_interp(x, y, x_fit):
        spl = splrep(x, y)
        y_fit = splev(x_fit, spl)
        return y_fit



数值导数
----------

使用 :code:`scipy.misc` 模块下的 :code:`derivative` 函数来计算函数在某点处的导数值。其调用方式为

.. code-block:: python

    scipy.misc.derivative(func, x0, dx=1.0, n=1, args=(), order=3)

其中各参数的含义如下：

- :code:`func` ：需要计算导数值的函数表达式。
- :code:`x0` ：计算导数值对应的横坐标，类型为 :code:`float` 。
- :code:`dx` ：步长间隔。将步长减小过小会导致舍入误差。
- :code:`n` ：求导阶数。默认为一阶导。
- :code:`order` ：用于计算的点数，必须是奇数整型。
  
一般的导入方式是 :code:`from scipy.misc import derivative` ，下面是一个简单的示例，计算了 :math:`\frac{\mathrm{d}(x^{3}+x^{2})}{\mathrm{d}x}\bigg|_{x=1}` ：

.. code-block:: python

    f = lambda x : x**3 + x**2
    result = derivative(f, 1.0, dx=1e-6)



数值积分
--------

一重积分
^^^^^^^^

使用 :code:`scipy.integrate` 库中的 :code:`quad` 函数进行一重积分。其调用方式为 :code:`scipy.integrate.quad(f，a，b)` ，各参数的含义如下：

- :code:`f` ：被积函数。
- :code:`a` ：积分下限的值。
- :code:`b` ：积分上限的值。
  
其返回的结果是一个元组，第一个元素是积分结果，第二个元素是积分值绝对误差的估计值。一般的导入方式是 :code:`from scipy.integrate import quad` 。下面是一个简单的示例，计算了 :math:`\int_{0}^{1}e^{-x^{2}}~\mathrm{d}x` ：

.. code-block:: python

    f = lambda x : np.exp(-x**2)
    result = quad(f, 0, 1)


二重积分
^^^^^^^^

使用 :code:`scipy.integrate` 库中的 :code:`dblquad` 函数进行二重积分。在进行计算前需要将二重积分写成累次积分的形式。其调用方式为

.. code-block::

    scipy.integrate.dblquad(func，a，b，gfun，hfun)


各参数的含义如下：

- :code:`func` ：被积函数的表达式。
- :code:`a` ：自由变量的下限。
- :code:`b` ：自由变量的上限。
- :code:`gfun` ：束缚变量的下限表达式。
- :code:`hfun` ：束缚变量的上限表达式。

需要注意，即使束缚变量的上下限是常数，也应该设为函数表达式来传入。其返回的结果是一个元组，第一个元素是积分结果，第二个元素是积分值绝对误差的估计值。一般的导入方式是 :code:`from scipy.integrate import dblquad` 。下面是一个简单的示例，计算了 :code:`\int_{0}^{1/2}\mathrm{d}y\int_{0}^{\sqrt{1-4y^{2}}}16xy~\mathrm{d}x` ：

.. code-block:: python

    f = lambda x, y : 16*x*y
    g = lambda x : 0
    h = lambda y : np.sqrt(1 - 4 * y**2)
    result = dblquad(f, 0, 0.5, g, h)


多重积分
^^^^^^^^

如果需要进行多重积分的数值计算，可以使用 :code:`scipy.integrate` 库中的 :code:`nquad` 函数。其调用方式为

.. code-block:: python

    scipy.integrate.nquad(func, ranges, args=None, opts=None, full_output=False)

各参数的含义如下：

- :code:`func` ：被积函数的表达式。要求以 :code:`func(x0, x1, ..., xn, t0, t1, ..., tm)` 的形式书写，其中 :code:`x0, x1, ..., xn` 为函数变量， :code:`t0, t1, ..., tm` 为函数参数，并且按次序使得 :code:`x0` 是最内层的积分变量， :code:`xn` 是最外层的积分变量。
- :code:`ranges` ：积分变量上下限。需要是一个可迭代对象，一般是二维列表，依次书写最内层积分变量的[下限，上限]列表直到最外层作为其元素。
- :code:`args` ：被积函数参数 :code:`t0, t1, ..., tm` 的值。
- :code:`opts` ：用来传递给具体积分运算的可选要求。需要是包含字典的可迭代对象或能够返回字典的函数。先后依次对应最内层积分直到最外层的运算。可以调整的opts参数有：
  
    * :code:`epsabs=1.49e-08` ，绝对误差宽容。
    * :code:`epsrel=1.49e-0.8` ，相对误差宽容。
    * :code:`limit=50` ，自适应算法中使用的子区间数的上限。
    * :code:`points=None` ，在有界积分区间内的断点序列，在这里被积函数可能出现奇点、不连续等问题。序列不需要排序。该选项不能与 :code:`weight` 一起使用。
    * :code:`weight=None` ，字符串指示权重函数。
    * :code:`wvar=None` ，用于权重函数的变量。
    * :code:`wopts=None` ，可选输入重用切比雪夫矩。
      
- :code:`full_output` ：如果设置为 :code:`full_output=True` ，那么就会返回一个 :code:`neval` 字典记录被积函数求值的次数。

该函数将返回计算结果、估计误差。一般的导入方式是 :code:`from scipy.integrate import nquad` 。下面是一个案例，计算了

.. math::
	\begin{align}
	\int_{t_{0}+t_{1}-1}^{t_{0}+t_{1}+1}\int_{x_{2}+t_{0}^{2}t_{1}^{3}-1}^{x_{2}+t_{0}^{2}t_{1}^{3}+1}\int_{t_{0}x_{1}+t_{1}x_{2}-1}^{t_{0}x_{1}+t_{1}x_{2}+1}f(x_{0},x_{1},x_{2},t_{0},t_{1})~\mathrm{d}x_{0}\mathrm{d}x_{1}\mathrm{d}x_{2}
	\end{align}

其中被积函数的表达式为

.. math::
	\begin{align}
	f(x_{0},x_{1},x_{2},t_{0},t_{1})=\left\{\begin{array}{ll}
	x_{0}x_{2}^{2}+\sin x_{1}+2 & (x_{0}+t_{1}x_{1}-t_{0}>0) \\
	x_{0}x_{2}^{2}+\sin x_{1}+1 & (x_{0}+t_{1}x_{1}-t_{0} \leqslant 0)
	\end{array}\right.
	\end{align}

且参数为 :math:`(t_{0}, t_{1})=(0,1)` ，计算代码如下：

.. code-block:: python

    def func(x0, x1, x2, t0, t1):
    	return x0*x2**2 + np.sin(x1) + 1 + (1 if x0+t1*x1-t0>0 else 0)
    def lim0(x1, x2, t0, t1):
    	return [t0*x1 + t1*x2 - 1, t0*x1 + t1*x2 + 1]
    def lim1(x2, t0, t1):
    	return [x2 + t0**2*t1**3 - 1, x2 + t0**2*t1**3 + 1]
    def lim2(t0, t1):
    	return [t0 + t1 - 1, t0 + t1 + 1]
    def opts0(x1, x2, t0, t1):
    	return {'points' : [t0 - t1*x1]}  # 由于被积函数分段，在x0=t0-t1*x1处不连续
    def opts1(x2, t0, t1):
    	return {}
    def opts2(t0, t1):
    	return {}
    result = nquad(func, [lim0, lim1, lim2], args=(0,1), opts=[opts0, opts1, opts2])



寻找函数极小值
--------------

:code:`scipy.optimize` 库的 :code:`fmin` 函数提供了使用下坡单纯形算法来求函数极小值的方法，可以寻找给定横坐标最近的极小值点。这个算法只使用函数的值，而没有使用函数的导数等信息。其调用方式为

.. code-block:: python

    scipy.optimize.fmin(func, x0, args=(), xtol=0.0001, ftol=0.0001, maxiter=None, maxfun=None, full_output=0, disp=1, retall=0, callback=None, initial_simplex=None)

各参数的含义如下：

- :code:`func` ：需要求极小值的函数表达式。
- :code:`x0` ：初始猜测点。
- :code:`args` ：传入函数表达式的额外参数。
- :code:`xtol` ：对于自变量收敛来说可接受的自变量迭代之间的绝对误差。
- :code:`ftol` ：对于函数值收敛来说可接受的函数值迭代之间的绝对误差。
- :code:`maxiter` ：迭代次数上限。
  
函数直接返回的是包含选取到的极小值点横坐标的列表，需要通过索引得到该极小值点的值，并回代到函数当中得到对应的极小值。一般的导入方式是 :code:`from scipy.optimize import fmin` 。下面是一个简单的案例：

.. code-block:: python

    def f(x):
    	return x**2 + 1
    result = fmin(f, 1)  # 寻找离1最近的极小值点
    print(result[0])
    print(f(result[0]))


:code:`scipy.optimize` 库的 :code:`fminbound` 函数则可以寻找给定区间的极小值点。其调用方式为

.. code-block:: python

    scipy.optimize.fminbound(func, x1, x2, args=(), xtol=1e-05, maxfun=500, full_output=0, disp=1)

其中 :code:`func` 为需要求极小值的函数表达式， :code:`x1` 为区间左端点， :code:`x2` 为区间右端点。一般的导入方式是 :code:`from scipy.optimize import fminbound` 。下面是一个简单的案例：

.. code-block:: python

    def f(x):
    	return x**2 + 1
    result = fminbound(f, -1, 2)
    print(result)
    print(f(result))




最小二乘法拟合
--------------

最小二乘法的数学原理就是使下面公式中的 :math:`S` 最小。其中的 :math:`p` 表示拟合函数 :math:`f` 的所有参数集合。

.. math::
	\begin{align}
	S(p)=\sum_{i=1}^{m}[y_{i}-f(x_{i},p)]^{2}
	\end{align}


leastsq函数
^^^^^^^^^^^

scipy中的子函数库optimize已经提供了实现最小二乘拟合算法的函数leastsq。需要导入 :code:`import numpy as np` 和 :code:`from scipy.optimize import leastsq` 。

首先要获取用于拟合的数据。作为测试，下面使用真实函数数据与噪声组合的方式来获取用于拟合的数据，数据集要以列表或数组的形式存在。

.. code-block:: python

	x = np.linspace(0, -2*np.pi, 100)
	A, k, theta = 10, 0.34, np.pi/6 # 真实数据的函数参数
	y0 = func(x, [A, k, theta]) # 真实数据
	y1 = y0 + 2 * np.random.randn(len(x)) # 加入噪声之后的实验数据

接下来要自定义拟合函数和残差计算函数。例如下面的拟合函数为 :math:`A\sin(2\pi kx+\theta)` ，拟合参数 :math:`p` 包括 :math:`A,k,\theta` 。

.. code-block:: python

	def func(x, p):
	    """
	    数据拟合所用的函数: A*sin(2*pi*k*x + theta)
	    """
	    A, k, theta = p
	    return A*np.sin(2*np.pi*k*x+theta)

.. code-block:: python

	def residuals(p, y, x):
	    """
	    实验数据x, y和拟合函数之间的差，p为拟合需要找到的系数
	    """
	    return y - func(x, p)

接下来开始进行最小二乘法拟合。首先需要自行猜测一组参数，在这个例子里就可以如下猜测：

.. code-block:: python
	
	p0 = [7, 0.2, 0] # 第一次猜测的函数拟合参数


之后就开始调用leastsq进行数据拟合，分别传入计算误差的函数、猜测的拟合参数和需要拟合的实验数据：

.. code-block:: python
	
	plsq = leastsq(residuals, p0, args=(y1, x))

调用成功后，通过 :code:`plsq[0]` 就可以获得拟合参数的列表。如果需要进行拟合曲线绘制，只需要plot即可。

.. code-block:: python
	
	plt.plot(x, func(x, plsq[0]), label='拟合曲线')


综合以上内容可知要完成最小二乘法曲线拟合要定义三个函数：

.. code-block:: python

	from scipy.optimize import leastsq

	def curve_func(x, p):
	    B, lam = p
	    return B * np.cos(2 * np.pi * (-x + 10.905) / lam - np.pi / 2)
	def residuals(p, y, x):
	    return y - curve_func(x, p)
	def fit_curve(x, y):
	    p0 = [27, 2.2]
	    plsq = leastsq(residuals, p0, args=(y, x))
	    return plsq[0]




如果需要求 **决定系数** ，可以使用下面的函数代码。需要依次传入实际y数据、拟合y数据。

.. code-block:: python

	def get_R2(y_real, y_fit):
	    y_real = np.array(y_real)
	    y_fit = np.array(y_fit)
	    
	    SSE = ((y_real - y_fit)**2).sum()
	    SST = ((y_real - y_real.mean())**2).sum()

	    R2 = 1 - SSE / SST
	    return R2



least_squares函数
^^^^^^^^^^^^^^^^^

:code:`scipy.optimize` 的 :code:`least_squares` 函数是更新的、更多功能的最小二乘计算函数，与 :code:`leastsq` 函数对比， :code:`least_squares` 函数能够对有界函数进行拟合。官方文档见 `scipy.optimize.least_squares <https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.least_squares.html>`_ 

一般来说只需要关注四个参数：

- :code:`func` ：残差函数，即真实数据的值与拟合得到的值的差值。
- :code:`x0` ：拟合函数的参数。
- :code:`bounds` ：参数的上下界，默认为无界限，即 :code:`(-np.inf, np.inf)` 。依次传入数组来限制每一个参数，需要与 :code:`x0` 的大小相匹配。
- :code:`args` ：传递给 :code:`fun` 的其他参数。
  
该函数将会返回一系列信息，可以很容易打印出来查看。后续需要进一步调用的有 :code:`res.x` 和 :code:`res.optimality` ，前者是拟合出来的参数数组，可以直接代入到函数当中来求拟合值；后者是一阶最优性度量，由此可以计算出决定系数 :code:`R2 = 1 - res.optimality` 。

.. code-block:: python

    from scipy.optimize import least_squares

    def curve_func(p, x):
        k, b = p
        return k * x + b
    def residuals(p, x, y):
        return y - curve_func(p, x)
    def fit_curve(x, y):
        p0 = [3, 4]  # 初始猜测值
        bound = ((0, 0), (1000, np.inf))   # 参数限定范围，左边是各参数的下限，右边是各参数的上限
        res = least_squares(residuals, x0=p0, args=(x, y), bounds=bound)
        return res

    res = fit_curve(x, y)
    print(res)
    R2 = 1 - res.optimality
    y_fit = curve_func(res.x, x)












非线性方程组求解
----------------

optimize库中的fsolve函数可以用来对非线性方程组进行求解，需要导入 :code:`from scipy.optimize import fsolve` 。它进行的数学计算逻辑如下，其中 :math:`f` 是方程组函数， :math:`X` 是未知数矢量。求未知数即是需要找到能令方程组计算误差趋于零的参数。

.. math::
	\begin{align}
	f(X) & = 0
	\end{align}

首先要自定义函数来表示方程组及方程组计算的误差。下面以如下的含有三个未知数的非线性方程组为例（已经导入了 :code:`from math import sin,cos` ），之后只需要直接调用fsolve函数即可。需要传入一组试验未知数参数，这里用的试验参数是 :code:`[1,1,1]` 。返回的result就是以列表形式储存的参数向量。可以用 :code:`func(result)` 来检查误差情况。

.. math::
	\begin{align}
	5x_{1}+3 & = 0 \\
	4x_{0}^{2}-2\sin(x_{1}\cdot x_{2}) &=0 \\
	x_{1}\cdot x_{2} - 1.5 &= 0
	\end{align}

.. code-block:: python

	def func(x):
	    x0, x1, x2 = x
	    return [
	        5*x1+3,
	        4*x0*x0 - 2*sin(x1*x2),
	        x1*x2 - 1.5
	    ]

	result = fsolve(func, [1,1,1])

.. attention:: 

	- 如果传入的猜测数不合适，有可能会导致溢出而报错、无法计算出正确结果等问题。有时候需要根据大致范围传入非常小的猜测数或非常大的猜测数。
	- 由于是通过迭代收敛求出的结果，所以如果方程组有多解，那么使用scipy的fsolve函数是无法求出所有解的。如果有必要的话，可以改用sympy的solve函数来求解。


在对方程组进行求解时，fsolve会自动计算方程组的雅可比矩阵，如果方程组中的未知数很多，而与每个方程有关的未知数较少时，即雅可比矩阵比较稀疏时，传递一个计算雅可比矩阵的函数将能大幅度提高运算速度。对于上面的非线性方程组，使用雅可比矩阵的fsolve方法如下。计算雅可比矩阵的函数j通过fprime参数传递给fsolve，即 :code:`result = fsolve(f, [1,1,1], fprime=j)` 。

.. code-block:: python

	def j(x):
	    x0, x1, x2 = x
	    return [
	        [0, 5, 0],
	        [8*x0, -2*x2*cos(x1*x2), -2*x1*cos(x1*x2)],
	        [0, x2, x1]
	    ]




微分方程的数值解
-----------------

使用odeint函数
^^^^^^^^^^^^^^

可以使用 :code:`scipy.integrate` 模块的odeint函数来求常微分方程的数值解，其采用FORTRAN的odepack库里面的lsoda方法。一般通过 :code:`from scipy.integrate import odeint` 来导入。需要注意的是，该函数只能处理一阶方程组，如果是高阶微分方程组，需要通过龙格-库塔方法化为一阶微分方程组。

该函数的基本调用格式是 :code:`result = odeint(func, y0, t)` ，其中 :code:`func` 是定义微分方程的函数或匿名函数； :code:`y0` 是初始条件的序列； :code:`t` 是一个自变量取值的序列（其第一个元素必须是初始时刻）；返回值是对应于序列 :code:`t` 中元素的数值解，如果微分方程组中有 :code:`n` 个函数，返回值会是 :math:`n` 列的矩阵，其第 :math:`i(i=1,2,\cdots,n)` 列对应于第 :math:`i` 个函数的数值解。

接下来处理下面给的一阶微分方程，求解其在 :math:`1<x<10` （步长间隔为0.5）的点上的数值解。

.. math::
	\begin{align}
	\left\{\begin{array}{l}
	y'=-2y+x^{2}+2x \\
	y(1)=2
	\end{array}\right.
	\end{align}

.. code-block:: python

    dy = lambda y,x: -2*y + x**2 + 2*x  # 定义微分方程
    x = np.arange(1, 10.5, 0.5)  # 给定求解范围与步长
    result = odeint(dy, 2, x)  # 初始条件的值与求解范围的第一个元素对应


接下来求解下面给的二阶微分方程的数值解。首先引入 :math:`y_{0}=y` ， :math:`y_{1}=y'` ，将原来的二阶微分方程转换为一阶微分方程组。

.. math::
	\begin{align}
	\left\{\begin{array}{l}
	\frac{\mathrm{d}^{2}y}{\mathrm{d}x^{2}}+2\frac{\mathrm{d}y}{\mathrm{d}x}+2y=0 \\
	y(0)=0 \\
	y'(0)=1  
	\end{array}\right .
	\quad \Rightarrow \quad 
	\left\{\begin{array}{l}
	y_{0}'=y_{1} \\
	y_{1}'=-2y_{0}-2y_{1} \\
	y_{0}(0)=0 \\
	y_{1}(0)=1
	\end{array}\right .
	\end{align}


.. code-block:: python

    def pfun(f_list, x):
        y0, y1 = f_list
        return np.array([
            y1,
            -2 * y0 - 2 * y1
        ])  # 返回的是等式右边的值，要求先低阶再高阶

    x = np.arange(0, 10, 0.1)  # 创建自变量序列
    result = odeint(pfun, [0.0, 1.0], x)



使用solve_ivp函数
^^^^^^^^^^^^^^^^^

如果对微分方程数值求解的方法有特殊要求，可以使用 :code:`integrate` 模块的 :code:`solve_ivp` 函数，官方文档见 `https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html <https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html>`_  。其基本的调用方式为

.. code-block:: python

    scipy.integrate.solve_ivp(fun, t_span, y0, method='RK45', t_eval=None, dense_output=False, events=None, vectorized=False, args=None, **options)

该函数解决的是 :math:`\left\{\begin{array}{c}\frac{\mathrm{d}y}{\mathrm{d}t}=f(t,y) \\ y(t_{0})=y_{0} \end{array}\right.` 类型的微分方程。各参数的含义如下：

- :code:`fun` ：微分方程组等号右边的函数。需要包含自变量与因变量，一般是 :code:`fun(t,y)` 的形式，其中 :code:`t` 必须是标量，而 :code:`y` 可以是数组，返回的函数数组维数需要与之对应。
- :code:`t_span` ：自变量计算区间。需要传入二元数组/元组/列表。
- :code:`y0` ：初始条件，可以是数组。如果需要在复数域求解，则传入复数类型的数据。
- :code:`method` ：积分方法。默认是 :code:`'RK45'` ，还可以选择 :code:`'RK23'` 、 :code:`'DOP853'` 、 :code:`Radau` 、 :code:`BDF` 、 :code:`LSODA` 。其中Explicit Runge-Kutta methods :code:`'RK45'` 、 :code:`'RK23'` 、 :code:`'DOP853'` 用于非刚性问题，implicit methods  :code:`Radau` 、 :code:`BDF` 用于刚性问题。
- :code:`t_eval` ：用于计算解的时间点，必须排序并落在 :code:`t_span` 内。如果为None，则使用求解器选择的点。、
- :code:`args` ：传递给所定义函数的附加参数。例如，如果fun具有给定的形式是 :code:`fun(t, y, a, b, c)` ，那么jac(如果给定)和任何事件函数必须具有相同的参数形式，并且 :code:`args` 必须是长度为3的元组。

函数将返回 :code:`t` 解出的自变量点、 :code:`y` 在解处的函数值，一般通过 :code:`result.t` 和 :code:`result.y` 来获取结果。

该函数的一般导入方式为 :code:`from scipy.integrate import solve_ivp` 。接下来的案例计算了下面的微分方程组，并且给定初值条件 :math:`y_{1}(0)=0, y_{2}(0)=1` 。

.. math::
	\begin{align}
	\left \{  \begin{array}{l}
	\frac{\mathrm{d}y_{1}}{\mathrm{d}x}=y_{2} \\
	\frac{\mathrm{d}y_{2}}{\mathrm{d}x}=x^{2} - y_{1} + x
	\end{array} \right.
	\end{align}

首先将其表述为矩阵形式 :math:`\dot{\boldsymbol{Y}}=\boldsymbol{A}\boldsymbol{Y}+\boldsymbol{B}` ，其中

.. math::
	\begin{align}
	\dot{\boldsymbol{Y}}=\begin{bmatrix} \frac{\mathrm{d}y_{1}}{\mathrm{d}x}  \\ \frac{\mathrm{d}y_{2}}{\mathrm{d}x}  \end{bmatrix},
	\quad 
	\boldsymbol{A}=\begin{bmatrix} 0 & 1 \\ -1 & 0 \end{bmatrix},
	\quad 
	\boldsymbol{Y}=\begin{bmatrix} y_{1} \\ y_{2} \end{bmatrix},
	\quad 
	\boldsymbol{B}=\begin{bmatrix} 0 \\ x^{2}+x\end{bmatrix}
	\end{align}

.. code-block:: python

    plt.rcParams['font.sans-serif'] = ['Microsoft YaHei']

    def pfun(x, Y):
        A = np.array(
            [[0, 1],
            [-1, 0]]
        )
        B = np.array(
            [[0],
            [x**2 + x]]
        )
        dY = np.dot(A, Y) + B
        return dY
        
    init = [0, 1]
    result = solve_ivp(pfun, (0, 500), init, method='Radau', t_eval=np.arange(1, 500, 1), vectorized=True)
    x = result.t
    y1_data = result.y[0]
    y2_data = result.y[1]

    plt.plot(x, y1_data, label='求解变量y1')
    plt.plot(x, y2_data, label='求解变量y2')
    plt.xlabel("时间s")
    plt.legend(loc='best')
    plt.savefig('testfig.png')

.. attention:: 这里为了有更好的拓展性，将微分方程组写成了矩阵形式，所以调用solve_ivp函数时需要设置参数 :code:`vectorized=True` 。如果方程组仍然按照odeint的方式来写，那么就不需要设置 :code:`vectorized` 参数。




sphinx
======

Sphinx是一个静态网页发布工具，可将rST和md文件，发布为各类常见的用户帮助如联机帮助，用户手册等。

快速新建项目
------------

详细内容可以参考 `sphinx快速入门`_ 

.. _sphinx快速入门: https://doclikecode.readthedocs.io/zh_CN/latest/1_sphinx/sphinx101.html#:~:text=%E5%BF%AB%E9%80%9F%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%BB%A5Mac%E7%B3%BB%E7%BB%9F%E4%B8%BA%E4%BE%8B%EF%BC%8CWindow%E7%B3%BB%E7%BB%9F%E7%B1%BB%E4%BC%BC%EF%BC%89%20%C2%B6%201%20%E5%9C%A8%E6%A1%8C%E9%9D%A2%E4%B8%8A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%8C%E5%B9%B6%E5%91%BD%E5%90%8D%E4%B8%BA%20sphinx-demo%202%20%E5%9C%A8Terminal%E4%B8%AD%E6%B5%8F%E8%A7%88%E8%87%B3%E4%B8%8A%E8%BF%B0%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%8C%E5%B9%B6%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4%EF%BC%9A,sphinx-quickstart%203%20%E5%9C%A8%E5%AF%B9%E8%AF%9D%E6%A1%86%E5%BC%8F%E7%9A%84%E9%80%89%E6%8B%A9%E4%B8%AD%EF%BC%8CY%2FN%E7%9A%84%E9%80%89%E9%A1%B9%EF%BC%8C%E9%80%89Y%EF%BC%9B%E5%A6%82%E6%9E%9C%E8%AF%A2%E9%97%AE%E9%85%8D%E7%BD%AE%EF%BC%8C%E7%9B%B4%E6%8E%A5%E5%A4%8D%E5%88%B6%20%5B%5D%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E5%A6%82%20%5B.rst%5D%EF%BC%8C%E5%88%99%E5%A1%AB%E5%86%99.rst%204%20%E6%96%B0%E5%BB%BA%E6%88%90%E5%8A%9F%E5%90%8E%EF%BC%8C%E5%88%99%E4%BC%9A%E5%BE%97%E5%88%B0%E5%A6%82%E5%9B%BE%E6%89%80%E7%A4%BA%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E7%BB%93%E6%9E%84

首先新建希望存放项目文件的文件夹，然后在Terminal中浏览至上述文件夹，并运行命令： :code:`sphinx-quickstart` 。在对话框式的选择中，Y/N的选项，根据需要选Y；语言设置时，填入 :code:`zh-CN` 以支持中文简体。

新建完成后，浏览至 source 文件夹，并在其根目录下创建新文件夹demo，在demo文件夹中放置用于生成页面的rst文件。放置完成后，打开source文件中的 index.rst，将demo内的文件添加至目录中。例如

.. code-block:: rst

    .. toctree::
       :maxdepth: 2
       :caption: Contents:

       demo/电路原理.rst
       demo/数字电路.rst

完成后在Terminal中运行编译命令： :code:`sphinx-build -b html source build` ，编译成功后在 build 文件夹中则有刚才发布的网站。

修改网页主题
------------

如果需要修改网页主题，打开 source 文件夹中的conf.py，并找到主题配置行 html_theme = ‘alabaster’ ，修改该参数即可。如果要使用ReadtheDoc主题，则修改为 html_theme = ‘sphinx_rtd_theme’ 。


加宽网页宽度
------------

在使用ReadtheDoc主题时，注意到其内容页面集中在中间，右边存在空间冗余。如果需要将网页宽度加大，可以在 :code:`source/_static` 中新建css文件，命名为 :code:`style.css` ，内容为

.. code-block:: css

    .wy-nav-content {
    	max-width: 1200px !important;
    }


再在 :code:`source/_templates` 文件夹中新建一个 :code:`layout.html` 文件，内容为

.. code-block:: 

	{% extends "!layout.html" %}
	{% block extrahead %}
	    <link href="{{ pathto("_static/style.css", True) }}" rel="stylesheet" type="text/css">
	{% endblock %}

确保 :code:`source/conf.py` 引用了 :code:`source/_static` 目录，即包含语句 :code:`html_static_path = ['_static']` ，就可以实现将原本ReadtheDoc主题页面宽度加大的效果。




sympy
=====

sympy是重要的数学符号运算库，可以完成数学公式的符号推导。为了调用方便，一般通过 :code:`import sympy as sp` 导入该库。并且，其计算的函数结果可以通过 :code:`latex` 函数直接输出 :math:`\LaTeX` 公式，例如 :code:`print(latex(integrate(sqrt(x), x)))` 。

需要注意的是，由sympy创建的符号函数对象不能混用numpy的函数运算。

变量赋值与精度转换
------------------

采用符号变量的 :code:`subs()` 方法来进行替换操作，例如下面的代码实现了令表达式 :math:`\frac{R_{3} \left(R_{1} U_{s2} + R_{2} U_{s1}\right)}{R_{1} R_{2} + R_{1} R_{3} + R_{2} R_{3}}` 中的 :math:`R_{1}=3.6,~R_{2}=3.6,~R_{3}=3.3,~U_{s1}=4,~U_{s2}=8` ，函数返回了其计算结果。如果只需要给一个变量赋值，那么可以像 :code:`expr.subs(x,1)` 这样传值。

.. code-block:: python

	v, R1, R2, R3, Us1, Us2 = sp.symbols('v R1 R2 R3 Us1 Us2')
	expr = R3 * (R1 * Us2 + R2 * Us1) / (R1 * R2 + R1 * R3 + R2 * R3)
	result = expr.subs({'R1': 3.6, 'R2': 3.6, 'R3': 3.3, 'Us1': 4, 'Us2': 8})
    

使用 :code:`sympify()` 函数可以将字符串表达式转换为Sympy表达式。例如：

.. code-block:: python

	str_expr = 'x**2 + 2*x + 1'
	expr = sympify(str_expr)

使用符号变量的 :code:`evalf()` 方法可以将数值转换为指定精度的数值解，保留指定的有效数字。例如：

.. code-block:: python

	pi.evalf(3)  # pi保留3位有效数字



有时候在使用sympy的表达式的同时还需要使用numpy的数组来进行赋值，这时不能使用 :code:`subs()` 函数，而需要 :code:`lambdify()` 函数来将原本的表达式转换为可识别numpy数组的形式，例如

.. code-block:: python

    expr_y1_solved = 1.5 + (-0.3062 * sp.sin(0.4899 * t) - 1.500 * sp.cos(0.4899 * t)) * sp.exp(-0.1 * t)
    expr_y1_diff1 = expr_y1_solved.diff(t)

    t_array = np.linspace(0, 50, 100)
    f = sp.lambdify([t], expr_y1_diff1)
    value_y1_diff1 = f(t_array)

更详细的使用方法可以查看 `lambdify官方文档 <https://docs.sympy.org/latest/modules/utilities/lambdify.html>`_ 



函数表达式化简
---------------

simplify函数化简
^^^^^^^^^^^^^^^^^

在符号计算中，最常用的操作就是利用 :code:`simplify` 函数对表达式进行化简。默认情况下， :code:`simplify` 函数将自行寻找它认为的最简单的表达形式。下面就是分别利用该函数将 :math:`\sin^{2}x+\cos^{2}x` 化简为 :math:`1` 和将 :math:`2\sin\alpha\cos\alpha` 化简为 :math:`\sin(2\alpha)` 。

.. code-block:: python

    expr = simplify(sin(x)**2 + cos(x)**2)

.. code-block:: python

	alpha = symbols('alpha')
	expr = simplify(2*sin(alpha)*cos(alpha))


多项式展开
^^^^^^^^^^

使用 :code:`expand` 函数来实现将多项式展开。例如下面就使用了该函数来展开 :math:`(x_{1}+1)^{2}` ，成功得到 :math:`x_{1}^{2}+2x_{1}+1` 。

.. code-block:: python

	x_1 = symbols('x_1')
	result = expand((x_1 + 1)**2)


多项式因式分解
^^^^^^^^^^^^^^

使用 :code:`factor` 函数来对多项式进行因式分解。例如下面就使用了该函数来对 :math:`x^{3}-x^{2}+x-1` 进行因式分解，成功得到 :math:`(x-1)(x^{2}+1)` 。

.. code-block:: python

	x = symbols('x')
	result = factor(x**3 - x**2 + x - 1)


合并同类项
^^^^^^^^^^

使用 :code:`collect` 函数来实现合并同类项的操作。例如下面就使用了该函数来对 :math:`xy+x-3+2x^{2}-zx^{2}` 根据 :math:`x` 合并同类项，成功得到 :math:`x^{3}+x^{2}(2-z)+x(y+1)-3` 。

.. code-block:: python

    x, y = symbols('x y')
    expr = x*y + x - 3 + 2*x**2 - z*x**2 + x**3
    new_expr = collect(expr, x)


有理分式化简
^^^^^^^^^^^^

使用 :code:`cancel` 函数来消去分子分母的公因式。例如下面就使用了该函数来将 :code:`\frac{x^{2}+2x+1}{x^{2}+x}` 化简为 :math:`\frac{x+1}{x}` 。

.. code-block:: python

    x = symbols('x')
    expr = cancel((x**2 + 2*x + 1) / (x**2 + x))


分式展开
^^^^^^^^

使用 :code:`apart` 函数来将分式展开。例如下面就使用了该函数来将 :math:`\frac{4x^{3}+21x^{2}+10x+12}{x^{4}+5x^{3}+5x^{2}+4x}` 展开为 :math:`\frac{2x-1}{x^{2}+x+1}-\frac{1}{x+4}+\frac{3}{x}` 。

.. code-block:: python

    x = symbols('x')
    expr = (4*x**3 + 21*x**2 + 10*x + 12) / (x**4 + 5*x**3 + 5*x**2 + 4*x)
    new_expr = apart(expr)


符号函数求导
-------------

求导函数使用的是 :code:`diff` 函数。对一个一元函数求一阶导可以简单地像这样完成： :code:`diff(cos(x), x)` 。如果需要求高阶导可以像这样来完成： :code:`diff(x**4, x, 3)` 。其中的表达式也不一定要放在括号内，可以作为符号变量放在外面。

下面以计算 :math:`\frac{\partial y}{\partial x_{2}}=\frac{\partial }{\partial x_{2}}\left ( x_{1}^{2}+x_{2}^{2} \right )` 为例来说明偏导数的计算。首先要定义表达式的变量名称：

.. code-block:: python
 
     x1, x2 = symbols('x1 x2')

然后定义表达式内容：

.. code-block:: python
 
     y = x1**2 + x2**2

那么计算对 :math:`x_{2}` 偏导数的结果为

.. code-block:: python

    dy_dx2 = diff(y, x2)

可以 :code:`print(dy_dx2)` 来查看计算结果的表达式。如果需要给该表达式的自变量赋值进行计算，可以使用 :code:`evalf(subs={})` 函数。其中 :code:`subs={}` 里面填入对应变量及其取值的字典。例如上述偏导结果代入 :math:`x_{2}=6` 的方式如下：

.. code-block:: python

    result = dy_dx2.evalf(subs={'x2': 6})


符号函数积分
-------------

使用 :code:`integrate` 函数来求积分。例如 :code:`integrate(cos(x), x)` 。

如果要求定积分，则在变量处传入元组，依次说明变量、积分下限和积分上限。同时注意，在sympy中，使用 :code:`oo` 来表示 :math:`\infty` 。例如 :code:`integrate(exp(-x), (x, 0, oo))` 就计算了 :math:`\int_{0}^{\infty}e^{-x}~\mathrm{d}x`

如果要计算二重积分，则只需多传入一个变量元组即可。例如 :code:`integrate(exp(-x**2 - y**2), (x, -oo, oo), (y, -oo, oo))` 就计算了 :math:`\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}e^{-x^{2}-y^{2}}~\mathrm{d}x\mathrm{d}y` 。


符号函数极限
--------------

使用 :code:`limit` 函数来计算函数极限。例如 :code:`limit(sp.sin(x)/x, x, 0)` 计算了 :math:`\lim\limits_{x\to 0}\frac{\sin x}{x}` 。

如果要计算单侧积分，则只需额外用 :code:`'+'` 或 :code:`'-'` 指定即可。例如 :code:`limit(1/x, x, 0, '+')` 计算了 :math:`\lim\limits _{x\to 0^{+}}\frac{1}{x}` 。


符号函数的级数展开
-------------------

使用符号变量的 :code:`series` 方法可以对函数 :math:`f(x)` 在 :math:`x=x_{0}` 处进行 :math:`n` 阶展开。例如下面进行对 :math:`f(x)=\sin x` 在 :math:`x=0` 处进行4阶展开：

.. code-block:: python

    x = sp.symbols('x')
    expr = sp.sin(x)
    new_expr = expr.series(x, 0, 4)


求解符号方程组
---------------

使用 :code:`solve` 函数来求解符号方程组，依次传入方程组列表和需要求解的变量列表，常数符号不需要写入参数当中。例如

.. code-block:: python

    u1, u2, R1, R2, R3 = sp.symbols('u1 u2 R1 R2 R3')

    eq1 = (R1 + R3)/R3 - 2
    eq2 = (R1*R2 + R1*R3 + R2*R3)/R3 - 8
    eq3 = 1/R3 - 0.5
    eq4 = (R2 + R3)/R3 - 2.5

    result = sp.solve([eq1, eq2, eq3, eq4], [R1, R2, R3])

如果没有解析解则会报错。这时可以改用 :code:`nsolve` 函数来求数值解。

该函数也可以处理不等式，例如

.. code-block:: python

    expr_uc1 = -4.0*sp.exp(-25.0*t)
    expr_uc2 = 8.0*sp.exp(-25.0*t)

    ineq = expr_uc1 + 12 - expr_uc2 > 1
    result = sp.solve(ineq, t)
    print(result)


求解微分符号方程
-----------------

使用 :code:`dsolve` 函数求解微分方程。首先建立符号函数变量，需要在 :code:`symbols` 函数内额外设置 :code:`cls` 参数，并且在后续方程的书写时带上括号和自变量符号，而不能仅使用符号函数变量来书写，同时使用 :code:`diff` 函数来表示微分量。下面的案例求解了一个二阶微分方程。

.. math::
	\begin{align}
	\frac{\mathrm{d}^{2}u_{c}(t)}{\mathrm{d}t^{2}} +2\alpha \frac{\mathrm{d}u_{c}(t)}{\mathrm{d}t} + \omega_{0}^{2}u_{c}(t)=0 
	\end{align}

.. code-block:: python

    uc = sp.symbols('u_c', cls=sp.Function)
    alpha, omega, t = sp.symbols('alpha omega t')
    eq = uc(t).diff(t, 2) + 2 * alpha * uc(t).diff(t) + omega ** 2 * uc(t)
    result = sp.dsolve(eq, uc(t))
    print(result)
    print(sp.latex(result))

可以支持微分方程组的计算，只需在传入方程时传入对应的列表即可。同时可以将初值条件字典传入到 :code:`ics` 参数当中，这样就会直接给出最终的函数结果。例如

.. code-block:: python

    il0 = 5 * 1e-3
    uc0 = 200 * 5 * 1e-3

    uc, il = sp.symbols('uc il', cls=sp.Function)
    t = sp.symbols('t')
    diffeq1 = 10 * 1e-6 * uc(t).diff(t) + il(t)
    diffeq2 = uc(t) + 10 * 1e-6 * uc(t).diff(t) * 2 * 1e3 - 1e-3 * il(t).diff(t) - 200 * il(t)

    condition = {
        uc(0): uc0,
        il(0): il0
    }

    result = sp.dsolve([diffeq1, diffeq2], [uc(t), il(t)], ics=condition)
    print(result)
    

有时候并不能直接列出ODE方程组，需要加入中间变量来列写方程，此时就要先借助 :code:`solve` 函数来将中间变量用待求量表示出来，然后再使用 :code:`dsolve` 求解ODE，例如

.. code-block:: python

    il = sp.symbols('il', cls=sp.Function)
    t = sp.symbols('t')
    v1, v2 = sp.symbols('v1 v2')

    eq1 = (v1 - 80) / 20 + v1 / 80 - il(t)
    eq2 = (v2 - 80) / 80 + v2 / 20 + il(t)
    result = sp.solve([eq1, eq2], [v1, v2])

    diffeq = result[v2] - result[v1] - 0.02 * il(t).diff(t)
    init = {il(0): 0}
    result = sp.dsolve(diffeq, il(t), ics=init)
    print(result)




矩阵运算
--------

构建矩阵
^^^^^^^^

使用 :code:`Matrix` 函数构造矩阵。例如 :code:`Matrix([[1, -1], [3, 4], [0, 2]])` 构造矩阵 :math:`\begin{pmatrix} 1 & -1\\ 3 & 4\\ 0 & 2\end{pmatrix}` ， :code:`Matrix([1, 2, 3])` 构造列向量 :math:`\begin{pmatrix}1 \\2 \\3\end{pmatrix}` ，配合转置操作 :code:`T` 可以像 :code:`Matrix([[1], [2], [3]]).T` 构造行向量 :math:`\begin{pmatrix} 1 & 2 & 3\end{pmatrix}` 。

特别地，可以用 :code:`eye(4)` 构建4阶单位矩阵；用 :code:`zeros(4)` 构建4阶全零矩阵；用 :code:`ones(4)` 构建4阶全一矩阵；用 :code:`diag(1, 2, 3, 4)` 构建对角矩阵。


求矩阵的幂与求逆
^^^^^^^^^^^^^^^^

直接对矩阵变量像数值那样进行幂操作即可，例如

.. code-block:: python

    M = Matrix([[1, 3], [-2, 3]])
    result = M**2

特别地，矩阵的 :math:`-1` 次幂就是矩阵的逆。


求矩阵的行列式
^^^^^^^^^^^^^^^

用矩阵变量的 :code:`det` 函数来求其行列式：

.. code-block:: python

    M = Matrix([[1, 0, 1], [2, -1, 3], [4, 3, 2]])
    result = M.det()


求矩阵的特征值和特征多项式
^^^^^^^^^^^^^^^^^^^^^^^^^^^

用矩阵变量的 :code:`eigenvals` 函数来求其特征值。该函数返回的是字典，字典的key是特征值，value是对应的重数。

.. code-block:: python

    M = Matrix([[3, -2,  4, -2], [5,  3, -3, -2], [5, -2,  2, -2], [5, -2, -3,  3]])
    eigenvalue = M.eigenvals()

用矩阵变量的 :code:`charpoly` 方法来求其特征多项式。

.. code-block:: python

    M = Matrix([[3, -2,  4, -2], [5,  3, -3, -2], [5, -2,  2, -2], [5, -2, -3,  3]])
    p = M.charpoly(lamda)
    eigenpolynomial = factor(p)  # 调用了factor来将表达式因式分解


Laplace变换
------------

使用 :code:`laplace_transform` 进行Laplace变换，例如

.. code-block:: python

    t, s = symbols('t s')
    expr = sin(t)
    result = laplace_transform(expr, t, s)

使用 :code:`inverse_laplace_transform` 进行逆Laplace变换，例如

.. code-block:: python

    s, t = symbols('s t')
    expr = 1/(s - 1)
    result = inverse_laplace_transform(expr, s, t)




